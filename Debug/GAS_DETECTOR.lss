
GAS_DETECTOR.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001a158  00008000  00008000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00022158  00022158  00022158  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     000004c8  20000000  00022160  00030000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          00004910  200004e0  00022640  000304c8  2**5
                  ALLOC
  4 .stack        00000800  20004df0  00026f50  000304c8  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  000304c8  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  000304f0  2**0
                  CONTENTS, READONLY
  7 .debug_info   0006262b  00000000  00000000  00030549  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000084e2  00000000  00000000  00092b74  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000b6db  00000000  00000000  0009b056  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00002028  00000000  00000000  000a6731  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00001df0  00000000  00000000  000a8759  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0002d8b9  00000000  00000000  000aa549  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000307cd  00000000  00000000  000d7e02  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000a9ec7  00000000  00000000  001085cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00007ba0  00000000  00000000  001b2498  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00008000 <_sfixed>:
    8000:	200055f0 	.word	0x200055f0
    8004:	00016d81 	.word	0x00016d81
    8008:	00016e79 	.word	0x00016e79
    800c:	00016e79 	.word	0x00016e79
	...
    802c:	0000fa3d 	.word	0x0000fa3d
	...
    8038:	0000fb61 	.word	0x0000fb61
    803c:	0000fba9 	.word	0x0000fba9
    8040:	00016e79 	.word	0x00016e79
    8044:	00016e79 	.word	0x00016e79
    8048:	00016e79 	.word	0x00016e79
    804c:	00016e79 	.word	0x00016e79
    8050:	0000e811 	.word	0x0000e811
    8054:	00016e79 	.word	0x00016e79
    8058:	0000e50d 	.word	0x0000e50d
    805c:	00016e79 	.word	0x00016e79
    8060:	00016e79 	.word	0x00016e79
    8064:	00014165 	.word	0x00014165
    8068:	0001417d 	.word	0x0001417d
    806c:	00014195 	.word	0x00014195
    8070:	000141ad 	.word	0x000141ad
    8074:	000141c5 	.word	0x000141c5
    8078:	000141dd 	.word	0x000141dd
    807c:	00016e79 	.word	0x00016e79
    8080:	00016e79 	.word	0x00016e79
    8084:	00016e79 	.word	0x00016e79
    8088:	0000f665 	.word	0x0000f665
    808c:	0000f679 	.word	0x0000f679
    8090:	0000f68d 	.word	0x0000f68d
    8094:	0000f6a1 	.word	0x0000f6a1
    8098:	0000f6b5 	.word	0x0000f6b5
    809c:	00016e79 	.word	0x00016e79
    80a0:	00016e79 	.word	0x00016e79
    80a4:	00016e79 	.word	0x00016e79
    80a8:	00016e79 	.word	0x00016e79
    80ac:	00016e79 	.word	0x00016e79
    80b0:	00000000 	.word	0x00000000

000080b4 <__do_global_dtors_aux>:
    80b4:	b510      	push	{r4, lr}
    80b6:	4c06      	ldr	r4, [pc, #24]	; (80d0 <__do_global_dtors_aux+0x1c>)
    80b8:	7823      	ldrb	r3, [r4, #0]
    80ba:	2b00      	cmp	r3, #0
    80bc:	d107      	bne.n	80ce <__do_global_dtors_aux+0x1a>
    80be:	4b05      	ldr	r3, [pc, #20]	; (80d4 <__do_global_dtors_aux+0x20>)
    80c0:	2b00      	cmp	r3, #0
    80c2:	d002      	beq.n	80ca <__do_global_dtors_aux+0x16>
    80c4:	4804      	ldr	r0, [pc, #16]	; (80d8 <__do_global_dtors_aux+0x24>)
    80c6:	e000      	b.n	80ca <__do_global_dtors_aux+0x16>
    80c8:	bf00      	nop
    80ca:	2301      	movs	r3, #1
    80cc:	7023      	strb	r3, [r4, #0]
    80ce:	bd10      	pop	{r4, pc}
    80d0:	200004e0 	.word	0x200004e0
    80d4:	00000000 	.word	0x00000000
    80d8:	00022160 	.word	0x00022160

000080dc <frame_dummy>:
    80dc:	4b08      	ldr	r3, [pc, #32]	; (8100 <frame_dummy+0x24>)
    80de:	b510      	push	{r4, lr}
    80e0:	2b00      	cmp	r3, #0
    80e2:	d003      	beq.n	80ec <frame_dummy+0x10>
    80e4:	4907      	ldr	r1, [pc, #28]	; (8104 <frame_dummy+0x28>)
    80e6:	4808      	ldr	r0, [pc, #32]	; (8108 <frame_dummy+0x2c>)
    80e8:	e000      	b.n	80ec <frame_dummy+0x10>
    80ea:	bf00      	nop
    80ec:	4807      	ldr	r0, [pc, #28]	; (810c <frame_dummy+0x30>)
    80ee:	6803      	ldr	r3, [r0, #0]
    80f0:	2b00      	cmp	r3, #0
    80f2:	d100      	bne.n	80f6 <frame_dummy+0x1a>
    80f4:	bd10      	pop	{r4, pc}
    80f6:	4b06      	ldr	r3, [pc, #24]	; (8110 <frame_dummy+0x34>)
    80f8:	2b00      	cmp	r3, #0
    80fa:	d0fb      	beq.n	80f4 <frame_dummy+0x18>
    80fc:	4798      	blx	r3
    80fe:	e7f9      	b.n	80f4 <frame_dummy+0x18>
    8100:	00000000 	.word	0x00000000
    8104:	200004e4 	.word	0x200004e4
    8108:	00022160 	.word	0x00022160
    810c:	00022160 	.word	0x00022160
    8110:	00000000 	.word	0x00000000

00008114 <delay_init>:
 * \brief Initialize the delay driver.
 *
 * Not used in cycle mode.
 */
void delay_init(void)
{
    8114:	b580      	push	{r7, lr}
    8116:	af00      	add	r7, sp, #0
}
    8118:	46c0      	nop			; (mov r8, r8)
    811a:	46bd      	mov	sp, r7
    811c:	bd80      	pop	{r7, pc}
    811e:	46c0      	nop			; (mov r8, r8)

00008120 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    8120:	b580      	push	{r7, lr}
    8122:	b084      	sub	sp, #16
    8124:	af00      	add	r7, sp, #0
    8126:	0002      	movs	r2, r0
    8128:	1dfb      	adds	r3, r7, #7
    812a:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    812c:	230f      	movs	r3, #15
    812e:	18fb      	adds	r3, r7, r3
    8130:	1dfa      	adds	r2, r7, #7
    8132:	7812      	ldrb	r2, [r2, #0]
    8134:	09d2      	lsrs	r2, r2, #7
    8136:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    8138:	230e      	movs	r3, #14
    813a:	18fb      	adds	r3, r7, r3
    813c:	1dfa      	adds	r2, r7, #7
    813e:	7812      	ldrb	r2, [r2, #0]
    8140:	0952      	lsrs	r2, r2, #5
    8142:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    8144:	4b0d      	ldr	r3, [pc, #52]	; (817c <system_pinmux_get_group_from_gpio_pin+0x5c>)
    8146:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    8148:	230f      	movs	r3, #15
    814a:	18fb      	adds	r3, r7, r3
    814c:	781b      	ldrb	r3, [r3, #0]
    814e:	2b00      	cmp	r3, #0
    8150:	d10f      	bne.n	8172 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    8152:	230f      	movs	r3, #15
    8154:	18fb      	adds	r3, r7, r3
    8156:	781b      	ldrb	r3, [r3, #0]
    8158:	009b      	lsls	r3, r3, #2
    815a:	2210      	movs	r2, #16
    815c:	4694      	mov	ip, r2
    815e:	44bc      	add	ip, r7
    8160:	4463      	add	r3, ip
    8162:	3b08      	subs	r3, #8
    8164:	681a      	ldr	r2, [r3, #0]
    8166:	230e      	movs	r3, #14
    8168:	18fb      	adds	r3, r7, r3
    816a:	781b      	ldrb	r3, [r3, #0]
    816c:	01db      	lsls	r3, r3, #7
    816e:	18d3      	adds	r3, r2, r3
    8170:	e000      	b.n	8174 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    8172:	2300      	movs	r3, #0
	}
}
    8174:	0018      	movs	r0, r3
    8176:	46bd      	mov	sp, r7
    8178:	b004      	add	sp, #16
    817a:	bd80      	pop	{r7, pc}
    817c:	41004400 	.word	0x41004400

00008180 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    8180:	b580      	push	{r7, lr}
    8182:	b082      	sub	sp, #8
    8184:	af00      	add	r7, sp, #0
    8186:	0002      	movs	r2, r0
    8188:	1dfb      	adds	r3, r7, #7
    818a:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    818c:	1dfb      	adds	r3, r7, #7
    818e:	781b      	ldrb	r3, [r3, #0]
    8190:	0018      	movs	r0, r3
    8192:	4b03      	ldr	r3, [pc, #12]	; (81a0 <port_get_group_from_gpio_pin+0x20>)
    8194:	4798      	blx	r3
    8196:	0003      	movs	r3, r0
}
    8198:	0018      	movs	r0, r3
    819a:	46bd      	mov	sp, r7
    819c:	b002      	add	sp, #8
    819e:	bd80      	pop	{r7, pc}
    81a0:	00008121 	.word	0x00008121

000081a4 <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    81a4:	b580      	push	{r7, lr}
    81a6:	b082      	sub	sp, #8
    81a8:	af00      	add	r7, sp, #0
    81aa:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    81ac:	687b      	ldr	r3, [r7, #4]
    81ae:	2200      	movs	r2, #0
    81b0:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    81b2:	687b      	ldr	r3, [r7, #4]
    81b4:	2201      	movs	r2, #1
    81b6:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    81b8:	687b      	ldr	r3, [r7, #4]
    81ba:	2200      	movs	r2, #0
    81bc:	709a      	strb	r2, [r3, #2]
}
    81be:	46c0      	nop			; (mov r8, r8)
    81c0:	46bd      	mov	sp, r7
    81c2:	b002      	add	sp, #8
    81c4:	bd80      	pop	{r7, pc}
    81c6:	46c0      	nop			; (mov r8, r8)

000081c8 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    81c8:	b580      	push	{r7, lr}
    81ca:	b084      	sub	sp, #16
    81cc:	af00      	add	r7, sp, #0
    81ce:	0002      	movs	r2, r0
    81d0:	1dfb      	adds	r3, r7, #7
    81d2:	701a      	strb	r2, [r3, #0]
    81d4:	1dbb      	adds	r3, r7, #6
    81d6:	1c0a      	adds	r2, r1, #0
    81d8:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    81da:	1dfb      	adds	r3, r7, #7
    81dc:	781b      	ldrb	r3, [r3, #0]
    81de:	0018      	movs	r0, r3
    81e0:	4b0d      	ldr	r3, [pc, #52]	; (8218 <port_pin_set_output_level+0x50>)
    81e2:	4798      	blx	r3
    81e4:	0003      	movs	r3, r0
    81e6:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    81e8:	1dfb      	adds	r3, r7, #7
    81ea:	781b      	ldrb	r3, [r3, #0]
    81ec:	221f      	movs	r2, #31
    81ee:	4013      	ands	r3, r2
    81f0:	2201      	movs	r2, #1
    81f2:	409a      	lsls	r2, r3
    81f4:	0013      	movs	r3, r2
    81f6:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    81f8:	1dbb      	adds	r3, r7, #6
    81fa:	781b      	ldrb	r3, [r3, #0]
    81fc:	2b00      	cmp	r3, #0
    81fe:	d003      	beq.n	8208 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    8200:	68fb      	ldr	r3, [r7, #12]
    8202:	68ba      	ldr	r2, [r7, #8]
    8204:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    8206:	e002      	b.n	820e <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    8208:	68fb      	ldr	r3, [r7, #12]
    820a:	68ba      	ldr	r2, [r7, #8]
    820c:	615a      	str	r2, [r3, #20]
	}
}
    820e:	46c0      	nop			; (mov r8, r8)
    8210:	46bd      	mov	sp, r7
    8212:	b004      	add	sp, #16
    8214:	bd80      	pop	{r7, pc}
    8216:	46c0      	nop			; (mov r8, r8)
    8218:	00008181 	.word	0x00008181

0000821c <system_interrupt_enable_global>:
 * \brief Enables global interrupts.
 *
 * Enables global interrupts in the device to fire any enabled interrupt handlers.
 */
static inline void system_interrupt_enable_global(void)
{
    821c:	b580      	push	{r7, lr}
    821e:	af00      	add	r7, sp, #0
	cpu_irq_enable();
    8220:	4b04      	ldr	r3, [pc, #16]	; (8234 <system_interrupt_enable_global+0x18>)
    8222:	2201      	movs	r2, #1
    8224:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    8226:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    822a:	b662      	cpsie	i
}
    822c:	46c0      	nop			; (mov r8, r8)
    822e:	46bd      	mov	sp, r7
    8230:	bd80      	pop	{r7, pc}
    8232:	46c0      	nop			; (mov r8, r8)
    8234:	20000051 	.word	0x20000051

00008238 <chip_isr>:
#include "conf_winc.h"

static tpfNmBspIsr gpfIsr;

static void chip_isr(void)
{
    8238:	b580      	push	{r7, lr}
    823a:	af00      	add	r7, sp, #0
	if (gpfIsr) {
    823c:	4b04      	ldr	r3, [pc, #16]	; (8250 <chip_isr+0x18>)
    823e:	681b      	ldr	r3, [r3, #0]
    8240:	2b00      	cmp	r3, #0
    8242:	d002      	beq.n	824a <chip_isr+0x12>
		gpfIsr();
    8244:	4b02      	ldr	r3, [pc, #8]	; (8250 <chip_isr+0x18>)
    8246:	681b      	ldr	r3, [r3, #0]
    8248:	4798      	blx	r3
	}
}
    824a:	46c0      	nop			; (mov r8, r8)
    824c:	46bd      	mov	sp, r7
    824e:	bd80      	pop	{r7, pc}
    8250:	200004fc 	.word	0x200004fc

00008254 <init_chip_pins>:
/*
 *	@fn		init_chip_pins
 *	@brief	Initialize reset, chip enable and wake pin
 */
static void init_chip_pins(void)
{
    8254:	b580      	push	{r7, lr}
    8256:	b082      	sub	sp, #8
    8258:	af00      	add	r7, sp, #0
	struct port_config pin_conf;

	port_get_config_defaults(&pin_conf);
    825a:	1d3b      	adds	r3, r7, #4
    825c:	0018      	movs	r0, r3
    825e:	4b0c      	ldr	r3, [pc, #48]	; (8290 <init_chip_pins+0x3c>)
    8260:	4798      	blx	r3

	/* Configure control pins as output. */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    8262:	1d3b      	adds	r3, r7, #4
    8264:	2201      	movs	r2, #1
    8266:	701a      	strb	r2, [r3, #0]
	port_pin_set_config(CONF_WINC_PIN_RESET, &pin_conf);
    8268:	1d3b      	adds	r3, r7, #4
    826a:	0019      	movs	r1, r3
    826c:	2026      	movs	r0, #38	; 0x26
    826e:	4b09      	ldr	r3, [pc, #36]	; (8294 <init_chip_pins+0x40>)
    8270:	4798      	blx	r3
	port_pin_set_config(CONF_WINC_PIN_CHIP_ENABLE, &pin_conf);
    8272:	1d3b      	adds	r3, r7, #4
    8274:	0019      	movs	r1, r3
    8276:	2025      	movs	r0, #37	; 0x25
    8278:	4b06      	ldr	r3, [pc, #24]	; (8294 <init_chip_pins+0x40>)
    827a:	4798      	blx	r3
	port_pin_set_config(CONF_WINC_PIN_WAKE, &pin_conf);
    827c:	1d3b      	adds	r3, r7, #4
    827e:	0019      	movs	r1, r3
    8280:	2027      	movs	r0, #39	; 0x27
    8282:	4b04      	ldr	r3, [pc, #16]	; (8294 <init_chip_pins+0x40>)
    8284:	4798      	blx	r3
}
    8286:	46c0      	nop			; (mov r8, r8)
    8288:	46bd      	mov	sp, r7
    828a:	b002      	add	sp, #8
    828c:	bd80      	pop	{r7, pc}
    828e:	46c0      	nop			; (mov r8, r8)
    8290:	000081a5 	.word	0x000081a5
    8294:	0001355d 	.word	0x0001355d

00008298 <nm_bsp_init>:
 *	@fn		nm_bsp_init
 *	@brief	Initialize BSP
 *	@return	0 in case of success and -1 in case of failure
 */
sint8 nm_bsp_init(void)
{
    8298:	b580      	push	{r7, lr}
    829a:	af00      	add	r7, sp, #0
	gpfIsr = NULL;
    829c:	4b0c      	ldr	r3, [pc, #48]	; (82d0 <nm_bsp_init+0x38>)
    829e:	2200      	movs	r2, #0
    82a0:	601a      	str	r2, [r3, #0]

	/* Initialize chip IOs. */
	init_chip_pins();
    82a2:	4b0c      	ldr	r3, [pc, #48]	; (82d4 <nm_bsp_init+0x3c>)
    82a4:	4798      	blx	r3

    /* Make sure a 1ms Systick is configured. */
    if (!(SysTick->CTRL & SysTick_CTRL_ENABLE_Msk && SysTick->CTRL & SysTick_CTRL_TICKINT_Msk)) {
    82a6:	4b0c      	ldr	r3, [pc, #48]	; (82d8 <nm_bsp_init+0x40>)
    82a8:	681b      	ldr	r3, [r3, #0]
    82aa:	2201      	movs	r2, #1
    82ac:	4013      	ands	r3, r2
    82ae:	d004      	beq.n	82ba <nm_bsp_init+0x22>
    82b0:	4b09      	ldr	r3, [pc, #36]	; (82d8 <nm_bsp_init+0x40>)
    82b2:	681b      	ldr	r3, [r3, #0]
    82b4:	2202      	movs	r2, #2
    82b6:	4013      	ands	r3, r2
    82b8:	d101      	bne.n	82be <nm_bsp_init+0x26>
	    delay_init();
    82ba:	4b08      	ldr	r3, [pc, #32]	; (82dc <nm_bsp_init+0x44>)
    82bc:	4798      	blx	r3
    }

	/* Perform chip reset. */
	nm_bsp_reset();
    82be:	4b08      	ldr	r3, [pc, #32]	; (82e0 <nm_bsp_init+0x48>)
    82c0:	4798      	blx	r3

	system_interrupt_enable_global();
    82c2:	4b08      	ldr	r3, [pc, #32]	; (82e4 <nm_bsp_init+0x4c>)
    82c4:	4798      	blx	r3

	return M2M_SUCCESS;
    82c6:	2300      	movs	r3, #0
}
    82c8:	0018      	movs	r0, r3
    82ca:	46bd      	mov	sp, r7
    82cc:	bd80      	pop	{r7, pc}
    82ce:	46c0      	nop			; (mov r8, r8)
    82d0:	200004fc 	.word	0x200004fc
    82d4:	00008255 	.word	0x00008255
    82d8:	e000e010 	.word	0xe000e010
    82dc:	00008115 	.word	0x00008115
    82e0:	000082e9 	.word	0x000082e9
    82e4:	0000821d 	.word	0x0000821d

000082e8 <nm_bsp_reset>:
 *	@fn		nm_bsp_reset
 *	@brief	Reset NMC1500 SoC by setting CHIP_EN and RESET_N signals low,
 *           CHIP_EN high then RESET_N high
 */
void nm_bsp_reset(void)
{
    82e8:	b580      	push	{r7, lr}
    82ea:	af00      	add	r7, sp, #0
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, false);
    82ec:	2100      	movs	r1, #0
    82ee:	2025      	movs	r0, #37	; 0x25
    82f0:	4b0c      	ldr	r3, [pc, #48]	; (8324 <nm_bsp_reset+0x3c>)
    82f2:	4798      	blx	r3
	port_pin_set_output_level(CONF_WINC_PIN_RESET, false);
    82f4:	2100      	movs	r1, #0
    82f6:	2026      	movs	r0, #38	; 0x26
    82f8:	4b0a      	ldr	r3, [pc, #40]	; (8324 <nm_bsp_reset+0x3c>)
    82fa:	4798      	blx	r3
	nm_bsp_sleep(100);
    82fc:	2064      	movs	r0, #100	; 0x64
    82fe:	4b0a      	ldr	r3, [pc, #40]	; (8328 <nm_bsp_reset+0x40>)
    8300:	4798      	blx	r3
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, true);
    8302:	2101      	movs	r1, #1
    8304:	2025      	movs	r0, #37	; 0x25
    8306:	4b07      	ldr	r3, [pc, #28]	; (8324 <nm_bsp_reset+0x3c>)
    8308:	4798      	blx	r3
	nm_bsp_sleep(10);
    830a:	200a      	movs	r0, #10
    830c:	4b06      	ldr	r3, [pc, #24]	; (8328 <nm_bsp_reset+0x40>)
    830e:	4798      	blx	r3
	port_pin_set_output_level(CONF_WINC_PIN_RESET, true);
    8310:	2101      	movs	r1, #1
    8312:	2026      	movs	r0, #38	; 0x26
    8314:	4b03      	ldr	r3, [pc, #12]	; (8324 <nm_bsp_reset+0x3c>)
    8316:	4798      	blx	r3
	nm_bsp_sleep(10);
    8318:	200a      	movs	r0, #10
    831a:	4b03      	ldr	r3, [pc, #12]	; (8328 <nm_bsp_reset+0x40>)
    831c:	4798      	blx	r3
}
    831e:	46c0      	nop			; (mov r8, r8)
    8320:	46bd      	mov	sp, r7
    8322:	bd80      	pop	{r7, pc}
    8324:	000081c9 	.word	0x000081c9
    8328:	0000832d 	.word	0x0000832d

0000832c <nm_bsp_sleep>:
 *	@brief	Sleep in units of mSec
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
    832c:	b5f0      	push	{r4, r5, r6, r7, lr}
    832e:	b083      	sub	sp, #12
    8330:	af00      	add	r7, sp, #0
    8332:	6078      	str	r0, [r7, #4]
	while (u32TimeMsec--) {
    8334:	e015      	b.n	8362 <nm_bsp_sleep+0x36>
		delay_ms(1);
    8336:	2000      	movs	r0, #0
    8338:	4b0e      	ldr	r3, [pc, #56]	; (8374 <nm_bsp_sleep+0x48>)
    833a:	4798      	blx	r3
    833c:	0003      	movs	r3, r0
    833e:	001d      	movs	r5, r3
    8340:	2300      	movs	r3, #0
    8342:	001e      	movs	r6, r3
    8344:	4b0c      	ldr	r3, [pc, #48]	; (8378 <nm_bsp_sleep+0x4c>)
    8346:	2400      	movs	r4, #0
    8348:	195b      	adds	r3, r3, r5
    834a:	4174      	adcs	r4, r6
    834c:	0018      	movs	r0, r3
    834e:	0021      	movs	r1, r4
    8350:	4c0a      	ldr	r4, [pc, #40]	; (837c <nm_bsp_sleep+0x50>)
    8352:	4a0b      	ldr	r2, [pc, #44]	; (8380 <nm_bsp_sleep+0x54>)
    8354:	2300      	movs	r3, #0
    8356:	47a0      	blx	r4
    8358:	0003      	movs	r3, r0
    835a:	000c      	movs	r4, r1
    835c:	0018      	movs	r0, r3
    835e:	4b09      	ldr	r3, [pc, #36]	; (8384 <nm_bsp_sleep+0x58>)
    8360:	4798      	blx	r3
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
	while (u32TimeMsec--) {
    8362:	687b      	ldr	r3, [r7, #4]
    8364:	1e5a      	subs	r2, r3, #1
    8366:	607a      	str	r2, [r7, #4]
    8368:	2b00      	cmp	r3, #0
    836a:	d1e4      	bne.n	8336 <nm_bsp_sleep+0xa>
		delay_ms(1);
	}
}
    836c:	46c0      	nop			; (mov r8, r8)
    836e:	46bd      	mov	sp, r7
    8370:	b003      	add	sp, #12
    8372:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8374:	00016909 	.word	0x00016909
    8378:	00001b57 	.word	0x00001b57
    837c:	0001d771 	.word	0x0001d771
    8380:	00001b58 	.word	0x00001b58
    8384:	20000001 	.word	0x20000001

00008388 <nm_bsp_register_isr>:
 *	@brief	Register interrupt service routine
 *	@param[IN]	pfIsr
 *				Pointer to ISR handler
 */
void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
{
    8388:	b580      	push	{r7, lr}
    838a:	b086      	sub	sp, #24
    838c:	af00      	add	r7, sp, #0
    838e:	6078      	str	r0, [r7, #4]
	struct extint_chan_conf config_extint_chan;

	gpfIsr = pfIsr;
    8390:	4b15      	ldr	r3, [pc, #84]	; (83e8 <nm_bsp_register_isr+0x60>)
    8392:	687a      	ldr	r2, [r7, #4]
    8394:	601a      	str	r2, [r3, #0]

	extint_chan_get_config_defaults(&config_extint_chan);
    8396:	230c      	movs	r3, #12
    8398:	18fb      	adds	r3, r7, r3
    839a:	0018      	movs	r0, r3
    839c:	4b13      	ldr	r3, [pc, #76]	; (83ec <nm_bsp_register_isr+0x64>)
    839e:	4798      	blx	r3
	config_extint_chan.gpio_pin = CONF_WINC_SPI_INT_PIN;
    83a0:	230c      	movs	r3, #12
    83a2:	18fb      	adds	r3, r7, r3
    83a4:	2224      	movs	r2, #36	; 0x24
    83a6:	601a      	str	r2, [r3, #0]
	config_extint_chan.gpio_pin_mux = CONF_WINC_SPI_INT_MUX;
    83a8:	230c      	movs	r3, #12
    83aa:	18fb      	adds	r3, r7, r3
    83ac:	2200      	movs	r2, #0
    83ae:	605a      	str	r2, [r3, #4]
	config_extint_chan.gpio_pin_pull = EXTINT_PULL_UP;
    83b0:	230c      	movs	r3, #12
    83b2:	18fb      	adds	r3, r7, r3
    83b4:	2201      	movs	r2, #1
    83b6:	721a      	strb	r2, [r3, #8]
	config_extint_chan.detection_criteria = EXTINT_DETECT_FALLING;
    83b8:	230c      	movs	r3, #12
    83ba:	18fb      	adds	r3, r7, r3
    83bc:	2202      	movs	r2, #2
    83be:	72da      	strb	r2, [r3, #11]

	extint_chan_set_config(CONF_WINC_SPI_INT_EIC, &config_extint_chan);
    83c0:	230c      	movs	r3, #12
    83c2:	18fb      	adds	r3, r7, r3
    83c4:	0019      	movs	r1, r3
    83c6:	2004      	movs	r0, #4
    83c8:	4b09      	ldr	r3, [pc, #36]	; (83f0 <nm_bsp_register_isr+0x68>)
    83ca:	4798      	blx	r3
	extint_register_callback(chip_isr, CONF_WINC_SPI_INT_EIC,
    83cc:	4b09      	ldr	r3, [pc, #36]	; (83f4 <nm_bsp_register_isr+0x6c>)
    83ce:	2200      	movs	r2, #0
    83d0:	2104      	movs	r1, #4
    83d2:	0018      	movs	r0, r3
    83d4:	4b08      	ldr	r3, [pc, #32]	; (83f8 <nm_bsp_register_isr+0x70>)
    83d6:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
	extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
    83d8:	2100      	movs	r1, #0
    83da:	2004      	movs	r0, #4
    83dc:	4b07      	ldr	r3, [pc, #28]	; (83fc <nm_bsp_register_isr+0x74>)
    83de:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
}
    83e0:	46c0      	nop			; (mov r8, r8)
    83e2:	46bd      	mov	sp, r7
    83e4:	b006      	add	sp, #24
    83e6:	bd80      	pop	{r7, pc}
    83e8:	200004fc 	.word	0x200004fc
    83ec:	0000eb1d 	.word	0x0000eb1d
    83f0:	0000eb51 	.word	0x0000eb51
    83f4:	00008239 	.word	0x00008239
    83f8:	0000e71d 	.word	0x0000e71d
    83fc:	0000e781 	.word	0x0000e781

00008400 <nm_bsp_interrupt_ctrl>:
 *	@brief	Enable/Disable interrupts
 *	@param[IN]	u8Enable
 *				'0' disable interrupts. '1' enable interrupts
 */
void nm_bsp_interrupt_ctrl(uint8 u8Enable)
{
    8400:	b580      	push	{r7, lr}
    8402:	b082      	sub	sp, #8
    8404:	af00      	add	r7, sp, #0
    8406:	0002      	movs	r2, r0
    8408:	1dfb      	adds	r3, r7, #7
    840a:	701a      	strb	r2, [r3, #0]
	if (u8Enable) {
    840c:	1dfb      	adds	r3, r7, #7
    840e:	781b      	ldrb	r3, [r3, #0]
    8410:	2b00      	cmp	r3, #0
    8412:	d004      	beq.n	841e <nm_bsp_interrupt_ctrl+0x1e>
		extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
    8414:	2100      	movs	r1, #0
    8416:	2004      	movs	r0, #4
    8418:	4b05      	ldr	r3, [pc, #20]	; (8430 <nm_bsp_interrupt_ctrl+0x30>)
    841a:	4798      	blx	r3
				EXTINT_CALLBACK_TYPE_DETECT);
	} else {
		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
				EXTINT_CALLBACK_TYPE_DETECT);
	}
}
    841c:	e003      	b.n	8426 <nm_bsp_interrupt_ctrl+0x26>
{
	if (u8Enable) {
		extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
				EXTINT_CALLBACK_TYPE_DETECT);
	} else {
		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
    841e:	2100      	movs	r1, #0
    8420:	2004      	movs	r0, #4
    8422:	4b04      	ldr	r3, [pc, #16]	; (8434 <nm_bsp_interrupt_ctrl+0x34>)
    8424:	4798      	blx	r3
				EXTINT_CALLBACK_TYPE_DETECT);
	}
}
    8426:	46c0      	nop			; (mov r8, r8)
    8428:	46bd      	mov	sp, r7
    842a:	b002      	add	sp, #8
    842c:	bd80      	pop	{r7, pc}
    842e:	46c0      	nop			; (mov r8, r8)
    8430:	0000e781 	.word	0x0000e781
    8434:	0000e7c9 	.word	0x0000e7c9

00008438 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    8438:	b580      	push	{r7, lr}
    843a:	b084      	sub	sp, #16
    843c:	af00      	add	r7, sp, #0
    843e:	0002      	movs	r2, r0
    8440:	1dfb      	adds	r3, r7, #7
    8442:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    8444:	230f      	movs	r3, #15
    8446:	18fb      	adds	r3, r7, r3
    8448:	1dfa      	adds	r2, r7, #7
    844a:	7812      	ldrb	r2, [r2, #0]
    844c:	09d2      	lsrs	r2, r2, #7
    844e:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    8450:	230e      	movs	r3, #14
    8452:	18fb      	adds	r3, r7, r3
    8454:	1dfa      	adds	r2, r7, #7
    8456:	7812      	ldrb	r2, [r2, #0]
    8458:	0952      	lsrs	r2, r2, #5
    845a:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    845c:	4b0d      	ldr	r3, [pc, #52]	; (8494 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    845e:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    8460:	230f      	movs	r3, #15
    8462:	18fb      	adds	r3, r7, r3
    8464:	781b      	ldrb	r3, [r3, #0]
    8466:	2b00      	cmp	r3, #0
    8468:	d10f      	bne.n	848a <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    846a:	230f      	movs	r3, #15
    846c:	18fb      	adds	r3, r7, r3
    846e:	781b      	ldrb	r3, [r3, #0]
    8470:	009b      	lsls	r3, r3, #2
    8472:	2210      	movs	r2, #16
    8474:	4694      	mov	ip, r2
    8476:	44bc      	add	ip, r7
    8478:	4463      	add	r3, ip
    847a:	3b08      	subs	r3, #8
    847c:	681a      	ldr	r2, [r3, #0]
    847e:	230e      	movs	r3, #14
    8480:	18fb      	adds	r3, r7, r3
    8482:	781b      	ldrb	r3, [r3, #0]
    8484:	01db      	lsls	r3, r3, #7
    8486:	18d3      	adds	r3, r2, r3
    8488:	e000      	b.n	848c <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    848a:	2300      	movs	r3, #0
	}
}
    848c:	0018      	movs	r0, r3
    848e:	46bd      	mov	sp, r7
    8490:	b004      	add	sp, #16
    8492:	bd80      	pop	{r7, pc}
    8494:	41004400 	.word	0x41004400

00008498 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    8498:	b580      	push	{r7, lr}
    849a:	b082      	sub	sp, #8
    849c:	af00      	add	r7, sp, #0
    849e:	0002      	movs	r2, r0
    84a0:	1dfb      	adds	r3, r7, #7
    84a2:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    84a4:	1dfb      	adds	r3, r7, #7
    84a6:	781b      	ldrb	r3, [r3, #0]
    84a8:	0018      	movs	r0, r3
    84aa:	4b03      	ldr	r3, [pc, #12]	; (84b8 <port_get_group_from_gpio_pin+0x20>)
    84ac:	4798      	blx	r3
    84ae:	0003      	movs	r3, r0
}
    84b0:	0018      	movs	r0, r3
    84b2:	46bd      	mov	sp, r7
    84b4:	b002      	add	sp, #8
    84b6:	bd80      	pop	{r7, pc}
    84b8:	00008439 	.word	0x00008439

000084bc <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    84bc:	b580      	push	{r7, lr}
    84be:	b082      	sub	sp, #8
    84c0:	af00      	add	r7, sp, #0
    84c2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    84c4:	687b      	ldr	r3, [r7, #4]
    84c6:	2200      	movs	r2, #0
    84c8:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    84ca:	687b      	ldr	r3, [r7, #4]
    84cc:	2201      	movs	r2, #1
    84ce:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    84d0:	687b      	ldr	r3, [r7, #4]
    84d2:	2200      	movs	r2, #0
    84d4:	709a      	strb	r2, [r3, #2]
}
    84d6:	46c0      	nop			; (mov r8, r8)
    84d8:	46bd      	mov	sp, r7
    84da:	b002      	add	sp, #8
    84dc:	bd80      	pop	{r7, pc}
    84de:	46c0      	nop			; (mov r8, r8)

000084e0 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    84e0:	b580      	push	{r7, lr}
    84e2:	b084      	sub	sp, #16
    84e4:	af00      	add	r7, sp, #0
    84e6:	0002      	movs	r2, r0
    84e8:	1dfb      	adds	r3, r7, #7
    84ea:	701a      	strb	r2, [r3, #0]
    84ec:	1dbb      	adds	r3, r7, #6
    84ee:	1c0a      	adds	r2, r1, #0
    84f0:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    84f2:	1dfb      	adds	r3, r7, #7
    84f4:	781b      	ldrb	r3, [r3, #0]
    84f6:	0018      	movs	r0, r3
    84f8:	4b0d      	ldr	r3, [pc, #52]	; (8530 <port_pin_set_output_level+0x50>)
    84fa:	4798      	blx	r3
    84fc:	0003      	movs	r3, r0
    84fe:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    8500:	1dfb      	adds	r3, r7, #7
    8502:	781b      	ldrb	r3, [r3, #0]
    8504:	221f      	movs	r2, #31
    8506:	4013      	ands	r3, r2
    8508:	2201      	movs	r2, #1
    850a:	409a      	lsls	r2, r3
    850c:	0013      	movs	r3, r2
    850e:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    8510:	1dbb      	adds	r3, r7, #6
    8512:	781b      	ldrb	r3, [r3, #0]
    8514:	2b00      	cmp	r3, #0
    8516:	d003      	beq.n	8520 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    8518:	68fb      	ldr	r3, [r7, #12]
    851a:	68ba      	ldr	r2, [r7, #8]
    851c:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    851e:	e002      	b.n	8526 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    8520:	68fb      	ldr	r3, [r7, #12]
    8522:	68ba      	ldr	r2, [r7, #8]
    8524:	615a      	str	r2, [r3, #20]
	}
}
    8526:	46c0      	nop			; (mov r8, r8)
    8528:	46bd      	mov	sp, r7
    852a:	b004      	add	sp, #16
    852c:	bd80      	pop	{r7, pc}
    852e:	46c0      	nop			; (mov r8, r8)
    8530:	00008499 	.word	0x00008499

00008534 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
    8534:	b580      	push	{r7, lr}
    8536:	b082      	sub	sp, #8
    8538:	af00      	add	r7, sp, #0
    853a:	0002      	movs	r2, r0
    853c:	1dfb      	adds	r3, r7, #7
    853e:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    8540:	4b06      	ldr	r3, [pc, #24]	; (855c <system_interrupt_enable+0x28>)
    8542:	1dfa      	adds	r2, r7, #7
    8544:	7812      	ldrb	r2, [r2, #0]
    8546:	0011      	movs	r1, r2
    8548:	221f      	movs	r2, #31
    854a:	400a      	ands	r2, r1
    854c:	2101      	movs	r1, #1
    854e:	4091      	lsls	r1, r2
    8550:	000a      	movs	r2, r1
    8552:	601a      	str	r2, [r3, #0]
}
    8554:	46c0      	nop			; (mov r8, r8)
    8556:	46bd      	mov	sp, r7
    8558:	b002      	add	sp, #8
    855a:	bd80      	pop	{r7, pc}
    855c:	e000e100 	.word	0xe000e100

00008560 <system_interrupt_disable>:
 *
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
    8560:	b580      	push	{r7, lr}
    8562:	b082      	sub	sp, #8
    8564:	af00      	add	r7, sp, #0
    8566:	0002      	movs	r2, r0
    8568:	1dfb      	adds	r3, r7, #7
    856a:	701a      	strb	r2, [r3, #0]
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    856c:	4a07      	ldr	r2, [pc, #28]	; (858c <system_interrupt_disable+0x2c>)
    856e:	1dfb      	adds	r3, r7, #7
    8570:	781b      	ldrb	r3, [r3, #0]
    8572:	0019      	movs	r1, r3
    8574:	231f      	movs	r3, #31
    8576:	400b      	ands	r3, r1
    8578:	2101      	movs	r1, #1
    857a:	4099      	lsls	r1, r3
    857c:	000b      	movs	r3, r1
    857e:	0019      	movs	r1, r3
    8580:	2380      	movs	r3, #128	; 0x80
    8582:	50d1      	str	r1, [r2, r3]
}
    8584:	46c0      	nop			; (mov r8, r8)
    8586:	46bd      	mov	sp, r7
    8588:	b002      	add	sp, #8
    858a:	bd80      	pop	{r7, pc}
    858c:	e000e100 	.word	0xe000e100

00008590 <spi_is_syncing>:
 * \retval false  Module synchronization is not ongoing
 *
 */
static inline bool spi_is_syncing(
		struct spi_module *const module)
{
    8590:	b580      	push	{r7, lr}
    8592:	b084      	sub	sp, #16
    8594:	af00      	add	r7, sp, #0
    8596:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    8598:	687b      	ldr	r3, [r7, #4]
    859a:	681b      	ldr	r3, [r3, #0]
    859c:	60fb      	str	r3, [r7, #12]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    859e:	68fb      	ldr	r3, [r7, #12]
    85a0:	69db      	ldr	r3, [r3, #28]
    85a2:	1e5a      	subs	r2, r3, #1
    85a4:	4193      	sbcs	r3, r2
    85a6:	b2db      	uxtb	r3, r3
#  else
	/* Return synchronization status */
	return (spi_module->STATUS.reg & SERCOM_SPI_STATUS_SYNCBUSY);
#  endif
}
    85a8:	0018      	movs	r0, r3
    85aa:	46bd      	mov	sp, r7
    85ac:	b004      	add	sp, #16
    85ae:	bd80      	pop	{r7, pc}

000085b0 <spi_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void spi_get_config_defaults(
		struct spi_config *const config)
{
    85b0:	b580      	push	{r7, lr}
    85b2:	b082      	sub	sp, #8
    85b4:	af00      	add	r7, sp, #0
    85b6:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
    85b8:	687b      	ldr	r3, [r7, #4]
    85ba:	2201      	movs	r2, #1
    85bc:	701a      	strb	r2, [r3, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
    85be:	687b      	ldr	r3, [r7, #4]
    85c0:	2200      	movs	r2, #0
    85c2:	605a      	str	r2, [r3, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
    85c4:	687b      	ldr	r3, [r7, #4]
    85c6:	2200      	movs	r2, #0
    85c8:	609a      	str	r2, [r3, #8]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
    85ca:	687b      	ldr	r3, [r7, #4]
    85cc:	22c0      	movs	r2, #192	; 0xc0
    85ce:	0392      	lsls	r2, r2, #14
    85d0:	60da      	str	r2, [r3, #12]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
    85d2:	687b      	ldr	r3, [r7, #4]
    85d4:	2200      	movs	r2, #0
    85d6:	741a      	strb	r2, [r3, #16]
	config->run_in_standby   = false;
    85d8:	687b      	ldr	r3, [r7, #4]
    85da:	2200      	movs	r2, #0
    85dc:	745a      	strb	r2, [r3, #17]
	config->receiver_enable  = true;
    85de:	687b      	ldr	r3, [r7, #4]
    85e0:	2201      	movs	r2, #1
    85e2:	749a      	strb	r2, [r3, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
    85e4:	687b      	ldr	r3, [r7, #4]
    85e6:	2201      	movs	r2, #1
    85e8:	74da      	strb	r2, [r3, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
    85ea:	687b      	ldr	r3, [r7, #4]
    85ec:	2200      	movs	r2, #0
    85ee:	751a      	strb	r2, [r3, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    85f0:	687b      	ldr	r3, [r7, #4]
    85f2:	2224      	movs	r2, #36	; 0x24
    85f4:	2100      	movs	r1, #0
    85f6:	5499      	strb	r1, [r3, r2]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
    85f8:	687b      	ldr	r3, [r7, #4]
    85fa:	3318      	adds	r3, #24
    85fc:	220c      	movs	r2, #12
    85fe:	2100      	movs	r1, #0
    8600:	0018      	movs	r0, r3
    8602:	4b0a      	ldr	r3, [pc, #40]	; (862c <spi_get_config_defaults+0x7c>)
    8604:	4798      	blx	r3

	/* Master config defaults */
	config->mode_specific.master.baudrate = 100000;
    8606:	687b      	ldr	r3, [r7, #4]
    8608:	4a09      	ldr	r2, [pc, #36]	; (8630 <spi_get_config_defaults+0x80>)
    860a:	619a      	str	r2, [r3, #24]

	/* pinmux config defaults */
	config->pinmux_pad0 = PINMUX_DEFAULT;
    860c:	687b      	ldr	r3, [r7, #4]
    860e:	2200      	movs	r2, #0
    8610:	629a      	str	r2, [r3, #40]	; 0x28
	config->pinmux_pad1 = PINMUX_DEFAULT;
    8612:	687b      	ldr	r3, [r7, #4]
    8614:	2200      	movs	r2, #0
    8616:	62da      	str	r2, [r3, #44]	; 0x2c
	config->pinmux_pad2 = PINMUX_DEFAULT;
    8618:	687b      	ldr	r3, [r7, #4]
    861a:	2200      	movs	r2, #0
    861c:	631a      	str	r2, [r3, #48]	; 0x30
	config->pinmux_pad3 = PINMUX_DEFAULT;
    861e:	687b      	ldr	r3, [r7, #4]
    8620:	2200      	movs	r2, #0
    8622:	635a      	str	r2, [r3, #52]	; 0x34

};
    8624:	46c0      	nop			; (mov r8, r8)
    8626:	46bd      	mov	sp, r7
    8628:	b002      	add	sp, #8
    862a:	bd80      	pop	{r7, pc}
    862c:	0001eead 	.word	0x0001eead
    8630:	000186a0 	.word	0x000186a0

00008634 <spi_slave_inst_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void spi_slave_inst_get_config_defaults(
		struct spi_slave_inst_config *const config)
{
    8634:	b580      	push	{r7, lr}
    8636:	b082      	sub	sp, #8
    8638:	af00      	add	r7, sp, #0
    863a:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->ss_pin          = 10;
    863c:	687b      	ldr	r3, [r7, #4]
    863e:	220a      	movs	r2, #10
    8640:	701a      	strb	r2, [r3, #0]
	config->address_enabled = false;
    8642:	687b      	ldr	r3, [r7, #4]
    8644:	2200      	movs	r2, #0
    8646:	705a      	strb	r2, [r3, #1]
	config->address         = 0;
    8648:	687b      	ldr	r3, [r7, #4]
    864a:	2200      	movs	r2, #0
    864c:	709a      	strb	r2, [r3, #2]
}
    864e:	46c0      	nop			; (mov r8, r8)
    8650:	46bd      	mov	sp, r7
    8652:	b002      	add	sp, #8
    8654:	bd80      	pop	{r7, pc}
    8656:	46c0      	nop			; (mov r8, r8)

00008658 <spi_attach_slave>:
 *
 */
static inline void spi_attach_slave(
		struct spi_slave_inst *const slave,
		const struct spi_slave_inst_config *const config)
{
    8658:	b580      	push	{r7, lr}
    865a:	b084      	sub	sp, #16
    865c:	af00      	add	r7, sp, #0
    865e:	6078      	str	r0, [r7, #4]
    8660:	6039      	str	r1, [r7, #0]
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
    8662:	683b      	ldr	r3, [r7, #0]
    8664:	781a      	ldrb	r2, [r3, #0]
    8666:	687b      	ldr	r3, [r7, #4]
    8668:	701a      	strb	r2, [r3, #0]
	slave->address_enabled = config->address_enabled;
    866a:	683b      	ldr	r3, [r7, #0]
    866c:	785a      	ldrb	r2, [r3, #1]
    866e:	687b      	ldr	r3, [r7, #4]
    8670:	705a      	strb	r2, [r3, #1]
	slave->address         = config->address;
    8672:	683b      	ldr	r3, [r7, #0]
    8674:	789a      	ldrb	r2, [r3, #2]
    8676:	687b      	ldr	r3, [r7, #4]
    8678:	709a      	strb	r2, [r3, #2]

	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);
    867a:	230c      	movs	r3, #12
    867c:	18fb      	adds	r3, r7, r3
    867e:	0018      	movs	r0, r3
    8680:	4b0b      	ldr	r3, [pc, #44]	; (86b0 <spi_attach_slave+0x58>)
    8682:	4798      	blx	r3

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
    8684:	230c      	movs	r3, #12
    8686:	18fb      	adds	r3, r7, r3
    8688:	2201      	movs	r2, #1
    868a:	701a      	strb	r2, [r3, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
    868c:	687b      	ldr	r3, [r7, #4]
    868e:	781b      	ldrb	r3, [r3, #0]
    8690:	220c      	movs	r2, #12
    8692:	18ba      	adds	r2, r7, r2
    8694:	0011      	movs	r1, r2
    8696:	0018      	movs	r0, r3
    8698:	4b06      	ldr	r3, [pc, #24]	; (86b4 <spi_attach_slave+0x5c>)
    869a:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
    869c:	687b      	ldr	r3, [r7, #4]
    869e:	781b      	ldrb	r3, [r3, #0]
    86a0:	2101      	movs	r1, #1
    86a2:	0018      	movs	r0, r3
    86a4:	4b04      	ldr	r3, [pc, #16]	; (86b8 <spi_attach_slave+0x60>)
    86a6:	4798      	blx	r3
}
    86a8:	46c0      	nop			; (mov r8, r8)
    86aa:	46bd      	mov	sp, r7
    86ac:	b004      	add	sp, #16
    86ae:	bd80      	pop	{r7, pc}
    86b0:	000084bd 	.word	0x000084bd
    86b4:	0001355d 	.word	0x0001355d
    86b8:	000084e1 	.word	0x000084e1

000086bc <spi_enable>:
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
static inline void spi_enable(
		struct spi_module *const module)
{
    86bc:	b580      	push	{r7, lr}
    86be:	b084      	sub	sp, #16
    86c0:	af00      	add	r7, sp, #0
    86c2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    86c4:	687b      	ldr	r3, [r7, #4]
    86c6:	681b      	ldr	r3, [r3, #0]
    86c8:	60fb      	str	r3, [r7, #12]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    86ca:	687b      	ldr	r3, [r7, #4]
    86cc:	681b      	ldr	r3, [r3, #0]
    86ce:	0018      	movs	r0, r3
    86d0:	4b0b      	ldr	r3, [pc, #44]	; (8700 <spi_enable+0x44>)
    86d2:	4798      	blx	r3
    86d4:	0003      	movs	r3, r0
    86d6:	0018      	movs	r0, r3
    86d8:	4b0a      	ldr	r3, [pc, #40]	; (8704 <spi_enable+0x48>)
    86da:	4798      	blx	r3
#  endif

	while (spi_is_syncing(module)) {
    86dc:	46c0      	nop			; (mov r8, r8)
    86de:	687b      	ldr	r3, [r7, #4]
    86e0:	0018      	movs	r0, r3
    86e2:	4b09      	ldr	r3, [pc, #36]	; (8708 <spi_enable+0x4c>)
    86e4:	4798      	blx	r3
    86e6:	1e03      	subs	r3, r0, #0
    86e8:	d1f9      	bne.n	86de <spi_enable+0x22>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    86ea:	68fb      	ldr	r3, [r7, #12]
    86ec:	681b      	ldr	r3, [r3, #0]
    86ee:	2202      	movs	r2, #2
    86f0:	431a      	orrs	r2, r3
    86f2:	68fb      	ldr	r3, [r7, #12]
    86f4:	601a      	str	r2, [r3, #0]
}
    86f6:	46c0      	nop			; (mov r8, r8)
    86f8:	46bd      	mov	sp, r7
    86fa:	b004      	add	sp, #16
    86fc:	bd80      	pop	{r7, pc}
    86fe:	46c0      	nop			; (mov r8, r8)
    8700:	00014119 	.word	0x00014119
    8704:	00008535 	.word	0x00008535
    8708:	00008591 	.word	0x00008591

0000870c <spi_disable>:
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
static inline void spi_disable(
		struct spi_module *const module)
{
    870c:	b580      	push	{r7, lr}
    870e:	b084      	sub	sp, #16
    8710:	af00      	add	r7, sp, #0
    8712:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    8714:	687b      	ldr	r3, [r7, #4]
    8716:	681b      	ldr	r3, [r3, #0]
    8718:	60fb      	str	r3, [r7, #12]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
    871a:	687b      	ldr	r3, [r7, #4]
    871c:	681b      	ldr	r3, [r3, #0]
    871e:	0018      	movs	r0, r3
    8720:	4b0b      	ldr	r3, [pc, #44]	; (8750 <spi_disable+0x44>)
    8722:	4798      	blx	r3
    8724:	0003      	movs	r3, r0
    8726:	0018      	movs	r0, r3
    8728:	4b0a      	ldr	r3, [pc, #40]	; (8754 <spi_disable+0x48>)
    872a:	4798      	blx	r3
#  endif

	while (spi_is_syncing(module)) {
    872c:	46c0      	nop			; (mov r8, r8)
    872e:	687b      	ldr	r3, [r7, #4]
    8730:	0018      	movs	r0, r3
    8732:	4b09      	ldr	r3, [pc, #36]	; (8758 <spi_disable+0x4c>)
    8734:	4798      	blx	r3
    8736:	1e03      	subs	r3, r0, #0
    8738:	d1f9      	bne.n	872e <spi_disable+0x22>
		/* Wait until the synchronization is complete */
	}

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    873a:	68fb      	ldr	r3, [r7, #12]
    873c:	681b      	ldr	r3, [r3, #0]
    873e:	2202      	movs	r2, #2
    8740:	4393      	bics	r3, r2
    8742:	001a      	movs	r2, r3
    8744:	68fb      	ldr	r3, [r7, #12]
    8746:	601a      	str	r2, [r3, #0]
}
    8748:	46c0      	nop			; (mov r8, r8)
    874a:	46bd      	mov	sp, r7
    874c:	b004      	add	sp, #16
    874e:	bd80      	pop	{r7, pc}
    8750:	00014119 	.word	0x00014119
    8754:	00008561 	.word	0x00008561
    8758:	00008591 	.word	0x00008591

0000875c <spi_is_write_complete>:
 *                has been drawn high for SPI slave
 * \retval false  If the SPI master module has not shifted out data
 */
static inline bool spi_is_write_complete(
		struct spi_module *const module)
{
    875c:	b580      	push	{r7, lr}
    875e:	b084      	sub	sp, #16
    8760:	af00      	add	r7, sp, #0
    8762:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    8764:	687b      	ldr	r3, [r7, #4]
    8766:	681b      	ldr	r3, [r3, #0]
    8768:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    876a:	68fb      	ldr	r3, [r7, #12]
    876c:	7e1b      	ldrb	r3, [r3, #24]
    876e:	b2db      	uxtb	r3, r3
    8770:	001a      	movs	r2, r3
    8772:	2302      	movs	r3, #2
    8774:	4013      	ands	r3, r2
    8776:	1e5a      	subs	r2, r3, #1
    8778:	4193      	sbcs	r3, r2
    877a:	b2db      	uxtb	r3, r3
}
    877c:	0018      	movs	r0, r3
    877e:	46bd      	mov	sp, r7
    8780:	b004      	add	sp, #16
    8782:	bd80      	pop	{r7, pc}

00008784 <spi_is_ready_to_write>:
 * \retval true   If the SPI module is ready to write data
 * \retval false  If the SPI module is not ready to write data
 */
static inline bool spi_is_ready_to_write(
		struct spi_module *const module)
{
    8784:	b580      	push	{r7, lr}
    8786:	b084      	sub	sp, #16
    8788:	af00      	add	r7, sp, #0
    878a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    878c:	687b      	ldr	r3, [r7, #4]
    878e:	681b      	ldr	r3, [r3, #0]
    8790:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    8792:	68fb      	ldr	r3, [r7, #12]
    8794:	7e1b      	ldrb	r3, [r3, #24]
    8796:	b2db      	uxtb	r3, r3
    8798:	001a      	movs	r2, r3
    879a:	2301      	movs	r3, #1
    879c:	4013      	ands	r3, r2
    879e:	1e5a      	subs	r2, r3, #1
    87a0:	4193      	sbcs	r3, r2
    87a2:	b2db      	uxtb	r3, r3
}
    87a4:	0018      	movs	r0, r3
    87a6:	46bd      	mov	sp, r7
    87a8:	b004      	add	sp, #16
    87aa:	bd80      	pop	{r7, pc}

000087ac <spi_is_ready_to_read>:
 * \retval true   If the SPI module is ready to read data
 * \retval false  If the SPI module is not ready to read data
 */
static inline bool spi_is_ready_to_read(
		struct spi_module *const module)
{
    87ac:	b580      	push	{r7, lr}
    87ae:	b084      	sub	sp, #16
    87b0:	af00      	add	r7, sp, #0
    87b2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    87b4:	687b      	ldr	r3, [r7, #4]
    87b6:	681b      	ldr	r3, [r3, #0]
    87b8:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    87ba:	68fb      	ldr	r3, [r7, #12]
    87bc:	7e1b      	ldrb	r3, [r3, #24]
    87be:	b2db      	uxtb	r3, r3
    87c0:	001a      	movs	r2, r3
    87c2:	2304      	movs	r3, #4
    87c4:	4013      	ands	r3, r2
    87c6:	1e5a      	subs	r2, r3, #1
    87c8:	4193      	sbcs	r3, r2
    87ca:	b2db      	uxtb	r3, r3
}
    87cc:	0018      	movs	r0, r3
    87ce:	46bd      	mov	sp, r7
    87d0:	b004      	add	sp, #16
    87d2:	bd80      	pop	{r7, pc}

000087d4 <spi_write>:
 * \retval STATUS_BUSY  If the last write was not completed
 */
static inline enum status_code spi_write(
		struct spi_module *module,
		uint16_t tx_data)
{
    87d4:	b580      	push	{r7, lr}
    87d6:	b084      	sub	sp, #16
    87d8:	af00      	add	r7, sp, #0
    87da:	6078      	str	r0, [r7, #4]
    87dc:	000a      	movs	r2, r1
    87de:	1cbb      	adds	r3, r7, #2
    87e0:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    87e2:	687b      	ldr	r3, [r7, #4]
    87e4:	681b      	ldr	r3, [r3, #0]
    87e6:	60fb      	str	r3, [r7, #12]

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    87e8:	687b      	ldr	r3, [r7, #4]
    87ea:	0018      	movs	r0, r3
    87ec:	4b0a      	ldr	r3, [pc, #40]	; (8818 <spi_write+0x44>)
    87ee:	4798      	blx	r3
    87f0:	0003      	movs	r3, r0
    87f2:	001a      	movs	r2, r3
    87f4:	2301      	movs	r3, #1
    87f6:	4053      	eors	r3, r2
    87f8:	b2db      	uxtb	r3, r3
    87fa:	2b00      	cmp	r3, #0
    87fc:	d001      	beq.n	8802 <spi_write+0x2e>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
    87fe:	2305      	movs	r3, #5
    8800:	e006      	b.n	8810 <spi_write+0x3c>
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    8802:	1cbb      	adds	r3, r7, #2
    8804:	881b      	ldrh	r3, [r3, #0]
    8806:	05db      	lsls	r3, r3, #23
    8808:	0dda      	lsrs	r2, r3, #23
    880a:	68fb      	ldr	r3, [r7, #12]
    880c:	629a      	str	r2, [r3, #40]	; 0x28

	return STATUS_OK;
    880e:	2300      	movs	r3, #0
}
    8810:	0018      	movs	r0, r3
    8812:	46bd      	mov	sp, r7
    8814:	b004      	add	sp, #16
    8816:	bd80      	pop	{r7, pc}
    8818:	00008785 	.word	0x00008785

0000881c <spi_read>:
 * \retval STATUS_ERR_OVERFLOW  If the data is overflown
 */
static inline enum status_code spi_read(
		struct spi_module *const module,
		uint16_t *rx_data)
{
    881c:	b580      	push	{r7, lr}
    881e:	b084      	sub	sp, #16
    8820:	af00      	add	r7, sp, #0
    8822:	6078      	str	r0, [r7, #4]
    8824:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    8826:	687b      	ldr	r3, [r7, #4]
    8828:	681b      	ldr	r3, [r3, #0]
    882a:	60bb      	str	r3, [r7, #8]

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    882c:	687b      	ldr	r3, [r7, #4]
    882e:	0018      	movs	r0, r3
    8830:	4b1d      	ldr	r3, [pc, #116]	; (88a8 <spi_read+0x8c>)
    8832:	4798      	blx	r3
    8834:	0003      	movs	r3, r0
    8836:	001a      	movs	r2, r3
    8838:	2301      	movs	r3, #1
    883a:	4053      	eors	r3, r2
    883c:	b2db      	uxtb	r3, r3
    883e:	2b00      	cmp	r3, #0
    8840:	d001      	beq.n	8846 <spi_read+0x2a>
		/* No data has been received, return */
		return STATUS_ERR_IO;
    8842:	2310      	movs	r3, #16
    8844:	e02c      	b.n	88a0 <spi_read+0x84>
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    8846:	230f      	movs	r3, #15
    8848:	18fb      	adds	r3, r7, r3
    884a:	2200      	movs	r2, #0
    884c:	701a      	strb	r2, [r3, #0]

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    884e:	68bb      	ldr	r3, [r7, #8]
    8850:	8b5b      	ldrh	r3, [r3, #26]
    8852:	b29b      	uxth	r3, r3
    8854:	001a      	movs	r2, r3
    8856:	2304      	movs	r3, #4
    8858:	4013      	ands	r3, r2
    885a:	d00b      	beq.n	8874 <spi_read+0x58>
		retval = STATUS_ERR_OVERFLOW;
    885c:	230f      	movs	r3, #15
    885e:	18fb      	adds	r3, r7, r3
    8860:	221e      	movs	r2, #30
    8862:	701a      	strb	r2, [r3, #0]
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    8864:	68bb      	ldr	r3, [r7, #8]
    8866:	8b5b      	ldrh	r3, [r3, #26]
    8868:	b29b      	uxth	r3, r3
    886a:	2204      	movs	r2, #4
    886c:	4313      	orrs	r3, r2
    886e:	b29a      	uxth	r2, r3
    8870:	68bb      	ldr	r3, [r7, #8]
    8872:	835a      	strh	r2, [r3, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    8874:	687b      	ldr	r3, [r7, #4]
    8876:	799b      	ldrb	r3, [r3, #6]
    8878:	2b01      	cmp	r3, #1
    887a:	d108      	bne.n	888e <spi_read+0x72>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    887c:	68bb      	ldr	r3, [r7, #8]
    887e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    8880:	b29b      	uxth	r3, r3
    8882:	05db      	lsls	r3, r3, #23
    8884:	0ddb      	lsrs	r3, r3, #23
    8886:	b29a      	uxth	r2, r3
    8888:	683b      	ldr	r3, [r7, #0]
    888a:	801a      	strh	r2, [r3, #0]
    888c:	e005      	b.n	889a <spi_read+0x7e>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    888e:	68bb      	ldr	r3, [r7, #8]
    8890:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    8892:	b2db      	uxtb	r3, r3
    8894:	b29a      	uxth	r2, r3
    8896:	683b      	ldr	r3, [r7, #0]
    8898:	801a      	strh	r2, [r3, #0]
	}

	return retval;
    889a:	230f      	movs	r3, #15
    889c:	18fb      	adds	r3, r7, r3
    889e:	781b      	ldrb	r3, [r3, #0]
}
    88a0:	0018      	movs	r0, r3
    88a2:	46bd      	mov	sp, r7
    88a4:	b004      	add	sp, #16
    88a6:	bd80      	pop	{r7, pc}
    88a8:	000087ad 	.word	0x000087ad

000088ac <spi_rw>:

struct spi_module master;
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
    88ac:	b580      	push	{r7, lr}
    88ae:	b086      	sub	sp, #24
    88b0:	af00      	add	r7, sp, #0
    88b2:	60f8      	str	r0, [r7, #12]
    88b4:	60b9      	str	r1, [r7, #8]
    88b6:	1dbb      	adds	r3, r7, #6
    88b8:	801a      	strh	r2, [r3, #0]
	uint8 u8Dummy = 0;
    88ba:	2313      	movs	r3, #19
    88bc:	18fb      	adds	r3, r7, r3
    88be:	2200      	movs	r2, #0
    88c0:	701a      	strb	r2, [r3, #0]
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
    88c2:	2317      	movs	r3, #23
    88c4:	18fb      	adds	r3, r7, r3
    88c6:	2200      	movs	r2, #0
    88c8:	701a      	strb	r2, [r3, #0]
    88ca:	2316      	movs	r3, #22
    88cc:	18fb      	adds	r3, r7, r3
    88ce:	2200      	movs	r2, #0
    88d0:	701a      	strb	r2, [r3, #0]
	uint16_t txd_data = 0;
    88d2:	2314      	movs	r3, #20
    88d4:	18fb      	adds	r3, r7, r3
    88d6:	2200      	movs	r2, #0
    88d8:	801a      	strh	r2, [r3, #0]
	uint16_t rxd_data = 0;
    88da:	2310      	movs	r3, #16
    88dc:	18fb      	adds	r3, r7, r3
    88de:	2200      	movs	r2, #0
    88e0:	801a      	strh	r2, [r3, #0]

	if (!pu8Mosi) {
    88e2:	68fb      	ldr	r3, [r7, #12]
    88e4:	2b00      	cmp	r3, #0
    88e6:	d107      	bne.n	88f8 <spi_rw+0x4c>
		pu8Mosi = &u8Dummy;
    88e8:	2313      	movs	r3, #19
    88ea:	18fb      	adds	r3, r7, r3
    88ec:	60fb      	str	r3, [r7, #12]
		u8SkipMosi = 1;
    88ee:	2317      	movs	r3, #23
    88f0:	18fb      	adds	r3, r7, r3
    88f2:	2201      	movs	r2, #1
    88f4:	701a      	strb	r2, [r3, #0]
    88f6:	e00d      	b.n	8914 <spi_rw+0x68>
	}
	else if(!pu8Miso) {
    88f8:	68bb      	ldr	r3, [r7, #8]
    88fa:	2b00      	cmp	r3, #0
    88fc:	d107      	bne.n	890e <spi_rw+0x62>
		pu8Miso = &u8Dummy;
    88fe:	2313      	movs	r3, #19
    8900:	18fb      	adds	r3, r7, r3
    8902:	60bb      	str	r3, [r7, #8]
		u8SkipMiso = 1;
    8904:	2316      	movs	r3, #22
    8906:	18fb      	adds	r3, r7, r3
    8908:	2201      	movs	r2, #1
    890a:	701a      	strb	r2, [r3, #0]
    890c:	e002      	b.n	8914 <spi_rw+0x68>
	}
	else {
		return M2M_ERR_BUS_FAIL;
    890e:	2306      	movs	r3, #6
    8910:	425b      	negs	r3, r3
    8912:	e06a      	b.n	89ea <spi_rw+0x13e>
	}

	spi_select_slave(&master, &slave_inst, true);
    8914:	4937      	ldr	r1, [pc, #220]	; (89f4 <spi_rw+0x148>)
    8916:	4b38      	ldr	r3, [pc, #224]	; (89f8 <spi_rw+0x14c>)
    8918:	2201      	movs	r2, #1
    891a:	0018      	movs	r0, r3
    891c:	4b37      	ldr	r3, [pc, #220]	; (89fc <spi_rw+0x150>)
    891e:	4798      	blx	r3

	while (u16Sz) {
    8920:	e04c      	b.n	89bc <spi_rw+0x110>
		txd_data = *pu8Mosi;
    8922:	68fb      	ldr	r3, [r7, #12]
    8924:	781a      	ldrb	r2, [r3, #0]
    8926:	2314      	movs	r3, #20
    8928:	18fb      	adds	r3, r7, r3
    892a:	801a      	strh	r2, [r3, #0]
		while (!spi_is_ready_to_write(&master))
    892c:	46c0      	nop			; (mov r8, r8)
    892e:	4b32      	ldr	r3, [pc, #200]	; (89f8 <spi_rw+0x14c>)
    8930:	0018      	movs	r0, r3
    8932:	4b33      	ldr	r3, [pc, #204]	; (8a00 <spi_rw+0x154>)
    8934:	4798      	blx	r3
    8936:	0003      	movs	r3, r0
    8938:	001a      	movs	r2, r3
    893a:	2301      	movs	r3, #1
    893c:	4053      	eors	r3, r2
    893e:	b2db      	uxtb	r3, r3
    8940:	2b00      	cmp	r3, #0
    8942:	d1f4      	bne.n	892e <spi_rw+0x82>
			;
		while(spi_write(&master, txd_data) != STATUS_OK)
    8944:	46c0      	nop			; (mov r8, r8)
    8946:	2314      	movs	r3, #20
    8948:	18fb      	adds	r3, r7, r3
    894a:	881a      	ldrh	r2, [r3, #0]
    894c:	4b2a      	ldr	r3, [pc, #168]	; (89f8 <spi_rw+0x14c>)
    894e:	0011      	movs	r1, r2
    8950:	0018      	movs	r0, r3
    8952:	4b2c      	ldr	r3, [pc, #176]	; (8a04 <spi_rw+0x158>)
    8954:	4798      	blx	r3
    8956:	1e03      	subs	r3, r0, #0
    8958:	d1f5      	bne.n	8946 <spi_rw+0x9a>
			;

		/* Read SPI master data register. */
		while (!spi_is_ready_to_read(&master))
    895a:	46c0      	nop			; (mov r8, r8)
    895c:	4b26      	ldr	r3, [pc, #152]	; (89f8 <spi_rw+0x14c>)
    895e:	0018      	movs	r0, r3
    8960:	4b29      	ldr	r3, [pc, #164]	; (8a08 <spi_rw+0x15c>)
    8962:	4798      	blx	r3
    8964:	0003      	movs	r3, r0
    8966:	001a      	movs	r2, r3
    8968:	2301      	movs	r3, #1
    896a:	4053      	eors	r3, r2
    896c:	b2db      	uxtb	r3, r3
    896e:	2b00      	cmp	r3, #0
    8970:	d1f4      	bne.n	895c <spi_rw+0xb0>
			;
		while (spi_read(&master, &rxd_data) != STATUS_OK)
    8972:	46c0      	nop			; (mov r8, r8)
    8974:	2310      	movs	r3, #16
    8976:	18fa      	adds	r2, r7, r3
    8978:	4b1f      	ldr	r3, [pc, #124]	; (89f8 <spi_rw+0x14c>)
    897a:	0011      	movs	r1, r2
    897c:	0018      	movs	r0, r3
    897e:	4b23      	ldr	r3, [pc, #140]	; (8a0c <spi_rw+0x160>)
    8980:	4798      	blx	r3
    8982:	1e03      	subs	r3, r0, #0
    8984:	d1f6      	bne.n	8974 <spi_rw+0xc8>
			;
		*pu8Miso = rxd_data;
    8986:	2310      	movs	r3, #16
    8988:	18fb      	adds	r3, r7, r3
    898a:	881b      	ldrh	r3, [r3, #0]
    898c:	b2da      	uxtb	r2, r3
    898e:	68bb      	ldr	r3, [r7, #8]
    8990:	701a      	strb	r2, [r3, #0]

		u16Sz--;
    8992:	1dbb      	adds	r3, r7, #6
    8994:	881a      	ldrh	r2, [r3, #0]
    8996:	1dbb      	adds	r3, r7, #6
    8998:	3a01      	subs	r2, #1
    899a:	801a      	strh	r2, [r3, #0]
		if (!u8SkipMiso)
    899c:	2316      	movs	r3, #22
    899e:	18fb      	adds	r3, r7, r3
    89a0:	781b      	ldrb	r3, [r3, #0]
    89a2:	2b00      	cmp	r3, #0
    89a4:	d102      	bne.n	89ac <spi_rw+0x100>
			pu8Miso++;
    89a6:	68bb      	ldr	r3, [r7, #8]
    89a8:	3301      	adds	r3, #1
    89aa:	60bb      	str	r3, [r7, #8]
		if (!u8SkipMosi)
    89ac:	2317      	movs	r3, #23
    89ae:	18fb      	adds	r3, r7, r3
    89b0:	781b      	ldrb	r3, [r3, #0]
    89b2:	2b00      	cmp	r3, #0
    89b4:	d102      	bne.n	89bc <spi_rw+0x110>
			pu8Mosi++;
    89b6:	68fb      	ldr	r3, [r7, #12]
    89b8:	3301      	adds	r3, #1
    89ba:	60fb      	str	r3, [r7, #12]
		return M2M_ERR_BUS_FAIL;
	}

	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
    89bc:	1dbb      	adds	r3, r7, #6
    89be:	881b      	ldrh	r3, [r3, #0]
    89c0:	2b00      	cmp	r3, #0
    89c2:	d1ae      	bne.n	8922 <spi_rw+0x76>
			pu8Miso++;
		if (!u8SkipMosi)
			pu8Mosi++;
	}

	while (!spi_is_write_complete(&master))
    89c4:	46c0      	nop			; (mov r8, r8)
    89c6:	4b0c      	ldr	r3, [pc, #48]	; (89f8 <spi_rw+0x14c>)
    89c8:	0018      	movs	r0, r3
    89ca:	4b11      	ldr	r3, [pc, #68]	; (8a10 <spi_rw+0x164>)
    89cc:	4798      	blx	r3
    89ce:	0003      	movs	r3, r0
    89d0:	001a      	movs	r2, r3
    89d2:	2301      	movs	r3, #1
    89d4:	4053      	eors	r3, r2
    89d6:	b2db      	uxtb	r3, r3
    89d8:	2b00      	cmp	r3, #0
    89da:	d1f4      	bne.n	89c6 <spi_rw+0x11a>
		;

	spi_select_slave(&master, &slave_inst, false);
    89dc:	4905      	ldr	r1, [pc, #20]	; (89f4 <spi_rw+0x148>)
    89de:	4b06      	ldr	r3, [pc, #24]	; (89f8 <spi_rw+0x14c>)
    89e0:	2200      	movs	r2, #0
    89e2:	0018      	movs	r0, r3
    89e4:	4b05      	ldr	r3, [pc, #20]	; (89fc <spi_rw+0x150>)
    89e6:	4798      	blx	r3
	
	return M2M_SUCCESS;
    89e8:	2300      	movs	r3, #0
}
    89ea:	0018      	movs	r0, r3
    89ec:	46bd      	mov	sp, r7
    89ee:	b006      	add	sp, #24
    89f0:	bd80      	pop	{r7, pc}
    89f2:	46c0      	nop			; (mov r8, r8)
    89f4:	200030c4 	.word	0x200030c4
    89f8:	200030c8 	.word	0x200030c8
    89fc:	00014c41 	.word	0x00014c41
    8a00:	00008785 	.word	0x00008785
    8a04:	000087d5 	.word	0x000087d5
    8a08:	000087ad 	.word	0x000087ad
    8a0c:	0000881d 	.word	0x0000881d
    8a10:	0000875d 	.word	0x0000875d

00008a14 <nm_bus_init>:
*	@fn		nm_bus_init
*	@brief	Initialize the bus wrapper
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*/
sint8 nm_bus_init(void *pvinit)
{
    8a14:	b580      	push	{r7, lr}
    8a16:	b092      	sub	sp, #72	; 0x48
    8a18:	af00      	add	r7, sp, #0
    8a1a:	6078      	str	r0, [r7, #4]
	sint8 result = M2M_SUCCESS;
    8a1c:	2347      	movs	r3, #71	; 0x47
    8a1e:	18fb      	adds	r3, r7, r3
    8a20:	2200      	movs	r2, #0
    8a22:	701a      	strb	r2, [r3, #0]
	struct spi_config config;
	struct spi_slave_inst_config slave_config;

	/* Select SPI slave CS pin. */
	/* This step will set the CS high */
	spi_slave_inst_get_config_defaults(&slave_config);
    8a24:	2308      	movs	r3, #8
    8a26:	18fb      	adds	r3, r7, r3
    8a28:	0018      	movs	r0, r3
    8a2a:	4b26      	ldr	r3, [pc, #152]	; (8ac4 <nm_bus_init+0xb0>)
    8a2c:	4798      	blx	r3
	slave_config.ss_pin = CONF_WINC_SPI_CS_PIN;
    8a2e:	2308      	movs	r3, #8
    8a30:	18fb      	adds	r3, r7, r3
    8a32:	2205      	movs	r2, #5
    8a34:	701a      	strb	r2, [r3, #0]
	spi_attach_slave(&slave_inst, &slave_config);
    8a36:	2308      	movs	r3, #8
    8a38:	18fa      	adds	r2, r7, r3
    8a3a:	4b23      	ldr	r3, [pc, #140]	; (8ac8 <nm_bus_init+0xb4>)
    8a3c:	0011      	movs	r1, r2
    8a3e:	0018      	movs	r0, r3
    8a40:	4b22      	ldr	r3, [pc, #136]	; (8acc <nm_bus_init+0xb8>)
    8a42:	4798      	blx	r3

	/* Configure the SPI master. */
	spi_get_config_defaults(&config);
    8a44:	230c      	movs	r3, #12
    8a46:	18fb      	adds	r3, r7, r3
    8a48:	0018      	movs	r0, r3
    8a4a:	4b21      	ldr	r3, [pc, #132]	; (8ad0 <nm_bus_init+0xbc>)
    8a4c:	4798      	blx	r3
	config.mux_setting = CONF_WINC_SPI_SERCOM_MUX;
    8a4e:	230c      	movs	r3, #12
    8a50:	18fb      	adds	r3, r7, r3
    8a52:	2280      	movs	r2, #128	; 0x80
    8a54:	0252      	lsls	r2, r2, #9
    8a56:	60da      	str	r2, [r3, #12]
	config.pinmux_pad0 = CONF_WINC_SPI_PINMUX_PAD0;
    8a58:	230c      	movs	r3, #12
    8a5a:	18fb      	adds	r3, r7, r3
    8a5c:	4a1d      	ldr	r2, [pc, #116]	; (8ad4 <nm_bus_init+0xc0>)
    8a5e:	629a      	str	r2, [r3, #40]	; 0x28
	config.pinmux_pad1 = CONF_WINC_SPI_PINMUX_PAD1;
    8a60:	230c      	movs	r3, #12
    8a62:	18fb      	adds	r3, r7, r3
    8a64:	2201      	movs	r2, #1
    8a66:	4252      	negs	r2, r2
    8a68:	62da      	str	r2, [r3, #44]	; 0x2c
	config.pinmux_pad2 = CONF_WINC_SPI_PINMUX_PAD2;
    8a6a:	230c      	movs	r3, #12
    8a6c:	18fb      	adds	r3, r7, r3
    8a6e:	4a1a      	ldr	r2, [pc, #104]	; (8ad8 <nm_bus_init+0xc4>)
    8a70:	631a      	str	r2, [r3, #48]	; 0x30
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
    8a72:	230c      	movs	r3, #12
    8a74:	18fb      	adds	r3, r7, r3
    8a76:	4a19      	ldr	r2, [pc, #100]	; (8adc <nm_bus_init+0xc8>)
    8a78:	635a      	str	r2, [r3, #52]	; 0x34
	config.master_slave_select_enable = false;
    8a7a:	230c      	movs	r3, #12
    8a7c:	18fb      	adds	r3, r7, r3
    8a7e:	2200      	movs	r2, #0
    8a80:	751a      	strb	r2, [r3, #20]

	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
    8a82:	230c      	movs	r3, #12
    8a84:	18fb      	adds	r3, r7, r3
    8a86:	4a16      	ldr	r2, [pc, #88]	; (8ae0 <nm_bus_init+0xcc>)
    8a88:	619a      	str	r2, [r3, #24]
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
    8a8a:	230c      	movs	r3, #12
    8a8c:	18fa      	adds	r2, r7, r3
    8a8e:	4915      	ldr	r1, [pc, #84]	; (8ae4 <nm_bus_init+0xd0>)
    8a90:	4b15      	ldr	r3, [pc, #84]	; (8ae8 <nm_bus_init+0xd4>)
    8a92:	0018      	movs	r0, r3
    8a94:	4b15      	ldr	r3, [pc, #84]	; (8aec <nm_bus_init+0xd8>)
    8a96:	4798      	blx	r3
    8a98:	1e03      	subs	r3, r0, #0
    8a9a:	d002      	beq.n	8aa2 <nm_bus_init+0x8e>
		return M2M_ERR_BUS_FAIL;
    8a9c:	2306      	movs	r3, #6
    8a9e:	425b      	negs	r3, r3
    8aa0:	e00c      	b.n	8abc <nm_bus_init+0xa8>
	}

	/* Enable the SPI master. */
	spi_enable(&master);
    8aa2:	4b11      	ldr	r3, [pc, #68]	; (8ae8 <nm_bus_init+0xd4>)
    8aa4:	0018      	movs	r0, r3
    8aa6:	4b12      	ldr	r3, [pc, #72]	; (8af0 <nm_bus_init+0xdc>)
    8aa8:	4798      	blx	r3

	nm_bsp_reset();
    8aaa:	4b12      	ldr	r3, [pc, #72]	; (8af4 <nm_bus_init+0xe0>)
    8aac:	4798      	blx	r3
	nm_bsp_sleep(1);
    8aae:	2001      	movs	r0, #1
    8ab0:	4b11      	ldr	r3, [pc, #68]	; (8af8 <nm_bus_init+0xe4>)
    8ab2:	4798      	blx	r3
#endif
	return result;
    8ab4:	2347      	movs	r3, #71	; 0x47
    8ab6:	18fb      	adds	r3, r7, r3
    8ab8:	781b      	ldrb	r3, [r3, #0]
    8aba:	b25b      	sxtb	r3, r3
}
    8abc:	0018      	movs	r0, r3
    8abe:	46bd      	mov	sp, r7
    8ac0:	b012      	add	sp, #72	; 0x48
    8ac2:	bd80      	pop	{r7, pc}
    8ac4:	00008635 	.word	0x00008635
    8ac8:	200030c4 	.word	0x200030c4
    8acc:	00008659 	.word	0x00008659
    8ad0:	000085b1 	.word	0x000085b1
    8ad4:	00040003 	.word	0x00040003
    8ad8:	00060003 	.word	0x00060003
    8adc:	00070003 	.word	0x00070003
    8ae0:	007a1200 	.word	0x007a1200
    8ae4:	42000800 	.word	0x42000800
    8ae8:	200030c8 	.word	0x200030c8
    8aec:	000148cd 	.word	0x000148cd
    8af0:	000086bd 	.word	0x000086bd
    8af4:	000082e9 	.word	0x000082e9
    8af8:	0000832d 	.word	0x0000832d

00008afc <nm_bus_ioctl>:
*					Arbitrary parameter depenging on IOCTL
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@note	For SPI only, it's important to be able to send/receive at the same time
*/
sint8 nm_bus_ioctl(uint8 u8Cmd, void* pvParameter)
{
    8afc:	b590      	push	{r4, r7, lr}
    8afe:	b085      	sub	sp, #20
    8b00:	af00      	add	r7, sp, #0
    8b02:	0002      	movs	r2, r0
    8b04:	6039      	str	r1, [r7, #0]
    8b06:	1dfb      	adds	r3, r7, #7
    8b08:	701a      	strb	r2, [r3, #0]
	sint8 s8Ret = 0;
    8b0a:	230f      	movs	r3, #15
    8b0c:	18fb      	adds	r3, r7, r3
    8b0e:	2200      	movs	r2, #0
    8b10:	701a      	strb	r2, [r3, #0]
	switch(u8Cmd)
    8b12:	1dfb      	adds	r3, r7, #7
    8b14:	781b      	ldrb	r3, [r3, #0]
    8b16:	2b03      	cmp	r3, #3
    8b18:	d10f      	bne.n	8b3a <nm_bus_ioctl+0x3e>
			s8Ret = nm_i2c_write_special(pstrParam->pu8Buf1, pstrParam->u16Sz1, pstrParam->pu8Buf2, pstrParam->u16Sz2);
		}
		break;
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
    8b1a:	683b      	ldr	r3, [r7, #0]
    8b1c:	60bb      	str	r3, [r7, #8]
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
    8b1e:	68bb      	ldr	r3, [r7, #8]
    8b20:	6818      	ldr	r0, [r3, #0]
    8b22:	68bb      	ldr	r3, [r7, #8]
    8b24:	6859      	ldr	r1, [r3, #4]
    8b26:	68bb      	ldr	r3, [r7, #8]
    8b28:	891b      	ldrh	r3, [r3, #8]
    8b2a:	220f      	movs	r2, #15
    8b2c:	18bc      	adds	r4, r7, r2
    8b2e:	001a      	movs	r2, r3
    8b30:	4b08      	ldr	r3, [pc, #32]	; (8b54 <nm_bus_ioctl+0x58>)
    8b32:	4798      	blx	r3
    8b34:	0003      	movs	r3, r0
    8b36:	7023      	strb	r3, [r4, #0]
		}
		break;
    8b38:	e004      	b.n	8b44 <nm_bus_ioctl+0x48>
#endif
		default:
			s8Ret = -1;
    8b3a:	230f      	movs	r3, #15
    8b3c:	18fb      	adds	r3, r7, r3
    8b3e:	22ff      	movs	r2, #255	; 0xff
    8b40:	701a      	strb	r2, [r3, #0]
			M2M_ERR("invalide ioclt cmd\n");
			break;
    8b42:	46c0      	nop			; (mov r8, r8)
	}

	return s8Ret;
    8b44:	230f      	movs	r3, #15
    8b46:	18fb      	adds	r3, r7, r3
    8b48:	781b      	ldrb	r3, [r3, #0]
    8b4a:	b25b      	sxtb	r3, r3
}
    8b4c:	0018      	movs	r0, r3
    8b4e:	46bd      	mov	sp, r7
    8b50:	b005      	add	sp, #20
    8b52:	bd90      	pop	{r4, r7, pc}
    8b54:	000088ad 	.word	0x000088ad

00008b58 <nm_bus_deinit>:
/*
*	@fn		nm_bus_deinit
*	@brief	De-initialize the bus wrapper
*/
sint8 nm_bus_deinit(void)
{
    8b58:	b580      	push	{r7, lr}
    8b5a:	b082      	sub	sp, #8
    8b5c:	af00      	add	r7, sp, #0
	sint8 result = M2M_SUCCESS;
    8b5e:	1dfb      	adds	r3, r7, #7
    8b60:	2200      	movs	r2, #0
    8b62:	701a      	strb	r2, [r3, #0]
	struct port_config pin_conf;
		
	port_get_config_defaults(&pin_conf);
    8b64:	1d3b      	adds	r3, r7, #4
    8b66:	0018      	movs	r0, r3
    8b68:	4b09      	ldr	r3, [pc, #36]	; (8b90 <nm_bus_deinit+0x38>)
    8b6a:	4798      	blx	r3
	/* Configure control pins as input no pull up. */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    8b6c:	1d3b      	adds	r3, r7, #4
    8b6e:	2200      	movs	r2, #0
    8b70:	701a      	strb	r2, [r3, #0]
	pin_conf.input_pull = PORT_PIN_PULL_NONE;
    8b72:	1d3b      	adds	r3, r7, #4
    8b74:	2200      	movs	r2, #0
    8b76:	705a      	strb	r2, [r3, #1]
	i2c_master_disable(&i2c_master_instance);
	port_pin_set_config(CONF_WINC_I2C_SCL, &pin_conf);
	port_pin_set_config(CONF_WINC_I2C_SDA, &pin_conf);
#endif /* CONF_WINC_USE_I2C */
#ifdef CONF_WINC_USE_SPI
	spi_disable(&master);	
    8b78:	4b06      	ldr	r3, [pc, #24]	; (8b94 <nm_bus_deinit+0x3c>)
    8b7a:	0018      	movs	r0, r3
    8b7c:	4b06      	ldr	r3, [pc, #24]	; (8b98 <nm_bus_deinit+0x40>)
    8b7e:	4798      	blx	r3

#endif /* CONF_WINC_USE_SPI */
	return result;
    8b80:	1dfb      	adds	r3, r7, #7
    8b82:	781b      	ldrb	r3, [r3, #0]
    8b84:	b25b      	sxtb	r3, r3
}
    8b86:	0018      	movs	r0, r3
    8b88:	46bd      	mov	sp, r7
    8b8a:	b002      	add	sp, #8
    8b8c:	bd80      	pop	{r7, pc}
    8b8e:	46c0      	nop			; (mov r8, r8)
    8b90:	000084bd 	.word	0x000084bd
    8b94:	200030c8 	.word	0x200030c8
    8b98:	0000870d 	.word	0x0000870d

00008b9c <m2m_memcpy>:
 *
 */
#include "common/include/nm_common.h"

void m2m_memcpy(uint8* pDst,uint8* pSrc,uint32 sz)
{
    8b9c:	b580      	push	{r7, lr}
    8b9e:	b084      	sub	sp, #16
    8ba0:	af00      	add	r7, sp, #0
    8ba2:	60f8      	str	r0, [r7, #12]
    8ba4:	60b9      	str	r1, [r7, #8]
    8ba6:	607a      	str	r2, [r7, #4]
	if(sz == 0) return;
    8ba8:	687b      	ldr	r3, [r7, #4]
    8baa:	2b00      	cmp	r3, #0
    8bac:	d010      	beq.n	8bd0 <m2m_memcpy+0x34>
	do
	{
		*pDst = *pSrc;
    8bae:	68bb      	ldr	r3, [r7, #8]
    8bb0:	781a      	ldrb	r2, [r3, #0]
    8bb2:	68fb      	ldr	r3, [r7, #12]
    8bb4:	701a      	strb	r2, [r3, #0]
		pDst++;
    8bb6:	68fb      	ldr	r3, [r7, #12]
    8bb8:	3301      	adds	r3, #1
    8bba:	60fb      	str	r3, [r7, #12]
		pSrc++;
    8bbc:	68bb      	ldr	r3, [r7, #8]
    8bbe:	3301      	adds	r3, #1
    8bc0:	60bb      	str	r3, [r7, #8]
	}while(--sz);
    8bc2:	687b      	ldr	r3, [r7, #4]
    8bc4:	3b01      	subs	r3, #1
    8bc6:	607b      	str	r3, [r7, #4]
    8bc8:	687b      	ldr	r3, [r7, #4]
    8bca:	2b00      	cmp	r3, #0
    8bcc:	d1ef      	bne.n	8bae <m2m_memcpy+0x12>
    8bce:	e000      	b.n	8bd2 <m2m_memcpy+0x36>
 */
#include "common/include/nm_common.h"

void m2m_memcpy(uint8* pDst,uint8* pSrc,uint32 sz)
{
	if(sz == 0) return;
    8bd0:	46c0      	nop			; (mov r8, r8)
	{
		*pDst = *pSrc;
		pDst++;
		pSrc++;
	}while(--sz);
}
    8bd2:	46bd      	mov	sp, r7
    8bd4:	b004      	add	sp, #16
    8bd6:	bd80      	pop	{r7, pc}

00008bd8 <m2m_memset>:

	return cs;
}

void m2m_memset(uint8* pBuf,uint8 val,uint32 sz)
{
    8bd8:	b580      	push	{r7, lr}
    8bda:	b084      	sub	sp, #16
    8bdc:	af00      	add	r7, sp, #0
    8bde:	60f8      	str	r0, [r7, #12]
    8be0:	607a      	str	r2, [r7, #4]
    8be2:	230b      	movs	r3, #11
    8be4:	18fb      	adds	r3, r7, r3
    8be6:	1c0a      	adds	r2, r1, #0
    8be8:	701a      	strb	r2, [r3, #0]
	if(sz == 0) return;
    8bea:	687b      	ldr	r3, [r7, #4]
    8bec:	2b00      	cmp	r3, #0
    8bee:	d00e      	beq.n	8c0e <m2m_memset+0x36>
	do
	{
		*pBuf = val;
    8bf0:	68fb      	ldr	r3, [r7, #12]
    8bf2:	220b      	movs	r2, #11
    8bf4:	18ba      	adds	r2, r7, r2
    8bf6:	7812      	ldrb	r2, [r2, #0]
    8bf8:	701a      	strb	r2, [r3, #0]
		pBuf++;
    8bfa:	68fb      	ldr	r3, [r7, #12]
    8bfc:	3301      	adds	r3, #1
    8bfe:	60fb      	str	r3, [r7, #12]
	}while(--sz);
    8c00:	687b      	ldr	r3, [r7, #4]
    8c02:	3b01      	subs	r3, #1
    8c04:	607b      	str	r3, [r7, #4]
    8c06:	687b      	ldr	r3, [r7, #4]
    8c08:	2b00      	cmp	r3, #0
    8c0a:	d1f1      	bne.n	8bf0 <m2m_memset+0x18>
    8c0c:	e000      	b.n	8c10 <m2m_memset+0x38>
	return cs;
}

void m2m_memset(uint8* pBuf,uint8 val,uint32 sz)
{
	if(sz == 0) return;
    8c0e:	46c0      	nop			; (mov r8, r8)
	do
	{
		*pBuf = val;
		pBuf++;
	}while(--sz);
}
    8c10:	46bd      	mov	sp, r7
    8c12:	b004      	add	sp, #16
    8c14:	bd80      	pop	{r7, pc}
    8c16:	46c0      	nop			; (mov r8, r8)

00008c18 <isr>:
tpfHifCallBack pfSigmaCb = NULL;
tpfHifCallBack pfHifCb = NULL;
tpfHifCallBack pfCryptoCb = NULL;

static void isr(void)
{   static BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    8c18:	b580      	push	{r7, lr}
    8c1a:	af00      	add	r7, sp, #0
	//gu8Interrupt++;
	//xSemaphoreGiveFromISR( xIntSemaphore, &xHigherPriorityTaskWoken );
	vTaskNotifyGiveFromISR( xWincTaskH, &xHigherPriorityTaskWoken );
    8c1c:	4b04      	ldr	r3, [pc, #16]	; (8c30 <isr+0x18>)
    8c1e:	681b      	ldr	r3, [r3, #0]
    8c20:	4a04      	ldr	r2, [pc, #16]	; (8c34 <isr+0x1c>)
    8c22:	0011      	movs	r1, r2
    8c24:	0018      	movs	r0, r3
    8c26:	4b04      	ldr	r3, [pc, #16]	; (8c38 <isr+0x20>)
    8c28:	4798      	blx	r3
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
    8c2a:	46c0      	nop			; (mov r8, r8)
    8c2c:	46bd      	mov	sp, r7
    8c2e:	bd80      	pop	{r7, pc}
    8c30:	2000377c 	.word	0x2000377c
    8c34:	2000051c 	.word	0x2000051c
    8c38:	00010c41 	.word	0x00010c41

00008c3c <hif_set_rx_done>:
static sint8 hif_set_rx_done(void)
{
    8c3c:	b590      	push	{r4, r7, lr}
    8c3e:	b083      	sub	sp, #12
    8c40:	af00      	add	r7, sp, #0
	uint32 reg;
	sint8 ret = M2M_SUCCESS;
    8c42:	1dfb      	adds	r3, r7, #7
    8c44:	2200      	movs	r2, #0
    8c46:	701a      	strb	r2, [r3, #0]
#ifdef NM_EDGE_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
    8c48:	2001      	movs	r0, #1
    8c4a:	4b13      	ldr	r3, [pc, #76]	; (8c98 <hif_set_rx_done+0x5c>)
    8c4c:	4798      	blx	r3
#endif

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
    8c4e:	1dfc      	adds	r4, r7, #7
    8c50:	003b      	movs	r3, r7
    8c52:	4a12      	ldr	r2, [pc, #72]	; (8c9c <hif_set_rx_done+0x60>)
    8c54:	0019      	movs	r1, r3
    8c56:	0010      	movs	r0, r2
    8c58:	4b11      	ldr	r3, [pc, #68]	; (8ca0 <hif_set_rx_done+0x64>)
    8c5a:	4798      	blx	r3
    8c5c:	0003      	movs	r3, r0
    8c5e:	7023      	strb	r3, [r4, #0]
	if(ret != M2M_SUCCESS)goto ERR1;
    8c60:	1dfb      	adds	r3, r7, #7
    8c62:	781b      	ldrb	r3, [r3, #0]
    8c64:	b25b      	sxtb	r3, r3
    8c66:	2b00      	cmp	r3, #0
    8c68:	d10d      	bne.n	8c86 <hif_set_rx_done+0x4a>
	//reg &= ~(1<<0);

	/* Set RX Done */
	reg |= (1<<1);
    8c6a:	683b      	ldr	r3, [r7, #0]
    8c6c:	2202      	movs	r2, #2
    8c6e:	4313      	orrs	r3, r2
    8c70:	603b      	str	r3, [r7, #0]
	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
    8c72:	683b      	ldr	r3, [r7, #0]
    8c74:	1dfc      	adds	r4, r7, #7
    8c76:	4a09      	ldr	r2, [pc, #36]	; (8c9c <hif_set_rx_done+0x60>)
    8c78:	0019      	movs	r1, r3
    8c7a:	0010      	movs	r0, r2
    8c7c:	4b09      	ldr	r3, [pc, #36]	; (8ca4 <hif_set_rx_done+0x68>)
    8c7e:	4798      	blx	r3
    8c80:	0003      	movs	r3, r0
    8c82:	7023      	strb	r3, [r4, #0]
    8c84:	e000      	b.n	8c88 <hif_set_rx_done+0x4c>
#ifdef NM_EDGE_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
#endif

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
	if(ret != M2M_SUCCESS)goto ERR1;
    8c86:	46c0      	nop			; (mov r8, r8)
	if(ret != M2M_SUCCESS)goto ERR1;
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
#endif
ERR1:
	return ret;
    8c88:	1dfb      	adds	r3, r7, #7
    8c8a:	781b      	ldrb	r3, [r3, #0]
    8c8c:	b25b      	sxtb	r3, r3

}
    8c8e:	0018      	movs	r0, r3
    8c90:	46bd      	mov	sp, r7
    8c92:	b003      	add	sp, #12
    8c94:	bd90      	pop	{r4, r7, pc}
    8c96:	46c0      	nop			; (mov r8, r8)
    8c98:	00008401 	.word	0x00008401
    8c9c:	00001070 	.word	0x00001070
    8ca0:	0000a251 	.word	0x0000a251
    8ca4:	0000a275 	.word	0x0000a275

00008ca8 <m2m_hif_cb>:
*	@author
*	@date
*	@version	1.0
*/
static void m2m_hif_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{
    8ca8:	b580      	push	{r7, lr}
    8caa:	b082      	sub	sp, #8
    8cac:	af00      	add	r7, sp, #0
    8cae:	603a      	str	r2, [r7, #0]
    8cb0:	1dfb      	adds	r3, r7, #7
    8cb2:	1c02      	adds	r2, r0, #0
    8cb4:	701a      	strb	r2, [r3, #0]
    8cb6:	1d3b      	adds	r3, r7, #4
    8cb8:	1c0a      	adds	r2, r1, #0
    8cba:	801a      	strh	r2, [r3, #0]


}
    8cbc:	46c0      	nop			; (mov r8, r8)
    8cbe:	46bd      	mov	sp, r7
    8cc0:	b002      	add	sp, #8
    8cc2:	bd80      	pop	{r7, pc}

00008cc4 <hif_chip_wake>:
*	@brief	To Wakeup the chip.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_wake(void)
{
    8cc4:	b590      	push	{r4, r7, lr}
    8cc6:	b083      	sub	sp, #12
    8cc8:	af00      	add	r7, sp, #0
	sint8 ret = M2M_SUCCESS;
    8cca:	1dfb      	adds	r3, r7, #7
    8ccc:	2200      	movs	r2, #0
    8cce:	701a      	strb	r2, [r3, #0]
	if(gu8ChipSleep == 0)
    8cd0:	4b1c      	ldr	r3, [pc, #112]	; (8d44 <hif_chip_wake+0x80>)
    8cd2:	781b      	ldrb	r3, [r3, #0]
    8cd4:	b2db      	uxtb	r3, r3
    8cd6:	2b00      	cmp	r3, #0
    8cd8:	d121      	bne.n	8d1e <hif_chip_wake+0x5a>
	{
		if((gu8ChipMode == M2M_PS_DEEP_AUTOMATIC)||(gu8ChipMode == M2M_PS_MANUAL))
    8cda:	4b1b      	ldr	r3, [pc, #108]	; (8d48 <hif_chip_wake+0x84>)
    8cdc:	781b      	ldrb	r3, [r3, #0]
    8cde:	b2db      	uxtb	r3, r3
    8ce0:	2b03      	cmp	r3, #3
    8ce2:	d004      	beq.n	8cee <hif_chip_wake+0x2a>
    8ce4:	4b18      	ldr	r3, [pc, #96]	; (8d48 <hif_chip_wake+0x84>)
    8ce6:	781b      	ldrb	r3, [r3, #0]
    8ce8:	b2db      	uxtb	r3, r3
    8cea:	2b04      	cmp	r3, #4
    8cec:	d117      	bne.n	8d1e <hif_chip_wake+0x5a>
		{
			ret = nm_clkless_wake();
    8cee:	1dfc      	adds	r4, r7, #7
    8cf0:	4b16      	ldr	r3, [pc, #88]	; (8d4c <hif_chip_wake+0x88>)
    8cf2:	4798      	blx	r3
    8cf4:	0003      	movs	r3, r0
    8cf6:	7023      	strb	r3, [r4, #0]
			if(ret != M2M_SUCCESS)goto ERR1;
    8cf8:	1dfb      	adds	r3, r7, #7
    8cfa:	781b      	ldrb	r3, [r3, #0]
    8cfc:	b25b      	sxtb	r3, r3
    8cfe:	2b00      	cmp	r3, #0
    8d00:	d115      	bne.n	8d2e <hif_chip_wake+0x6a>
			ret = nm_write_reg(WAKE_REG, WAKE_VALUE);
    8d02:	1dfc      	adds	r4, r7, #7
    8d04:	4a12      	ldr	r2, [pc, #72]	; (8d50 <hif_chip_wake+0x8c>)
    8d06:	4b13      	ldr	r3, [pc, #76]	; (8d54 <hif_chip_wake+0x90>)
    8d08:	0011      	movs	r1, r2
    8d0a:	0018      	movs	r0, r3
    8d0c:	4b12      	ldr	r3, [pc, #72]	; (8d58 <hif_chip_wake+0x94>)
    8d0e:	4798      	blx	r3
    8d10:	0003      	movs	r3, r0
    8d12:	7023      	strb	r3, [r4, #0]
			if(ret != M2M_SUCCESS)goto ERR1;
    8d14:	1dfb      	adds	r3, r7, #7
    8d16:	781b      	ldrb	r3, [r3, #0]
    8d18:	b25b      	sxtb	r3, r3
    8d1a:	2b00      	cmp	r3, #0
    8d1c:	d109      	bne.n	8d32 <hif_chip_wake+0x6e>
		}
		else
		{
		}
	}
	gu8ChipSleep++;
    8d1e:	4b09      	ldr	r3, [pc, #36]	; (8d44 <hif_chip_wake+0x80>)
    8d20:	781b      	ldrb	r3, [r3, #0]
    8d22:	b2db      	uxtb	r3, r3
    8d24:	3301      	adds	r3, #1
    8d26:	b2da      	uxtb	r2, r3
    8d28:	4b06      	ldr	r3, [pc, #24]	; (8d44 <hif_chip_wake+0x80>)
    8d2a:	701a      	strb	r2, [r3, #0]
    8d2c:	e002      	b.n	8d34 <hif_chip_wake+0x70>
	if(gu8ChipSleep == 0)
	{
		if((gu8ChipMode == M2M_PS_DEEP_AUTOMATIC)||(gu8ChipMode == M2M_PS_MANUAL))
		{
			ret = nm_clkless_wake();
			if(ret != M2M_SUCCESS)goto ERR1;
    8d2e:	46c0      	nop			; (mov r8, r8)
    8d30:	e000      	b.n	8d34 <hif_chip_wake+0x70>
			ret = nm_write_reg(WAKE_REG, WAKE_VALUE);
			if(ret != M2M_SUCCESS)goto ERR1;
    8d32:	46c0      	nop			; (mov r8, r8)
		{
		}
	}
	gu8ChipSleep++;
ERR1:
	return ret;
    8d34:	1dfb      	adds	r3, r7, #7
    8d36:	781b      	ldrb	r3, [r3, #0]
    8d38:	b25b      	sxtb	r3, r3
}
    8d3a:	0018      	movs	r0, r3
    8d3c:	46bd      	mov	sp, r7
    8d3e:	b003      	add	sp, #12
    8d40:	bd90      	pop	{r4, r7, pc}
    8d42:	46c0      	nop			; (mov r8, r8)
    8d44:	20000501 	.word	0x20000501
    8d48:	20000500 	.word	0x20000500
    8d4c:	00009be9 	.word	0x00009be9
    8d50:	00005678 	.word	0x00005678
    8d54:	00001074 	.word	0x00001074
    8d58:	0000a275 	.word	0x0000a275

00008d5c <hif_chip_sleep>:
*	@brief	To make the chip sleep.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
    8d5c:	b590      	push	{r4, r7, lr}
    8d5e:	b083      	sub	sp, #12
    8d60:	af00      	add	r7, sp, #0
	sint8 ret = M2M_SUCCESS;
    8d62:	1dfb      	adds	r3, r7, #7
    8d64:	2200      	movs	r2, #0
    8d66:	701a      	strb	r2, [r3, #0]

	if(gu8ChipSleep >= 1)
    8d68:	4b29      	ldr	r3, [pc, #164]	; (8e10 <hif_chip_sleep+0xb4>)
    8d6a:	781b      	ldrb	r3, [r3, #0]
    8d6c:	b2db      	uxtb	r3, r3
    8d6e:	2b00      	cmp	r3, #0
    8d70:	d006      	beq.n	8d80 <hif_chip_sleep+0x24>
	{
		gu8ChipSleep--;
    8d72:	4b27      	ldr	r3, [pc, #156]	; (8e10 <hif_chip_sleep+0xb4>)
    8d74:	781b      	ldrb	r3, [r3, #0]
    8d76:	b2db      	uxtb	r3, r3
    8d78:	3b01      	subs	r3, #1
    8d7a:	b2da      	uxtb	r2, r3
    8d7c:	4b24      	ldr	r3, [pc, #144]	; (8e10 <hif_chip_sleep+0xb4>)
    8d7e:	701a      	strb	r2, [r3, #0]
	}
	
	if(gu8ChipSleep == 0)
    8d80:	4b23      	ldr	r3, [pc, #140]	; (8e10 <hif_chip_sleep+0xb4>)
    8d82:	781b      	ldrb	r3, [r3, #0]
    8d84:	b2db      	uxtb	r3, r3
    8d86:	2b00      	cmp	r3, #0
    8d88:	d13a      	bne.n	8e00 <hif_chip_sleep+0xa4>
	{
		if((gu8ChipMode == M2M_PS_DEEP_AUTOMATIC)||(gu8ChipMode == M2M_PS_MANUAL))
    8d8a:	4b22      	ldr	r3, [pc, #136]	; (8e14 <hif_chip_sleep+0xb8>)
    8d8c:	781b      	ldrb	r3, [r3, #0]
    8d8e:	b2db      	uxtb	r3, r3
    8d90:	2b03      	cmp	r3, #3
    8d92:	d004      	beq.n	8d9e <hif_chip_sleep+0x42>
    8d94:	4b1f      	ldr	r3, [pc, #124]	; (8e14 <hif_chip_sleep+0xb8>)
    8d96:	781b      	ldrb	r3, [r3, #0]
    8d98:	b2db      	uxtb	r3, r3
    8d9a:	2b04      	cmp	r3, #4
    8d9c:	d130      	bne.n	8e00 <hif_chip_sleep+0xa4>
		{
			uint32 reg = 0;
    8d9e:	2300      	movs	r3, #0
    8da0:	603b      	str	r3, [r7, #0]
			ret = nm_write_reg(WAKE_REG, SLEEP_VALUE);
    8da2:	1dfc      	adds	r4, r7, #7
    8da4:	4a1c      	ldr	r2, [pc, #112]	; (8e18 <hif_chip_sleep+0xbc>)
    8da6:	4b1d      	ldr	r3, [pc, #116]	; (8e1c <hif_chip_sleep+0xc0>)
    8da8:	0011      	movs	r1, r2
    8daa:	0018      	movs	r0, r3
    8dac:	4b1c      	ldr	r3, [pc, #112]	; (8e20 <hif_chip_sleep+0xc4>)
    8dae:	4798      	blx	r3
    8db0:	0003      	movs	r3, r0
    8db2:	7023      	strb	r3, [r4, #0]
			if(ret != M2M_SUCCESS)goto ERR1;
    8db4:	1dfb      	adds	r3, r7, #7
    8db6:	781b      	ldrb	r3, [r3, #0]
    8db8:	b25b      	sxtb	r3, r3
    8dba:	2b00      	cmp	r3, #0
    8dbc:	d11d      	bne.n	8dfa <hif_chip_sleep+0x9e>
			/* Clear bit 1 */
			ret = nm_read_reg_with_ret(0x1, &reg);
    8dbe:	1dfc      	adds	r4, r7, #7
    8dc0:	003b      	movs	r3, r7
    8dc2:	0019      	movs	r1, r3
    8dc4:	2001      	movs	r0, #1
    8dc6:	4b17      	ldr	r3, [pc, #92]	; (8e24 <hif_chip_sleep+0xc8>)
    8dc8:	4798      	blx	r3
    8dca:	0003      	movs	r3, r0
    8dcc:	7023      	strb	r3, [r4, #0]
			if(ret != M2M_SUCCESS)goto ERR1;
    8dce:	1dfb      	adds	r3, r7, #7
    8dd0:	781b      	ldrb	r3, [r3, #0]
    8dd2:	b25b      	sxtb	r3, r3
    8dd4:	2b00      	cmp	r3, #0
    8dd6:	d112      	bne.n	8dfe <hif_chip_sleep+0xa2>
			if(reg&0x2)
    8dd8:	683b      	ldr	r3, [r7, #0]
    8dda:	2202      	movs	r2, #2
    8ddc:	4013      	ands	r3, r2
    8dde:	d00f      	beq.n	8e00 <hif_chip_sleep+0xa4>
			{
				reg &=~(1 << 1);
    8de0:	683b      	ldr	r3, [r7, #0]
    8de2:	2202      	movs	r2, #2
    8de4:	4393      	bics	r3, r2
    8de6:	603b      	str	r3, [r7, #0]
				ret = nm_write_reg(0x1, reg);
    8de8:	683b      	ldr	r3, [r7, #0]
    8dea:	1dfc      	adds	r4, r7, #7
    8dec:	0019      	movs	r1, r3
    8dee:	2001      	movs	r0, #1
    8df0:	4b0b      	ldr	r3, [pc, #44]	; (8e20 <hif_chip_sleep+0xc4>)
    8df2:	4798      	blx	r3
    8df4:	0003      	movs	r3, r0
    8df6:	7023      	strb	r3, [r4, #0]
    8df8:	e002      	b.n	8e00 <hif_chip_sleep+0xa4>
	{
		if((gu8ChipMode == M2M_PS_DEEP_AUTOMATIC)||(gu8ChipMode == M2M_PS_MANUAL))
		{
			uint32 reg = 0;
			ret = nm_write_reg(WAKE_REG, SLEEP_VALUE);
			if(ret != M2M_SUCCESS)goto ERR1;
    8dfa:	46c0      	nop			; (mov r8, r8)
    8dfc:	e000      	b.n	8e00 <hif_chip_sleep+0xa4>
			/* Clear bit 1 */
			ret = nm_read_reg_with_ret(0x1, &reg);
			if(ret != M2M_SUCCESS)goto ERR1;
    8dfe:	46c0      	nop			; (mov r8, r8)
		else
		{
		}
	}
ERR1:
	return ret;
    8e00:	1dfb      	adds	r3, r7, #7
    8e02:	781b      	ldrb	r3, [r3, #0]
    8e04:	b25b      	sxtb	r3, r3
}
    8e06:	0018      	movs	r0, r3
    8e08:	46bd      	mov	sp, r7
    8e0a:	b003      	add	sp, #12
    8e0c:	bd90      	pop	{r4, r7, pc}
    8e0e:	46c0      	nop			; (mov r8, r8)
    8e10:	20000501 	.word	0x20000501
    8e14:	20000500 	.word	0x20000500
    8e18:	00004321 	.word	0x00004321
    8e1c:	00001074 	.word	0x00001074
    8e20:	0000a275 	.word	0x0000a275
    8e24:	0000a251 	.word	0x0000a251

00008e28 <hif_init>:
*				Pointer to the arguments.
*   @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_init(void * arg)
{
    8e28:	b580      	push	{r7, lr}
    8e2a:	b082      	sub	sp, #8
    8e2c:	af00      	add	r7, sp, #0
    8e2e:	6078      	str	r0, [r7, #4]
	pfWifiCb = NULL;
    8e30:	4b0e      	ldr	r3, [pc, #56]	; (8e6c <hif_init+0x44>)
    8e32:	2200      	movs	r2, #0
    8e34:	601a      	str	r2, [r3, #0]
	pfIpCb = NULL;
    8e36:	4b0e      	ldr	r3, [pc, #56]	; (8e70 <hif_init+0x48>)
    8e38:	2200      	movs	r2, #0
    8e3a:	601a      	str	r2, [r3, #0]

	gu8ChipSleep = 0;
    8e3c:	4b0d      	ldr	r3, [pc, #52]	; (8e74 <hif_init+0x4c>)
    8e3e:	2200      	movs	r2, #0
    8e40:	701a      	strb	r2, [r3, #0]
	gu8ChipMode = M2M_NO_PS;
    8e42:	4b0d      	ldr	r3, [pc, #52]	; (8e78 <hif_init+0x50>)
    8e44:	2200      	movs	r2, #0
    8e46:	701a      	strb	r2, [r3, #0]

	gu8Interrupt = 0;
    8e48:	4b0c      	ldr	r3, [pc, #48]	; (8e7c <hif_init+0x54>)
    8e4a:	2200      	movs	r2, #0
    8e4c:	701a      	strb	r2, [r3, #0]
	nm_bsp_register_isr(isr);
    8e4e:	4b0c      	ldr	r3, [pc, #48]	; (8e80 <hif_init+0x58>)
    8e50:	0018      	movs	r0, r3
    8e52:	4b0c      	ldr	r3, [pc, #48]	; (8e84 <hif_init+0x5c>)
    8e54:	4798      	blx	r3

	hif_register_cb(M2M_REQ_GROUP_HIF,m2m_hif_cb);
    8e56:	4b0c      	ldr	r3, [pc, #48]	; (8e88 <hif_init+0x60>)
    8e58:	0019      	movs	r1, r3
    8e5a:	2003      	movs	r0, #3
    8e5c:	4b0b      	ldr	r3, [pc, #44]	; (8e8c <hif_init+0x64>)
    8e5e:	4798      	blx	r3

	return M2M_SUCCESS;
    8e60:	2300      	movs	r3, #0
}
    8e62:	0018      	movs	r0, r3
    8e64:	46bd      	mov	sp, r7
    8e66:	b002      	add	sp, #8
    8e68:	bd80      	pop	{r7, pc}
    8e6a:	46c0      	nop			; (mov r8, r8)
    8e6c:	20000504 	.word	0x20000504
    8e70:	20000508 	.word	0x20000508
    8e74:	20000501 	.word	0x20000501
    8e78:	20000500 	.word	0x20000500
    8e7c:	20000503 	.word	0x20000503
    8e80:	00008c19 	.word	0x00008c19
    8e84:	00008389 	.word	0x00008389
    8e88:	00008ca9 	.word	0x00008ca9
    8e8c:	000095f9 	.word	0x000095f9

00008e90 <hif_send>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
			   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset)
{
    8e90:	b590      	push	{r4, r7, lr}
    8e92:	b089      	sub	sp, #36	; 0x24
    8e94:	af00      	add	r7, sp, #0
    8e96:	0004      	movs	r4, r0
    8e98:	0008      	movs	r0, r1
    8e9a:	603a      	str	r2, [r7, #0]
    8e9c:	0019      	movs	r1, r3
    8e9e:	1dfb      	adds	r3, r7, #7
    8ea0:	1c22      	adds	r2, r4, #0
    8ea2:	701a      	strb	r2, [r3, #0]
    8ea4:	1dbb      	adds	r3, r7, #6
    8ea6:	1c02      	adds	r2, r0, #0
    8ea8:	701a      	strb	r2, [r3, #0]
    8eaa:	1d3b      	adds	r3, r7, #4
    8eac:	1c0a      	adds	r2, r1, #0
    8eae:	801a      	strh	r2, [r3, #0]
	sint8		ret = M2M_ERR_SEND;
    8eb0:	231f      	movs	r3, #31
    8eb2:	18fb      	adds	r3, r7, r3
    8eb4:	22ff      	movs	r2, #255	; 0xff
    8eb6:	701a      	strb	r2, [r3, #0]
	volatile tstrHifHdr	strHif;

	strHif.u8Opcode		= u8Opcode&(~NBIT7);
    8eb8:	1dbb      	adds	r3, r7, #6
    8eba:	781b      	ldrb	r3, [r3, #0]
    8ebc:	227f      	movs	r2, #127	; 0x7f
    8ebe:	4013      	ands	r3, r2
    8ec0:	b2da      	uxtb	r2, r3
    8ec2:	2318      	movs	r3, #24
    8ec4:	18fb      	adds	r3, r7, r3
    8ec6:	705a      	strb	r2, [r3, #1]
	strHif.u8Gid		= u8Gid;
    8ec8:	2318      	movs	r3, #24
    8eca:	18fb      	adds	r3, r7, r3
    8ecc:	1dfa      	adds	r2, r7, #7
    8ece:	7812      	ldrb	r2, [r2, #0]
    8ed0:	701a      	strb	r2, [r3, #0]
	strHif.u16Length	= M2M_HIF_HDR_OFFSET;
    8ed2:	2318      	movs	r3, #24
    8ed4:	18fb      	adds	r3, r7, r3
    8ed6:	2208      	movs	r2, #8
    8ed8:	805a      	strh	r2, [r3, #2]
	if(pu8DataBuf != NULL)
    8eda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8edc:	2b00      	cmp	r3, #0
    8ede:	d011      	beq.n	8f04 <hif_send+0x74>
	{
		strHif.u16Length += u16DataOffset + u16DataSize;
    8ee0:	2318      	movs	r3, #24
    8ee2:	18fb      	adds	r3, r7, r3
    8ee4:	885b      	ldrh	r3, [r3, #2]
    8ee6:	b29a      	uxth	r2, r3
    8ee8:	2338      	movs	r3, #56	; 0x38
    8eea:	18f9      	adds	r1, r7, r3
    8eec:	2334      	movs	r3, #52	; 0x34
    8eee:	18fb      	adds	r3, r7, r3
    8ef0:	8809      	ldrh	r1, [r1, #0]
    8ef2:	881b      	ldrh	r3, [r3, #0]
    8ef4:	18cb      	adds	r3, r1, r3
    8ef6:	b29b      	uxth	r3, r3
    8ef8:	18d3      	adds	r3, r2, r3
    8efa:	b29a      	uxth	r2, r3
    8efc:	2318      	movs	r3, #24
    8efe:	18fb      	adds	r3, r7, r3
    8f00:	805a      	strh	r2, [r3, #2]
    8f02:	e00a      	b.n	8f1a <hif_send+0x8a>
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
    8f04:	2318      	movs	r3, #24
    8f06:	18fb      	adds	r3, r7, r3
    8f08:	885b      	ldrh	r3, [r3, #2]
    8f0a:	b29a      	uxth	r2, r3
    8f0c:	1d3b      	adds	r3, r7, #4
    8f0e:	881b      	ldrh	r3, [r3, #0]
    8f10:	18d3      	adds	r3, r2, r3
    8f12:	b29a      	uxth	r2, r3
    8f14:	2318      	movs	r3, #24
    8f16:	18fb      	adds	r3, r7, r3
    8f18:	805a      	strh	r2, [r3, #2]
	}
	ret = hif_chip_wake();
    8f1a:	231f      	movs	r3, #31
    8f1c:	18fc      	adds	r4, r7, r3
    8f1e:	4b94      	ldr	r3, [pc, #592]	; (9170 <hif_send+0x2e0>)
    8f20:	4798      	blx	r3
    8f22:	0003      	movs	r3, r0
    8f24:	7023      	strb	r3, [r4, #0]
	if(ret == M2M_SUCCESS)
    8f26:	231f      	movs	r3, #31
    8f28:	18fb      	adds	r3, r7, r3
    8f2a:	781b      	ldrb	r3, [r3, #0]
    8f2c:	b25b      	sxtb	r3, r3
    8f2e:	2b00      	cmp	r3, #0
    8f30:	d000      	beq.n	8f34 <hif_send+0xa4>
    8f32:	e10a      	b.n	914a <hif_send+0x2ba>
	{
		volatile uint32 reg, dma_addr = 0;
    8f34:	2300      	movs	r3, #0
    8f36:	613b      	str	r3, [r7, #16]
		volatile uint16 cnt = 0;
    8f38:	230e      	movs	r3, #14
    8f3a:	18fb      	adds	r3, r7, r3
    8f3c:	2200      	movs	r2, #0
    8f3e:	801a      	strh	r2, [r3, #0]

		reg = 0UL;
    8f40:	2300      	movs	r3, #0
    8f42:	617b      	str	r3, [r7, #20]
		reg |= (uint32)u8Gid;
    8f44:	1dfb      	adds	r3, r7, #7
    8f46:	781a      	ldrb	r2, [r3, #0]
    8f48:	697b      	ldr	r3, [r7, #20]
    8f4a:	4313      	orrs	r3, r2
    8f4c:	617b      	str	r3, [r7, #20]
		reg |= ((uint32)u8Opcode<<8);
    8f4e:	1dbb      	adds	r3, r7, #6
    8f50:	781b      	ldrb	r3, [r3, #0]
    8f52:	021a      	lsls	r2, r3, #8
    8f54:	697b      	ldr	r3, [r7, #20]
    8f56:	4313      	orrs	r3, r2
    8f58:	617b      	str	r3, [r7, #20]
		reg |= ((uint32)strHif.u16Length<<16);
    8f5a:	2318      	movs	r3, #24
    8f5c:	18fb      	adds	r3, r7, r3
    8f5e:	885b      	ldrh	r3, [r3, #2]
    8f60:	b29b      	uxth	r3, r3
    8f62:	041a      	lsls	r2, r3, #16
    8f64:	697b      	ldr	r3, [r7, #20]
    8f66:	4313      	orrs	r3, r2
    8f68:	617b      	str	r3, [r7, #20]
		ret = nm_write_reg(NMI_STATE_REG,reg);
    8f6a:	697b      	ldr	r3, [r7, #20]
    8f6c:	221f      	movs	r2, #31
    8f6e:	18bc      	adds	r4, r7, r2
    8f70:	4a80      	ldr	r2, [pc, #512]	; (9174 <hif_send+0x2e4>)
    8f72:	0019      	movs	r1, r3
    8f74:	0010      	movs	r0, r2
    8f76:	4b80      	ldr	r3, [pc, #512]	; (9178 <hif_send+0x2e8>)
    8f78:	4798      	blx	r3
    8f7a:	0003      	movs	r3, r0
    8f7c:	7023      	strb	r3, [r4, #0]
		if(M2M_SUCCESS != ret) goto ERR1;
    8f7e:	231f      	movs	r3, #31
    8f80:	18fb      	adds	r3, r7, r3
    8f82:	781b      	ldrb	r3, [r3, #0]
    8f84:	b25b      	sxtb	r3, r3
    8f86:	2b00      	cmp	r3, #0
    8f88:	d000      	beq.n	8f8c <hif_send+0xfc>
    8f8a:	e0e0      	b.n	914e <hif_send+0x2be>


		reg = 0;
    8f8c:	2300      	movs	r3, #0
    8f8e:	617b      	str	r3, [r7, #20]
		reg |= (1<<1);
    8f90:	697b      	ldr	r3, [r7, #20]
    8f92:	2202      	movs	r2, #2
    8f94:	4313      	orrs	r3, r2
    8f96:	617b      	str	r3, [r7, #20]
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
    8f98:	697b      	ldr	r3, [r7, #20]
    8f9a:	221f      	movs	r2, #31
    8f9c:	18bc      	adds	r4, r7, r2
    8f9e:	4a77      	ldr	r2, [pc, #476]	; (917c <hif_send+0x2ec>)
    8fa0:	0019      	movs	r1, r3
    8fa2:	0010      	movs	r0, r2
    8fa4:	4b74      	ldr	r3, [pc, #464]	; (9178 <hif_send+0x2e8>)
    8fa6:	4798      	blx	r3
    8fa8:	0003      	movs	r3, r0
    8faa:	7023      	strb	r3, [r4, #0]
		if(M2M_SUCCESS != ret) goto ERR1;
    8fac:	231f      	movs	r3, #31
    8fae:	18fb      	adds	r3, r7, r3
    8fb0:	781b      	ldrb	r3, [r3, #0]
    8fb2:	b25b      	sxtb	r3, r3
    8fb4:	2b00      	cmp	r3, #0
    8fb6:	d000      	beq.n	8fba <hif_send+0x12a>
    8fb8:	e0cb      	b.n	9152 <hif_send+0x2c2>
		dma_addr = 0;
    8fba:	2300      	movs	r3, #0
    8fbc:	613b      	str	r3, [r7, #16]

		//nm_bsp_interrupt_ctrl(0);

		for(cnt = 0; cnt < 1000; cnt ++)
    8fbe:	230e      	movs	r3, #14
    8fc0:	18fb      	adds	r3, r7, r3
    8fc2:	2200      	movs	r2, #0
    8fc4:	801a      	strh	r2, [r3, #0]
    8fc6:	e031      	b.n	902c <hif_send+0x19c>
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
    8fc8:	231f      	movs	r3, #31
    8fca:	18fc      	adds	r4, r7, r3
    8fcc:	2314      	movs	r3, #20
    8fce:	18fb      	adds	r3, r7, r3
    8fd0:	4a6a      	ldr	r2, [pc, #424]	; (917c <hif_send+0x2ec>)
    8fd2:	0019      	movs	r1, r3
    8fd4:	0010      	movs	r0, r2
    8fd6:	4b6a      	ldr	r3, [pc, #424]	; (9180 <hif_send+0x2f0>)
    8fd8:	4798      	blx	r3
    8fda:	0003      	movs	r3, r0
    8fdc:	7023      	strb	r3, [r4, #0]
			if(ret != M2M_SUCCESS) break;
    8fde:	231f      	movs	r3, #31
    8fe0:	18fb      	adds	r3, r7, r3
    8fe2:	781b      	ldrb	r3, [r3, #0]
    8fe4:	b25b      	sxtb	r3, r3
    8fe6:	2b00      	cmp	r3, #0
    8fe8:	d128      	bne.n	903c <hif_send+0x1ac>
			if (!(reg & 0x2))
    8fea:	697b      	ldr	r3, [r7, #20]
    8fec:	2202      	movs	r2, #2
    8fee:	4013      	ands	r3, r2
    8ff0:	d113      	bne.n	901a <hif_send+0x18a>
			{
				ret = nm_read_reg_with_ret(0x150400,(uint32 *)&dma_addr);
    8ff2:	231f      	movs	r3, #31
    8ff4:	18fc      	adds	r4, r7, r3
    8ff6:	2310      	movs	r3, #16
    8ff8:	18fb      	adds	r3, r7, r3
    8ffa:	4a62      	ldr	r2, [pc, #392]	; (9184 <hif_send+0x2f4>)
    8ffc:	0019      	movs	r1, r3
    8ffe:	0010      	movs	r0, r2
    9000:	4b5f      	ldr	r3, [pc, #380]	; (9180 <hif_send+0x2f0>)
    9002:	4798      	blx	r3
    9004:	0003      	movs	r3, r0
    9006:	7023      	strb	r3, [r4, #0]
				if(ret != M2M_SUCCESS) {
    9008:	231f      	movs	r3, #31
    900a:	18fb      	adds	r3, r7, r3
    900c:	781b      	ldrb	r3, [r3, #0]
    900e:	b25b      	sxtb	r3, r3
    9010:	2b00      	cmp	r3, #0
    9012:	d015      	beq.n	9040 <hif_send+0x1b0>
					/*in case of read error clear the dma address and return error*/
					dma_addr = 0;
    9014:	2300      	movs	r3, #0
    9016:	613b      	str	r3, [r7, #16]
				}
				/*in case of success break */
				break;
    9018:	e012      	b.n	9040 <hif_send+0x1b0>
		if(M2M_SUCCESS != ret) goto ERR1;
		dma_addr = 0;

		//nm_bsp_interrupt_ctrl(0);

		for(cnt = 0; cnt < 1000; cnt ++)
    901a:	230e      	movs	r3, #14
    901c:	18fb      	adds	r3, r7, r3
    901e:	881b      	ldrh	r3, [r3, #0]
    9020:	b29b      	uxth	r3, r3
    9022:	3301      	adds	r3, #1
    9024:	b29a      	uxth	r2, r3
    9026:	230e      	movs	r3, #14
    9028:	18fb      	adds	r3, r7, r3
    902a:	801a      	strh	r2, [r3, #0]
    902c:	230e      	movs	r3, #14
    902e:	18fb      	adds	r3, r7, r3
    9030:	881b      	ldrh	r3, [r3, #0]
    9032:	b29b      	uxth	r3, r3
    9034:	4a54      	ldr	r2, [pc, #336]	; (9188 <hif_send+0x2f8>)
    9036:	4293      	cmp	r3, r2
    9038:	d9c6      	bls.n	8fc8 <hif_send+0x138>
    903a:	e002      	b.n	9042 <hif_send+0x1b2>
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
			if(ret != M2M_SUCCESS) break;
    903c:	46c0      	nop			; (mov r8, r8)
    903e:	e000      	b.n	9042 <hif_send+0x1b2>
				if(ret != M2M_SUCCESS) {
					/*in case of read error clear the dma address and return error*/
					dma_addr = 0;
				}
				/*in case of success break */
				break;
    9040:	46c0      	nop			; (mov r8, r8)
			}
		}
		//nm_bsp_interrupt_ctrl(1);

		if (dma_addr != 0)
    9042:	693b      	ldr	r3, [r7, #16]
    9044:	2b00      	cmp	r3, #0
    9046:	d100      	bne.n	904a <hif_send+0x1ba>
    9048:	e073      	b.n	9132 <hif_send+0x2a2>
		{
			volatile uint32	u32CurrAddr;
			u32CurrAddr = dma_addr;
    904a:	693b      	ldr	r3, [r7, #16]
    904c:	60bb      	str	r3, [r7, #8]
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
    904e:	2318      	movs	r3, #24
    9050:	18fb      	adds	r3, r7, r3
    9052:	885b      	ldrh	r3, [r3, #2]
    9054:	b29a      	uxth	r2, r3
    9056:	2318      	movs	r3, #24
    9058:	18fb      	adds	r3, r7, r3
    905a:	805a      	strh	r2, [r3, #2]
			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
    905c:	68bb      	ldr	r3, [r7, #8]
    905e:	221f      	movs	r2, #31
    9060:	18bc      	adds	r4, r7, r2
    9062:	2218      	movs	r2, #24
    9064:	18b9      	adds	r1, r7, r2
    9066:	2208      	movs	r2, #8
    9068:	0018      	movs	r0, r3
    906a:	4b48      	ldr	r3, [pc, #288]	; (918c <hif_send+0x2fc>)
    906c:	4798      	blx	r3
    906e:	0003      	movs	r3, r0
    9070:	7023      	strb	r3, [r4, #0]
		#ifdef CONF_WINC_USE_I2C
			nm_bsp_sleep(1);
		#endif
			if(M2M_SUCCESS != ret) goto ERR1;
    9072:	231f      	movs	r3, #31
    9074:	18fb      	adds	r3, r7, r3
    9076:	781b      	ldrb	r3, [r3, #0]
    9078:	b25b      	sxtb	r3, r3
    907a:	2b00      	cmp	r3, #0
    907c:	d000      	beq.n	9080 <hif_send+0x1f0>
    907e:	e06a      	b.n	9156 <hif_send+0x2c6>
			u32CurrAddr += M2M_HIF_HDR_OFFSET;
    9080:	68bb      	ldr	r3, [r7, #8]
    9082:	3308      	adds	r3, #8
    9084:	60bb      	str	r3, [r7, #8]
			if(pu8CtrlBuf != NULL)
    9086:	683b      	ldr	r3, [r7, #0]
    9088:	2b00      	cmp	r3, #0
    908a:	d015      	beq.n	90b8 <hif_send+0x228>
			{
				ret = nm_write_block(u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
    908c:	68b8      	ldr	r0, [r7, #8]
    908e:	1d3b      	adds	r3, r7, #4
    9090:	881a      	ldrh	r2, [r3, #0]
    9092:	231f      	movs	r3, #31
    9094:	18fc      	adds	r4, r7, r3
    9096:	683b      	ldr	r3, [r7, #0]
    9098:	0019      	movs	r1, r3
    909a:	4b3c      	ldr	r3, [pc, #240]	; (918c <hif_send+0x2fc>)
    909c:	4798      	blx	r3
    909e:	0003      	movs	r3, r0
    90a0:	7023      	strb	r3, [r4, #0]
			#ifdef CONF_WINC_USE_I2C
				nm_bsp_sleep(1);
			#endif
				if(M2M_SUCCESS != ret) goto ERR1;
    90a2:	231f      	movs	r3, #31
    90a4:	18fb      	adds	r3, r7, r3
    90a6:	781b      	ldrb	r3, [r3, #0]
    90a8:	b25b      	sxtb	r3, r3
    90aa:	2b00      	cmp	r3, #0
    90ac:	d155      	bne.n	915a <hif_send+0x2ca>
				u32CurrAddr += u16CtrlBufSize;
    90ae:	1d3b      	adds	r3, r7, #4
    90b0:	881a      	ldrh	r2, [r3, #0]
    90b2:	68bb      	ldr	r3, [r7, #8]
    90b4:	18d3      	adds	r3, r2, r3
    90b6:	60bb      	str	r3, [r7, #8]
			}
			if(pu8DataBuf != NULL)
    90b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    90ba:	2b00      	cmp	r3, #0
    90bc:	d021      	beq.n	9102 <hif_send+0x272>
			{
				u32CurrAddr += (u16DataOffset - u16CtrlBufSize);
    90be:	2338      	movs	r3, #56	; 0x38
    90c0:	18fb      	adds	r3, r7, r3
    90c2:	881a      	ldrh	r2, [r3, #0]
    90c4:	1d3b      	adds	r3, r7, #4
    90c6:	881b      	ldrh	r3, [r3, #0]
    90c8:	1ad3      	subs	r3, r2, r3
    90ca:	001a      	movs	r2, r3
    90cc:	68bb      	ldr	r3, [r7, #8]
    90ce:	18d3      	adds	r3, r2, r3
    90d0:	60bb      	str	r3, [r7, #8]
				ret = nm_write_block(u32CurrAddr, pu8DataBuf, u16DataSize);
    90d2:	68b8      	ldr	r0, [r7, #8]
    90d4:	2334      	movs	r3, #52	; 0x34
    90d6:	18fb      	adds	r3, r7, r3
    90d8:	881a      	ldrh	r2, [r3, #0]
    90da:	231f      	movs	r3, #31
    90dc:	18fc      	adds	r4, r7, r3
    90de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    90e0:	0019      	movs	r1, r3
    90e2:	4b2a      	ldr	r3, [pc, #168]	; (918c <hif_send+0x2fc>)
    90e4:	4798      	blx	r3
    90e6:	0003      	movs	r3, r0
    90e8:	7023      	strb	r3, [r4, #0]
			#ifdef CONF_WINC_USE_I2C	
				nm_bsp_sleep(1);
			#endif
				if(M2M_SUCCESS != ret) goto ERR1;
    90ea:	231f      	movs	r3, #31
    90ec:	18fb      	adds	r3, r7, r3
    90ee:	781b      	ldrb	r3, [r3, #0]
    90f0:	b25b      	sxtb	r3, r3
    90f2:	2b00      	cmp	r3, #0
    90f4:	d133      	bne.n	915e <hif_send+0x2ce>
				u32CurrAddr += u16DataSize;
    90f6:	2334      	movs	r3, #52	; 0x34
    90f8:	18fb      	adds	r3, r7, r3
    90fa:	881a      	ldrh	r2, [r3, #0]
    90fc:	68bb      	ldr	r3, [r7, #8]
    90fe:	18d3      	adds	r3, r2, r3
    9100:	60bb      	str	r3, [r7, #8]
			}

			reg = dma_addr << 2;
    9102:	693b      	ldr	r3, [r7, #16]
    9104:	009b      	lsls	r3, r3, #2
    9106:	617b      	str	r3, [r7, #20]
			reg |= (1 << 1);
    9108:	697b      	ldr	r3, [r7, #20]
    910a:	2202      	movs	r2, #2
    910c:	4313      	orrs	r3, r2
    910e:	617b      	str	r3, [r7, #20]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
    9110:	697b      	ldr	r3, [r7, #20]
    9112:	221f      	movs	r2, #31
    9114:	18bc      	adds	r4, r7, r2
    9116:	4a1e      	ldr	r2, [pc, #120]	; (9190 <hif_send+0x300>)
    9118:	0019      	movs	r1, r3
    911a:	0010      	movs	r0, r2
    911c:	4b16      	ldr	r3, [pc, #88]	; (9178 <hif_send+0x2e8>)
    911e:	4798      	blx	r3
    9120:	0003      	movs	r3, r0
    9122:	7023      	strb	r3, [r4, #0]
			if(M2M_SUCCESS != ret) goto ERR1;
    9124:	231f      	movs	r3, #31
    9126:	18fb      	adds	r3, r7, r3
    9128:	781b      	ldrb	r3, [r3, #0]
    912a:	b25b      	sxtb	r3, r3
    912c:	2b00      	cmp	r3, #0
    912e:	d005      	beq.n	913c <hif_send+0x2ac>
    9130:	e016      	b.n	9160 <hif_send+0x2d0>
		}
		else
		{
			M2M_DBG("Failed to alloc rx size\r");
			ret =  M2M_ERR_MEM_ALLOC;
    9132:	231f      	movs	r3, #31
    9134:	18fb      	adds	r3, r7, r3
    9136:	22fd      	movs	r2, #253	; 0xfd
    9138:	701a      	strb	r2, [r3, #0]
			goto ERR1;
    913a:	e011      	b.n	9160 <hif_send+0x2d0>
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
		goto ERR1;
	}
	ret = hif_chip_sleep();
    913c:	231f      	movs	r3, #31
    913e:	18fc      	adds	r4, r7, r3
    9140:	4b14      	ldr	r3, [pc, #80]	; (9194 <hif_send+0x304>)
    9142:	4798      	blx	r3
    9144:	0003      	movs	r3, r0
    9146:	7023      	strb	r3, [r4, #0]
    9148:	e00a      	b.n	9160 <hif_send+0x2d0>

	}
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
		goto ERR1;
    914a:	46c0      	nop			; (mov r8, r8)
    914c:	e008      	b.n	9160 <hif_send+0x2d0>
		reg = 0UL;
		reg |= (uint32)u8Gid;
		reg |= ((uint32)u8Opcode<<8);
		reg |= ((uint32)strHif.u16Length<<16);
		ret = nm_write_reg(NMI_STATE_REG,reg);
		if(M2M_SUCCESS != ret) goto ERR1;
    914e:	46c0      	nop			; (mov r8, r8)
    9150:	e006      	b.n	9160 <hif_send+0x2d0>


		reg = 0;
		reg |= (1<<1);
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
		if(M2M_SUCCESS != ret) goto ERR1;
    9152:	46c0      	nop			; (mov r8, r8)
    9154:	e004      	b.n	9160 <hif_send+0x2d0>
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
		#ifdef CONF_WINC_USE_I2C
			nm_bsp_sleep(1);
		#endif
			if(M2M_SUCCESS != ret) goto ERR1;
    9156:	46c0      	nop			; (mov r8, r8)
    9158:	e002      	b.n	9160 <hif_send+0x2d0>
			{
				ret = nm_write_block(u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
			#ifdef CONF_WINC_USE_I2C
				nm_bsp_sleep(1);
			#endif
				if(M2M_SUCCESS != ret) goto ERR1;
    915a:	46c0      	nop			; (mov r8, r8)
    915c:	e000      	b.n	9160 <hif_send+0x2d0>
				u32CurrAddr += (u16DataOffset - u16CtrlBufSize);
				ret = nm_write_block(u32CurrAddr, pu8DataBuf, u16DataSize);
			#ifdef CONF_WINC_USE_I2C	
				nm_bsp_sleep(1);
			#endif
				if(M2M_SUCCESS != ret) goto ERR1;
    915e:	46c0      	nop			; (mov r8, r8)
		goto ERR1;
	}
	ret = hif_chip_sleep();

ERR1:
	return ret;
    9160:	231f      	movs	r3, #31
    9162:	18fb      	adds	r3, r7, r3
    9164:	781b      	ldrb	r3, [r3, #0]
    9166:	b25b      	sxtb	r3, r3
}
    9168:	0018      	movs	r0, r3
    916a:	46bd      	mov	sp, r7
    916c:	b009      	add	sp, #36	; 0x24
    916e:	bd90      	pop	{r4, r7, pc}
    9170:	00008cc5 	.word	0x00008cc5
    9174:	0000108c 	.word	0x0000108c
    9178:	0000a275 	.word	0x0000a275
    917c:	00001078 	.word	0x00001078
    9180:	0000a251 	.word	0x0000a251
    9184:	00150400 	.word	0x00150400
    9188:	000003e7 	.word	0x000003e7
    918c:	0000a3bd 	.word	0x0000a3bd
    9190:	0000106c 	.word	0x0000106c
    9194:	00008d5d 	.word	0x00008d5d

00009198 <hif_isr>:
*	@date	15 July 2012
*	@return	1 in case of interrupt received else 0 will be returned
*	@version	1.0
*/
static sint8 hif_isr(void)
{
    9198:	b590      	push	{r4, r7, lr}
    919a:	b085      	sub	sp, #20
    919c:	af00      	add	r7, sp, #0
	sint8 ret = M2M_ERR_BUS_FAIL;
    919e:	230f      	movs	r3, #15
    91a0:	18fb      	adds	r3, r7, r3
    91a2:	22fa      	movs	r2, #250	; 0xfa
    91a4:	701a      	strb	r2, [r3, #0]
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = hif_chip_wake();
    91a6:	230f      	movs	r3, #15
    91a8:	18fc      	adds	r4, r7, r3
    91aa:	4b99      	ldr	r3, [pc, #612]	; (9410 <hif_isr+0x278>)
    91ac:	4798      	blx	r3
    91ae:	0003      	movs	r3, r0
    91b0:	7023      	strb	r3, [r4, #0]
	if(ret == M2M_SUCCESS)
    91b2:	230f      	movs	r3, #15
    91b4:	18fb      	adds	r3, r7, r3
    91b6:	781b      	ldrb	r3, [r3, #0]
    91b8:	b25b      	sxtb	r3, r3
    91ba:	2b00      	cmp	r3, #0
    91bc:	d000      	beq.n	91c0 <hif_isr+0x28>
    91be:	e119      	b.n	93f4 <hif_isr+0x25c>
	{
		ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
    91c0:	230f      	movs	r3, #15
    91c2:	18fc      	adds	r4, r7, r3
    91c4:	2308      	movs	r3, #8
    91c6:	18fb      	adds	r3, r7, r3
    91c8:	4a92      	ldr	r2, [pc, #584]	; (9414 <hif_isr+0x27c>)
    91ca:	0019      	movs	r1, r3
    91cc:	0010      	movs	r0, r2
    91ce:	4b92      	ldr	r3, [pc, #584]	; (9418 <hif_isr+0x280>)
    91d0:	4798      	blx	r3
    91d2:	0003      	movs	r3, r0
    91d4:	7023      	strb	r3, [r4, #0]
		if(M2M_SUCCESS == ret)
    91d6:	230f      	movs	r3, #15
    91d8:	18fb      	adds	r3, r7, r3
    91da:	781b      	ldrb	r3, [r3, #0]
    91dc:	b25b      	sxtb	r3, r3
    91de:	2b00      	cmp	r3, #0
    91e0:	d000      	beq.n	91e4 <hif_isr+0x4c>
    91e2:	e109      	b.n	93f8 <hif_isr+0x260>
		{
			if(reg & 0x1)	/* New interrupt has been received */
    91e4:	68bb      	ldr	r3, [r7, #8]
    91e6:	2201      	movs	r2, #1
    91e8:	4013      	ands	r3, r2
    91ea:	d100      	bne.n	91ee <hif_isr+0x56>
    91ec:	e0fb      	b.n	93e6 <hif_isr+0x24e>
			{
				uint16 size;

				nm_bsp_interrupt_ctrl(0);
    91ee:	2000      	movs	r0, #0
    91f0:	4b8a      	ldr	r3, [pc, #552]	; (941c <hif_isr+0x284>)
    91f2:	4798      	blx	r3
				/*Clearing RX interrupt*/
				reg &= ~(1<<0);
    91f4:	68bb      	ldr	r3, [r7, #8]
    91f6:	2201      	movs	r2, #1
    91f8:	4393      	bics	r3, r2
    91fa:	60bb      	str	r3, [r7, #8]
				ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
    91fc:	68bb      	ldr	r3, [r7, #8]
    91fe:	220f      	movs	r2, #15
    9200:	18bc      	adds	r4, r7, r2
    9202:	4a84      	ldr	r2, [pc, #528]	; (9414 <hif_isr+0x27c>)
    9204:	0019      	movs	r1, r3
    9206:	0010      	movs	r0, r2
    9208:	4b85      	ldr	r3, [pc, #532]	; (9420 <hif_isr+0x288>)
    920a:	4798      	blx	r3
    920c:	0003      	movs	r3, r0
    920e:	7023      	strb	r3, [r4, #0]
				if(ret != M2M_SUCCESS)goto ERR1;
    9210:	230f      	movs	r3, #15
    9212:	18fb      	adds	r3, r7, r3
    9214:	781b      	ldrb	r3, [r3, #0]
    9216:	b25b      	sxtb	r3, r3
    9218:	2b00      	cmp	r3, #0
    921a:	d000      	beq.n	921e <hif_isr+0x86>
    921c:	e0ee      	b.n	93fc <hif_isr+0x264>
				gu8HifSizeDone = 0;
    921e:	4b81      	ldr	r3, [pc, #516]	; (9424 <hif_isr+0x28c>)
    9220:	2200      	movs	r2, #0
    9222:	701a      	strb	r2, [r3, #0]
				size = (uint16)((reg >> 2) & 0xfff);
    9224:	68bb      	ldr	r3, [r7, #8]
    9226:	089b      	lsrs	r3, r3, #2
    9228:	b29a      	uxth	r2, r3
    922a:	230c      	movs	r3, #12
    922c:	18fb      	adds	r3, r7, r3
    922e:	0512      	lsls	r2, r2, #20
    9230:	0d12      	lsrs	r2, r2, #20
    9232:	801a      	strh	r2, [r3, #0]
				if (size > 0) {
    9234:	230c      	movs	r3, #12
    9236:	18fb      	adds	r3, r7, r3
    9238:	881b      	ldrh	r3, [r3, #0]
    923a:	2b00      	cmp	r3, #0
    923c:	d100      	bne.n	9240 <hif_isr+0xa8>
    923e:	e0cd      	b.n	93dc <hif_isr+0x244>
					uint32 address = 0;
    9240:	2300      	movs	r3, #0
    9242:	603b      	str	r3, [r7, #0]
					/**
					start bus transfer
					**/
					ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1, &address);
    9244:	230f      	movs	r3, #15
    9246:	18fc      	adds	r4, r7, r3
    9248:	003b      	movs	r3, r7
    924a:	4a77      	ldr	r2, [pc, #476]	; (9428 <hif_isr+0x290>)
    924c:	0019      	movs	r1, r3
    924e:	0010      	movs	r0, r2
    9250:	4b71      	ldr	r3, [pc, #452]	; (9418 <hif_isr+0x280>)
    9252:	4798      	blx	r3
    9254:	0003      	movs	r3, r0
    9256:	7023      	strb	r3, [r4, #0]
					if(M2M_SUCCESS != ret)
    9258:	230f      	movs	r3, #15
    925a:	18fb      	adds	r3, r7, r3
    925c:	781b      	ldrb	r3, [r3, #0]
    925e:	b25b      	sxtb	r3, r3
    9260:	2b00      	cmp	r3, #0
    9262:	d003      	beq.n	926c <hif_isr+0xd4>
					{
						M2M_ERR("(hif) WIFI_HOST_RCV_CTRL_1 bus fail\n");
						nm_bsp_interrupt_ctrl(1);
    9264:	2001      	movs	r0, #1
    9266:	4b6d      	ldr	r3, [pc, #436]	; (941c <hif_isr+0x284>)
    9268:	4798      	blx	r3
						goto ERR1;
    926a:	e0c8      	b.n	93fe <hif_isr+0x266>
					}
					ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
    926c:	683b      	ldr	r3, [r7, #0]
    926e:	220f      	movs	r2, #15
    9270:	18bc      	adds	r4, r7, r2
    9272:	1d39      	adds	r1, r7, #4
    9274:	2204      	movs	r2, #4
    9276:	0018      	movs	r0, r3
    9278:	4b6c      	ldr	r3, [pc, #432]	; (942c <hif_isr+0x294>)
    927a:	4798      	blx	r3
    927c:	0003      	movs	r3, r0
    927e:	7023      	strb	r3, [r4, #0]
					strHif.u16Length = NM_BSP_B_L_16(strHif.u16Length);
    9280:	1d3b      	adds	r3, r7, #4
    9282:	885b      	ldrh	r3, [r3, #2]
    9284:	b29a      	uxth	r2, r3
    9286:	1d3b      	adds	r3, r7, #4
    9288:	805a      	strh	r2, [r3, #2]
					if(M2M_SUCCESS != ret)
    928a:	230f      	movs	r3, #15
    928c:	18fb      	adds	r3, r7, r3
    928e:	781b      	ldrb	r3, [r3, #0]
    9290:	b25b      	sxtb	r3, r3
    9292:	2b00      	cmp	r3, #0
    9294:	d003      	beq.n	929e <hif_isr+0x106>
					{
						M2M_ERR("(hif) address bus fail\n");
						nm_bsp_interrupt_ctrl(1);
    9296:	2001      	movs	r0, #1
    9298:	4b60      	ldr	r3, [pc, #384]	; (941c <hif_isr+0x284>)
    929a:	4798      	blx	r3
						goto ERR1;
    929c:	e0af      	b.n	93fe <hif_isr+0x266>
					}
					if(strHif.u16Length != size)
    929e:	1d3b      	adds	r3, r7, #4
    92a0:	885b      	ldrh	r3, [r3, #2]
    92a2:	b29b      	uxth	r3, r3
    92a4:	220c      	movs	r2, #12
    92a6:	18ba      	adds	r2, r7, r2
    92a8:	8812      	ldrh	r2, [r2, #0]
    92aa:	429a      	cmp	r2, r3
    92ac:	d010      	beq.n	92d0 <hif_isr+0x138>
					{
						if((size - strHif.u16Length) > 4)
    92ae:	230c      	movs	r3, #12
    92b0:	18fb      	adds	r3, r7, r3
    92b2:	881b      	ldrh	r3, [r3, #0]
    92b4:	1d3a      	adds	r2, r7, #4
    92b6:	8852      	ldrh	r2, [r2, #2]
    92b8:	b292      	uxth	r2, r2
    92ba:	1a9b      	subs	r3, r3, r2
    92bc:	2b04      	cmp	r3, #4
    92be:	dd07      	ble.n	92d0 <hif_isr+0x138>
						{
							M2M_ERR("(hif) Corrupted packet Size = %u <L = %u, G = %u, OP = %02X>\n",
								size, strHif.u16Length, strHif.u8Gid, strHif.u8Opcode);
							nm_bsp_interrupt_ctrl(1);
    92c0:	2001      	movs	r0, #1
    92c2:	4b56      	ldr	r3, [pc, #344]	; (941c <hif_isr+0x284>)
    92c4:	4798      	blx	r3
							ret = M2M_ERR_BUS_FAIL;
    92c6:	230f      	movs	r3, #15
    92c8:	18fb      	adds	r3, r7, r3
    92ca:	22fa      	movs	r2, #250	; 0xfa
    92cc:	701a      	strb	r2, [r3, #0]
							goto ERR1;
    92ce:	e096      	b.n	93fe <hif_isr+0x266>
						}
					}

					if(M2M_REQ_GROUP_WIFI == strHif.u8Gid)
    92d0:	1d3b      	adds	r3, r7, #4
    92d2:	781b      	ldrb	r3, [r3, #0]
    92d4:	b2db      	uxtb	r3, r3
    92d6:	2b01      	cmp	r3, #1
    92d8:	d112      	bne.n	9300 <hif_isr+0x168>
					{
						if(pfWifiCb)
    92da:	4b55      	ldr	r3, [pc, #340]	; (9430 <hif_isr+0x298>)
    92dc:	681b      	ldr	r3, [r3, #0]
    92de:	2b00      	cmp	r3, #0
    92e0:	d100      	bne.n	92e4 <hif_isr+0x14c>
    92e2:	e06f      	b.n	93c4 <hif_isr+0x22c>
							pfWifiCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    92e4:	4b52      	ldr	r3, [pc, #328]	; (9430 <hif_isr+0x298>)
    92e6:	681b      	ldr	r3, [r3, #0]
    92e8:	1d3a      	adds	r2, r7, #4
    92ea:	7852      	ldrb	r2, [r2, #1]
    92ec:	b2d0      	uxtb	r0, r2
    92ee:	1d3a      	adds	r2, r7, #4
    92f0:	8852      	ldrh	r2, [r2, #2]
    92f2:	b292      	uxth	r2, r2
    92f4:	3a08      	subs	r2, #8
    92f6:	b291      	uxth	r1, r2
    92f8:	683a      	ldr	r2, [r7, #0]
    92fa:	3208      	adds	r2, #8
    92fc:	4798      	blx	r3
    92fe:	e061      	b.n	93c4 <hif_isr+0x22c>

					}
					else if(M2M_REQ_GROUP_IP == strHif.u8Gid)
    9300:	1d3b      	adds	r3, r7, #4
    9302:	781b      	ldrb	r3, [r3, #0]
    9304:	b2db      	uxtb	r3, r3
    9306:	2b02      	cmp	r3, #2
    9308:	d111      	bne.n	932e <hif_isr+0x196>
					{
						if(pfIpCb)
    930a:	4b4a      	ldr	r3, [pc, #296]	; (9434 <hif_isr+0x29c>)
    930c:	681b      	ldr	r3, [r3, #0]
    930e:	2b00      	cmp	r3, #0
    9310:	d058      	beq.n	93c4 <hif_isr+0x22c>
							pfIpCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    9312:	4b48      	ldr	r3, [pc, #288]	; (9434 <hif_isr+0x29c>)
    9314:	681b      	ldr	r3, [r3, #0]
    9316:	1d3a      	adds	r2, r7, #4
    9318:	7852      	ldrb	r2, [r2, #1]
    931a:	b2d0      	uxtb	r0, r2
    931c:	1d3a      	adds	r2, r7, #4
    931e:	8852      	ldrh	r2, [r2, #2]
    9320:	b292      	uxth	r2, r2
    9322:	3a08      	subs	r2, #8
    9324:	b291      	uxth	r1, r2
    9326:	683a      	ldr	r2, [r7, #0]
    9328:	3208      	adds	r2, #8
    932a:	4798      	blx	r3
    932c:	e04a      	b.n	93c4 <hif_isr+0x22c>
					}
					else if(M2M_REQ_GROUP_OTA == strHif.u8Gid)
    932e:	1d3b      	adds	r3, r7, #4
    9330:	781b      	ldrb	r3, [r3, #0]
    9332:	b2db      	uxtb	r3, r3
    9334:	2b04      	cmp	r3, #4
    9336:	d111      	bne.n	935c <hif_isr+0x1c4>
					{
						if(pfOtaCb)
    9338:	4b3f      	ldr	r3, [pc, #252]	; (9438 <hif_isr+0x2a0>)
    933a:	681b      	ldr	r3, [r3, #0]
    933c:	2b00      	cmp	r3, #0
    933e:	d041      	beq.n	93c4 <hif_isr+0x22c>
							pfOtaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    9340:	4b3d      	ldr	r3, [pc, #244]	; (9438 <hif_isr+0x2a0>)
    9342:	681b      	ldr	r3, [r3, #0]
    9344:	1d3a      	adds	r2, r7, #4
    9346:	7852      	ldrb	r2, [r2, #1]
    9348:	b2d0      	uxtb	r0, r2
    934a:	1d3a      	adds	r2, r7, #4
    934c:	8852      	ldrh	r2, [r2, #2]
    934e:	b292      	uxth	r2, r2
    9350:	3a08      	subs	r2, #8
    9352:	b291      	uxth	r1, r2
    9354:	683a      	ldr	r2, [r7, #0]
    9356:	3208      	adds	r2, #8
    9358:	4798      	blx	r3
    935a:	e033      	b.n	93c4 <hif_isr+0x22c>
					}
					else if(M2M_REQ_GROUP_CRYPTO == strHif.u8Gid)
    935c:	1d3b      	adds	r3, r7, #4
    935e:	781b      	ldrb	r3, [r3, #0]
    9360:	b2db      	uxtb	r3, r3
    9362:	2b06      	cmp	r3, #6
    9364:	d111      	bne.n	938a <hif_isr+0x1f2>
					{
						if(pfCryptoCb)
    9366:	4b35      	ldr	r3, [pc, #212]	; (943c <hif_isr+0x2a4>)
    9368:	681b      	ldr	r3, [r3, #0]
    936a:	2b00      	cmp	r3, #0
    936c:	d02a      	beq.n	93c4 <hif_isr+0x22c>
							pfCryptoCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    936e:	4b33      	ldr	r3, [pc, #204]	; (943c <hif_isr+0x2a4>)
    9370:	681b      	ldr	r3, [r3, #0]
    9372:	1d3a      	adds	r2, r7, #4
    9374:	7852      	ldrb	r2, [r2, #1]
    9376:	b2d0      	uxtb	r0, r2
    9378:	1d3a      	adds	r2, r7, #4
    937a:	8852      	ldrh	r2, [r2, #2]
    937c:	b292      	uxth	r2, r2
    937e:	3a08      	subs	r2, #8
    9380:	b291      	uxth	r1, r2
    9382:	683a      	ldr	r2, [r7, #0]
    9384:	3208      	adds	r2, #8
    9386:	4798      	blx	r3
    9388:	e01c      	b.n	93c4 <hif_isr+0x22c>
					}
					else if(M2M_REQ_GROUP_SIGMA == strHif.u8Gid)
    938a:	1d3b      	adds	r3, r7, #4
    938c:	781b      	ldrb	r3, [r3, #0]
    938e:	b2db      	uxtb	r3, r3
    9390:	2b07      	cmp	r3, #7
    9392:	d111      	bne.n	93b8 <hif_isr+0x220>
					{
						if(pfSigmaCb)
    9394:	4b2a      	ldr	r3, [pc, #168]	; (9440 <hif_isr+0x2a8>)
    9396:	681b      	ldr	r3, [r3, #0]
    9398:	2b00      	cmp	r3, #0
    939a:	d013      	beq.n	93c4 <hif_isr+0x22c>
							pfSigmaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    939c:	4b28      	ldr	r3, [pc, #160]	; (9440 <hif_isr+0x2a8>)
    939e:	681b      	ldr	r3, [r3, #0]
    93a0:	1d3a      	adds	r2, r7, #4
    93a2:	7852      	ldrb	r2, [r2, #1]
    93a4:	b2d0      	uxtb	r0, r2
    93a6:	1d3a      	adds	r2, r7, #4
    93a8:	8852      	ldrh	r2, [r2, #2]
    93aa:	b292      	uxth	r2, r2
    93ac:	3a08      	subs	r2, #8
    93ae:	b291      	uxth	r1, r2
    93b0:	683a      	ldr	r2, [r7, #0]
    93b2:	3208      	adds	r2, #8
    93b4:	4798      	blx	r3
    93b6:	e005      	b.n	93c4 <hif_isr+0x22c>
					}
					else
					{
						M2M_ERR("(hif) invalid group ID\n");
						ret = M2M_ERR_BUS_FAIL;
    93b8:	230f      	movs	r3, #15
    93ba:	18fb      	adds	r3, r7, r3
    93bc:	22fa      	movs	r2, #250	; 0xfa
    93be:	701a      	strb	r2, [r3, #0]
						goto ERR1;
    93c0:	46c0      	nop			; (mov r8, r8)
    93c2:	e01c      	b.n	93fe <hif_isr+0x266>
					}
					#ifndef ENABLE_UNO_BOARD
					if(!gu8HifSizeDone)
    93c4:	4b17      	ldr	r3, [pc, #92]	; (9424 <hif_isr+0x28c>)
    93c6:	781b      	ldrb	r3, [r3, #0]
    93c8:	b2db      	uxtb	r3, r3
    93ca:	2b00      	cmp	r3, #0
    93cc:	d10b      	bne.n	93e6 <hif_isr+0x24e>
					{
						M2M_ERR("(hif) host app didn't set RX Done\n");
						ret = hif_set_rx_done();
    93ce:	230f      	movs	r3, #15
    93d0:	18fc      	adds	r4, r7, r3
    93d2:	4b1c      	ldr	r3, [pc, #112]	; (9444 <hif_isr+0x2ac>)
    93d4:	4798      	blx	r3
    93d6:	0003      	movs	r3, r0
    93d8:	7023      	strb	r3, [r4, #0]
    93da:	e004      	b.n	93e6 <hif_isr+0x24e>
					}
					#endif
				}
				else
				{
					ret = M2M_ERR_RCV;
    93dc:	230f      	movs	r3, #15
    93de:	18fb      	adds	r3, r7, r3
    93e0:	22fe      	movs	r2, #254	; 0xfe
    93e2:	701a      	strb	r2, [r3, #0]
					M2M_ERR("(hif) Wrong Size\n");
					goto ERR1;
    93e4:	e00b      	b.n	93fe <hif_isr+0x266>
	{
		M2M_ERR("(hif) FAIL to wakeup the chip\n");
		goto ERR1;
	}

	ret = hif_chip_sleep();
    93e6:	230f      	movs	r3, #15
    93e8:	18fc      	adds	r4, r7, r3
    93ea:	4b17      	ldr	r3, [pc, #92]	; (9448 <hif_isr+0x2b0>)
    93ec:	4798      	blx	r3
    93ee:	0003      	movs	r3, r0
    93f0:	7023      	strb	r3, [r4, #0]
    93f2:	e004      	b.n	93fe <hif_isr+0x266>
		}
	}
	else
	{
		M2M_ERR("(hif) FAIL to wakeup the chip\n");
		goto ERR1;
    93f4:	46c0      	nop			; (mov r8, r8)
    93f6:	e002      	b.n	93fe <hif_isr+0x266>
			}
		}
		else
		{
			M2M_ERR("(hif) Fail to Read interrupt reg\n");
			goto ERR1;
    93f8:	46c0      	nop			; (mov r8, r8)
    93fa:	e000      	b.n	93fe <hif_isr+0x266>

				nm_bsp_interrupt_ctrl(0);
				/*Clearing RX interrupt*/
				reg &= ~(1<<0);
				ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
				if(ret != M2M_SUCCESS)goto ERR1;
    93fc:	46c0      	nop			; (mov r8, r8)
		goto ERR1;
	}

	ret = hif_chip_sleep();
ERR1:
	return ret;
    93fe:	230f      	movs	r3, #15
    9400:	18fb      	adds	r3, r7, r3
    9402:	781b      	ldrb	r3, [r3, #0]
    9404:	b25b      	sxtb	r3, r3
}
    9406:	0018      	movs	r0, r3
    9408:	46bd      	mov	sp, r7
    940a:	b005      	add	sp, #20
    940c:	bd90      	pop	{r4, r7, pc}
    940e:	46c0      	nop			; (mov r8, r8)
    9410:	00008cc5 	.word	0x00008cc5
    9414:	00001070 	.word	0x00001070
    9418:	0000a251 	.word	0x0000a251
    941c:	00008401 	.word	0x00008401
    9420:	0000a275 	.word	0x0000a275
    9424:	20000502 	.word	0x20000502
    9428:	00001084 	.word	0x00001084
    942c:	0000a2c5 	.word	0x0000a2c5
    9430:	20000504 	.word	0x20000504
    9434:	20000508 	.word	0x20000508
    9438:	2000050c 	.word	0x2000050c
    943c:	20000518 	.word	0x20000518
    9440:	20000510 	.word	0x20000510
    9444:	00008c3d 	.word	0x00008c3d
    9448:	00008d5d 	.word	0x00008d5d

0000944c <hif_handle_isr>:
//
	//return ret;
//}

sint8 hif_handle_isr(void)
{
    944c:	b590      	push	{r4, r7, lr}
    944e:	b083      	sub	sp, #12
    9450:	af00      	add	r7, sp, #0
sint8 ret = M2M_SUCCESS;
    9452:	1dfb      	adds	r3, r7, #7
    9454:	2200      	movs	r2, #0
    9456:	701a      	strb	r2, [r3, #0]
/*must be at that place because of the race of interrupt increment and that decrement*/
/*when the interrupt enabled*/
//gu8Interrupt--;
while(1)
{
ret = hif_isr();
    9458:	1dfc      	adds	r4, r7, #7
    945a:	4b09      	ldr	r3, [pc, #36]	; (9480 <hif_handle_isr+0x34>)
    945c:	4798      	blx	r3
    945e:	0003      	movs	r3, r0
    9460:	7023      	strb	r3, [r4, #0]
if(ret == M2M_SUCCESS) {
    9462:	1dfb      	adds	r3, r7, #7
    9464:	781b      	ldrb	r3, [r3, #0]
    9466:	b25b      	sxtb	r3, r3
    9468:	2b00      	cmp	r3, #0
    946a:	d000      	beq.n	946e <hif_handle_isr+0x22>
/*Fail return errors here due to bus errors (reading expected values)*/
break;
} //else {
//M2M_ERR("(HIF) Fail to handle interrupt %d try Again..\n",ret);
//}
}
    946c:	e7f4      	b.n	9458 <hif_handle_isr+0xc>
{
ret = hif_isr();
if(ret == M2M_SUCCESS) {
/*we will try forever untill we get that interrupt*/
/*Fail return errors here due to bus errors (reading expected values)*/
break;
    946e:	46c0      	nop			; (mov r8, r8)
//M2M_ERR("(HIF) Fail to handle interrupt %d try Again..\n",ret);
//}
}
//}

return ret;
    9470:	1dfb      	adds	r3, r7, #7
    9472:	781b      	ldrb	r3, [r3, #0]
    9474:	b25b      	sxtb	r3, r3
}
    9476:	0018      	movs	r0, r3
    9478:	46bd      	mov	sp, r7
    947a:	b003      	add	sp, #12
    947c:	bd90      	pop	{r4, r7, pc}
    947e:	46c0      	nop			; (mov r8, r8)
    9480:	00009199 	.word	0x00009199

00009484 <hif_receive>:
*	@param [in]	isDone
*				If you don't need any more packets send True otherwise send false
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/
sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
{
    9484:	b590      	push	{r4, r7, lr}
    9486:	b089      	sub	sp, #36	; 0x24
    9488:	af00      	add	r7, sp, #0
    948a:	60f8      	str	r0, [r7, #12]
    948c:	60b9      	str	r1, [r7, #8]
    948e:	0019      	movs	r1, r3
    9490:	1dbb      	adds	r3, r7, #6
    9492:	801a      	strh	r2, [r3, #0]
    9494:	1d7b      	adds	r3, r7, #5
    9496:	1c0a      	adds	r2, r1, #0
    9498:	701a      	strb	r2, [r3, #0]
	uint32 address, reg;
	uint16 size;
	sint8 ret = M2M_SUCCESS;
    949a:	231f      	movs	r3, #31
    949c:	18fb      	adds	r3, r7, r3
    949e:	2200      	movs	r2, #0
    94a0:	701a      	strb	r2, [r3, #0]

	if(u32Addr == 0 ||pu8Buf == NULL || u16Sz == 0)
    94a2:	68fb      	ldr	r3, [r7, #12]
    94a4:	2b00      	cmp	r3, #0
    94a6:	d006      	beq.n	94b6 <hif_receive+0x32>
    94a8:	68bb      	ldr	r3, [r7, #8]
    94aa:	2b00      	cmp	r3, #0
    94ac:	d003      	beq.n	94b6 <hif_receive+0x32>
    94ae:	1dbb      	adds	r3, r7, #6
    94b0:	881b      	ldrh	r3, [r3, #0]
    94b2:	2b00      	cmp	r3, #0
    94b4:	d112      	bne.n	94dc <hif_receive+0x58>
	{
		if(isDone)
    94b6:	1d7b      	adds	r3, r7, #5
    94b8:	781b      	ldrb	r3, [r3, #0]
    94ba:	2b00      	cmp	r3, #0
    94bc:	d009      	beq.n	94d2 <hif_receive+0x4e>
		{
			gu8HifSizeDone = 1;
    94be:	4b48      	ldr	r3, [pc, #288]	; (95e0 <hif_receive+0x15c>)
    94c0:	2201      	movs	r2, #1
    94c2:	701a      	strb	r2, [r3, #0]
			
			/* set RX done */
			ret = hif_set_rx_done();
    94c4:	231f      	movs	r3, #31
    94c6:	18fc      	adds	r4, r7, r3
    94c8:	4b46      	ldr	r3, [pc, #280]	; (95e4 <hif_receive+0x160>)
    94ca:	4798      	blx	r3
    94cc:	0003      	movs	r3, r0
    94ce:	7023      	strb	r3, [r4, #0]
		else
		{
			ret = M2M_ERR_FAIL;
			M2M_ERR(" hif_receive: Invalid argument\n");
		}
		goto ERR1;
    94d0:	e07d      	b.n	95ce <hif_receive+0x14a>
			/* set RX done */
			ret = hif_set_rx_done();
		}
		else
		{
			ret = M2M_ERR_FAIL;
    94d2:	231f      	movs	r3, #31
    94d4:	18fb      	adds	r3, r7, r3
    94d6:	22f4      	movs	r2, #244	; 0xf4
    94d8:	701a      	strb	r2, [r3, #0]
			M2M_ERR(" hif_receive: Invalid argument\n");
		}
		goto ERR1;
    94da:	e078      	b.n	95ce <hif_receive+0x14a>
	}

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
    94dc:	231f      	movs	r3, #31
    94de:	18fc      	adds	r4, r7, r3
    94e0:	2314      	movs	r3, #20
    94e2:	18fb      	adds	r3, r7, r3
    94e4:	4a40      	ldr	r2, [pc, #256]	; (95e8 <hif_receive+0x164>)
    94e6:	0019      	movs	r1, r3
    94e8:	0010      	movs	r0, r2
    94ea:	4b40      	ldr	r3, [pc, #256]	; (95ec <hif_receive+0x168>)
    94ec:	4798      	blx	r3
    94ee:	0003      	movs	r3, r0
    94f0:	7023      	strb	r3, [r4, #0]
	if(ret != M2M_SUCCESS)goto ERR1;
    94f2:	231f      	movs	r3, #31
    94f4:	18fb      	adds	r3, r7, r3
    94f6:	781b      	ldrb	r3, [r3, #0]
    94f8:	b25b      	sxtb	r3, r3
    94fa:	2b00      	cmp	r3, #0
    94fc:	d162      	bne.n	95c4 <hif_receive+0x140>


	size = (uint16)((reg >> 2) & 0xfff);
    94fe:	697b      	ldr	r3, [r7, #20]
    9500:	089b      	lsrs	r3, r3, #2
    9502:	b29a      	uxth	r2, r3
    9504:	231c      	movs	r3, #28
    9506:	18fb      	adds	r3, r7, r3
    9508:	0512      	lsls	r2, r2, #20
    950a:	0d12      	lsrs	r2, r2, #20
    950c:	801a      	strh	r2, [r3, #0]
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1,&address);
    950e:	231f      	movs	r3, #31
    9510:	18fc      	adds	r4, r7, r3
    9512:	2318      	movs	r3, #24
    9514:	18fb      	adds	r3, r7, r3
    9516:	4a36      	ldr	r2, [pc, #216]	; (95f0 <hif_receive+0x16c>)
    9518:	0019      	movs	r1, r3
    951a:	0010      	movs	r0, r2
    951c:	4b33      	ldr	r3, [pc, #204]	; (95ec <hif_receive+0x168>)
    951e:	4798      	blx	r3
    9520:	0003      	movs	r3, r0
    9522:	7023      	strb	r3, [r4, #0]
	if(ret != M2M_SUCCESS)goto ERR1;
    9524:	231f      	movs	r3, #31
    9526:	18fb      	adds	r3, r7, r3
    9528:	781b      	ldrb	r3, [r3, #0]
    952a:	b25b      	sxtb	r3, r3
    952c:	2b00      	cmp	r3, #0
    952e:	d14b      	bne.n	95c8 <hif_receive+0x144>


	if(u16Sz > size)
    9530:	1dba      	adds	r2, r7, #6
    9532:	231c      	movs	r3, #28
    9534:	18fb      	adds	r3, r7, r3
    9536:	8812      	ldrh	r2, [r2, #0]
    9538:	881b      	ldrh	r3, [r3, #0]
    953a:	429a      	cmp	r2, r3
    953c:	d904      	bls.n	9548 <hif_receive+0xc4>
	{
		ret = M2M_ERR_FAIL;
    953e:	231f      	movs	r3, #31
    9540:	18fb      	adds	r3, r7, r3
    9542:	22f4      	movs	r2, #244	; 0xf4
    9544:	701a      	strb	r2, [r3, #0]
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%d><%d>\n",u16Sz, size);
		goto ERR1;
    9546:	e042      	b.n	95ce <hif_receive+0x14a>
	}
	if((u32Addr < address)||((u32Addr + u16Sz)>(address+size)))
    9548:	69bb      	ldr	r3, [r7, #24]
    954a:	68fa      	ldr	r2, [r7, #12]
    954c:	429a      	cmp	r2, r3
    954e:	d30a      	bcc.n	9566 <hif_receive+0xe2>
    9550:	1dbb      	adds	r3, r7, #6
    9552:	881a      	ldrh	r2, [r3, #0]
    9554:	68fb      	ldr	r3, [r7, #12]
    9556:	18d2      	adds	r2, r2, r3
    9558:	231c      	movs	r3, #28
    955a:	18fb      	adds	r3, r7, r3
    955c:	8819      	ldrh	r1, [r3, #0]
    955e:	69bb      	ldr	r3, [r7, #24]
    9560:	18cb      	adds	r3, r1, r3
    9562:	429a      	cmp	r2, r3
    9564:	d904      	bls.n	9570 <hif_receive+0xec>
	{
		ret = M2M_ERR_FAIL;
    9566:	231f      	movs	r3, #31
    9568:	18fb      	adds	r3, r7, r3
    956a:	22f4      	movs	r2, #244	; 0xf4
    956c:	701a      	strb	r2, [r3, #0]
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
		goto ERR1;
    956e:	e02e      	b.n	95ce <hif_receive+0x14a>
	}
	
	/* Receive the payload */
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
    9570:	1dbb      	adds	r3, r7, #6
    9572:	881a      	ldrh	r2, [r3, #0]
    9574:	231f      	movs	r3, #31
    9576:	18fc      	adds	r4, r7, r3
    9578:	68b9      	ldr	r1, [r7, #8]
    957a:	68fb      	ldr	r3, [r7, #12]
    957c:	0018      	movs	r0, r3
    957e:	4b1d      	ldr	r3, [pc, #116]	; (95f4 <hif_receive+0x170>)
    9580:	4798      	blx	r3
    9582:	0003      	movs	r3, r0
    9584:	7023      	strb	r3, [r4, #0]
	if(ret != M2M_SUCCESS)goto ERR1;
    9586:	231f      	movs	r3, #31
    9588:	18fb      	adds	r3, r7, r3
    958a:	781b      	ldrb	r3, [r3, #0]
    958c:	b25b      	sxtb	r3, r3
    958e:	2b00      	cmp	r3, #0
    9590:	d11c      	bne.n	95cc <hif_receive+0x148>

	/* check if this is the last packet */
	if((((address + size) - (u32Addr + u16Sz)) <= 0) || isDone)
    9592:	231c      	movs	r3, #28
    9594:	18fb      	adds	r3, r7, r3
    9596:	881a      	ldrh	r2, [r3, #0]
    9598:	69bb      	ldr	r3, [r7, #24]
    959a:	18d2      	adds	r2, r2, r3
    959c:	1dbb      	adds	r3, r7, #6
    959e:	8819      	ldrh	r1, [r3, #0]
    95a0:	68fb      	ldr	r3, [r7, #12]
    95a2:	18cb      	adds	r3, r1, r3
    95a4:	429a      	cmp	r2, r3
    95a6:	d003      	beq.n	95b0 <hif_receive+0x12c>
    95a8:	1d7b      	adds	r3, r7, #5
    95aa:	781b      	ldrb	r3, [r3, #0]
    95ac:	2b00      	cmp	r3, #0
    95ae:	d00e      	beq.n	95ce <hif_receive+0x14a>
	{
		gu8HifSizeDone = 1;
    95b0:	4b0b      	ldr	r3, [pc, #44]	; (95e0 <hif_receive+0x15c>)
    95b2:	2201      	movs	r2, #1
    95b4:	701a      	strb	r2, [r3, #0]

		/* set RX done */
		ret = hif_set_rx_done();
    95b6:	231f      	movs	r3, #31
    95b8:	18fc      	adds	r4, r7, r3
    95ba:	4b0a      	ldr	r3, [pc, #40]	; (95e4 <hif_receive+0x160>)
    95bc:	4798      	blx	r3
    95be:	0003      	movs	r3, r0
    95c0:	7023      	strb	r3, [r4, #0]
    95c2:	e004      	b.n	95ce <hif_receive+0x14a>
		}
		goto ERR1;
	}

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
	if(ret != M2M_SUCCESS)goto ERR1;
    95c4:	46c0      	nop			; (mov r8, r8)
    95c6:	e002      	b.n	95ce <hif_receive+0x14a>


	size = (uint16)((reg >> 2) & 0xfff);
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1,&address);
	if(ret != M2M_SUCCESS)goto ERR1;
    95c8:	46c0      	nop			; (mov r8, r8)
    95ca:	e000      	b.n	95ce <hif_receive+0x14a>
		goto ERR1;
	}
	
	/* Receive the payload */
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
	if(ret != M2M_SUCCESS)goto ERR1;
    95cc:	46c0      	nop			; (mov r8, r8)
	}



ERR1:
	return ret;
    95ce:	231f      	movs	r3, #31
    95d0:	18fb      	adds	r3, r7, r3
    95d2:	781b      	ldrb	r3, [r3, #0]
    95d4:	b25b      	sxtb	r3, r3
}
    95d6:	0018      	movs	r0, r3
    95d8:	46bd      	mov	sp, r7
    95da:	b009      	add	sp, #36	; 0x24
    95dc:	bd90      	pop	{r4, r7, pc}
    95de:	46c0      	nop			; (mov r8, r8)
    95e0:	20000502 	.word	0x20000502
    95e4:	00008c3d 	.word	0x00008c3d
    95e8:	00001070 	.word	0x00001070
    95ec:	0000a251 	.word	0x0000a251
    95f0:	00001084 	.word	0x00001084
    95f4:	0000a2c5 	.word	0x0000a2c5

000095f8 <hif_register_cb>:
*				function to be set
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
    95f8:	b580      	push	{r7, lr}
    95fa:	b084      	sub	sp, #16
    95fc:	af00      	add	r7, sp, #0
    95fe:	0002      	movs	r2, r0
    9600:	6039      	str	r1, [r7, #0]
    9602:	1dfb      	adds	r3, r7, #7
    9604:	701a      	strb	r2, [r3, #0]
	sint8 ret = M2M_SUCCESS;
    9606:	230f      	movs	r3, #15
    9608:	18fb      	adds	r3, r7, r3
    960a:	2200      	movs	r2, #0
    960c:	701a      	strb	r2, [r3, #0]
	switch(u8Grp)
    960e:	1dfb      	adds	r3, r7, #7
    9610:	781b      	ldrb	r3, [r3, #0]
    9612:	2b07      	cmp	r3, #7
    9614:	d81c      	bhi.n	9650 <hif_register_cb+0x58>
    9616:	009a      	lsls	r2, r3, #2
    9618:	4b14      	ldr	r3, [pc, #80]	; (966c <hif_register_cb+0x74>)
    961a:	18d3      	adds	r3, r2, r3
    961c:	681b      	ldr	r3, [r3, #0]
    961e:	469f      	mov	pc, r3
	{
		case M2M_REQ_GROUP_IP:
			pfIpCb = fn;
    9620:	4b13      	ldr	r3, [pc, #76]	; (9670 <hif_register_cb+0x78>)
    9622:	683a      	ldr	r2, [r7, #0]
    9624:	601a      	str	r2, [r3, #0]
			break;
    9626:	e018      	b.n	965a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_WIFI:
			pfWifiCb = fn;
    9628:	4b12      	ldr	r3, [pc, #72]	; (9674 <hif_register_cb+0x7c>)
    962a:	683a      	ldr	r2, [r7, #0]
    962c:	601a      	str	r2, [r3, #0]
			break;
    962e:	e014      	b.n	965a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_OTA:
			pfOtaCb = fn;
    9630:	4b11      	ldr	r3, [pc, #68]	; (9678 <hif_register_cb+0x80>)
    9632:	683a      	ldr	r2, [r7, #0]
    9634:	601a      	str	r2, [r3, #0]
			break;
    9636:	e010      	b.n	965a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_HIF:
			pfHifCb = fn;
    9638:	4b10      	ldr	r3, [pc, #64]	; (967c <hif_register_cb+0x84>)
    963a:	683a      	ldr	r2, [r7, #0]
    963c:	601a      	str	r2, [r3, #0]
			break;
    963e:	e00c      	b.n	965a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_CRYPTO:
			pfCryptoCb = fn;
    9640:	4b0f      	ldr	r3, [pc, #60]	; (9680 <hif_register_cb+0x88>)
    9642:	683a      	ldr	r2, [r7, #0]
    9644:	601a      	str	r2, [r3, #0]
			break;
    9646:	e008      	b.n	965a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_SIGMA:
			pfSigmaCb = fn;
    9648:	4b0e      	ldr	r3, [pc, #56]	; (9684 <hif_register_cb+0x8c>)
    964a:	683a      	ldr	r2, [r7, #0]
    964c:	601a      	str	r2, [r3, #0]
			break;
    964e:	e004      	b.n	965a <hif_register_cb+0x62>
		default:
			M2M_ERR("GRp ? %d\n",u8Grp);
			ret = M2M_ERR_FAIL;
    9650:	230f      	movs	r3, #15
    9652:	18fb      	adds	r3, r7, r3
    9654:	22f4      	movs	r2, #244	; 0xf4
    9656:	701a      	strb	r2, [r3, #0]
			break;
    9658:	46c0      	nop			; (mov r8, r8)
	}
	return ret;
    965a:	230f      	movs	r3, #15
    965c:	18fb      	adds	r3, r7, r3
    965e:	781b      	ldrb	r3, [r3, #0]
    9660:	b25b      	sxtb	r3, r3
}
    9662:	0018      	movs	r0, r3
    9664:	46bd      	mov	sp, r7
    9666:	b004      	add	sp, #16
    9668:	bd80      	pop	{r7, pc}
    966a:	46c0      	nop			; (mov r8, r8)
    966c:	00020c6c 	.word	0x00020c6c
    9670:	20000508 	.word	0x20000508
    9674:	20000504 	.word	0x20000504
    9678:	2000050c 	.word	0x2000050c
    967c:	20000514 	.word	0x20000514
    9680:	20000518 	.word	0x20000518
    9684:	20000510 	.word	0x20000510

00009688 <m2m_wifi_cb>:
*	@author
*	@date
*	@version	1.0
*/
static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{
    9688:	b590      	push	{r4, r7, lr}
    968a:	b0ab      	sub	sp, #172	; 0xac
    968c:	af00      	add	r7, sp, #0
    968e:	603a      	str	r2, [r7, #0]
    9690:	1dfb      	adds	r3, r7, #7
    9692:	1c02      	adds	r2, r0, #0
    9694:	701a      	strb	r2, [r3, #0]
    9696:	1d3b      	adds	r3, r7, #4
    9698:	1c0a      	adds	r2, r1, #0
    969a:	801a      	strh	r2, [r3, #0]
	uint8 rx_buf[8];
	if (u8OpCode == M2M_WIFI_RESP_CON_STATE_CHANGED)
    969c:	1dfb      	adds	r3, r7, #7
    969e:	781b      	ldrb	r3, [r3, #0]
    96a0:	2b2c      	cmp	r3, #44	; 0x2c
    96a2:	d116      	bne.n	96d2 <m2m_wifi_cb+0x4a>
	{
		tstrM2mWifiStateChanged strState;
		if (hif_receive(u32Addr, (uint8*) &strState,sizeof(tstrM2mWifiStateChanged), 0) == M2M_SUCCESS)
    96a4:	239c      	movs	r3, #156	; 0x9c
    96a6:	18f9      	adds	r1, r7, r3
    96a8:	6838      	ldr	r0, [r7, #0]
    96aa:	2300      	movs	r3, #0
    96ac:	2204      	movs	r2, #4
    96ae:	4cb9      	ldr	r4, [pc, #740]	; (9994 <m2m_wifi_cb+0x30c>)
    96b0:	47a0      	blx	r4
    96b2:	1e03      	subs	r3, r0, #0
    96b4:	d000      	beq.n	96b8 <m2m_wifi_cb+0x30>
    96b6:	e168      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
    96b8:	4bb7      	ldr	r3, [pc, #732]	; (9998 <m2m_wifi_cb+0x310>)
    96ba:	681b      	ldr	r3, [r3, #0]
    96bc:	2b00      	cmp	r3, #0
    96be:	d100      	bne.n	96c2 <m2m_wifi_cb+0x3a>
    96c0:	e163      	b.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_CON_STATE_CHANGED, &strState);
    96c2:	4bb5      	ldr	r3, [pc, #724]	; (9998 <m2m_wifi_cb+0x310>)
    96c4:	681b      	ldr	r3, [r3, #0]
    96c6:	229c      	movs	r2, #156	; 0x9c
    96c8:	18ba      	adds	r2, r7, r2
    96ca:	0011      	movs	r1, r2
    96cc:	202c      	movs	r0, #44	; 0x2c
    96ce:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    96d0:	e15b      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_CON_STATE_CHANGED, &strState);
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_GET_SYS_TIME)
    96d2:	1dfb      	adds	r3, r7, #7
    96d4:	781b      	ldrb	r3, [r3, #0]
    96d6:	2b1b      	cmp	r3, #27
    96d8:	d116      	bne.n	9708 <m2m_wifi_cb+0x80>
	{
		tstrSystemTime strSysTime;
		if (hif_receive(u32Addr, (uint8*) &strSysTime,sizeof(tstrSystemTime), 0) == M2M_SUCCESS)
    96da:	2394      	movs	r3, #148	; 0x94
    96dc:	18f9      	adds	r1, r7, r3
    96de:	6838      	ldr	r0, [r7, #0]
    96e0:	2300      	movs	r3, #0
    96e2:	2208      	movs	r2, #8
    96e4:	4cab      	ldr	r4, [pc, #684]	; (9994 <m2m_wifi_cb+0x30c>)
    96e6:	47a0      	blx	r4
    96e8:	1e03      	subs	r3, r0, #0
    96ea:	d000      	beq.n	96ee <m2m_wifi_cb+0x66>
    96ec:	e14d      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
    96ee:	4baa      	ldr	r3, [pc, #680]	; (9998 <m2m_wifi_cb+0x310>)
    96f0:	681b      	ldr	r3, [r3, #0]
    96f2:	2b00      	cmp	r3, #0
    96f4:	d100      	bne.n	96f8 <m2m_wifi_cb+0x70>
    96f6:	e148      	b.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_GET_SYS_TIME, &strSysTime);
    96f8:	4ba7      	ldr	r3, [pc, #668]	; (9998 <m2m_wifi_cb+0x310>)
    96fa:	681b      	ldr	r3, [r3, #0]
    96fc:	2294      	movs	r2, #148	; 0x94
    96fe:	18ba      	adds	r2, r7, r2
    9700:	0011      	movs	r1, r2
    9702:	201b      	movs	r0, #27
    9704:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    9706:	e140      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_GET_SYS_TIME, &strSysTime);
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_CONN_INFO)
    9708:	1dfb      	adds	r3, r7, #7
    970a:	781b      	ldrb	r3, [r3, #0]
    970c:	2b06      	cmp	r3, #6
    970e:	d116      	bne.n	973e <m2m_wifi_cb+0xb6>
	{
		tstrM2MConnInfo		strConnInfo;
		if(hif_receive(u32Addr, (uint8*)&strConnInfo, sizeof(tstrM2MConnInfo), 1) == M2M_SUCCESS)
    9710:	230c      	movs	r3, #12
    9712:	18f9      	adds	r1, r7, r3
    9714:	6838      	ldr	r0, [r7, #0]
    9716:	2301      	movs	r3, #1
    9718:	2230      	movs	r2, #48	; 0x30
    971a:	4c9e      	ldr	r4, [pc, #632]	; (9994 <m2m_wifi_cb+0x30c>)
    971c:	47a0      	blx	r4
    971e:	1e03      	subs	r3, r0, #0
    9720:	d000      	beq.n	9724 <m2m_wifi_cb+0x9c>
    9722:	e132      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if(gpfAppWifiCb)
    9724:	4b9c      	ldr	r3, [pc, #624]	; (9998 <m2m_wifi_cb+0x310>)
    9726:	681b      	ldr	r3, [r3, #0]
    9728:	2b00      	cmp	r3, #0
    972a:	d100      	bne.n	972e <m2m_wifi_cb+0xa6>
    972c:	e12d      	b.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_CONN_INFO, &strConnInfo);
    972e:	4b9a      	ldr	r3, [pc, #616]	; (9998 <m2m_wifi_cb+0x310>)
    9730:	681b      	ldr	r3, [r3, #0]
    9732:	220c      	movs	r2, #12
    9734:	18ba      	adds	r2, r7, r2
    9736:	0011      	movs	r1, r2
    9738:	2006      	movs	r0, #6
    973a:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    973c:	e125      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if(gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_CONN_INFO, &strConnInfo);
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_MEMORY_RECOVER)
    973e:	1dfb      	adds	r3, r7, #7
    9740:	781b      	ldrb	r3, [r3, #0]
    9742:	2b0e      	cmp	r3, #14
    9744:	d100      	bne.n	9748 <m2m_wifi_cb+0xc0>
    9746:	e120      	b.n	998a <m2m_wifi_cb+0x302>
			if (app_wifi_recover_cb)
				app_wifi_recover_cb(strState.u8CurrState);
		}
#endif
	}
	else if (u8OpCode == M2M_WIFI_REQ_DHCP_CONF)
    9748:	1dfb      	adds	r3, r7, #7
    974a:	781b      	ldrb	r3, [r3, #0]
    974c:	2b32      	cmp	r3, #50	; 0x32
    974e:	d116      	bne.n	977e <m2m_wifi_cb+0xf6>
	{
		tstrM2MIPConfig strIpConfig;
		if (hif_receive(u32Addr, (uint8 *)&strIpConfig, sizeof(tstrM2MIPConfig), 0) == M2M_SUCCESS)
    9750:	2384      	movs	r3, #132	; 0x84
    9752:	18f9      	adds	r1, r7, r3
    9754:	6838      	ldr	r0, [r7, #0]
    9756:	2300      	movs	r3, #0
    9758:	2210      	movs	r2, #16
    975a:	4c8e      	ldr	r4, [pc, #568]	; (9994 <m2m_wifi_cb+0x30c>)
    975c:	47a0      	blx	r4
    975e:	1e03      	subs	r3, r0, #0
    9760:	d000      	beq.n	9764 <m2m_wifi_cb+0xdc>
    9762:	e112      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
    9764:	4b8c      	ldr	r3, [pc, #560]	; (9998 <m2m_wifi_cb+0x310>)
    9766:	681b      	ldr	r3, [r3, #0]
    9768:	2b00      	cmp	r3, #0
    976a:	d100      	bne.n	976e <m2m_wifi_cb+0xe6>
    976c:	e10d      	b.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_REQ_DHCP_CONF, (uint8 *)&strIpConfig);
    976e:	4b8a      	ldr	r3, [pc, #552]	; (9998 <m2m_wifi_cb+0x310>)
    9770:	681b      	ldr	r3, [r3, #0]
    9772:	2284      	movs	r2, #132	; 0x84
    9774:	18ba      	adds	r2, r7, r2
    9776:	0011      	movs	r1, r2
    9778:	2032      	movs	r0, #50	; 0x32
    977a:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    977c:	e105      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_REQ_DHCP_CONF, (uint8 *)&strIpConfig);
		}
	}
	else if (u8OpCode == M2M_WIFI_REQ_WPS)
    977e:	1dfb      	adds	r3, r7, #7
    9780:	781b      	ldrb	r3, [r3, #0]
    9782:	2b2f      	cmp	r3, #47	; 0x2f
    9784:	d11d      	bne.n	97c2 <m2m_wifi_cb+0x13a>
	{
		tstrM2MWPSInfo strWps;
		m2m_memset((uint8*)&strWps,0,sizeof(tstrM2MWPSInfo));
    9786:	230c      	movs	r3, #12
    9788:	18fb      	adds	r3, r7, r3
    978a:	2264      	movs	r2, #100	; 0x64
    978c:	2100      	movs	r1, #0
    978e:	0018      	movs	r0, r3
    9790:	4b82      	ldr	r3, [pc, #520]	; (999c <m2m_wifi_cb+0x314>)
    9792:	4798      	blx	r3
		if(hif_receive(u32Addr, (uint8*)&strWps, sizeof(tstrM2MWPSInfo), 0) == M2M_SUCCESS)
    9794:	230c      	movs	r3, #12
    9796:	18f9      	adds	r1, r7, r3
    9798:	6838      	ldr	r0, [r7, #0]
    979a:	2300      	movs	r3, #0
    979c:	2264      	movs	r2, #100	; 0x64
    979e:	4c7d      	ldr	r4, [pc, #500]	; (9994 <m2m_wifi_cb+0x30c>)
    97a0:	47a0      	blx	r4
    97a2:	1e03      	subs	r3, r0, #0
    97a4:	d000      	beq.n	97a8 <m2m_wifi_cb+0x120>
    97a6:	e0f0      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
    97a8:	4b7b      	ldr	r3, [pc, #492]	; (9998 <m2m_wifi_cb+0x310>)
    97aa:	681b      	ldr	r3, [r3, #0]
    97ac:	2b00      	cmp	r3, #0
    97ae:	d100      	bne.n	97b2 <m2m_wifi_cb+0x12a>
    97b0:	e0eb      	b.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_REQ_WPS, &strWps);
    97b2:	4b79      	ldr	r3, [pc, #484]	; (9998 <m2m_wifi_cb+0x310>)
    97b4:	681b      	ldr	r3, [r3, #0]
    97b6:	220c      	movs	r2, #12
    97b8:	18ba      	adds	r2, r7, r2
    97ba:	0011      	movs	r1, r2
    97bc:	202f      	movs	r0, #47	; 0x2f
    97be:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    97c0:	e0e3      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_REQ_WPS, &strWps);
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_IP_CONFLICT)
    97c2:	1dfb      	adds	r3, r7, #7
    97c4:	781b      	ldrb	r3, [r3, #0]
    97c6:	2b34      	cmp	r3, #52	; 0x34
    97c8:	d114      	bne.n	97f4 <m2m_wifi_cb+0x16c>
	{
		uint32  u32ConflictedIP;
		if(hif_receive(u32Addr, (uint8 *)&u32ConflictedIP, sizeof(u32ConflictedIP), 0) == M2M_SUCCESS)
    97ca:	2380      	movs	r3, #128	; 0x80
    97cc:	18f9      	adds	r1, r7, r3
    97ce:	6838      	ldr	r0, [r7, #0]
    97d0:	2300      	movs	r3, #0
    97d2:	2204      	movs	r2, #4
    97d4:	4c6f      	ldr	r4, [pc, #444]	; (9994 <m2m_wifi_cb+0x30c>)
    97d6:	47a0      	blx	r4
    97d8:	1e03      	subs	r3, r0, #0
    97da:	d000      	beq.n	97de <m2m_wifi_cb+0x156>
    97dc:	e0d5      	b.n	998a <m2m_wifi_cb+0x302>
		{
			M2M_INFO("Conflicted IP \" %u.%u.%u.%u \" \n", 
				BYTE_0(u32ConflictedIP),BYTE_1(u32ConflictedIP),BYTE_2(u32ConflictedIP),BYTE_3(u32ConflictedIP));
			if (gpfAppWifiCb)
    97de:	4b6e      	ldr	r3, [pc, #440]	; (9998 <m2m_wifi_cb+0x310>)
    97e0:	681b      	ldr	r3, [r3, #0]
    97e2:	2b00      	cmp	r3, #0
    97e4:	d100      	bne.n	97e8 <m2m_wifi_cb+0x160>
    97e6:	e0d0      	b.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_IP_CONFLICT, NULL);
    97e8:	4b6b      	ldr	r3, [pc, #428]	; (9998 <m2m_wifi_cb+0x310>)
    97ea:	681b      	ldr	r3, [r3, #0]
    97ec:	2100      	movs	r1, #0
    97ee:	2034      	movs	r0, #52	; 0x34
    97f0:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    97f2:	e0ca      	b.n	998a <m2m_wifi_cb+0x302>
			if (gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_IP_CONFLICT, NULL);

		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_DONE)
    97f4:	1dfb      	adds	r3, r7, #7
    97f6:	781b      	ldrb	r3, [r3, #0]
    97f8:	2b11      	cmp	r3, #17
    97fa:	d11e      	bne.n	983a <m2m_wifi_cb+0x1b2>
	{
		tstrM2mScanDone strState;
		gu8scanInProgress = 0;
    97fc:	4b68      	ldr	r3, [pc, #416]	; (99a0 <m2m_wifi_cb+0x318>)
    97fe:	2200      	movs	r2, #0
    9800:	701a      	strb	r2, [r3, #0]
		if(hif_receive(u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
    9802:	237c      	movs	r3, #124	; 0x7c
    9804:	18f9      	adds	r1, r7, r3
    9806:	6838      	ldr	r0, [r7, #0]
    9808:	2300      	movs	r3, #0
    980a:	2204      	movs	r2, #4
    980c:	4c61      	ldr	r4, [pc, #388]	; (9994 <m2m_wifi_cb+0x30c>)
    980e:	47a0      	blx	r4
    9810:	1e03      	subs	r3, r0, #0
    9812:	d000      	beq.n	9816 <m2m_wifi_cb+0x18e>
    9814:	e0b9      	b.n	998a <m2m_wifi_cb+0x302>
		{
			gu8ChNum = strState.u8NumofCh;
    9816:	237c      	movs	r3, #124	; 0x7c
    9818:	18fb      	adds	r3, r7, r3
    981a:	781a      	ldrb	r2, [r3, #0]
    981c:	4b61      	ldr	r3, [pc, #388]	; (99a4 <m2m_wifi_cb+0x31c>)
    981e:	701a      	strb	r2, [r3, #0]
			if (gpfAppWifiCb)
    9820:	4b5d      	ldr	r3, [pc, #372]	; (9998 <m2m_wifi_cb+0x310>)
    9822:	681b      	ldr	r3, [r3, #0]
    9824:	2b00      	cmp	r3, #0
    9826:	d100      	bne.n	982a <m2m_wifi_cb+0x1a2>
    9828:	e0af      	b.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_DONE, &strState);
    982a:	4b5b      	ldr	r3, [pc, #364]	; (9998 <m2m_wifi_cb+0x310>)
    982c:	681b      	ldr	r3, [r3, #0]
    982e:	227c      	movs	r2, #124	; 0x7c
    9830:	18ba      	adds	r2, r7, r2
    9832:	0011      	movs	r1, r2
    9834:	2011      	movs	r0, #17
    9836:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    9838:	e0a7      	b.n	998a <m2m_wifi_cb+0x302>
			gu8ChNum = strState.u8NumofCh;
			if (gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_DONE, &strState);
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_RESULT)
    983a:	1dfb      	adds	r3, r7, #7
    983c:	781b      	ldrb	r3, [r3, #0]
    983e:	2b13      	cmp	r3, #19
    9840:	d116      	bne.n	9870 <m2m_wifi_cb+0x1e8>
	{
		tstrM2mWifiscanResult strScanResult;
		if(hif_receive(u32Addr, (uint8*)&strScanResult, sizeof(tstrM2mWifiscanResult), 0) == M2M_SUCCESS)
    9842:	230c      	movs	r3, #12
    9844:	18f9      	adds	r1, r7, r3
    9846:	6838      	ldr	r0, [r7, #0]
    9848:	2300      	movs	r3, #0
    984a:	222c      	movs	r2, #44	; 0x2c
    984c:	4c51      	ldr	r4, [pc, #324]	; (9994 <m2m_wifi_cb+0x30c>)
    984e:	47a0      	blx	r4
    9850:	1e03      	subs	r3, r0, #0
    9852:	d000      	beq.n	9856 <m2m_wifi_cb+0x1ce>
    9854:	e099      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
    9856:	4b50      	ldr	r3, [pc, #320]	; (9998 <m2m_wifi_cb+0x310>)
    9858:	681b      	ldr	r3, [r3, #0]
    985a:	2b00      	cmp	r3, #0
    985c:	d100      	bne.n	9860 <m2m_wifi_cb+0x1d8>
    985e:	e094      	b.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
    9860:	4b4d      	ldr	r3, [pc, #308]	; (9998 <m2m_wifi_cb+0x310>)
    9862:	681b      	ldr	r3, [r3, #0]
    9864:	220c      	movs	r2, #12
    9866:	18ba      	adds	r2, r7, r2
    9868:	0011      	movs	r1, r2
    986a:	2013      	movs	r0, #19
    986c:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    986e:	e08c      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CURRENT_RSSI)
    9870:	1dfb      	adds	r3, r7, #7
    9872:	781b      	ldrb	r3, [r3, #0]
    9874:	2b04      	cmp	r3, #4
    9876:	d116      	bne.n	98a6 <m2m_wifi_cb+0x21e>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
    9878:	23a0      	movs	r3, #160	; 0xa0
    987a:	18f9      	adds	r1, r7, r3
    987c:	6838      	ldr	r0, [r7, #0]
    987e:	2300      	movs	r3, #0
    9880:	2204      	movs	r2, #4
    9882:	4c44      	ldr	r4, [pc, #272]	; (9994 <m2m_wifi_cb+0x30c>)
    9884:	47a0      	blx	r4
    9886:	1e03      	subs	r3, r0, #0
    9888:	d000      	beq.n	988c <m2m_wifi_cb+0x204>
    988a:	e07e      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
    988c:	4b42      	ldr	r3, [pc, #264]	; (9998 <m2m_wifi_cb+0x310>)
    988e:	681b      	ldr	r3, [r3, #0]
    9890:	2b00      	cmp	r3, #0
    9892:	d100      	bne.n	9896 <m2m_wifi_cb+0x20e>
    9894:	e079      	b.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
    9896:	4b40      	ldr	r3, [pc, #256]	; (9998 <m2m_wifi_cb+0x310>)
    9898:	681b      	ldr	r3, [r3, #0]
    989a:	22a0      	movs	r2, #160	; 0xa0
    989c:	18ba      	adds	r2, r7, r2
    989e:	0011      	movs	r1, r2
    98a0:	2004      	movs	r0, #4
    98a2:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    98a4:	e071      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CLIENT_INFO)
    98a6:	1dfb      	adds	r3, r7, #7
    98a8:	781b      	ldrb	r3, [r3, #0]
    98aa:	2b65      	cmp	r3, #101	; 0x65
    98ac:	d115      	bne.n	98da <m2m_wifi_cb+0x252>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
    98ae:	23a0      	movs	r3, #160	; 0xa0
    98b0:	18f9      	adds	r1, r7, r3
    98b2:	6838      	ldr	r0, [r7, #0]
    98b4:	2300      	movs	r3, #0
    98b6:	2204      	movs	r2, #4
    98b8:	4c36      	ldr	r4, [pc, #216]	; (9994 <m2m_wifi_cb+0x30c>)
    98ba:	47a0      	blx	r4
    98bc:	1e03      	subs	r3, r0, #0
    98be:	d000      	beq.n	98c2 <m2m_wifi_cb+0x23a>
    98c0:	e063      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
    98c2:	4b35      	ldr	r3, [pc, #212]	; (9998 <m2m_wifi_cb+0x310>)
    98c4:	681b      	ldr	r3, [r3, #0]
    98c6:	2b00      	cmp	r3, #0
    98c8:	d05f      	beq.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_CLIENT_INFO, rx_buf);
    98ca:	4b33      	ldr	r3, [pc, #204]	; (9998 <m2m_wifi_cb+0x310>)
    98cc:	681b      	ldr	r3, [r3, #0]
    98ce:	22a0      	movs	r2, #160	; 0xa0
    98d0:	18ba      	adds	r2, r7, r2
    98d2:	0011      	movs	r1, r2
    98d4:	2065      	movs	r0, #101	; 0x65
    98d6:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    98d8:	e057      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if (gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_CLIENT_INFO, rx_buf);
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_PROVISION_INFO)
    98da:	1dfb      	adds	r3, r7, #7
    98dc:	781b      	ldrb	r3, [r3, #0]
    98de:	2b09      	cmp	r3, #9
    98e0:	d114      	bne.n	990c <m2m_wifi_cb+0x284>
	{
		tstrM2MProvisionInfo	strProvInfo;
		if(hif_receive(u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
    98e2:	230c      	movs	r3, #12
    98e4:	18f9      	adds	r1, r7, r3
    98e6:	6838      	ldr	r0, [r7, #0]
    98e8:	2301      	movs	r3, #1
    98ea:	2264      	movs	r2, #100	; 0x64
    98ec:	4c29      	ldr	r4, [pc, #164]	; (9994 <m2m_wifi_cb+0x30c>)
    98ee:	47a0      	blx	r4
    98f0:	1e03      	subs	r3, r0, #0
    98f2:	d14a      	bne.n	998a <m2m_wifi_cb+0x302>
		{
			if(gpfAppWifiCb)
    98f4:	4b28      	ldr	r3, [pc, #160]	; (9998 <m2m_wifi_cb+0x310>)
    98f6:	681b      	ldr	r3, [r3, #0]
    98f8:	2b00      	cmp	r3, #0
    98fa:	d046      	beq.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_PROVISION_INFO, &strProvInfo);
    98fc:	4b26      	ldr	r3, [pc, #152]	; (9998 <m2m_wifi_cb+0x310>)
    98fe:	681b      	ldr	r3, [r3, #0]
    9900:	220c      	movs	r2, #12
    9902:	18ba      	adds	r2, r7, r2
    9904:	0011      	movs	r1, r2
    9906:	2009      	movs	r0, #9
    9908:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    990a:	e03e      	b.n	998a <m2m_wifi_cb+0x302>
		{
			if(gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_PROVISION_INFO, &strProvInfo);
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_DEFAULT_CONNECT)
    990c:	1dfb      	adds	r3, r7, #7
    990e:	781b      	ldrb	r3, [r3, #0]
    9910:	2b2a      	cmp	r3, #42	; 0x2a
    9912:	d114      	bne.n	993e <m2m_wifi_cb+0x2b6>
	{
		tstrM2MDefaultConnResp	strResp;
		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
    9914:	2378      	movs	r3, #120	; 0x78
    9916:	18f9      	adds	r1, r7, r3
    9918:	6838      	ldr	r0, [r7, #0]
    991a:	2301      	movs	r3, #1
    991c:	2204      	movs	r2, #4
    991e:	4c1d      	ldr	r4, [pc, #116]	; (9994 <m2m_wifi_cb+0x30c>)
    9920:	47a0      	blx	r4
    9922:	1e03      	subs	r3, r0, #0
    9924:	d131      	bne.n	998a <m2m_wifi_cb+0x302>
		{
			if(gpfAppWifiCb)
    9926:	4b1c      	ldr	r3, [pc, #112]	; (9998 <m2m_wifi_cb+0x310>)
    9928:	681b      	ldr	r3, [r3, #0]
    992a:	2b00      	cmp	r3, #0
    992c:	d02d      	beq.n	998a <m2m_wifi_cb+0x302>
				gpfAppWifiCb(M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
    992e:	4b1a      	ldr	r3, [pc, #104]	; (9998 <m2m_wifi_cb+0x310>)
    9930:	681b      	ldr	r3, [r3, #0]
    9932:	2278      	movs	r2, #120	; 0x78
    9934:	18ba      	adds	r2, r7, r2
    9936:	0011      	movs	r1, r2
    9938:	202a      	movs	r0, #42	; 0x2a
    993a:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    993c:	e025      	b.n	998a <m2m_wifi_cb+0x302>
			if(gpfAppWifiCb)
				gpfAppWifiCb(M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
		}
	}
	
	else if(u8OpCode == M2M_WIFI_RESP_GET_PRNG)
    993e:	1dfb      	adds	r3, r7, #7
    9940:	781b      	ldrb	r3, [r3, #0]
    9942:	2b20      	cmp	r3, #32
    9944:	d121      	bne.n	998a <m2m_wifi_cb+0x302>
	{
		tstrPrng strPrng;
		if(hif_receive(u32Addr, (uint8*)&strPrng,sizeof(tstrPrng), 0) == M2M_SUCCESS)
    9946:	2370      	movs	r3, #112	; 0x70
    9948:	18f9      	adds	r1, r7, r3
    994a:	6838      	ldr	r0, [r7, #0]
    994c:	2300      	movs	r3, #0
    994e:	2208      	movs	r2, #8
    9950:	4c10      	ldr	r4, [pc, #64]	; (9994 <m2m_wifi_cb+0x30c>)
    9952:	47a0      	blx	r4
    9954:	1e03      	subs	r3, r0, #0
    9956:	d118      	bne.n	998a <m2m_wifi_cb+0x302>
		{
			if(hif_receive(u32Addr + sizeof(tstrPrng),strPrng.pu8RngBuff,strPrng.u16PrngSize, 1) == M2M_SUCCESS)
    9958:	683b      	ldr	r3, [r7, #0]
    995a:	3308      	adds	r3, #8
    995c:	0018      	movs	r0, r3
    995e:	2370      	movs	r3, #112	; 0x70
    9960:	18fb      	adds	r3, r7, r3
    9962:	6819      	ldr	r1, [r3, #0]
    9964:	2370      	movs	r3, #112	; 0x70
    9966:	18fb      	adds	r3, r7, r3
    9968:	889a      	ldrh	r2, [r3, #4]
    996a:	2301      	movs	r3, #1
    996c:	4c09      	ldr	r4, [pc, #36]	; (9994 <m2m_wifi_cb+0x30c>)
    996e:	47a0      	blx	r4
    9970:	1e03      	subs	r3, r0, #0
    9972:	d10a      	bne.n	998a <m2m_wifi_cb+0x302>
			{
				if(gpfAppWifiCb)
    9974:	4b08      	ldr	r3, [pc, #32]	; (9998 <m2m_wifi_cb+0x310>)
    9976:	681b      	ldr	r3, [r3, #0]
    9978:	2b00      	cmp	r3, #0
    997a:	d006      	beq.n	998a <m2m_wifi_cb+0x302>
					gpfAppWifiCb(M2M_WIFI_RESP_GET_PRNG,&strPrng);
    997c:	4b06      	ldr	r3, [pc, #24]	; (9998 <m2m_wifi_cb+0x310>)
    997e:	681b      	ldr	r3, [r3, #0]
    9980:	2270      	movs	r2, #112	; 0x70
    9982:	18ba      	adds	r2, r7, r2
    9984:	0011      	movs	r1, r2
    9986:	2020      	movs	r0, #32
    9988:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    998a:	46c0      	nop			; (mov r8, r8)
    998c:	46bd      	mov	sp, r7
    998e:	b02b      	add	sp, #172	; 0xac
    9990:	bd90      	pop	{r4, r7, pc}
    9992:	46c0      	nop			; (mov r8, r8)
    9994:	00009485 	.word	0x00009485
    9998:	20000524 	.word	0x20000524
    999c:	00008bd9 	.word	0x00008bd9
    99a0:	20000521 	.word	0x20000521
    99a4:	20000520 	.word	0x20000520

000099a8 <m2m_wifi_init>:
	}	
	return s8Ret;
}

sint8 m2m_wifi_init(tstrWifiInitParam * param)
{
    99a8:	b590      	push	{r4, r7, lr}
    99aa:	b08d      	sub	sp, #52	; 0x34
    99ac:	af00      	add	r7, sp, #0
    99ae:	6078      	str	r0, [r7, #4]
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
    99b0:	232f      	movs	r3, #47	; 0x2f
    99b2:	18fb      	adds	r3, r7, r3
    99b4:	2200      	movs	r2, #0
    99b6:	701a      	strb	r2, [r3, #0]
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
    99b8:	230b      	movs	r3, #11
    99ba:	18fb      	adds	r3, r7, r3
    99bc:	2201      	movs	r2, #1
    99be:	701a      	strb	r2, [r3, #0]
	
	if(param == NULL) {
    99c0:	687b      	ldr	r3, [r7, #4]
    99c2:	2b00      	cmp	r3, #0
    99c4:	d104      	bne.n	99d0 <m2m_wifi_init+0x28>
		ret = M2M_ERR_FAIL;
    99c6:	232f      	movs	r3, #47	; 0x2f
    99c8:	18fb      	adds	r3, r7, r3
    99ca:	22f4      	movs	r2, #244	; 0xf4
    99cc:	701a      	strb	r2, [r3, #0]
		goto _EXIT0;
    99ce:	e037      	b.n	9a40 <m2m_wifi_init+0x98>
	}
	
	gpfAppWifiCb = param->pfAppWifiCb;
    99d0:	687b      	ldr	r3, [r7, #4]
    99d2:	681a      	ldr	r2, [r3, #0]
    99d4:	4b1e      	ldr	r3, [pc, #120]	; (9a50 <m2m_wifi_init+0xa8>)
    99d6:	601a      	str	r2, [r3, #0]
#endif /* ETH_MODE */

#ifdef CONF_MGMT
	gpfAppMonCb  = param->pfAppMonCb;
#endif
	gu8scanInProgress = 0;
    99d8:	4b1e      	ldr	r3, [pc, #120]	; (9a54 <m2m_wifi_init+0xac>)
    99da:	2200      	movs	r2, #0
    99dc:	701a      	strb	r2, [r3, #0]
	/* Apply device specific initialization. */
	ret = nm_drv_init(&u8WifiMode);
    99de:	232f      	movs	r3, #47	; 0x2f
    99e0:	18fc      	adds	r4, r7, r3
    99e2:	230b      	movs	r3, #11
    99e4:	18fb      	adds	r3, r7, r3
    99e6:	0018      	movs	r0, r3
    99e8:	4b1b      	ldr	r3, [pc, #108]	; (9a58 <m2m_wifi_init+0xb0>)
    99ea:	4798      	blx	r3
    99ec:	0003      	movs	r3, r0
    99ee:	7023      	strb	r3, [r4, #0]
	if(ret != M2M_SUCCESS) 	goto _EXIT0;
    99f0:	232f      	movs	r3, #47	; 0x2f
    99f2:	18fb      	adds	r3, r7, r3
    99f4:	781b      	ldrb	r3, [r3, #0]
    99f6:	b25b      	sxtb	r3, r3
    99f8:	2b00      	cmp	r3, #0
    99fa:	d120      	bne.n	9a3e <m2m_wifi_init+0x96>
	/* Initialize host interface module */
	ret = hif_init(NULL);
    99fc:	232f      	movs	r3, #47	; 0x2f
    99fe:	18fc      	adds	r4, r7, r3
    9a00:	2000      	movs	r0, #0
    9a02:	4b16      	ldr	r3, [pc, #88]	; (9a5c <m2m_wifi_init+0xb4>)
    9a04:	4798      	blx	r3
    9a06:	0003      	movs	r3, r0
    9a08:	7023      	strb	r3, [r4, #0]
	if(ret != M2M_SUCCESS) 	goto _EXIT1;
    9a0a:	232f      	movs	r3, #47	; 0x2f
    9a0c:	18fb      	adds	r3, r7, r3
    9a0e:	781b      	ldrb	r3, [r3, #0]
    9a10:	b25b      	sxtb	r3, r3
    9a12:	2b00      	cmp	r3, #0
    9a14:	d10e      	bne.n	9a34 <m2m_wifi_init+0x8c>

	hif_register_cb(M2M_REQ_GROUP_WIFI,m2m_wifi_cb);
    9a16:	4b12      	ldr	r3, [pc, #72]	; (9a60 <m2m_wifi_init+0xb8>)
    9a18:	0019      	movs	r1, r3
    9a1a:	2001      	movs	r0, #1
    9a1c:	4b11      	ldr	r3, [pc, #68]	; (9a64 <m2m_wifi_init+0xbc>)
    9a1e:	4798      	blx	r3

	ret = nm_get_firmware_info(&strtmp);
    9a20:	232f      	movs	r3, #47	; 0x2f
    9a22:	18fc      	adds	r4, r7, r3
    9a24:	230c      	movs	r3, #12
    9a26:	18fb      	adds	r3, r7, r3
    9a28:	0018      	movs	r0, r3
    9a2a:	4b0f      	ldr	r3, [pc, #60]	; (9a68 <m2m_wifi_init+0xc0>)
    9a2c:	4798      	blx	r3
    9a2e:	0003      	movs	r3, r0
    9a30:	7023      	strb	r3, [r4, #0]
	if(M2M_ERR_FW_VER_MISMATCH == ret)
	{
		M2M_ERR("Mismatch Firmawre Version\n");
	}

	goto _EXIT0;
    9a32:	e005      	b.n	9a40 <m2m_wifi_init+0x98>
	/* Apply device specific initialization. */
	ret = nm_drv_init(&u8WifiMode);
	if(ret != M2M_SUCCESS) 	goto _EXIT0;
	/* Initialize host interface module */
	ret = hif_init(NULL);
	if(ret != M2M_SUCCESS) 	goto _EXIT1;
    9a34:	46c0      	nop			; (mov r8, r8)
	}

	goto _EXIT0;

_EXIT1:
	nm_drv_deinit(NULL);
    9a36:	2000      	movs	r0, #0
    9a38:	4b0c      	ldr	r3, [pc, #48]	; (9a6c <m2m_wifi_init+0xc4>)
    9a3a:	4798      	blx	r3
    9a3c:	e000      	b.n	9a40 <m2m_wifi_init+0x98>
	gpfAppMonCb  = param->pfAppMonCb;
#endif
	gu8scanInProgress = 0;
	/* Apply device specific initialization. */
	ret = nm_drv_init(&u8WifiMode);
	if(ret != M2M_SUCCESS) 	goto _EXIT0;
    9a3e:	46c0      	nop			; (mov r8, r8)
	goto _EXIT0;

_EXIT1:
	nm_drv_deinit(NULL);
_EXIT0:
	return ret;
    9a40:	232f      	movs	r3, #47	; 0x2f
    9a42:	18fb      	adds	r3, r7, r3
    9a44:	781b      	ldrb	r3, [r3, #0]
    9a46:	b25b      	sxtb	r3, r3
}
    9a48:	0018      	movs	r0, r3
    9a4a:	46bd      	mov	sp, r7
    9a4c:	b00d      	add	sp, #52	; 0x34
    9a4e:	bd90      	pop	{r4, r7, pc}
    9a50:	20000524 	.word	0x20000524
    9a54:	20000521 	.word	0x20000521
    9a58:	0000a5f1 	.word	0x0000a5f1
    9a5c:	00008e29 	.word	0x00008e29
    9a60:	00009689 	.word	0x00009689
    9a64:	000095f9 	.word	0x000095f9
    9a68:	0000a489 	.word	0x0000a489
    9a6c:	0000a705 	.word	0x0000a705

00009a70 <m2m_wifi_handle_events>:

	return M2M_SUCCESS;
}

sint8 m2m_wifi_handle_events(void * arg)
{
    9a70:	b580      	push	{r7, lr}
    9a72:	b082      	sub	sp, #8
    9a74:	af00      	add	r7, sp, #0
    9a76:	6078      	str	r0, [r7, #4]
	return hif_handle_isr();	
    9a78:	4b03      	ldr	r3, [pc, #12]	; (9a88 <m2m_wifi_handle_events+0x18>)
    9a7a:	4798      	blx	r3
    9a7c:	0003      	movs	r3, r0
}
    9a7e:	0018      	movs	r0, r3
    9a80:	46bd      	mov	sp, r7
    9a82:	b002      	add	sp, #8
    9a84:	bd80      	pop	{r7, pc}
    9a86:	46c0      	nop			; (mov r8, r8)
    9a88:	0000944d 	.word	0x0000944d

00009a8c <m2m_wifi_request_dhcp_client>:
	return hif_send(M2M_REQ_GROUP_IP, M2M_IP_REQ_STATIC_IP_CONF,
		(uint8*) pstrStaticIPConf, sizeof(tstrM2MIPConfig), NULL, 0,0);
}

sint8 m2m_wifi_request_dhcp_client(void)
{
    9a8c:	b580      	push	{r7, lr}
    9a8e:	af00      	add	r7, sp, #0
	/*legacy API should be removed */
	return 0;
    9a90:	2300      	movs	r3, #0
}
    9a92:	0018      	movs	r0, r3
    9a94:	46bd      	mov	sp, r7
    9a96:	bd80      	pop	{r7, pc}

00009a98 <m2m_wifi_p2p>:
	M2M_ERR("_PS_SERVER_ is not defined\n");
#endif
	return ret;
}
sint8 m2m_wifi_p2p(uint8 u8Channel)
{
    9a98:	b5b0      	push	{r4, r5, r7, lr}
    9a9a:	b088      	sub	sp, #32
    9a9c:	af04      	add	r7, sp, #16
    9a9e:	0002      	movs	r2, r0
    9aa0:	1dfb      	adds	r3, r7, #7
    9aa2:	701a      	strb	r2, [r3, #0]
	sint8 ret = M2M_SUCCESS;
    9aa4:	230f      	movs	r3, #15
    9aa6:	18fb      	adds	r3, r7, r3
    9aa8:	2200      	movs	r2, #0
    9aaa:	701a      	strb	r2, [r3, #0]
	if((u8Channel == M2M_WIFI_CH_1) || (u8Channel == M2M_WIFI_CH_6) || (u8Channel == M2M_WIFI_CH_11))
    9aac:	1dfb      	adds	r3, r7, #7
    9aae:	781b      	ldrb	r3, [r3, #0]
    9ab0:	2b00      	cmp	r3, #0
    9ab2:	d007      	beq.n	9ac4 <m2m_wifi_p2p+0x2c>
    9ab4:	1dfb      	adds	r3, r7, #7
    9ab6:	781b      	ldrb	r3, [r3, #0]
    9ab8:	2b05      	cmp	r3, #5
    9aba:	d003      	beq.n	9ac4 <m2m_wifi_p2p+0x2c>
    9abc:	1dfb      	adds	r3, r7, #7
    9abe:	781b      	ldrb	r3, [r3, #0]
    9ac0:	2b0a      	cmp	r3, #10
    9ac2:	d116      	bne.n	9af2 <m2m_wifi_p2p+0x5a>
	{
		tstrM2MP2PConnect strtmp;
		strtmp.u8ListenChannel = u8Channel;
    9ac4:	2308      	movs	r3, #8
    9ac6:	18fb      	adds	r3, r7, r3
    9ac8:	1dfa      	adds	r2, r7, #7
    9aca:	7812      	ldrb	r2, [r2, #0]
    9acc:	701a      	strb	r2, [r3, #0]
		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_P2P, (uint8*)&strtmp, sizeof(tstrM2MP2PConnect), NULL, 0,0);
    9ace:	230f      	movs	r3, #15
    9ad0:	18fc      	adds	r4, r7, r3
    9ad2:	2308      	movs	r3, #8
    9ad4:	18fa      	adds	r2, r7, r3
    9ad6:	2300      	movs	r3, #0
    9ad8:	9302      	str	r3, [sp, #8]
    9ada:	2300      	movs	r3, #0
    9adc:	9301      	str	r3, [sp, #4]
    9ade:	2300      	movs	r3, #0
    9ae0:	9300      	str	r3, [sp, #0]
    9ae2:	2304      	movs	r3, #4
    9ae4:	215b      	movs	r1, #91	; 0x5b
    9ae6:	2001      	movs	r0, #1
    9ae8:	4d08      	ldr	r5, [pc, #32]	; (9b0c <m2m_wifi_p2p+0x74>)
    9aea:	47a8      	blx	r5
    9aec:	0003      	movs	r3, r0
    9aee:	7023      	strb	r3, [r4, #0]
}
sint8 m2m_wifi_p2p(uint8 u8Channel)
{
	sint8 ret = M2M_SUCCESS;
	if((u8Channel == M2M_WIFI_CH_1) || (u8Channel == M2M_WIFI_CH_6) || (u8Channel == M2M_WIFI_CH_11))
	{
    9af0:	e003      	b.n	9afa <m2m_wifi_p2p+0x62>
		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_P2P, (uint8*)&strtmp, sizeof(tstrM2MP2PConnect), NULL, 0,0);
	}
	else
	{
		M2M_ERR("Listen channel should only be 1, 6 or 11\n");
		ret = M2M_ERR_FAIL;
    9af2:	230f      	movs	r3, #15
    9af4:	18fb      	adds	r3, r7, r3
    9af6:	22f4      	movs	r2, #244	; 0xf4
    9af8:	701a      	strb	r2, [r3, #0]
	}
	return ret;
    9afa:	230f      	movs	r3, #15
    9afc:	18fb      	adds	r3, r7, r3
    9afe:	781b      	ldrb	r3, [r3, #0]
    9b00:	b25b      	sxtb	r3, r3
}
    9b02:	0018      	movs	r0, r3
    9b04:	46bd      	mov	sp, r7
    9b06:	b004      	add	sp, #16
    9b08:	bdb0      	pop	{r4, r5, r7, pc}
    9b0a:	46c0      	nop			; (mov r8, r8)
    9b0c:	00008e91 	.word	0x00008e91

00009b10 <m2m_wifi_set_device_name>:
			Length of the device name.
@return		The function SHALL return M2M_SUCCESS for success and a negative value otherwise.
@warning	The Function called once after initialization. 
*/
sint8 m2m_wifi_set_device_name(uint8 *pu8DeviceName, uint8 u8DeviceNameLength)
{
    9b10:	b590      	push	{r4, r7, lr}
    9b12:	b093      	sub	sp, #76	; 0x4c
    9b14:	af04      	add	r7, sp, #16
    9b16:	6078      	str	r0, [r7, #4]
    9b18:	000a      	movs	r2, r1
    9b1a:	1cfb      	adds	r3, r7, #3
    9b1c:	701a      	strb	r2, [r3, #0]
	tstrM2MDeviceNameConfig strDeviceName;
	if(u8DeviceNameLength >= M2M_DEVICE_NAME_MAX)
    9b1e:	1cfb      	adds	r3, r7, #3
    9b20:	781b      	ldrb	r3, [r3, #0]
    9b22:	2b2f      	cmp	r3, #47	; 0x2f
    9b24:	d902      	bls.n	9b2c <m2m_wifi_set_device_name+0x1c>
	{
		u8DeviceNameLength = M2M_DEVICE_NAME_MAX;
    9b26:	1cfb      	adds	r3, r7, #3
    9b28:	2230      	movs	r2, #48	; 0x30
    9b2a:	701a      	strb	r2, [r3, #0]
	}
	//pu8DeviceName[u8DeviceNameLength] = '\0';
	u8DeviceNameLength ++;
    9b2c:	1cfb      	adds	r3, r7, #3
    9b2e:	781a      	ldrb	r2, [r3, #0]
    9b30:	1cfb      	adds	r3, r7, #3
    9b32:	3201      	adds	r2, #1
    9b34:	701a      	strb	r2, [r3, #0]
	m2m_memcpy(strDeviceName.au8DeviceName, pu8DeviceName, u8DeviceNameLength);
    9b36:	1cfb      	adds	r3, r7, #3
    9b38:	781a      	ldrb	r2, [r3, #0]
    9b3a:	6879      	ldr	r1, [r7, #4]
    9b3c:	2308      	movs	r3, #8
    9b3e:	18fb      	adds	r3, r7, r3
    9b40:	0018      	movs	r0, r3
    9b42:	4b0a      	ldr	r3, [pc, #40]	; (9b6c <m2m_wifi_set_device_name+0x5c>)
    9b44:	4798      	blx	r3
	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_DEVICE_NAME,
    9b46:	2308      	movs	r3, #8
    9b48:	18fa      	adds	r2, r7, r3
    9b4a:	2300      	movs	r3, #0
    9b4c:	9302      	str	r3, [sp, #8]
    9b4e:	2300      	movs	r3, #0
    9b50:	9301      	str	r3, [sp, #4]
    9b52:	2300      	movs	r3, #0
    9b54:	9300      	str	r3, [sp, #0]
    9b56:	2330      	movs	r3, #48	; 0x30
    9b58:	2107      	movs	r1, #7
    9b5a:	2001      	movs	r0, #1
    9b5c:	4c04      	ldr	r4, [pc, #16]	; (9b70 <m2m_wifi_set_device_name+0x60>)
    9b5e:	47a0      	blx	r4
    9b60:	0003      	movs	r3, r0
		(uint8*)&strDeviceName, sizeof(tstrM2MDeviceNameConfig), NULL, 0,0);
}
    9b62:	0018      	movs	r0, r3
    9b64:	46bd      	mov	sp, r7
    9b66:	b00f      	add	sp, #60	; 0x3c
    9b68:	bd90      	pop	{r4, r7, pc}
    9b6a:	46c0      	nop			; (mov r8, r8)
    9b6c:	00008b9d 	.word	0x00008b9d
    9b70:	00008e91 	.word	0x00008e91

00009b74 <chip_apply_conf>:
#define M2M_DISABLE_PS				(0xd0ul)

static uint32 clk_status_reg_adr = 0xf; /* Assume initially it is B0 chip */

sint8 chip_apply_conf(uint32 u32Conf)
{
    9b74:	b590      	push	{r4, r7, lr}
    9b76:	b087      	sub	sp, #28
    9b78:	af00      	add	r7, sp, #0
    9b7a:	6078      	str	r0, [r7, #4]
	sint8 ret = M2M_SUCCESS;
    9b7c:	2317      	movs	r3, #23
    9b7e:	18fb      	adds	r3, r7, r3
    9b80:	2200      	movs	r2, #0
    9b82:	701a      	strb	r2, [r3, #0]
	uint32 val32 = u32Conf;
    9b84:	687b      	ldr	r3, [r7, #4]
    9b86:	613b      	str	r3, [r7, #16]
#endif
#ifdef __DISABLE_FIRMWARE_LOGS__
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
    9b88:	693a      	ldr	r2, [r7, #16]
    9b8a:	23a5      	movs	r3, #165	; 0xa5
    9b8c:	015b      	lsls	r3, r3, #5
    9b8e:	0011      	movs	r1, r2
    9b90:	0018      	movs	r0, r3
    9b92:	4b13      	ldr	r3, [pc, #76]	; (9be0 <chip_apply_conf+0x6c>)
    9b94:	4798      	blx	r3
		if(val32 != 0) {		
    9b96:	693b      	ldr	r3, [r7, #16]
    9b98:	2b00      	cmp	r3, #0
    9b9a:	d018      	beq.n	9bce <chip_apply_conf+0x5a>
			uint32 reg = 0;
    9b9c:	2300      	movs	r3, #0
    9b9e:	60fb      	str	r3, [r7, #12]
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
    9ba0:	2317      	movs	r3, #23
    9ba2:	18fc      	adds	r4, r7, r3
    9ba4:	230c      	movs	r3, #12
    9ba6:	18fa      	adds	r2, r7, r3
    9ba8:	23a5      	movs	r3, #165	; 0xa5
    9baa:	015b      	lsls	r3, r3, #5
    9bac:	0011      	movs	r1, r2
    9bae:	0018      	movs	r0, r3
    9bb0:	4b0c      	ldr	r3, [pc, #48]	; (9be4 <chip_apply_conf+0x70>)
    9bb2:	4798      	blx	r3
    9bb4:	0003      	movs	r3, r0
    9bb6:	7023      	strb	r3, [r4, #0]
			if(ret == M2M_SUCCESS) {
    9bb8:	2317      	movs	r3, #23
    9bba:	18fb      	adds	r3, r7, r3
    9bbc:	781b      	ldrb	r3, [r3, #0]
    9bbe:	b25b      	sxtb	r3, r3
    9bc0:	2b00      	cmp	r3, #0
    9bc2:	d1e1      	bne.n	9b88 <chip_apply_conf+0x14>
				if(reg == val32)
    9bc4:	68fa      	ldr	r2, [r7, #12]
    9bc6:	693b      	ldr	r3, [r7, #16]
    9bc8:	429a      	cmp	r2, r3
    9bca:	d002      	beq.n	9bd2 <chip_apply_conf+0x5e>
					break;
			}
		} else {
			break;
		}
	} while(1);
    9bcc:	e7dc      	b.n	9b88 <chip_apply_conf+0x14>
			if(ret == M2M_SUCCESS) {
				if(reg == val32)
					break;
			}
		} else {
			break;
    9bce:	46c0      	nop			; (mov r8, r8)
    9bd0:	e000      	b.n	9bd4 <chip_apply_conf+0x60>
		if(val32 != 0) {		
			uint32 reg = 0;
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
			if(ret == M2M_SUCCESS) {
				if(reg == val32)
					break;
    9bd2:	46c0      	nop			; (mov r8, r8)
		} else {
			break;
		}
	} while(1);

	return M2M_SUCCESS;
    9bd4:	2300      	movs	r3, #0
}
    9bd6:	0018      	movs	r0, r3
    9bd8:	46bd      	mov	sp, r7
    9bda:	b007      	add	sp, #28
    9bdc:	bd90      	pop	{r4, r7, pc}
    9bde:	46c0      	nop			; (mov r8, r8)
    9be0:	0000a275 	.word	0x0000a275
    9be4:	0000a251 	.word	0x0000a251

00009be8 <nm_clkless_wake>:
*	@author	Samer Sarhan
*	@date	06 June 2014
*	@version	1.0
*/
sint8 nm_clkless_wake(void)
{
    9be8:	b590      	push	{r4, r7, lr}
    9bea:	b085      	sub	sp, #20
    9bec:	af00      	add	r7, sp, #0
	sint8 ret = M2M_SUCCESS;
    9bee:	230f      	movs	r3, #15
    9bf0:	18fb      	adds	r3, r7, r3
    9bf2:	2200      	movs	r2, #0
    9bf4:	701a      	strb	r2, [r3, #0]
	uint32 reg, clk_status_reg,trials = 0;
    9bf6:	2300      	movs	r3, #0
    9bf8:	60bb      	str	r3, [r7, #8]
	/* wait 1ms, spi data read */
	nm_bsp_sleep(1);
    9bfa:	2001      	movs	r0, #1
    9bfc:	4b50      	ldr	r3, [pc, #320]	; (9d40 <nm_clkless_wake+0x158>)
    9bfe:	4798      	blx	r3
	ret = nm_read_reg_with_ret(0x1, &reg);
    9c00:	230f      	movs	r3, #15
    9c02:	18fc      	adds	r4, r7, r3
    9c04:	1d3b      	adds	r3, r7, #4
    9c06:	0019      	movs	r1, r3
    9c08:	2001      	movs	r0, #1
    9c0a:	4b4e      	ldr	r3, [pc, #312]	; (9d44 <nm_clkless_wake+0x15c>)
    9c0c:	4798      	blx	r3
    9c0e:	0003      	movs	r3, r0
    9c10:	7023      	strb	r3, [r4, #0]
	if(ret != M2M_SUCCESS) {
    9c12:	230f      	movs	r3, #15
    9c14:	18fb      	adds	r3, r7, r3
    9c16:	781b      	ldrb	r3, [r3, #0]
    9c18:	b25b      	sxtb	r3, r3
    9c1a:	2b00      	cmp	r3, #0
    9c1c:	d000      	beq.n	9c20 <nm_clkless_wake+0x38>
    9c1e:	e084      	b.n	9d2a <nm_clkless_wake+0x142>
	 * If A0, then clks_enabled bit exists in register 0xe
	 */
	do
	{
		/* Set bit 1 */
		nm_write_reg(0x1, reg | (1 << 1));
    9c20:	687b      	ldr	r3, [r7, #4]
    9c22:	2202      	movs	r2, #2
    9c24:	4313      	orrs	r3, r2
    9c26:	0019      	movs	r1, r3
    9c28:	2001      	movs	r0, #1
    9c2a:	4b47      	ldr	r3, [pc, #284]	; (9d48 <nm_clkless_wake+0x160>)
    9c2c:	4798      	blx	r3
		/* wait 1ms, spi data read */
		nm_bsp_sleep(1);
    9c2e:	2001      	movs	r0, #1
    9c30:	4b43      	ldr	r3, [pc, #268]	; (9d40 <nm_clkless_wake+0x158>)
    9c32:	4798      	blx	r3
		// Check the clock status
		ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    9c34:	4b45      	ldr	r3, [pc, #276]	; (9d4c <nm_clkless_wake+0x164>)
    9c36:	681b      	ldr	r3, [r3, #0]
    9c38:	220f      	movs	r2, #15
    9c3a:	18bc      	adds	r4, r7, r2
    9c3c:	003a      	movs	r2, r7
    9c3e:	0011      	movs	r1, r2
    9c40:	0018      	movs	r0, r3
    9c42:	4b40      	ldr	r3, [pc, #256]	; (9d44 <nm_clkless_wake+0x15c>)
    9c44:	4798      	blx	r3
    9c46:	0003      	movs	r3, r0
    9c48:	7023      	strb	r3, [r4, #0]
		if( (ret != M2M_SUCCESS) || ((ret == M2M_SUCCESS) && (clk_status_reg == 0)) ) {
    9c4a:	230f      	movs	r3, #15
    9c4c:	18fb      	adds	r3, r7, r3
    9c4e:	781b      	ldrb	r3, [r3, #0]
    9c50:	b25b      	sxtb	r3, r3
    9c52:	2b00      	cmp	r3, #0
    9c54:	d108      	bne.n	9c68 <nm_clkless_wake+0x80>
    9c56:	230f      	movs	r3, #15
    9c58:	18fb      	adds	r3, r7, r3
    9c5a:	781b      	ldrb	r3, [r3, #0]
    9c5c:	b25b      	sxtb	r3, r3
    9c5e:	2b00      	cmp	r3, #0
    9c60:	d144      	bne.n	9cec <nm_clkless_wake+0x104>
    9c62:	683b      	ldr	r3, [r7, #0]
    9c64:	2b00      	cmp	r3, #0
    9c66:	d141      	bne.n	9cec <nm_clkless_wake+0x104>
			/* Register 0xf did not exist in A0.
			 * If register 0xf fails to read or if it reads 0,
			 * then the chip is A0.
			 */
			clk_status_reg_adr = 0xe;
    9c68:	4b38      	ldr	r3, [pc, #224]	; (9d4c <nm_clkless_wake+0x164>)
    9c6a:	220e      	movs	r2, #14
    9c6c:	601a      	str	r2, [r3, #0]
			/* wait 1ms, spi data read */
			nm_bsp_sleep(1);
    9c6e:	2001      	movs	r0, #1
    9c70:	4b33      	ldr	r3, [pc, #204]	; (9d40 <nm_clkless_wake+0x158>)
    9c72:	4798      	blx	r3
			ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    9c74:	4b35      	ldr	r3, [pc, #212]	; (9d4c <nm_clkless_wake+0x164>)
    9c76:	681b      	ldr	r3, [r3, #0]
    9c78:	220f      	movs	r2, #15
    9c7a:	18bc      	adds	r4, r7, r2
    9c7c:	003a      	movs	r2, r7
    9c7e:	0011      	movs	r1, r2
    9c80:	0018      	movs	r0, r3
    9c82:	4b30      	ldr	r3, [pc, #192]	; (9d44 <nm_clkless_wake+0x15c>)
    9c84:	4798      	blx	r3
    9c86:	0003      	movs	r3, r0
    9c88:	7023      	strb	r3, [r4, #0]
			
			/* Aelmeleh 24-08-2015*/
			/* Check for C3000 rev. D0 value */
			if( (ret != M2M_SUCCESS) || ((ret == M2M_SUCCESS) && (clk_status_reg == 0)) ) {
    9c8a:	230f      	movs	r3, #15
    9c8c:	18fb      	adds	r3, r7, r3
    9c8e:	781b      	ldrb	r3, [r3, #0]
    9c90:	b25b      	sxtb	r3, r3
    9c92:	2b00      	cmp	r3, #0
    9c94:	d108      	bne.n	9ca8 <nm_clkless_wake+0xc0>
    9c96:	230f      	movs	r3, #15
    9c98:	18fb      	adds	r3, r7, r3
    9c9a:	781b      	ldrb	r3, [r3, #0]
    9c9c:	b25b      	sxtb	r3, r3
    9c9e:	2b00      	cmp	r3, #0
    9ca0:	d124      	bne.n	9cec <nm_clkless_wake+0x104>
    9ca2:	683b      	ldr	r3, [r7, #0]
    9ca4:	2b00      	cmp	r3, #0
    9ca6:	d121      	bne.n	9cec <nm_clkless_wake+0x104>
				 
				clk_status_reg_adr = 0x13;
    9ca8:	4b28      	ldr	r3, [pc, #160]	; (9d4c <nm_clkless_wake+0x164>)
    9caa:	2213      	movs	r2, #19
    9cac:	601a      	str	r2, [r3, #0]
				/* wait 1ms, spi data read */
				nm_bsp_sleep(1);
    9cae:	2001      	movs	r0, #1
    9cb0:	4b23      	ldr	r3, [pc, #140]	; (9d40 <nm_clkless_wake+0x158>)
    9cb2:	4798      	blx	r3
				ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    9cb4:	4b25      	ldr	r3, [pc, #148]	; (9d4c <nm_clkless_wake+0x164>)
    9cb6:	681b      	ldr	r3, [r3, #0]
    9cb8:	220f      	movs	r2, #15
    9cba:	18bc      	adds	r4, r7, r2
    9cbc:	003a      	movs	r2, r7
    9cbe:	0011      	movs	r1, r2
    9cc0:	0018      	movs	r0, r3
    9cc2:	4b20      	ldr	r3, [pc, #128]	; (9d44 <nm_clkless_wake+0x15c>)
    9cc4:	4798      	blx	r3
    9cc6:	0003      	movs	r3, r0
    9cc8:	7023      	strb	r3, [r4, #0]
			
				if(ret != M2M_SUCCESS) {
    9cca:	230f      	movs	r3, #15
    9ccc:	18fb      	adds	r3, r7, r3
    9cce:	781b      	ldrb	r3, [r3, #0]
    9cd0:	b25b      	sxtb	r3, r3
    9cd2:	2b00      	cmp	r3, #0
    9cd4:	d12b      	bne.n	9d2e <nm_clkless_wake+0x146>
		}

		// in case of clocks off, wait 2ms, and check it again.
		// if still off, wait for another 2ms, for a total wait of 6ms.
		// If still off, redo the wake up sequence
		while( ((clk_status_reg & 0x4) == 0) && (((++trials) %3) == 0))
    9cd6:	e009      	b.n	9cec <nm_clkless_wake+0x104>
		{
			/* Wait for the chip to stabilize*/
			nm_bsp_sleep(2);
    9cd8:	2002      	movs	r0, #2
    9cda:	4b19      	ldr	r3, [pc, #100]	; (9d40 <nm_clkless_wake+0x158>)
    9cdc:	4798      	blx	r3

			// Make sure chip is awake. This is an extra step that can be removed
			// later to avoid the bus access overhead
			nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    9cde:	4b1b      	ldr	r3, [pc, #108]	; (9d4c <nm_clkless_wake+0x164>)
    9ce0:	681b      	ldr	r3, [r3, #0]
    9ce2:	003a      	movs	r2, r7
    9ce4:	0011      	movs	r1, r2
    9ce6:	0018      	movs	r0, r3
    9ce8:	4b16      	ldr	r3, [pc, #88]	; (9d44 <nm_clkless_wake+0x15c>)
    9cea:	4798      	blx	r3
		}

		// in case of clocks off, wait 2ms, and check it again.
		// if still off, wait for another 2ms, for a total wait of 6ms.
		// If still off, redo the wake up sequence
		while( ((clk_status_reg & 0x4) == 0) && (((++trials) %3) == 0))
    9cec:	683b      	ldr	r3, [r7, #0]
    9cee:	2204      	movs	r2, #4
    9cf0:	4013      	ands	r3, r2
    9cf2:	d109      	bne.n	9d08 <nm_clkless_wake+0x120>
    9cf4:	68bb      	ldr	r3, [r7, #8]
    9cf6:	3301      	adds	r3, #1
    9cf8:	60bb      	str	r3, [r7, #8]
    9cfa:	68ba      	ldr	r2, [r7, #8]
    9cfc:	4b14      	ldr	r3, [pc, #80]	; (9d50 <nm_clkless_wake+0x168>)
    9cfe:	2103      	movs	r1, #3
    9d00:	0010      	movs	r0, r2
    9d02:	4798      	blx	r3
    9d04:	1e0b      	subs	r3, r1, #0
    9d06:	d0e7      	beq.n	9cd8 <nm_clkless_wake+0xf0>
			{
				M2M_ERR("clocks still OFF. Wake up failed\n");
			}
		}
		// in case of failure, Reset the wakeup bit to introduce a new edge on the next loop
		if((clk_status_reg & 0x4) == 0)
    9d08:	683b      	ldr	r3, [r7, #0]
    9d0a:	2204      	movs	r2, #4
    9d0c:	4013      	ands	r3, r2
    9d0e:	d106      	bne.n	9d1e <nm_clkless_wake+0x136>
		{
			// Reset bit 0
			nm_write_reg(0x1, reg | (1 << 1));
    9d10:	687b      	ldr	r3, [r7, #4]
    9d12:	2202      	movs	r2, #2
    9d14:	4313      	orrs	r3, r2
    9d16:	0019      	movs	r1, r3
    9d18:	2001      	movs	r0, #1
    9d1a:	4b0b      	ldr	r3, [pc, #44]	; (9d48 <nm_clkless_wake+0x160>)
    9d1c:	4798      	blx	r3
		}
	} while((clk_status_reg & 0x4) == 0);
    9d1e:	683b      	ldr	r3, [r7, #0]
    9d20:	2204      	movs	r2, #4
    9d22:	4013      	ands	r3, r2
    9d24:	d100      	bne.n	9d28 <nm_clkless_wake+0x140>
    9d26:	e77b      	b.n	9c20 <nm_clkless_wake+0x38>
    9d28:	e002      	b.n	9d30 <nm_clkless_wake+0x148>
	/* wait 1ms, spi data read */
	nm_bsp_sleep(1);
	ret = nm_read_reg_with_ret(0x1, &reg);
	if(ret != M2M_SUCCESS) {
		M2M_ERR("Bus error (1). Wake up failed\n");
		goto _WAKE_EXIT;
    9d2a:	46c0      	nop			; (mov r8, r8)
    9d2c:	e000      	b.n	9d30 <nm_clkless_wake+0x148>
				nm_bsp_sleep(1);
				ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
			
				if(ret != M2M_SUCCESS) {
					M2M_ERR("Bus error (2). Wake up failed\n");
					goto _WAKE_EXIT;
    9d2e:	46c0      	nop			; (mov r8, r8)
			nm_write_reg(0x1, reg | (1 << 1));
		}
	} while((clk_status_reg & 0x4) == 0);

_WAKE_EXIT:
	return ret;
    9d30:	230f      	movs	r3, #15
    9d32:	18fb      	adds	r3, r7, r3
    9d34:	781b      	ldrb	r3, [r3, #0]
    9d36:	b25b      	sxtb	r3, r3
}
    9d38:	0018      	movs	r0, r3
    9d3a:	46bd      	mov	sp, r7
    9d3c:	b005      	add	sp, #20
    9d3e:	bd90      	pop	{r4, r7, pc}
    9d40:	0000832d 	.word	0x0000832d
    9d44:	0000a251 	.word	0x0000a251
    9d48:	0000a275 	.word	0x0000a275
    9d4c:	20000020 	.word	0x20000020
    9d50:	0001d591 	.word	0x0001d591

00009d54 <enable_interrupts>:
	nm_write_reg(0x6, 0x0);
	nm_write_reg(0x7, 0x0);
}

sint8 enable_interrupts(void)
{
    9d54:	b590      	push	{r4, r7, lr}
    9d56:	b083      	sub	sp, #12
    9d58:	af00      	add	r7, sp, #0
	uint32 reg;
	sint8 ret;
	/**
	interrupt pin mux select
	**/
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
    9d5a:	1dfc      	adds	r4, r7, #7
    9d5c:	003b      	movs	r3, r7
    9d5e:	4a29      	ldr	r2, [pc, #164]	; (9e04 <enable_interrupts+0xb0>)
    9d60:	0019      	movs	r1, r3
    9d62:	0010      	movs	r0, r2
    9d64:	4b28      	ldr	r3, [pc, #160]	; (9e08 <enable_interrupts+0xb4>)
    9d66:	4798      	blx	r3
    9d68:	0003      	movs	r3, r0
    9d6a:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    9d6c:	1dfb      	adds	r3, r7, #7
    9d6e:	781b      	ldrb	r3, [r3, #0]
    9d70:	b25b      	sxtb	r3, r3
    9d72:	2b00      	cmp	r3, #0
    9d74:	d002      	beq.n	9d7c <enable_interrupts+0x28>
		return M2M_ERR_BUS_FAIL;
    9d76:	2306      	movs	r3, #6
    9d78:	425b      	negs	r3, r3
    9d7a:	e03f      	b.n	9dfc <enable_interrupts+0xa8>
	}
	reg |= ((uint32) 1 << 8);
    9d7c:	683b      	ldr	r3, [r7, #0]
    9d7e:	2280      	movs	r2, #128	; 0x80
    9d80:	0052      	lsls	r2, r2, #1
    9d82:	4313      	orrs	r3, r2
    9d84:	603b      	str	r3, [r7, #0]
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
    9d86:	683b      	ldr	r3, [r7, #0]
    9d88:	1dfc      	adds	r4, r7, #7
    9d8a:	4a1e      	ldr	r2, [pc, #120]	; (9e04 <enable_interrupts+0xb0>)
    9d8c:	0019      	movs	r1, r3
    9d8e:	0010      	movs	r0, r2
    9d90:	4b1e      	ldr	r3, [pc, #120]	; (9e0c <enable_interrupts+0xb8>)
    9d92:	4798      	blx	r3
    9d94:	0003      	movs	r3, r0
    9d96:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    9d98:	1dfb      	adds	r3, r7, #7
    9d9a:	781b      	ldrb	r3, [r3, #0]
    9d9c:	b25b      	sxtb	r3, r3
    9d9e:	2b00      	cmp	r3, #0
    9da0:	d002      	beq.n	9da8 <enable_interrupts+0x54>
		return M2M_ERR_BUS_FAIL;
    9da2:	2306      	movs	r3, #6
    9da4:	425b      	negs	r3, r3
    9da6:	e029      	b.n	9dfc <enable_interrupts+0xa8>
	}
	/**
	interrupt enable
	**/
	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
    9da8:	1dfc      	adds	r4, r7, #7
    9daa:	003a      	movs	r2, r7
    9dac:	23d0      	movs	r3, #208	; 0xd0
    9dae:	015b      	lsls	r3, r3, #5
    9db0:	0011      	movs	r1, r2
    9db2:	0018      	movs	r0, r3
    9db4:	4b14      	ldr	r3, [pc, #80]	; (9e08 <enable_interrupts+0xb4>)
    9db6:	4798      	blx	r3
    9db8:	0003      	movs	r3, r0
    9dba:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    9dbc:	1dfb      	adds	r3, r7, #7
    9dbe:	781b      	ldrb	r3, [r3, #0]
    9dc0:	b25b      	sxtb	r3, r3
    9dc2:	2b00      	cmp	r3, #0
    9dc4:	d002      	beq.n	9dcc <enable_interrupts+0x78>
		return M2M_ERR_BUS_FAIL;
    9dc6:	2306      	movs	r3, #6
    9dc8:	425b      	negs	r3, r3
    9dca:	e017      	b.n	9dfc <enable_interrupts+0xa8>
	}
	reg |= ((uint32) 1 << 16);
    9dcc:	683b      	ldr	r3, [r7, #0]
    9dce:	2280      	movs	r2, #128	; 0x80
    9dd0:	0252      	lsls	r2, r2, #9
    9dd2:	4313      	orrs	r3, r2
    9dd4:	603b      	str	r3, [r7, #0]
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
    9dd6:	683a      	ldr	r2, [r7, #0]
    9dd8:	1dfc      	adds	r4, r7, #7
    9dda:	23d0      	movs	r3, #208	; 0xd0
    9ddc:	015b      	lsls	r3, r3, #5
    9dde:	0011      	movs	r1, r2
    9de0:	0018      	movs	r0, r3
    9de2:	4b0a      	ldr	r3, [pc, #40]	; (9e0c <enable_interrupts+0xb8>)
    9de4:	4798      	blx	r3
    9de6:	0003      	movs	r3, r0
    9de8:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    9dea:	1dfb      	adds	r3, r7, #7
    9dec:	781b      	ldrb	r3, [r3, #0]
    9dee:	b25b      	sxtb	r3, r3
    9df0:	2b00      	cmp	r3, #0
    9df2:	d002      	beq.n	9dfa <enable_interrupts+0xa6>
		return M2M_ERR_BUS_FAIL;
    9df4:	2306      	movs	r3, #6
    9df6:	425b      	negs	r3, r3
    9df8:	e000      	b.n	9dfc <enable_interrupts+0xa8>
	}
	return M2M_SUCCESS;
    9dfa:	2300      	movs	r3, #0
}
    9dfc:	0018      	movs	r0, r3
    9dfe:	46bd      	mov	sp, r7
    9e00:	b003      	add	sp, #12
    9e02:	bd90      	pop	{r4, r7, pc}
    9e04:	00001408 	.word	0x00001408
    9e08:	0000a251 	.word	0x0000a251
    9e0c:	0000a275 	.word	0x0000a275

00009e10 <nmi_get_chipid>:
	nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
	return ret;
}

uint32 nmi_get_chipid(void)
{
    9e10:	b580      	push	{r7, lr}
    9e12:	b082      	sub	sp, #8
    9e14:	af00      	add	r7, sp, #0
	static uint32 chipid = 0;

	if (chipid == 0) {
    9e16:	4b32      	ldr	r3, [pc, #200]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e18:	681b      	ldr	r3, [r3, #0]
    9e1a:	2b00      	cmp	r3, #0
    9e1c:	d159      	bne.n	9ed2 <nmi_get_chipid+0xc2>
		uint32 rfrevid;

		if((nm_read_reg_with_ret(0x1000, &chipid)) != M2M_SUCCESS) {
    9e1e:	4a30      	ldr	r2, [pc, #192]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e20:	2380      	movs	r3, #128	; 0x80
    9e22:	015b      	lsls	r3, r3, #5
    9e24:	0011      	movs	r1, r2
    9e26:	0018      	movs	r0, r3
    9e28:	4b2e      	ldr	r3, [pc, #184]	; (9ee4 <nmi_get_chipid+0xd4>)
    9e2a:	4798      	blx	r3
    9e2c:	1e03      	subs	r3, r0, #0
    9e2e:	d004      	beq.n	9e3a <nmi_get_chipid+0x2a>
			chipid = 0;
    9e30:	4b2b      	ldr	r3, [pc, #172]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e32:	2200      	movs	r2, #0
    9e34:	601a      	str	r2, [r3, #0]
			return 0;
    9e36:	2300      	movs	r3, #0
    9e38:	e04d      	b.n	9ed6 <nmi_get_chipid+0xc6>
		}
		//if((ret = nm_read_reg_with_ret(0x11fc, &revid)) != M2M_SUCCESS) {
		//	return 0;
		//}
		if((nm_read_reg_with_ret(0x13f4, &rfrevid)) != M2M_SUCCESS) {
    9e3a:	1d3b      	adds	r3, r7, #4
    9e3c:	4a2a      	ldr	r2, [pc, #168]	; (9ee8 <nmi_get_chipid+0xd8>)
    9e3e:	0019      	movs	r1, r3
    9e40:	0010      	movs	r0, r2
    9e42:	4b28      	ldr	r3, [pc, #160]	; (9ee4 <nmi_get_chipid+0xd4>)
    9e44:	4798      	blx	r3
    9e46:	1e03      	subs	r3, r0, #0
    9e48:	d004      	beq.n	9e54 <nmi_get_chipid+0x44>
			chipid = 0;
    9e4a:	4b25      	ldr	r3, [pc, #148]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e4c:	2200      	movs	r2, #0
    9e4e:	601a      	str	r2, [r3, #0]
			return 0;
    9e50:	2300      	movs	r3, #0
    9e52:	e040      	b.n	9ed6 <nmi_get_chipid+0xc6>
		}

		if (chipid == 0x1002a0)  {
    9e54:	4b22      	ldr	r3, [pc, #136]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e56:	681b      	ldr	r3, [r3, #0]
    9e58:	4a24      	ldr	r2, [pc, #144]	; (9eec <nmi_get_chipid+0xdc>)
    9e5a:	4293      	cmp	r3, r2
    9e5c:	d106      	bne.n	9e6c <nmi_get_chipid+0x5c>
			if (rfrevid == 0x1) { /* 1002A0 */
    9e5e:	687b      	ldr	r3, [r7, #4]
    9e60:	2b01      	cmp	r3, #1
    9e62:	d029      	beq.n	9eb8 <nmi_get_chipid+0xa8>
			} else /* if (rfrevid == 0x2) */ { /* 1002A1 */
				chipid = 0x1002a1;
    9e64:	4b1e      	ldr	r3, [pc, #120]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e66:	4a22      	ldr	r2, [pc, #136]	; (9ef0 <nmi_get_chipid+0xe0>)
    9e68:	601a      	str	r2, [r3, #0]
    9e6a:	e025      	b.n	9eb8 <nmi_get_chipid+0xa8>
			}
		} else if(chipid == 0x1002b0) {
    9e6c:	4b1c      	ldr	r3, [pc, #112]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e6e:	681b      	ldr	r3, [r3, #0]
    9e70:	4a20      	ldr	r2, [pc, #128]	; (9ef4 <nmi_get_chipid+0xe4>)
    9e72:	4293      	cmp	r3, r2
    9e74:	d10d      	bne.n	9e92 <nmi_get_chipid+0x82>
			if(rfrevid == 3) { /* 1002B0 */
    9e76:	687b      	ldr	r3, [r7, #4]
    9e78:	2b03      	cmp	r3, #3
    9e7a:	d01d      	beq.n	9eb8 <nmi_get_chipid+0xa8>
			} else if(rfrevid == 4) { /* 1002B1 */
    9e7c:	687b      	ldr	r3, [r7, #4]
    9e7e:	2b04      	cmp	r3, #4
    9e80:	d103      	bne.n	9e8a <nmi_get_chipid+0x7a>
				chipid = 0x1002b1;
    9e82:	4b17      	ldr	r3, [pc, #92]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e84:	4a1c      	ldr	r2, [pc, #112]	; (9ef8 <nmi_get_chipid+0xe8>)
    9e86:	601a      	str	r2, [r3, #0]
    9e88:	e016      	b.n	9eb8 <nmi_get_chipid+0xa8>
			} else /* if(rfrevid == 5) */ { /* 1002B2 */
				chipid = 0x1002b2;
    9e8a:	4b15      	ldr	r3, [pc, #84]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e8c:	4a1b      	ldr	r2, [pc, #108]	; (9efc <nmi_get_chipid+0xec>)
    9e8e:	601a      	str	r2, [r3, #0]
    9e90:	e012      	b.n	9eb8 <nmi_get_chipid+0xa8>
			}
		} else if(chipid == 0x1000F0) { 
    9e92:	4b13      	ldr	r3, [pc, #76]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e94:	681b      	ldr	r3, [r3, #0]
    9e96:	4a1a      	ldr	r2, [pc, #104]	; (9f00 <nmi_get_chipid+0xf0>)
    9e98:	4293      	cmp	r3, r2
    9e9a:	d10d      	bne.n	9eb8 <nmi_get_chipid+0xa8>
			if((nm_read_reg_with_ret(0x3B0000, &chipid)) != M2M_SUCCESS) {
    9e9c:	4a10      	ldr	r2, [pc, #64]	; (9ee0 <nmi_get_chipid+0xd0>)
    9e9e:	23ec      	movs	r3, #236	; 0xec
    9ea0:	039b      	lsls	r3, r3, #14
    9ea2:	0011      	movs	r1, r2
    9ea4:	0018      	movs	r0, r3
    9ea6:	4b0f      	ldr	r3, [pc, #60]	; (9ee4 <nmi_get_chipid+0xd4>)
    9ea8:	4798      	blx	r3
    9eaa:	1e03      	subs	r3, r0, #0
    9eac:	d004      	beq.n	9eb8 <nmi_get_chipid+0xa8>
			chipid = 0;
    9eae:	4b0c      	ldr	r3, [pc, #48]	; (9ee0 <nmi_get_chipid+0xd0>)
    9eb0:	2200      	movs	r2, #0
    9eb2:	601a      	str	r2, [r3, #0]
			return 0;
    9eb4:	2300      	movs	r3, #0
    9eb6:	e00e      	b.n	9ed6 <nmi_get_chipid+0xc6>
				chipid |= 0x050000;
			}
		}
#else
		/*M2M is by default have SPI flash*/
		chipid &= ~(0x0f0000);
    9eb8:	4b09      	ldr	r3, [pc, #36]	; (9ee0 <nmi_get_chipid+0xd0>)
    9eba:	681b      	ldr	r3, [r3, #0]
    9ebc:	4a11      	ldr	r2, [pc, #68]	; (9f04 <nmi_get_chipid+0xf4>)
    9ebe:	401a      	ands	r2, r3
    9ec0:	4b07      	ldr	r3, [pc, #28]	; (9ee0 <nmi_get_chipid+0xd0>)
    9ec2:	601a      	str	r2, [r3, #0]
		chipid |= 0x050000;
    9ec4:	4b06      	ldr	r3, [pc, #24]	; (9ee0 <nmi_get_chipid+0xd0>)
    9ec6:	681b      	ldr	r3, [r3, #0]
    9ec8:	22a0      	movs	r2, #160	; 0xa0
    9eca:	02d2      	lsls	r2, r2, #11
    9ecc:	431a      	orrs	r2, r3
    9ece:	4b04      	ldr	r3, [pc, #16]	; (9ee0 <nmi_get_chipid+0xd0>)
    9ed0:	601a      	str	r2, [r3, #0]
#endif /* PROBE_FLASH */
	}
	return chipid;
    9ed2:	4b03      	ldr	r3, [pc, #12]	; (9ee0 <nmi_get_chipid+0xd0>)
    9ed4:	681b      	ldr	r3, [r3, #0]
}
    9ed6:	0018      	movs	r0, r3
    9ed8:	46bd      	mov	sp, r7
    9eda:	b002      	add	sp, #8
    9edc:	bd80      	pop	{r7, pc}
    9ede:	46c0      	nop			; (mov r8, r8)
    9ee0:	20000528 	.word	0x20000528
    9ee4:	0000a251 	.word	0x0000a251
    9ee8:	000013f4 	.word	0x000013f4
    9eec:	001002a0 	.word	0x001002a0
    9ef0:	001002a1 	.word	0x001002a1
    9ef4:	001002b0 	.word	0x001002b0
    9ef8:	001002b1 	.word	0x001002b1
    9efc:	001002b2 	.word	0x001002b2
    9f00:	001000f0 	.word	0x001000f0
    9f04:	fff0ffff 	.word	0xfff0ffff

00009f08 <wait_for_bootrom>:
#endif
	return ret;
}

sint8 wait_for_bootrom(uint8 arg)
{
    9f08:	b580      	push	{r7, lr}
    9f0a:	b086      	sub	sp, #24
    9f0c:	af00      	add	r7, sp, #0
    9f0e:	0002      	movs	r2, r0
    9f10:	1dfb      	adds	r3, r7, #7
    9f12:	701a      	strb	r2, [r3, #0]
	sint8 ret = M2M_SUCCESS;
    9f14:	230b      	movs	r3, #11
    9f16:	18fb      	adds	r3, r7, r3
    9f18:	2200      	movs	r2, #0
    9f1a:	701a      	strb	r2, [r3, #0]
	uint32 reg = 0, cnt = 0;
    9f1c:	2300      	movs	r3, #0
    9f1e:	617b      	str	r3, [r7, #20]
    9f20:	2300      	movs	r3, #0
    9f22:	613b      	str	r3, [r7, #16]
	uint32 u32GpReg1 = 0;
    9f24:	2300      	movs	r3, #0
    9f26:	60fb      	str	r3, [r7, #12]

	reg = 0;
    9f28:	2300      	movs	r3, #0
    9f2a:	617b      	str	r3, [r7, #20]
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
    9f2c:	4b3b      	ldr	r3, [pc, #236]	; (a01c <wait_for_bootrom+0x114>)
    9f2e:	0018      	movs	r0, r3
    9f30:	4b3b      	ldr	r3, [pc, #236]	; (a020 <wait_for_bootrom+0x118>)
    9f32:	4798      	blx	r3
    9f34:	0003      	movs	r3, r0
    9f36:	617b      	str	r3, [r7, #20]
		if (reg & 0x80000000) {
    9f38:	697b      	ldr	r3, [r7, #20]
    9f3a:	2b00      	cmp	r3, #0
    9f3c:	db03      	blt.n	9f46 <wait_for_bootrom+0x3e>
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
    9f3e:	2001      	movs	r0, #1
    9f40:	4b38      	ldr	r3, [pc, #224]	; (a024 <wait_for_bootrom+0x11c>)
    9f42:	4798      	blx	r3
	}
    9f44:	e7f2      	b.n	9f2c <wait_for_bootrom+0x24>

	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
		if (reg & 0x80000000) {
			break;
    9f46:	46c0      	nop			; (mov r8, r8)
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
	}
	reg = nm_read_reg(M2M_WAIT_FOR_HOST_REG);
    9f48:	4b37      	ldr	r3, [pc, #220]	; (a028 <wait_for_bootrom+0x120>)
    9f4a:	0018      	movs	r0, r3
    9f4c:	4b34      	ldr	r3, [pc, #208]	; (a020 <wait_for_bootrom+0x118>)
    9f4e:	4798      	blx	r3
    9f50:	0003      	movs	r3, r0
    9f52:	617b      	str	r3, [r7, #20]
	reg &= 0x1;
    9f54:	697b      	ldr	r3, [r7, #20]
    9f56:	2201      	movs	r2, #1
    9f58:	4013      	ands	r3, r2
    9f5a:	617b      	str	r3, [r7, #20]

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
    9f5c:	697b      	ldr	r3, [r7, #20]
    9f5e:	2b00      	cmp	r3, #0
    9f60:	d112      	bne.n	9f88 <wait_for_bootrom+0x80>
	{
		reg = 0;
    9f62:	2300      	movs	r3, #0
    9f64:	617b      	str	r3, [r7, #20]
		while(reg != M2M_FINISH_BOOT_ROM)
    9f66:	e00b      	b.n	9f80 <wait_for_bootrom+0x78>
		{
			nm_bsp_sleep(1);
    9f68:	2001      	movs	r0, #1
    9f6a:	4b2e      	ldr	r3, [pc, #184]	; (a024 <wait_for_bootrom+0x11c>)
    9f6c:	4798      	blx	r3
			reg = nm_read_reg(BOOTROM_REG);
    9f6e:	4b2f      	ldr	r3, [pc, #188]	; (a02c <wait_for_bootrom+0x124>)
    9f70:	0018      	movs	r0, r3
    9f72:	4b2b      	ldr	r3, [pc, #172]	; (a020 <wait_for_bootrom+0x118>)
    9f74:	4798      	blx	r3
    9f76:	0003      	movs	r3, r0
    9f78:	617b      	str	r3, [r7, #20]

			if(++cnt > TIMEOUT)
    9f7a:	693b      	ldr	r3, [r7, #16]
    9f7c:	3301      	adds	r3, #1
    9f7e:	613b      	str	r3, [r7, #16]

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
    9f80:	697b      	ldr	r3, [r7, #20]
    9f82:	4a2b      	ldr	r2, [pc, #172]	; (a030 <wait_for_bootrom+0x128>)
    9f84:	4293      	cmp	r3, r2
    9f86:	d1ef      	bne.n	9f68 <wait_for_bootrom+0x60>
				goto ERR2;
			}
		}
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
    9f88:	1dfb      	adds	r3, r7, #7
    9f8a:	781b      	ldrb	r3, [r3, #0]
    9f8c:	2b02      	cmp	r3, #2
    9f8e:	d10d      	bne.n	9fac <wait_for_bootrom+0xa4>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    9f90:	4a28      	ldr	r2, [pc, #160]	; (a034 <wait_for_bootrom+0x12c>)
    9f92:	4b29      	ldr	r3, [pc, #164]	; (a038 <wait_for_bootrom+0x130>)
    9f94:	0011      	movs	r1, r2
    9f96:	0018      	movs	r0, r3
    9f98:	4b28      	ldr	r3, [pc, #160]	; (a03c <wait_for_bootrom+0x134>)
    9f9a:	4798      	blx	r3
		nm_write_reg(NMI_STATE_REG, NBIT20);
    9f9c:	2380      	movs	r3, #128	; 0x80
    9f9e:	035b      	lsls	r3, r3, #13
    9fa0:	4a27      	ldr	r2, [pc, #156]	; (a040 <wait_for_bootrom+0x138>)
    9fa2:	0019      	movs	r1, r3
    9fa4:	0010      	movs	r0, r2
    9fa6:	4b25      	ldr	r3, [pc, #148]	; (a03c <wait_for_bootrom+0x134>)
    9fa8:	4798      	blx	r3
    9faa:	e015      	b.n	9fd8 <wait_for_bootrom+0xd0>
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
    9fac:	1dfb      	adds	r3, r7, #7
    9fae:	781b      	ldrb	r3, [r3, #0]
    9fb0:	2b03      	cmp	r3, #3
    9fb2:	d10b      	bne.n	9fcc <wait_for_bootrom+0xc4>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    9fb4:	4a1f      	ldr	r2, [pc, #124]	; (a034 <wait_for_bootrom+0x12c>)
    9fb6:	4b20      	ldr	r3, [pc, #128]	; (a038 <wait_for_bootrom+0x130>)
    9fb8:	0011      	movs	r1, r2
    9fba:	0018      	movs	r0, r3
    9fbc:	4b1f      	ldr	r3, [pc, #124]	; (a03c <wait_for_bootrom+0x134>)
    9fbe:	4798      	blx	r3
		nm_write_reg(NMI_STATE_REG, 0);
    9fc0:	4b1f      	ldr	r3, [pc, #124]	; (a040 <wait_for_bootrom+0x138>)
    9fc2:	2100      	movs	r1, #0
    9fc4:	0018      	movs	r0, r3
    9fc6:	4b1d      	ldr	r3, [pc, #116]	; (a03c <wait_for_bootrom+0x134>)
    9fc8:	4798      	blx	r3
    9fca:	e005      	b.n	9fd8 <wait_for_bootrom+0xd0>
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
    9fcc:	1dfb      	adds	r3, r7, #7
    9fce:	781b      	ldrb	r3, [r3, #0]
    9fd0:	2b04      	cmp	r3, #4
    9fd2:	d101      	bne.n	9fd8 <wait_for_bootrom+0xd0>
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
    9fd4:	2380      	movs	r3, #128	; 0x80
    9fd6:	60fb      	str	r3, [r7, #12]
	} else {
		/*bypass this step*/
	}

	if(REV(nmi_get_chipid()) == REV_3A0)
    9fd8:	4b1a      	ldr	r3, [pc, #104]	; (a044 <wait_for_bootrom+0x13c>)
    9fda:	4798      	blx	r3
    9fdc:	0003      	movs	r3, r0
    9fde:	051b      	lsls	r3, r3, #20
    9fe0:	0d1a      	lsrs	r2, r3, #20
    9fe2:	23e8      	movs	r3, #232	; 0xe8
    9fe4:	009b      	lsls	r3, r3, #2
    9fe6:	429a      	cmp	r2, r3
    9fe8:	d106      	bne.n	9ff8 <wait_for_bootrom+0xf0>
	{
		chip_apply_conf(u32GpReg1 | rHAVE_USE_PMU_BIT);
    9fea:	68fb      	ldr	r3, [r7, #12]
    9fec:	2202      	movs	r2, #2
    9fee:	4313      	orrs	r3, r2
    9ff0:	0018      	movs	r0, r3
    9ff2:	4b15      	ldr	r3, [pc, #84]	; (a048 <wait_for_bootrom+0x140>)
    9ff4:	4798      	blx	r3
    9ff6:	e003      	b.n	a000 <wait_for_bootrom+0xf8>
	}
	else
	{
		chip_apply_conf(u32GpReg1);
    9ff8:	68fb      	ldr	r3, [r7, #12]
    9ffa:	0018      	movs	r0, r3
    9ffc:	4b12      	ldr	r3, [pc, #72]	; (a048 <wait_for_bootrom+0x140>)
    9ffe:	4798      	blx	r3
	}
	
	nm_write_reg(BOOTROM_REG,M2M_START_FIRMWARE);
    a000:	4a12      	ldr	r2, [pc, #72]	; (a04c <wait_for_bootrom+0x144>)
    a002:	4b0a      	ldr	r3, [pc, #40]	; (a02c <wait_for_bootrom+0x124>)
    a004:	0011      	movs	r1, r2
    a006:	0018      	movs	r0, r3
    a008:	4b0c      	ldr	r3, [pc, #48]	; (a03c <wait_for_bootrom+0x134>)
    a00a:	4798      	blx	r3
#ifdef __ROM_TEST__
	rom_test();
#endif /* __ROM_TEST__ */

ERR2:
	return ret;
    a00c:	230b      	movs	r3, #11
    a00e:	18fb      	adds	r3, r7, r3
    a010:	781b      	ldrb	r3, [r3, #0]
    a012:	b25b      	sxtb	r3, r3
}
    a014:	0018      	movs	r0, r3
    a016:	46bd      	mov	sp, r7
    a018:	b006      	add	sp, #24
    a01a:	bd80      	pop	{r7, pc}
    a01c:	00001014 	.word	0x00001014
    a020:	0000a231 	.word	0x0000a231
    a024:	0000832d 	.word	0x0000832d
    a028:	000207bc 	.word	0x000207bc
    a02c:	000c000c 	.word	0x000c000c
    a030:	10add09e 	.word	0x10add09e
    a034:	3c1cd57d 	.word	0x3c1cd57d
    a038:	000207ac 	.word	0x000207ac
    a03c:	0000a275 	.word	0x0000a275
    a040:	0000108c 	.word	0x0000108c
    a044:	00009e11 	.word	0x00009e11
    a048:	00009b75 	.word	0x00009b75
    a04c:	ef522f61 	.word	0xef522f61

0000a050 <wait_for_firmware_start>:

sint8 wait_for_firmware_start(uint8 arg)
{
    a050:	b580      	push	{r7, lr}
    a052:	b088      	sub	sp, #32
    a054:	af00      	add	r7, sp, #0
    a056:	0002      	movs	r2, r0
    a058:	1dfb      	adds	r3, r7, #7
    a05a:	701a      	strb	r2, [r3, #0]
	sint8 ret = M2M_SUCCESS;
    a05c:	231f      	movs	r3, #31
    a05e:	18fb      	adds	r3, r7, r3
    a060:	2200      	movs	r2, #0
    a062:	701a      	strb	r2, [r3, #0]
	uint32 reg = 0, cnt = 0;
    a064:	2300      	movs	r3, #0
    a066:	61bb      	str	r3, [r7, #24]
    a068:	2300      	movs	r3, #0
    a06a:	617b      	str	r3, [r7, #20]
	uint32 u32Timeout = TIMEOUT;
    a06c:	2301      	movs	r3, #1
    a06e:	425b      	negs	r3, r3
    a070:	613b      	str	r3, [r7, #16]
	volatile uint32 regAddress = NMI_STATE_REG;
    a072:	4b1d      	ldr	r3, [pc, #116]	; (a0e8 <wait_for_firmware_start+0x98>)
    a074:	60fb      	str	r3, [r7, #12]
	volatile uint32 checkValue = M2M_FINISH_INIT_STATE;
    a076:	4b1d      	ldr	r3, [pc, #116]	; (a0ec <wait_for_firmware_start+0x9c>)
    a078:	60bb      	str	r3, [r7, #8]
	
	if((M2M_WIFI_MODE_ATE_HIGH == arg)||(M2M_WIFI_MODE_ATE_LOW == arg)) {
    a07a:	1dfb      	adds	r3, r7, #7
    a07c:	781b      	ldrb	r3, [r3, #0]
    a07e:	2b02      	cmp	r3, #2
    a080:	d003      	beq.n	a08a <wait_for_firmware_start+0x3a>
    a082:	1dfb      	adds	r3, r7, #7
    a084:	781b      	ldrb	r3, [r3, #0]
    a086:	2b03      	cmp	r3, #3
    a088:	d119      	bne.n	a0be <wait_for_firmware_start+0x6e>
		regAddress = NMI_REV_REG;
    a08a:	4b19      	ldr	r3, [pc, #100]	; (a0f0 <wait_for_firmware_start+0xa0>)
    a08c:	60fb      	str	r3, [r7, #12]
		checkValue = M2M_ATE_FW_IS_UP_VALUE;
    a08e:	4b19      	ldr	r3, [pc, #100]	; (a0f4 <wait_for_firmware_start+0xa4>)
    a090:	60bb      	str	r3, [r7, #8]
	} else {
		/*bypass this step*/
	}
	
	
	while (checkValue != reg)
    a092:	e014      	b.n	a0be <wait_for_firmware_start+0x6e>
	{
	
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
    a094:	2002      	movs	r0, #2
    a096:	4b18      	ldr	r3, [pc, #96]	; (a0f8 <wait_for_firmware_start+0xa8>)
    a098:	4798      	blx	r3
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
    a09a:	68fb      	ldr	r3, [r7, #12]
    a09c:	0018      	movs	r0, r3
    a09e:	4b17      	ldr	r3, [pc, #92]	; (a0fc <wait_for_firmware_start+0xac>)
    a0a0:	4798      	blx	r3
    a0a2:	0003      	movs	r3, r0
    a0a4:	61bb      	str	r3, [r7, #24]
		if(++cnt >= u32Timeout)
    a0a6:	697b      	ldr	r3, [r7, #20]
    a0a8:	3301      	adds	r3, #1
    a0aa:	617b      	str	r3, [r7, #20]
    a0ac:	697a      	ldr	r2, [r7, #20]
    a0ae:	693b      	ldr	r3, [r7, #16]
    a0b0:	429a      	cmp	r2, r3
    a0b2:	d304      	bcc.n	a0be <wait_for_firmware_start+0x6e>
		{
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
    a0b4:	231f      	movs	r3, #31
    a0b6:	18fb      	adds	r3, r7, r3
    a0b8:	22fb      	movs	r2, #251	; 0xfb
    a0ba:	701a      	strb	r2, [r3, #0]
			goto ERR;
    a0bc:	e00c      	b.n	a0d8 <wait_for_firmware_start+0x88>
	} else {
		/*bypass this step*/
	}
	
	
	while (checkValue != reg)
    a0be:	68ba      	ldr	r2, [r7, #8]
    a0c0:	69bb      	ldr	r3, [r7, #24]
    a0c2:	429a      	cmp	r2, r3
    a0c4:	d1e6      	bne.n	a094 <wait_for_firmware_start+0x44>
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
    a0c6:	68bb      	ldr	r3, [r7, #8]
    a0c8:	4a08      	ldr	r2, [pc, #32]	; (a0ec <wait_for_firmware_start+0x9c>)
    a0ca:	4293      	cmp	r3, r2
    a0cc:	d104      	bne.n	a0d8 <wait_for_firmware_start+0x88>
	{
		nm_write_reg(NMI_STATE_REG, 0);
    a0ce:	4b06      	ldr	r3, [pc, #24]	; (a0e8 <wait_for_firmware_start+0x98>)
    a0d0:	2100      	movs	r1, #0
    a0d2:	0018      	movs	r0, r3
    a0d4:	4b0a      	ldr	r3, [pc, #40]	; (a100 <wait_for_firmware_start+0xb0>)
    a0d6:	4798      	blx	r3
	}
ERR:
	return ret;
    a0d8:	231f      	movs	r3, #31
    a0da:	18fb      	adds	r3, r7, r3
    a0dc:	781b      	ldrb	r3, [r3, #0]
    a0de:	b25b      	sxtb	r3, r3
}
    a0e0:	0018      	movs	r0, r3
    a0e2:	46bd      	mov	sp, r7
    a0e4:	b008      	add	sp, #32
    a0e6:	bd80      	pop	{r7, pc}
    a0e8:	0000108c 	.word	0x0000108c
    a0ec:	02532636 	.word	0x02532636
    a0f0:	000207ac 	.word	0x000207ac
    a0f4:	d75dc1c3 	.word	0xd75dc1c3
    a0f8:	0000832d 	.word	0x0000832d
    a0fc:	0000a231 	.word	0x0000a231
    a100:	0000a275 	.word	0x0000a275

0000a104 <chip_deinit>:

sint8 chip_deinit(void)
{
    a104:	b590      	push	{r4, r7, lr}
    a106:	b083      	sub	sp, #12
    a108:	af00      	add	r7, sp, #0
	uint32 reg = 0;
    a10a:	2300      	movs	r3, #0
    a10c:	603b      	str	r3, [r7, #0]
	sint8 ret;
	uint8 timeout = 10;
    a10e:	1dbb      	adds	r3, r7, #6
    a110:	220a      	movs	r2, #10
    a112:	701a      	strb	r2, [r3, #0]

	/**
	stop the firmware, need a re-download
	**/
	ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
    a114:	1dfc      	adds	r4, r7, #7
    a116:	003a      	movs	r2, r7
    a118:	23a0      	movs	r3, #160	; 0xa0
    a11a:	015b      	lsls	r3, r3, #5
    a11c:	0011      	movs	r1, r2
    a11e:	0018      	movs	r0, r3
    a120:	4b29      	ldr	r3, [pc, #164]	; (a1c8 <chip_deinit+0xc4>)
    a122:	4798      	blx	r3
    a124:	0003      	movs	r3, r0
    a126:	7023      	strb	r3, [r4, #0]
	if (ret != M2M_SUCCESS) {
		M2M_ERR("failed to de-initialize\n");
	}
	reg &= ~(1 << 10);
    a128:	683b      	ldr	r3, [r7, #0]
    a12a:	4a28      	ldr	r2, [pc, #160]	; (a1cc <chip_deinit+0xc8>)
    a12c:	4013      	ands	r3, r2
    a12e:	603b      	str	r3, [r7, #0]
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
    a130:	683a      	ldr	r2, [r7, #0]
    a132:	1dfc      	adds	r4, r7, #7
    a134:	23a0      	movs	r3, #160	; 0xa0
    a136:	015b      	lsls	r3, r3, #5
    a138:	0011      	movs	r1, r2
    a13a:	0018      	movs	r0, r3
    a13c:	4b24      	ldr	r3, [pc, #144]	; (a1d0 <chip_deinit+0xcc>)
    a13e:	4798      	blx	r3
    a140:	0003      	movs	r3, r0
    a142:	7023      	strb	r3, [r4, #0]

	if (ret != M2M_SUCCESS) {
    a144:	1dfb      	adds	r3, r7, #7
    a146:	781b      	ldrb	r3, [r3, #0]
    a148:	b25b      	sxtb	r3, r3
    a14a:	2b00      	cmp	r3, #0
    a14c:	d003      	beq.n	a156 <chip_deinit+0x52>
		M2M_ERR("Error while writing reg\n");
		return ret;
    a14e:	1dfb      	adds	r3, r7, #7
    a150:	781b      	ldrb	r3, [r3, #0]
    a152:	b25b      	sxtb	r3, r3
    a154:	e033      	b.n	a1be <chip_deinit+0xba>
	}

	do {
		ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
    a156:	1dfc      	adds	r4, r7, #7
    a158:	003a      	movs	r2, r7
    a15a:	23a0      	movs	r3, #160	; 0xa0
    a15c:	015b      	lsls	r3, r3, #5
    a15e:	0011      	movs	r1, r2
    a160:	0018      	movs	r0, r3
    a162:	4b19      	ldr	r3, [pc, #100]	; (a1c8 <chip_deinit+0xc4>)
    a164:	4798      	blx	r3
    a166:	0003      	movs	r3, r0
    a168:	7023      	strb	r3, [r4, #0]
		if (ret != M2M_SUCCESS) {
    a16a:	1dfb      	adds	r3, r7, #7
    a16c:	781b      	ldrb	r3, [r3, #0]
    a16e:	b25b      	sxtb	r3, r3
    a170:	2b00      	cmp	r3, #0
    a172:	d003      	beq.n	a17c <chip_deinit+0x78>
			M2M_ERR("Error while reading reg\n");
			return ret;
    a174:	1dfb      	adds	r3, r7, #7
    a176:	781b      	ldrb	r3, [r3, #0]
    a178:	b25b      	sxtb	r3, r3
    a17a:	e020      	b.n	a1be <chip_deinit+0xba>
		}
		/*Workaround to ensure that the chip is actually reset*/
		if ((reg & (1 << 10))) {
    a17c:	683a      	ldr	r2, [r7, #0]
    a17e:	2380      	movs	r3, #128	; 0x80
    a180:	00db      	lsls	r3, r3, #3
    a182:	4013      	ands	r3, r2
    a184:	d017      	beq.n	a1b6 <chip_deinit+0xb2>
			M2M_DBG("Bit 10 not reset retry %d\n", timeout);
			reg &= ~(1 << 10);
    a186:	683b      	ldr	r3, [r7, #0]
    a188:	4a10      	ldr	r2, [pc, #64]	; (a1cc <chip_deinit+0xc8>)
    a18a:	4013      	ands	r3, r2
    a18c:	603b      	str	r3, [r7, #0]
			ret = nm_write_reg(NMI_GLB_RESET_0, reg);
    a18e:	683a      	ldr	r2, [r7, #0]
    a190:	1dfc      	adds	r4, r7, #7
    a192:	23a0      	movs	r3, #160	; 0xa0
    a194:	015b      	lsls	r3, r3, #5
    a196:	0011      	movs	r1, r2
    a198:	0018      	movs	r0, r3
    a19a:	4b0d      	ldr	r3, [pc, #52]	; (a1d0 <chip_deinit+0xcc>)
    a19c:	4798      	blx	r3
    a19e:	0003      	movs	r3, r0
    a1a0:	7023      	strb	r3, [r4, #0]
			timeout--;
    a1a2:	1dbb      	adds	r3, r7, #6
    a1a4:	781a      	ldrb	r2, [r3, #0]
    a1a6:	1dbb      	adds	r3, r7, #6
    a1a8:	3a01      	subs	r2, #1
    a1aa:	701a      	strb	r2, [r3, #0]
		} else {
			break;
		}

	} while (timeout);
    a1ac:	1dbb      	adds	r3, r7, #6
    a1ae:	781b      	ldrb	r3, [r3, #0]
    a1b0:	2b00      	cmp	r3, #0
    a1b2:	d1d0      	bne.n	a156 <chip_deinit+0x52>
    a1b4:	e000      	b.n	a1b8 <chip_deinit+0xb4>
			M2M_DBG("Bit 10 not reset retry %d\n", timeout);
			reg &= ~(1 << 10);
			ret = nm_write_reg(NMI_GLB_RESET_0, reg);
			timeout--;
		} else {
			break;
    a1b6:	46c0      	nop			; (mov r8, r8)
		}

	} while (timeout);

	return ret;
    a1b8:	1dfb      	adds	r3, r7, #7
    a1ba:	781b      	ldrb	r3, [r3, #0]
    a1bc:	b25b      	sxtb	r3, r3
}
    a1be:	0018      	movs	r0, r3
    a1c0:	46bd      	mov	sp, r7
    a1c2:	b003      	add	sp, #12
    a1c4:	bd90      	pop	{r4, r7, pc}
    a1c6:	46c0      	nop			; (mov r8, r8)
    a1c8:	0000a251 	.word	0x0000a251
    a1cc:	fffffbff 	.word	0xfffffbff
    a1d0:	0000a275 	.word	0x0000a275

0000a1d4 <nm_bus_iface_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_bus_iface_init(void *pvInitVal)
{
    a1d4:	b590      	push	{r4, r7, lr}
    a1d6:	b085      	sub	sp, #20
    a1d8:	af00      	add	r7, sp, #0
    a1da:	6078      	str	r0, [r7, #4]
	sint8 ret = M2M_SUCCESS;
    a1dc:	230f      	movs	r3, #15
    a1de:	18fb      	adds	r3, r7, r3
    a1e0:	2200      	movs	r2, #0
    a1e2:	701a      	strb	r2, [r3, #0]
	ret = nm_bus_init(pvInitVal);
    a1e4:	230f      	movs	r3, #15
    a1e6:	18fc      	adds	r4, r7, r3
    a1e8:	687b      	ldr	r3, [r7, #4]
    a1ea:	0018      	movs	r0, r3
    a1ec:	4b05      	ldr	r3, [pc, #20]	; (a204 <nm_bus_iface_init+0x30>)
    a1ee:	4798      	blx	r3
    a1f0:	0003      	movs	r3, r0
    a1f2:	7023      	strb	r3, [r4, #0]

	return ret;
    a1f4:	230f      	movs	r3, #15
    a1f6:	18fb      	adds	r3, r7, r3
    a1f8:	781b      	ldrb	r3, [r3, #0]
    a1fa:	b25b      	sxtb	r3, r3
}
    a1fc:	0018      	movs	r0, r3
    a1fe:	46bd      	mov	sp, r7
    a200:	b005      	add	sp, #20
    a202:	bd90      	pop	{r4, r7, pc}
    a204:	00008a15 	.word	0x00008a15

0000a208 <nm_bus_iface_deinit>:
*	@author	Samer Sarhan
*	@date	07 April 2014
*	@version	1.0
*/
sint8 nm_bus_iface_deinit(void)
{
    a208:	b590      	push	{r4, r7, lr}
    a20a:	b083      	sub	sp, #12
    a20c:	af00      	add	r7, sp, #0
	sint8 ret = M2M_SUCCESS;
    a20e:	1dfb      	adds	r3, r7, #7
    a210:	2200      	movs	r2, #0
    a212:	701a      	strb	r2, [r3, #0]
	ret = nm_bus_deinit();
    a214:	1dfc      	adds	r4, r7, #7
    a216:	4b05      	ldr	r3, [pc, #20]	; (a22c <nm_bus_iface_deinit+0x24>)
    a218:	4798      	blx	r3
    a21a:	0003      	movs	r3, r0
    a21c:	7023      	strb	r3, [r4, #0]

	return ret;
    a21e:	1dfb      	adds	r3, r7, #7
    a220:	781b      	ldrb	r3, [r3, #0]
    a222:	b25b      	sxtb	r3, r3
}
    a224:	0018      	movs	r0, r3
    a226:	46bd      	mov	sp, r7
    a228:	b003      	add	sp, #12
    a22a:	bd90      	pop	{r4, r7, pc}
    a22c:	00008b59 	.word	0x00008b59

0000a230 <nm_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_read_reg(uint32 u32Addr)
{
    a230:	b580      	push	{r7, lr}
    a232:	b082      	sub	sp, #8
    a234:	af00      	add	r7, sp, #0
    a236:	6078      	str	r0, [r7, #4]
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg(u32Addr);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg(u32Addr);
    a238:	687b      	ldr	r3, [r7, #4]
    a23a:	0018      	movs	r0, r3
    a23c:	4b03      	ldr	r3, [pc, #12]	; (a24c <nm_read_reg+0x1c>)
    a23e:	4798      	blx	r3
    a240:	0003      	movs	r3, r0
	return nm_i2c_read_reg(u32Addr);
#else
#error "Plesae define bus usage"
#endif

}
    a242:	0018      	movs	r0, r3
    a244:	46bd      	mov	sp, r7
    a246:	b002      	add	sp, #8
    a248:	bd80      	pop	{r7, pc}
    a24a:	46c0      	nop			; (mov r8, r8)
    a24c:	0000b3c1 	.word	0x0000b3c1

0000a250 <nm_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    a250:	b580      	push	{r7, lr}
    a252:	b082      	sub	sp, #8
    a254:	af00      	add	r7, sp, #0
    a256:	6078      	str	r0, [r7, #4]
    a258:	6039      	str	r1, [r7, #0]
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg_with_ret(u32Addr,pu32RetVal);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg_with_ret(u32Addr,pu32RetVal);
    a25a:	683a      	ldr	r2, [r7, #0]
    a25c:	687b      	ldr	r3, [r7, #4]
    a25e:	0011      	movs	r1, r2
    a260:	0018      	movs	r0, r3
    a262:	4b03      	ldr	r3, [pc, #12]	; (a270 <nm_read_reg_with_ret+0x20>)
    a264:	4798      	blx	r3
    a266:	0003      	movs	r3, r0
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_read_reg_with_ret(u32Addr,pu32RetVal);
#else
#error "Plesae define bus usage"
#endif
}
    a268:	0018      	movs	r0, r3
    a26a:	46bd      	mov	sp, r7
    a26c:	b002      	add	sp, #8
    a26e:	bd80      	pop	{r7, pc}
    a270:	0000b3e5 	.word	0x0000b3e5

0000a274 <nm_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val)
{
    a274:	b580      	push	{r7, lr}
    a276:	b082      	sub	sp, #8
    a278:	af00      	add	r7, sp, #0
    a27a:	6078      	str	r0, [r7, #4]
    a27c:	6039      	str	r1, [r7, #0]
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_reg(u32Addr,u32Val);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_reg(u32Addr,u32Val);
    a27e:	683a      	ldr	r2, [r7, #0]
    a280:	687b      	ldr	r3, [r7, #4]
    a282:	0011      	movs	r1, r2
    a284:	0018      	movs	r0, r3
    a286:	4b03      	ldr	r3, [pc, #12]	; (a294 <nm_write_reg+0x20>)
    a288:	4798      	blx	r3
    a28a:	0003      	movs	r3, r0
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_write_reg(u32Addr,u32Val);
#else
#error "Plesae define bus usage"
#endif
}
    a28c:	0018      	movs	r0, r3
    a28e:	46bd      	mov	sp, r7
    a290:	b002      	add	sp, #8
    a292:	bd80      	pop	{r7, pc}
    a294:	0000b435 	.word	0x0000b435

0000a298 <p_nm_read_block>:

static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    a298:	b580      	push	{r7, lr}
    a29a:	b084      	sub	sp, #16
    a29c:	af00      	add	r7, sp, #0
    a29e:	60f8      	str	r0, [r7, #12]
    a2a0:	60b9      	str	r1, [r7, #8]
    a2a2:	1dbb      	adds	r3, r7, #6
    a2a4:	801a      	strh	r2, [r3, #0]
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
    a2a6:	1dbb      	adds	r3, r7, #6
    a2a8:	881a      	ldrh	r2, [r3, #0]
    a2aa:	68b9      	ldr	r1, [r7, #8]
    a2ac:	68fb      	ldr	r3, [r7, #12]
    a2ae:	0018      	movs	r0, r3
    a2b0:	4b03      	ldr	r3, [pc, #12]	; (a2c0 <p_nm_read_block+0x28>)
    a2b2:	4798      	blx	r3
    a2b4:	0003      	movs	r3, r0
	return nm_i2c_read_block(u32Addr,puBuf,u16Sz);
#else
#error "Plesae define bus usage"
#endif

}
    a2b6:	0018      	movs	r0, r3
    a2b8:	46bd      	mov	sp, r7
    a2ba:	b004      	add	sp, #16
    a2bc:	bd80      	pop	{r7, pc}
    a2be:	46c0      	nop			; (mov r8, r8)
    a2c0:	0000b485 	.word	0x0000b485

0000a2c4 <nm_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    a2c4:	b580      	push	{r7, lr}
    a2c6:	b086      	sub	sp, #24
    a2c8:	af00      	add	r7, sp, #0
    a2ca:	60f8      	str	r0, [r7, #12]
    a2cc:	60b9      	str	r1, [r7, #8]
    a2ce:	607a      	str	r2, [r7, #4]
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    a2d0:	4b2d      	ldr	r3, [pc, #180]	; (a388 <nm_read_block+0xc4>)
    a2d2:	881a      	ldrh	r2, [r3, #0]
    a2d4:	2310      	movs	r3, #16
    a2d6:	18fb      	adds	r3, r7, r3
    a2d8:	3a08      	subs	r2, #8
    a2da:	801a      	strh	r2, [r3, #0]
	uint32 off = 0;
    a2dc:	2300      	movs	r3, #0
    a2de:	617b      	str	r3, [r7, #20]
	sint8 s8Ret = M2M_SUCCESS;
    a2e0:	2313      	movs	r3, #19
    a2e2:	18fb      	adds	r3, r7, r3
    a2e4:	2200      	movs	r2, #0
    a2e6:	701a      	strb	r2, [r3, #0]

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    a2e8:	2310      	movs	r3, #16
    a2ea:	18fb      	adds	r3, r7, r3
    a2ec:	881a      	ldrh	r2, [r3, #0]
    a2ee:	687b      	ldr	r3, [r7, #4]
    a2f0:	429a      	cmp	r2, r3
    a2f2:	d313      	bcc.n	a31c <nm_read_block+0x58>
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], (uint16)u32Sz);
    a2f4:	68ba      	ldr	r2, [r7, #8]
    a2f6:	697b      	ldr	r3, [r7, #20]
    a2f8:	18d1      	adds	r1, r2, r3
    a2fa:	687b      	ldr	r3, [r7, #4]
    a2fc:	b29a      	uxth	r2, r3
    a2fe:	68fb      	ldr	r3, [r7, #12]
    a300:	0018      	movs	r0, r3
    a302:	4b22      	ldr	r3, [pc, #136]	; (a38c <nm_read_block+0xc8>)
    a304:	4798      	blx	r3
    a306:	0003      	movs	r3, r0
    a308:	b2da      	uxtb	r2, r3
    a30a:	2313      	movs	r3, #19
    a30c:	18fb      	adds	r3, r7, r3
    a30e:	781b      	ldrb	r3, [r3, #0]
    a310:	18d3      	adds	r3, r2, r3
    a312:	b2da      	uxtb	r2, r3
    a314:	2313      	movs	r3, #19
    a316:	18fb      	adds	r3, r7, r3
    a318:	701a      	strb	r2, [r3, #0]
			break;
    a31a:	e02d      	b.n	a378 <nm_read_block+0xb4>
		}
		else
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], u16MaxTrxSz);
    a31c:	68ba      	ldr	r2, [r7, #8]
    a31e:	697b      	ldr	r3, [r7, #20]
    a320:	18d1      	adds	r1, r2, r3
    a322:	2310      	movs	r3, #16
    a324:	18fb      	adds	r3, r7, r3
    a326:	881a      	ldrh	r2, [r3, #0]
    a328:	68fb      	ldr	r3, [r7, #12]
    a32a:	0018      	movs	r0, r3
    a32c:	4b17      	ldr	r3, [pc, #92]	; (a38c <nm_read_block+0xc8>)
    a32e:	4798      	blx	r3
    a330:	0003      	movs	r3, r0
    a332:	b2da      	uxtb	r2, r3
    a334:	2313      	movs	r3, #19
    a336:	18fb      	adds	r3, r7, r3
    a338:	781b      	ldrb	r3, [r3, #0]
    a33a:	18d3      	adds	r3, r2, r3
    a33c:	b2da      	uxtb	r2, r3
    a33e:	2313      	movs	r3, #19
    a340:	18fb      	adds	r3, r7, r3
    a342:	701a      	strb	r2, [r3, #0]
			if(M2M_SUCCESS != s8Ret) break;
    a344:	2313      	movs	r3, #19
    a346:	18fb      	adds	r3, r7, r3
    a348:	781b      	ldrb	r3, [r3, #0]
    a34a:	b25b      	sxtb	r3, r3
    a34c:	2b00      	cmp	r3, #0
    a34e:	d112      	bne.n	a376 <nm_read_block+0xb2>
			u32Sz -= u16MaxTrxSz;
    a350:	2310      	movs	r3, #16
    a352:	18fb      	adds	r3, r7, r3
    a354:	881b      	ldrh	r3, [r3, #0]
    a356:	687a      	ldr	r2, [r7, #4]
    a358:	1ad3      	subs	r3, r2, r3
    a35a:	607b      	str	r3, [r7, #4]
			off += u16MaxTrxSz;
    a35c:	2310      	movs	r3, #16
    a35e:	18fb      	adds	r3, r7, r3
    a360:	881b      	ldrh	r3, [r3, #0]
    a362:	697a      	ldr	r2, [r7, #20]
    a364:	18d3      	adds	r3, r2, r3
    a366:	617b      	str	r3, [r7, #20]
			u32Addr += u16MaxTrxSz;
    a368:	2310      	movs	r3, #16
    a36a:	18fb      	adds	r3, r7, r3
    a36c:	881b      	ldrh	r3, [r3, #0]
    a36e:	68fa      	ldr	r2, [r7, #12]
    a370:	18d3      	adds	r3, r2, r3
    a372:	60fb      	str	r3, [r7, #12]
		}
	}
    a374:	e7b8      	b.n	a2e8 <nm_read_block+0x24>
			break;
		}
		else
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    a376:	46c0      	nop			; (mov r8, r8)
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
    a378:	2313      	movs	r3, #19
    a37a:	18fb      	adds	r3, r7, r3
    a37c:	781b      	ldrb	r3, [r3, #0]
    a37e:	b25b      	sxtb	r3, r3
}
    a380:	0018      	movs	r0, r3
    a382:	46bd      	mov	sp, r7
    a384:	b006      	add	sp, #24
    a386:	bd80      	pop	{r7, pc}
    a388:	2000001c 	.word	0x2000001c
    a38c:	0000a299 	.word	0x0000a299

0000a390 <p_nm_write_block>:

static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    a390:	b580      	push	{r7, lr}
    a392:	b084      	sub	sp, #16
    a394:	af00      	add	r7, sp, #0
    a396:	60f8      	str	r0, [r7, #12]
    a398:	60b9      	str	r1, [r7, #8]
    a39a:	1dbb      	adds	r3, r7, #6
    a39c:	801a      	strh	r2, [r3, #0]
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
    a39e:	1dbb      	adds	r3, r7, #6
    a3a0:	881a      	ldrh	r2, [r3, #0]
    a3a2:	68b9      	ldr	r1, [r7, #8]
    a3a4:	68fb      	ldr	r3, [r7, #12]
    a3a6:	0018      	movs	r0, r3
    a3a8:	4b03      	ldr	r3, [pc, #12]	; (a3b8 <p_nm_write_block+0x28>)
    a3aa:	4798      	blx	r3
    a3ac:	0003      	movs	r3, r0
	return nm_i2c_write_block(u32Addr,puBuf,u16Sz);
#else
#error "Plesae define bus usage"
#endif

}
    a3ae:	0018      	movs	r0, r3
    a3b0:	46bd      	mov	sp, r7
    a3b2:	b004      	add	sp, #16
    a3b4:	bd80      	pop	{r7, pc}
    a3b6:	46c0      	nop			; (mov r8, r8)
    a3b8:	0000b4dd 	.word	0x0000b4dd

0000a3bc <nm_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    a3bc:	b580      	push	{r7, lr}
    a3be:	b086      	sub	sp, #24
    a3c0:	af00      	add	r7, sp, #0
    a3c2:	60f8      	str	r0, [r7, #12]
    a3c4:	60b9      	str	r1, [r7, #8]
    a3c6:	607a      	str	r2, [r7, #4]
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    a3c8:	4b2d      	ldr	r3, [pc, #180]	; (a480 <nm_write_block+0xc4>)
    a3ca:	881a      	ldrh	r2, [r3, #0]
    a3cc:	2310      	movs	r3, #16
    a3ce:	18fb      	adds	r3, r7, r3
    a3d0:	3a08      	subs	r2, #8
    a3d2:	801a      	strh	r2, [r3, #0]
	uint32 off = 0;
    a3d4:	2300      	movs	r3, #0
    a3d6:	617b      	str	r3, [r7, #20]
	sint8 s8Ret = M2M_SUCCESS;
    a3d8:	2313      	movs	r3, #19
    a3da:	18fb      	adds	r3, r7, r3
    a3dc:	2200      	movs	r2, #0
    a3de:	701a      	strb	r2, [r3, #0]

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    a3e0:	2310      	movs	r3, #16
    a3e2:	18fb      	adds	r3, r7, r3
    a3e4:	881a      	ldrh	r2, [r3, #0]
    a3e6:	687b      	ldr	r3, [r7, #4]
    a3e8:	429a      	cmp	r2, r3
    a3ea:	d313      	bcc.n	a414 <nm_write_block+0x58>
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], (uint16)u32Sz);
    a3ec:	68ba      	ldr	r2, [r7, #8]
    a3ee:	697b      	ldr	r3, [r7, #20]
    a3f0:	18d1      	adds	r1, r2, r3
    a3f2:	687b      	ldr	r3, [r7, #4]
    a3f4:	b29a      	uxth	r2, r3
    a3f6:	68fb      	ldr	r3, [r7, #12]
    a3f8:	0018      	movs	r0, r3
    a3fa:	4b22      	ldr	r3, [pc, #136]	; (a484 <nm_write_block+0xc8>)
    a3fc:	4798      	blx	r3
    a3fe:	0003      	movs	r3, r0
    a400:	b2da      	uxtb	r2, r3
    a402:	2313      	movs	r3, #19
    a404:	18fb      	adds	r3, r7, r3
    a406:	781b      	ldrb	r3, [r3, #0]
    a408:	18d3      	adds	r3, r2, r3
    a40a:	b2da      	uxtb	r2, r3
    a40c:	2313      	movs	r3, #19
    a40e:	18fb      	adds	r3, r7, r3
    a410:	701a      	strb	r2, [r3, #0]
			break;
    a412:	e02d      	b.n	a470 <nm_write_block+0xb4>
		}
		else
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], u16MaxTrxSz);
    a414:	68ba      	ldr	r2, [r7, #8]
    a416:	697b      	ldr	r3, [r7, #20]
    a418:	18d1      	adds	r1, r2, r3
    a41a:	2310      	movs	r3, #16
    a41c:	18fb      	adds	r3, r7, r3
    a41e:	881a      	ldrh	r2, [r3, #0]
    a420:	68fb      	ldr	r3, [r7, #12]
    a422:	0018      	movs	r0, r3
    a424:	4b17      	ldr	r3, [pc, #92]	; (a484 <nm_write_block+0xc8>)
    a426:	4798      	blx	r3
    a428:	0003      	movs	r3, r0
    a42a:	b2da      	uxtb	r2, r3
    a42c:	2313      	movs	r3, #19
    a42e:	18fb      	adds	r3, r7, r3
    a430:	781b      	ldrb	r3, [r3, #0]
    a432:	18d3      	adds	r3, r2, r3
    a434:	b2da      	uxtb	r2, r3
    a436:	2313      	movs	r3, #19
    a438:	18fb      	adds	r3, r7, r3
    a43a:	701a      	strb	r2, [r3, #0]
			if(M2M_SUCCESS != s8Ret) break;
    a43c:	2313      	movs	r3, #19
    a43e:	18fb      	adds	r3, r7, r3
    a440:	781b      	ldrb	r3, [r3, #0]
    a442:	b25b      	sxtb	r3, r3
    a444:	2b00      	cmp	r3, #0
    a446:	d112      	bne.n	a46e <nm_write_block+0xb2>
			u32Sz -= u16MaxTrxSz;
    a448:	2310      	movs	r3, #16
    a44a:	18fb      	adds	r3, r7, r3
    a44c:	881b      	ldrh	r3, [r3, #0]
    a44e:	687a      	ldr	r2, [r7, #4]
    a450:	1ad3      	subs	r3, r2, r3
    a452:	607b      	str	r3, [r7, #4]
			off += u16MaxTrxSz;
    a454:	2310      	movs	r3, #16
    a456:	18fb      	adds	r3, r7, r3
    a458:	881b      	ldrh	r3, [r3, #0]
    a45a:	697a      	ldr	r2, [r7, #20]
    a45c:	18d3      	adds	r3, r2, r3
    a45e:	617b      	str	r3, [r7, #20]
			u32Addr += u16MaxTrxSz;
    a460:	2310      	movs	r3, #16
    a462:	18fb      	adds	r3, r7, r3
    a464:	881b      	ldrh	r3, [r3, #0]
    a466:	68fa      	ldr	r2, [r7, #12]
    a468:	18d3      	adds	r3, r2, r3
    a46a:	60fb      	str	r3, [r7, #12]
		}
	}
    a46c:	e7b8      	b.n	a3e0 <nm_write_block+0x24>
			break;
		}
		else
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    a46e:	46c0      	nop			; (mov r8, r8)
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
    a470:	2313      	movs	r3, #19
    a472:	18fb      	adds	r3, r7, r3
    a474:	781b      	ldrb	r3, [r3, #0]
    a476:	b25b      	sxtb	r3, r3
}
    a478:	0018      	movs	r0, r3
    a47a:	46bd      	mov	sp, r7
    a47c:	b006      	add	sp, #24
    a47e:	bd80      	pop	{r7, pc}
    a480:	2000001c 	.word	0x2000001c
    a484:	0000a391 	.word	0x0000a391

0000a488 <nm_get_firmware_info>:
*	@param [out]	M2mRev
*			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
*	@version	1.0
*/
sint8 nm_get_firmware_info(tstrM2mRev* M2mRev)
{
    a488:	b590      	push	{r4, r7, lr}
    a48a:	b087      	sub	sp, #28
    a48c:	af00      	add	r7, sp, #0
    a48e:	6078      	str	r0, [r7, #4]
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
    a490:	2300      	movs	r3, #0
    a492:	60fb      	str	r3, [r7, #12]
	sint8	ret = M2M_SUCCESS;
    a494:	2317      	movs	r3, #23
    a496:	18fb      	adds	r3, r7, r3
    a498:	2200      	movs	r2, #0
    a49a:	701a      	strb	r2, [r3, #0]

	ret = nm_read_reg_with_ret(NMI_REV_REG, &reg);
    a49c:	2317      	movs	r3, #23
    a49e:	18fc      	adds	r4, r7, r3
    a4a0:	230c      	movs	r3, #12
    a4a2:	18fb      	adds	r3, r7, r3
    a4a4:	4a4c      	ldr	r2, [pc, #304]	; (a5d8 <nm_get_firmware_info+0x150>)
    a4a6:	0019      	movs	r1, r3
    a4a8:	0010      	movs	r0, r2
    a4aa:	4b4c      	ldr	r3, [pc, #304]	; (a5dc <nm_get_firmware_info+0x154>)
    a4ac:	4798      	blx	r3
    a4ae:	0003      	movs	r3, r0
    a4b0:	7023      	strb	r3, [r4, #0]
	//In case the Firmware running is ATE fw
	if(M2M_ATE_FW_IS_UP_VALUE == reg)
    a4b2:	68fb      	ldr	r3, [r7, #12]
    a4b4:	4a4a      	ldr	r2, [pc, #296]	; (a5e0 <nm_get_firmware_info+0x158>)
    a4b6:	4293      	cmp	r3, r2
    a4b8:	d10a      	bne.n	a4d0 <nm_get_firmware_info+0x48>
	{
		//Read FW info again from the register specified for ATE
		ret = nm_read_reg_with_ret(NMI_REV_REG_ATE, &reg);
    a4ba:	2317      	movs	r3, #23
    a4bc:	18fc      	adds	r4, r7, r3
    a4be:	230c      	movs	r3, #12
    a4c0:	18fb      	adds	r3, r7, r3
    a4c2:	4a48      	ldr	r2, [pc, #288]	; (a5e4 <nm_get_firmware_info+0x15c>)
    a4c4:	0019      	movs	r1, r3
    a4c6:	0010      	movs	r0, r2
    a4c8:	4b44      	ldr	r3, [pc, #272]	; (a5dc <nm_get_firmware_info+0x154>)
    a4ca:	4798      	blx	r3
    a4cc:	0003      	movs	r3, r0
    a4ce:	7023      	strb	r3, [r4, #0]
	}
	M2mRev->u8DriverMajor	= M2M_GET_DRV_MAJOR(reg);
    a4d0:	68fb      	ldr	r3, [r7, #12]
    a4d2:	0c1b      	lsrs	r3, r3, #16
    a4d4:	121b      	asrs	r3, r3, #8
    a4d6:	b2da      	uxtb	r2, r3
    a4d8:	687b      	ldr	r3, [r7, #4]
    a4da:	71da      	strb	r2, [r3, #7]
	M2mRev->u8DriverMinor   = M2M_GET_DRV_MINOR(reg);
    a4dc:	68fb      	ldr	r3, [r7, #12]
    a4de:	0c1b      	lsrs	r3, r3, #16
    a4e0:	111b      	asrs	r3, r3, #4
    a4e2:	b2db      	uxtb	r3, r3
    a4e4:	220f      	movs	r2, #15
    a4e6:	4013      	ands	r3, r2
    a4e8:	b2da      	uxtb	r2, r3
    a4ea:	687b      	ldr	r3, [r7, #4]
    a4ec:	721a      	strb	r2, [r3, #8]
	M2mRev->u8DriverPatch	= M2M_GET_DRV_PATCH(reg);
    a4ee:	68fb      	ldr	r3, [r7, #12]
    a4f0:	0c1b      	lsrs	r3, r3, #16
    a4f2:	b2db      	uxtb	r3, r3
    a4f4:	220f      	movs	r2, #15
    a4f6:	4013      	ands	r3, r2
    a4f8:	b2da      	uxtb	r2, r3
    a4fa:	687b      	ldr	r3, [r7, #4]
    a4fc:	725a      	strb	r2, [r3, #9]
	M2mRev->u8FirmwareMajor	= M2M_GET_FW_MAJOR(reg);
    a4fe:	68fb      	ldr	r3, [r7, #12]
    a500:	121b      	asrs	r3, r3, #8
    a502:	b2da      	uxtb	r2, r3
    a504:	687b      	ldr	r3, [r7, #4]
    a506:	711a      	strb	r2, [r3, #4]
	M2mRev->u8FirmwareMinor = M2M_GET_FW_MINOR(reg);
    a508:	68fb      	ldr	r3, [r7, #12]
    a50a:	111b      	asrs	r3, r3, #4
    a50c:	b2db      	uxtb	r3, r3
    a50e:	220f      	movs	r2, #15
    a510:	4013      	ands	r3, r2
    a512:	b2da      	uxtb	r2, r3
    a514:	687b      	ldr	r3, [r7, #4]
    a516:	715a      	strb	r2, [r3, #5]
	M2mRev->u8FirmwarePatch = M2M_GET_FW_PATCH(reg);
    a518:	68fb      	ldr	r3, [r7, #12]
    a51a:	b2db      	uxtb	r3, r3
    a51c:	220f      	movs	r2, #15
    a51e:	4013      	ands	r3, r2
    a520:	b2da      	uxtb	r2, r3
    a522:	687b      	ldr	r3, [r7, #4]
    a524:	719a      	strb	r2, [r3, #6]
	M2mRev->u32Chipid	= nmi_get_chipid();
    a526:	4b30      	ldr	r3, [pc, #192]	; (a5e8 <nm_get_firmware_info+0x160>)
    a528:	4798      	blx	r3
    a52a:	0002      	movs	r2, r0
    a52c:	687b      	ldr	r3, [r7, #4]
    a52e:	601a      	str	r2, [r3, #0]
	
	curr_firm_ver   = M2M_MAKE_VERSION(M2mRev->u8FirmwareMajor, M2mRev->u8FirmwareMinor,M2mRev->u8FirmwarePatch);
    a530:	687b      	ldr	r3, [r7, #4]
    a532:	791b      	ldrb	r3, [r3, #4]
    a534:	021b      	lsls	r3, r3, #8
    a536:	b21a      	sxth	r2, r3
    a538:	687b      	ldr	r3, [r7, #4]
    a53a:	795b      	ldrb	r3, [r3, #5]
    a53c:	011b      	lsls	r3, r3, #4
    a53e:	b21b      	sxth	r3, r3
    a540:	21ff      	movs	r1, #255	; 0xff
    a542:	400b      	ands	r3, r1
    a544:	b21b      	sxth	r3, r3
    a546:	4313      	orrs	r3, r2
    a548:	b21a      	sxth	r2, r3
    a54a:	687b      	ldr	r3, [r7, #4]
    a54c:	799b      	ldrb	r3, [r3, #6]
    a54e:	b21b      	sxth	r3, r3
    a550:	210f      	movs	r1, #15
    a552:	400b      	ands	r3, r1
    a554:	b21b      	sxth	r3, r3
    a556:	4313      	orrs	r3, r2
    a558:	b21a      	sxth	r2, r3
    a55a:	2314      	movs	r3, #20
    a55c:	18fb      	adds	r3, r7, r3
    a55e:	801a      	strh	r2, [r3, #0]
	curr_drv_ver    = M2M_MAKE_VERSION(M2M_DRIVER_VERSION_MAJOR_NO, M2M_DRIVER_VERSION_MINOR_NO, M2M_DRIVER_VERSION_PATCH_NO);
    a560:	2312      	movs	r3, #18
    a562:	18fb      	adds	r3, r7, r3
    a564:	4a21      	ldr	r2, [pc, #132]	; (a5ec <nm_get_firmware_info+0x164>)
    a566:	801a      	strh	r2, [r3, #0]
	min_req_drv_ver = M2M_MAKE_VERSION(M2mRev->u8DriverMajor, M2mRev->u8DriverMinor,M2mRev->u8DriverPatch);
    a568:	687b      	ldr	r3, [r7, #4]
    a56a:	79db      	ldrb	r3, [r3, #7]
    a56c:	021b      	lsls	r3, r3, #8
    a56e:	b21a      	sxth	r2, r3
    a570:	687b      	ldr	r3, [r7, #4]
    a572:	7a1b      	ldrb	r3, [r3, #8]
    a574:	011b      	lsls	r3, r3, #4
    a576:	b21b      	sxth	r3, r3
    a578:	21ff      	movs	r1, #255	; 0xff
    a57a:	400b      	ands	r3, r1
    a57c:	b21b      	sxth	r3, r3
    a57e:	4313      	orrs	r3, r2
    a580:	b21a      	sxth	r2, r3
    a582:	687b      	ldr	r3, [r7, #4]
    a584:	7a5b      	ldrb	r3, [r3, #9]
    a586:	b21b      	sxth	r3, r3
    a588:	210f      	movs	r1, #15
    a58a:	400b      	ands	r3, r1
    a58c:	b21b      	sxth	r3, r3
    a58e:	4313      	orrs	r3, r2
    a590:	b21a      	sxth	r2, r3
    a592:	2310      	movs	r3, #16
    a594:	18fb      	adds	r3, r7, r3
    a596:	801a      	strh	r2, [r3, #0]
	if(curr_drv_ver <  min_req_drv_ver) {
    a598:	2312      	movs	r3, #18
    a59a:	18fa      	adds	r2, r7, r3
    a59c:	2310      	movs	r3, #16
    a59e:	18fb      	adds	r3, r7, r3
    a5a0:	8812      	ldrh	r2, [r2, #0]
    a5a2:	881b      	ldrh	r3, [r3, #0]
    a5a4:	429a      	cmp	r2, r3
    a5a6:	d203      	bcs.n	a5b0 <nm_get_firmware_info+0x128>
		/*The current driver version should be larger or equal 
		than the min driver that the current firmware support  */
		ret = M2M_ERR_FW_VER_MISMATCH;
    a5a8:	2317      	movs	r3, #23
    a5aa:	18fb      	adds	r3, r7, r3
    a5ac:	22f3      	movs	r2, #243	; 0xf3
    a5ae:	701a      	strb	r2, [r3, #0]
	}
	if(curr_drv_ver >  curr_firm_ver) {
    a5b0:	2312      	movs	r3, #18
    a5b2:	18fa      	adds	r2, r7, r3
    a5b4:	2314      	movs	r3, #20
    a5b6:	18fb      	adds	r3, r7, r3
    a5b8:	8812      	ldrh	r2, [r2, #0]
    a5ba:	881b      	ldrh	r3, [r3, #0]
    a5bc:	429a      	cmp	r2, r3
    a5be:	d903      	bls.n	a5c8 <nm_get_firmware_info+0x140>
		/*The current driver should be equal or less than the firmware version*/
		ret = M2M_ERR_FW_VER_MISMATCH;
    a5c0:	2317      	movs	r3, #23
    a5c2:	18fb      	adds	r3, r7, r3
    a5c4:	22f3      	movs	r2, #243	; 0xf3
    a5c6:	701a      	strb	r2, [r3, #0]
	}
	return ret;
    a5c8:	2317      	movs	r3, #23
    a5ca:	18fb      	adds	r3, r7, r3
    a5cc:	781b      	ldrb	r3, [r3, #0]
    a5ce:	b25b      	sxtb	r3, r3
}
    a5d0:	0018      	movs	r0, r3
    a5d2:	46bd      	mov	sp, r7
    a5d4:	b007      	add	sp, #28
    a5d6:	bd90      	pop	{r4, r7, pc}
    a5d8:	000207ac 	.word	0x000207ac
    a5dc:	0000a251 	.word	0x0000a251
    a5e0:	d75dc1c3 	.word	0xd75dc1c3
    a5e4:	00001048 	.word	0x00001048
    a5e8:	00009e11 	.word	0x00009e11
    a5ec:	00001330 	.word	0x00001330

0000a5f0 <nm_drv_init>:
*	@author	M. Abdelmawla
*	@date	15 July 2012
*	@version	1.0
*/
sint8 nm_drv_init(void * arg)
{
    a5f0:	b590      	push	{r4, r7, lr}
    a5f2:	b085      	sub	sp, #20
    a5f4:	af00      	add	r7, sp, #0
    a5f6:	6078      	str	r0, [r7, #4]
	sint8 ret = M2M_SUCCESS;
    a5f8:	230f      	movs	r3, #15
    a5fa:	18fb      	adds	r3, r7, r3
    a5fc:	2200      	movs	r2, #0
    a5fe:	701a      	strb	r2, [r3, #0]
	uint8 u8Mode;
	
	if(NULL != arg) {
    a600:	687b      	ldr	r3, [r7, #4]
    a602:	2b00      	cmp	r3, #0
    a604:	d013      	beq.n	a62e <nm_drv_init+0x3e>
		u8Mode = *((uint8 *)arg);
    a606:	230e      	movs	r3, #14
    a608:	18fb      	adds	r3, r7, r3
    a60a:	687a      	ldr	r2, [r7, #4]
    a60c:	7812      	ldrb	r2, [r2, #0]
    a60e:	701a      	strb	r2, [r3, #0]
		if((u8Mode < M2M_WIFI_MODE_NORMAL)||(u8Mode >= M2M_WIFI_MODE_MAX)) {
    a610:	230e      	movs	r3, #14
    a612:	18fb      	adds	r3, r7, r3
    a614:	781b      	ldrb	r3, [r3, #0]
    a616:	2b00      	cmp	r3, #0
    a618:	d004      	beq.n	a624 <nm_drv_init+0x34>
    a61a:	230e      	movs	r3, #14
    a61c:	18fb      	adds	r3, r7, r3
    a61e:	781b      	ldrb	r3, [r3, #0]
    a620:	2b04      	cmp	r3, #4
    a622:	d908      	bls.n	a636 <nm_drv_init+0x46>
			u8Mode = M2M_WIFI_MODE_NORMAL;
    a624:	230e      	movs	r3, #14
    a626:	18fb      	adds	r3, r7, r3
    a628:	2201      	movs	r2, #1
    a62a:	701a      	strb	r2, [r3, #0]
    a62c:	e003      	b.n	a636 <nm_drv_init+0x46>
		}
	} else {
		u8Mode = M2M_WIFI_MODE_NORMAL;
    a62e:	230e      	movs	r3, #14
    a630:	18fb      	adds	r3, r7, r3
    a632:	2201      	movs	r2, #1
    a634:	701a      	strb	r2, [r3, #0]
	}
	
	ret = nm_bus_iface_init(NULL);
    a636:	230f      	movs	r3, #15
    a638:	18fc      	adds	r4, r7, r3
    a63a:	2000      	movs	r0, #0
    a63c:	4b2b      	ldr	r3, [pc, #172]	; (a6ec <nm_drv_init+0xfc>)
    a63e:	4798      	blx	r3
    a640:	0003      	movs	r3, r0
    a642:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    a644:	230f      	movs	r3, #15
    a646:	18fb      	adds	r3, r7, r3
    a648:	781b      	ldrb	r3, [r3, #0]
    a64a:	b25b      	sxtb	r3, r3
    a64c:	2b00      	cmp	r3, #0
    a64e:	d144      	bne.n	a6da <nm_drv_init+0xea>
	}
#endif
	M2M_INFO("Chip ID %lx\n", nmi_get_chipid());
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_init();
    a650:	4b27      	ldr	r3, [pc, #156]	; (a6f0 <nm_drv_init+0x100>)
    a652:	4798      	blx	r3
	ret = cpu_start();
	if (M2M_SUCCESS != ret) {
		goto ERR2;
	}
#endif
	ret = wait_for_bootrom(u8Mode);
    a654:	230f      	movs	r3, #15
    a656:	18fc      	adds	r4, r7, r3
    a658:	230e      	movs	r3, #14
    a65a:	18fb      	adds	r3, r7, r3
    a65c:	781b      	ldrb	r3, [r3, #0]
    a65e:	0018      	movs	r0, r3
    a660:	4b24      	ldr	r3, [pc, #144]	; (a6f4 <nm_drv_init+0x104>)
    a662:	4798      	blx	r3
    a664:	0003      	movs	r3, r0
    a666:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    a668:	230f      	movs	r3, #15
    a66a:	18fb      	adds	r3, r7, r3
    a66c:	781b      	ldrb	r3, [r3, #0]
    a66e:	b25b      	sxtb	r3, r3
    a670:	2b00      	cmp	r3, #0
    a672:	d12a      	bne.n	a6ca <nm_drv_init+0xda>
		goto ERR2;
	}
		
	ret = wait_for_firmware_start(u8Mode);
    a674:	230f      	movs	r3, #15
    a676:	18fc      	adds	r4, r7, r3
    a678:	230e      	movs	r3, #14
    a67a:	18fb      	adds	r3, r7, r3
    a67c:	781b      	ldrb	r3, [r3, #0]
    a67e:	0018      	movs	r0, r3
    a680:	4b1d      	ldr	r3, [pc, #116]	; (a6f8 <nm_drv_init+0x108>)
    a682:	4798      	blx	r3
    a684:	0003      	movs	r3, r0
    a686:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    a688:	230f      	movs	r3, #15
    a68a:	18fb      	adds	r3, r7, r3
    a68c:	781b      	ldrb	r3, [r3, #0]
    a68e:	b25b      	sxtb	r3, r3
    a690:	2b00      	cmp	r3, #0
    a692:	d11c      	bne.n	a6ce <nm_drv_init+0xde>
		goto ERR2;
	}
	
	if((M2M_WIFI_MODE_ATE_HIGH == u8Mode)||(M2M_WIFI_MODE_ATE_LOW == u8Mode)) {
    a694:	230e      	movs	r3, #14
    a696:	18fb      	adds	r3, r7, r3
    a698:	781b      	ldrb	r3, [r3, #0]
    a69a:	2b02      	cmp	r3, #2
    a69c:	d01e      	beq.n	a6dc <nm_drv_init+0xec>
    a69e:	230e      	movs	r3, #14
    a6a0:	18fb      	adds	r3, r7, r3
    a6a2:	781b      	ldrb	r3, [r3, #0]
    a6a4:	2b03      	cmp	r3, #3
    a6a6:	d019      	beq.n	a6dc <nm_drv_init+0xec>
		goto ERR1;
	} else {
		/*continue running*/
	}
	
	ret = enable_interrupts();
    a6a8:	230f      	movs	r3, #15
    a6aa:	18fc      	adds	r4, r7, r3
    a6ac:	4b13      	ldr	r3, [pc, #76]	; (a6fc <nm_drv_init+0x10c>)
    a6ae:	4798      	blx	r3
    a6b0:	0003      	movs	r3, r0
    a6b2:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    a6b4:	230f      	movs	r3, #15
    a6b6:	18fb      	adds	r3, r7, r3
    a6b8:	781b      	ldrb	r3, [r3, #0]
    a6ba:	b25b      	sxtb	r3, r3
    a6bc:	2b00      	cmp	r3, #0
    a6be:	d108      	bne.n	a6d2 <nm_drv_init+0xe2>
		M2M_ERR("failed to enable interrupts..\n");
		goto ERR2;
	}
	
	return ret;
    a6c0:	230f      	movs	r3, #15
    a6c2:	18fb      	adds	r3, r7, r3
    a6c4:	781b      	ldrb	r3, [r3, #0]
    a6c6:	b25b      	sxtb	r3, r3
    a6c8:	e00c      	b.n	a6e4 <nm_drv_init+0xf4>
		goto ERR2;
	}
#endif
	ret = wait_for_bootrom(u8Mode);
	if (M2M_SUCCESS != ret) {
		goto ERR2;
    a6ca:	46c0      	nop			; (mov r8, r8)
    a6cc:	e002      	b.n	a6d4 <nm_drv_init+0xe4>
	}
		
	ret = wait_for_firmware_start(u8Mode);
	if (M2M_SUCCESS != ret) {
		goto ERR2;
    a6ce:	46c0      	nop			; (mov r8, r8)
    a6d0:	e000      	b.n	a6d4 <nm_drv_init+0xe4>
	}
	
	ret = enable_interrupts();
	if (M2M_SUCCESS != ret) {
		M2M_ERR("failed to enable interrupts..\n");
		goto ERR2;
    a6d2:	46c0      	nop			; (mov r8, r8)
	}
	
	return ret;
ERR2:
	nm_bus_iface_deinit();
    a6d4:	4b0a      	ldr	r3, [pc, #40]	; (a700 <nm_drv_init+0x110>)
    a6d6:	4798      	blx	r3
    a6d8:	e000      	b.n	a6dc <nm_drv_init+0xec>
	}
	
	ret = nm_bus_iface_init(NULL);
	if (M2M_SUCCESS != ret) {
		M2M_ERR("[nmi start]: fail init bus\n");
		goto ERR1;
    a6da:	46c0      	nop			; (mov r8, r8)
	
	return ret;
ERR2:
	nm_bus_iface_deinit();
ERR1:
	return ret;
    a6dc:	230f      	movs	r3, #15
    a6de:	18fb      	adds	r3, r7, r3
    a6e0:	781b      	ldrb	r3, [r3, #0]
    a6e2:	b25b      	sxtb	r3, r3
}
    a6e4:	0018      	movs	r0, r3
    a6e6:	46bd      	mov	sp, r7
    a6e8:	b005      	add	sp, #20
    a6ea:	bd90      	pop	{r4, r7, pc}
    a6ec:	0000a1d5 	.word	0x0000a1d5
    a6f0:	0000b2f9 	.word	0x0000b2f9
    a6f4:	00009f09 	.word	0x00009f09
    a6f8:	0000a051 	.word	0x0000a051
    a6fc:	00009d55 	.word	0x00009d55
    a700:	0000a209 	.word	0x0000a209

0000a704 <nm_drv_deinit>:
*	@author	M. Abdelmawla
*	@date	17 July 2012
*	@version	1.0
*/
sint8 nm_drv_deinit(void * arg)
{
    a704:	b590      	push	{r4, r7, lr}
    a706:	b085      	sub	sp, #20
    a708:	af00      	add	r7, sp, #0
    a70a:	6078      	str	r0, [r7, #4]
	sint8 ret;

	ret = chip_deinit();
    a70c:	230f      	movs	r3, #15
    a70e:	18fc      	adds	r4, r7, r3
    a710:	4b19      	ldr	r3, [pc, #100]	; (a778 <nm_drv_deinit+0x74>)
    a712:	4798      	blx	r3
    a714:	0003      	movs	r3, r0
    a716:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    a718:	230f      	movs	r3, #15
    a71a:	18fb      	adds	r3, r7, r3
    a71c:	781b      	ldrb	r3, [r3, #0]
    a71e:	b25b      	sxtb	r3, r3
    a720:	2b00      	cmp	r3, #0
    a722:	d11b      	bne.n	a75c <nm_drv_deinit+0x58>
		M2M_ERR("[nmi stop]: chip_deinit fail\n");
		goto ERR1;
	}
	
	/* Disable SPI flash to save power when the chip is off */
	ret = spi_flash_enable(0);
    a724:	230f      	movs	r3, #15
    a726:	18fc      	adds	r4, r7, r3
    a728:	2000      	movs	r0, #0
    a72a:	4b14      	ldr	r3, [pc, #80]	; (a77c <nm_drv_deinit+0x78>)
    a72c:	4798      	blx	r3
    a72e:	0003      	movs	r3, r0
    a730:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    a732:	230f      	movs	r3, #15
    a734:	18fb      	adds	r3, r7, r3
    a736:	781b      	ldrb	r3, [r3, #0]
    a738:	b25b      	sxtb	r3, r3
    a73a:	2b00      	cmp	r3, #0
    a73c:	d110      	bne.n	a760 <nm_drv_deinit+0x5c>
		M2M_ERR("[nmi stop]: SPI flash disable fail\n");
		goto ERR1;
	}

	ret = nm_bus_iface_deinit();
    a73e:	230f      	movs	r3, #15
    a740:	18fc      	adds	r4, r7, r3
    a742:	4b0f      	ldr	r3, [pc, #60]	; (a780 <nm_drv_deinit+0x7c>)
    a744:	4798      	blx	r3
    a746:	0003      	movs	r3, r0
    a748:	7023      	strb	r3, [r4, #0]
	if (M2M_SUCCESS != ret) {
    a74a:	230f      	movs	r3, #15
    a74c:	18fb      	adds	r3, r7, r3
    a74e:	781b      	ldrb	r3, [r3, #0]
    a750:	b25b      	sxtb	r3, r3
    a752:	2b00      	cmp	r3, #0
    a754:	d106      	bne.n	a764 <nm_drv_deinit+0x60>
		M2M_ERR("[nmi stop]: fail init bus\n");
		goto ERR1;
	}
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_deinit();
    a756:	4b0b      	ldr	r3, [pc, #44]	; (a784 <nm_drv_deinit+0x80>)
    a758:	4798      	blx	r3
    a75a:	e004      	b.n	a766 <nm_drv_deinit+0x62>
	sint8 ret;

	ret = chip_deinit();
	if (M2M_SUCCESS != ret) {
		M2M_ERR("[nmi stop]: chip_deinit fail\n");
		goto ERR1;
    a75c:	46c0      	nop			; (mov r8, r8)
    a75e:	e002      	b.n	a766 <nm_drv_deinit+0x62>
	
	/* Disable SPI flash to save power when the chip is off */
	ret = spi_flash_enable(0);
	if (M2M_SUCCESS != ret) {
		M2M_ERR("[nmi stop]: SPI flash disable fail\n");
		goto ERR1;
    a760:	46c0      	nop			; (mov r8, r8)
    a762:	e000      	b.n	a766 <nm_drv_deinit+0x62>
	}

	ret = nm_bus_iface_deinit();
	if (M2M_SUCCESS != ret) {
		M2M_ERR("[nmi stop]: fail init bus\n");
		goto ERR1;
    a764:	46c0      	nop			; (mov r8, r8)
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_deinit();
#endif

ERR1:
	return ret;
    a766:	230f      	movs	r3, #15
    a768:	18fb      	adds	r3, r7, r3
    a76a:	781b      	ldrb	r3, [r3, #0]
    a76c:	b25b      	sxtb	r3, r3
}
    a76e:	0018      	movs	r0, r3
    a770:	46bd      	mov	sp, r7
    a772:	b005      	add	sp, #20
    a774:	bd90      	pop	{r4, r7, pc}
    a776:	46c0      	nop			; (mov r8, r8)
    a778:	0000a105 	.word	0x0000a105
    a77c:	0000bb61 	.word	0x0000bb61
    a780:	0000a209 	.word	0x0000a209
    a784:	0000b3a9 	.word	0x0000b3a9

0000a788 <nmi_spi_read>:
#define DATA_PKT_SZ				DATA_PKT_SZ_8K

static uint8 	gu8Crc_off	=   0;

static sint8 nmi_spi_read(uint8* b, uint16 sz)
{
    a788:	b580      	push	{r7, lr}
    a78a:	b086      	sub	sp, #24
    a78c:	af00      	add	r7, sp, #0
    a78e:	6078      	str	r0, [r7, #4]
    a790:	000a      	movs	r2, r1
    a792:	1cbb      	adds	r3, r7, #2
    a794:	801a      	strh	r2, [r3, #0]
	tstrNmSpiRw spi;
	spi.pu8InBuf = NULL;
    a796:	230c      	movs	r3, #12
    a798:	18fb      	adds	r3, r7, r3
    a79a:	2200      	movs	r2, #0
    a79c:	601a      	str	r2, [r3, #0]
	spi.pu8OutBuf = b;
    a79e:	230c      	movs	r3, #12
    a7a0:	18fb      	adds	r3, r7, r3
    a7a2:	687a      	ldr	r2, [r7, #4]
    a7a4:	605a      	str	r2, [r3, #4]
	spi.u16Sz = sz;
    a7a6:	230c      	movs	r3, #12
    a7a8:	18fb      	adds	r3, r7, r3
    a7aa:	1cba      	adds	r2, r7, #2
    a7ac:	8812      	ldrh	r2, [r2, #0]
    a7ae:	811a      	strh	r2, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    a7b0:	230c      	movs	r3, #12
    a7b2:	18fb      	adds	r3, r7, r3
    a7b4:	0019      	movs	r1, r3
    a7b6:	2003      	movs	r0, #3
    a7b8:	4b03      	ldr	r3, [pc, #12]	; (a7c8 <nmi_spi_read+0x40>)
    a7ba:	4798      	blx	r3
    a7bc:	0003      	movs	r3, r0
}
    a7be:	0018      	movs	r0, r3
    a7c0:	46bd      	mov	sp, r7
    a7c2:	b006      	add	sp, #24
    a7c4:	bd80      	pop	{r7, pc}
    a7c6:	46c0      	nop			; (mov r8, r8)
    a7c8:	00008afd 	.word	0x00008afd

0000a7cc <nmi_spi_write>:

static sint8 nmi_spi_write(uint8* b, uint16 sz)
{
    a7cc:	b580      	push	{r7, lr}
    a7ce:	b086      	sub	sp, #24
    a7d0:	af00      	add	r7, sp, #0
    a7d2:	6078      	str	r0, [r7, #4]
    a7d4:	000a      	movs	r2, r1
    a7d6:	1cbb      	adds	r3, r7, #2
    a7d8:	801a      	strh	r2, [r3, #0]
	tstrNmSpiRw spi;
	spi.pu8InBuf = b;
    a7da:	230c      	movs	r3, #12
    a7dc:	18fb      	adds	r3, r7, r3
    a7de:	687a      	ldr	r2, [r7, #4]
    a7e0:	601a      	str	r2, [r3, #0]
	spi.pu8OutBuf = NULL;
    a7e2:	230c      	movs	r3, #12
    a7e4:	18fb      	adds	r3, r7, r3
    a7e6:	2200      	movs	r2, #0
    a7e8:	605a      	str	r2, [r3, #4]
	spi.u16Sz = sz;
    a7ea:	230c      	movs	r3, #12
    a7ec:	18fb      	adds	r3, r7, r3
    a7ee:	1cba      	adds	r2, r7, #2
    a7f0:	8812      	ldrh	r2, [r2, #0]
    a7f2:	811a      	strh	r2, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    a7f4:	230c      	movs	r3, #12
    a7f6:	18fb      	adds	r3, r7, r3
    a7f8:	0019      	movs	r1, r3
    a7fa:	2003      	movs	r0, #3
    a7fc:	4b03      	ldr	r3, [pc, #12]	; (a80c <nmi_spi_write+0x40>)
    a7fe:	4798      	blx	r3
    a800:	0003      	movs	r3, r0
}
    a802:	0018      	movs	r0, r3
    a804:	46bd      	mov	sp, r7
    a806:	b006      	add	sp, #24
    a808:	bd80      	pop	{r7, pc}
    a80a:	46c0      	nop			; (mov r8, r8)
    a80c:	00008afd 	.word	0x00008afd

0000a810 <crc7_byte>:
	0x46, 0x4f, 0x54, 0x5d, 0x62, 0x6b, 0x70, 0x79
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
    a810:	b580      	push	{r7, lr}
    a812:	b082      	sub	sp, #8
    a814:	af00      	add	r7, sp, #0
    a816:	0002      	movs	r2, r0
    a818:	1dfb      	adds	r3, r7, #7
    a81a:	701a      	strb	r2, [r3, #0]
    a81c:	1dbb      	adds	r3, r7, #6
    a81e:	1c0a      	adds	r2, r1, #0
    a820:	701a      	strb	r2, [r3, #0]
	return crc7_syndrome_table[(crc << 1) ^ data];
    a822:	1dfb      	adds	r3, r7, #7
    a824:	781b      	ldrb	r3, [r3, #0]
    a826:	005a      	lsls	r2, r3, #1
    a828:	1dbb      	adds	r3, r7, #6
    a82a:	781b      	ldrb	r3, [r3, #0]
    a82c:	4053      	eors	r3, r2
    a82e:	4a03      	ldr	r2, [pc, #12]	; (a83c <crc7_byte+0x2c>)
    a830:	5cd3      	ldrb	r3, [r2, r3]
}
    a832:	0018      	movs	r0, r3
    a834:	46bd      	mov	sp, r7
    a836:	b002      	add	sp, #8
    a838:	bd80      	pop	{r7, pc}
    a83a:	46c0      	nop			; (mov r8, r8)
    a83c:	00020c8c 	.word	0x00020c8c

0000a840 <crc7>:

static uint8 crc7(uint8 crc, const uint8 *buffer, uint32 len)
{
    a840:	b590      	push	{r4, r7, lr}
    a842:	b085      	sub	sp, #20
    a844:	af00      	add	r7, sp, #0
    a846:	60b9      	str	r1, [r7, #8]
    a848:	607a      	str	r2, [r7, #4]
    a84a:	230f      	movs	r3, #15
    a84c:	18fb      	adds	r3, r7, r3
    a84e:	1c02      	adds	r2, r0, #0
    a850:	701a      	strb	r2, [r3, #0]
	while (len--)
    a852:	e00e      	b.n	a872 <crc7+0x32>
		crc = crc7_byte(crc, *buffer++);
    a854:	68bb      	ldr	r3, [r7, #8]
    a856:	1c5a      	adds	r2, r3, #1
    a858:	60ba      	str	r2, [r7, #8]
    a85a:	781a      	ldrb	r2, [r3, #0]
    a85c:	230f      	movs	r3, #15
    a85e:	18fc      	adds	r4, r7, r3
    a860:	230f      	movs	r3, #15
    a862:	18fb      	adds	r3, r7, r3
    a864:	781b      	ldrb	r3, [r3, #0]
    a866:	0011      	movs	r1, r2
    a868:	0018      	movs	r0, r3
    a86a:	4b08      	ldr	r3, [pc, #32]	; (a88c <crc7+0x4c>)
    a86c:	4798      	blx	r3
    a86e:	0003      	movs	r3, r0
    a870:	7023      	strb	r3, [r4, #0]
	return crc7_syndrome_table[(crc << 1) ^ data];
}

static uint8 crc7(uint8 crc, const uint8 *buffer, uint32 len)
{
	while (len--)
    a872:	687b      	ldr	r3, [r7, #4]
    a874:	1e5a      	subs	r2, r3, #1
    a876:	607a      	str	r2, [r7, #4]
    a878:	2b00      	cmp	r3, #0
    a87a:	d1eb      	bne.n	a854 <crc7+0x14>
		crc = crc7_byte(crc, *buffer++);
	return crc;
    a87c:	230f      	movs	r3, #15
    a87e:	18fb      	adds	r3, r7, r3
    a880:	781b      	ldrb	r3, [r3, #0]
}
    a882:	0018      	movs	r0, r3
    a884:	46bd      	mov	sp, r7
    a886:	b005      	add	sp, #20
    a888:	bd90      	pop	{r4, r7, pc}
    a88a:	46c0      	nop			; (mov r8, r8)
    a88c:	0000a811 	.word	0x0000a811

0000a890 <spi_cmd>:
	Spi protocol Function

********************************************/

static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 clockless)
{
    a890:	b590      	push	{r4, r7, lr}
    a892:	b089      	sub	sp, #36	; 0x24
    a894:	af00      	add	r7, sp, #0
    a896:	60b9      	str	r1, [r7, #8]
    a898:	607a      	str	r2, [r7, #4]
    a89a:	603b      	str	r3, [r7, #0]
    a89c:	230f      	movs	r3, #15
    a89e:	18fb      	adds	r3, r7, r3
    a8a0:	1c02      	adds	r2, r0, #0
    a8a2:	701a      	strb	r2, [r3, #0]
	uint8 bc[9];
	uint8 len = 5;
    a8a4:	231f      	movs	r3, #31
    a8a6:	18fb      	adds	r3, r7, r3
    a8a8:	2205      	movs	r2, #5
    a8aa:	701a      	strb	r2, [r3, #0]
	sint8 result = N_OK;
    a8ac:	231e      	movs	r3, #30
    a8ae:	18fb      	adds	r3, r7, r3
    a8b0:	2201      	movs	r2, #1
    a8b2:	701a      	strb	r2, [r3, #0]

	bc[0] = cmd;
    a8b4:	2314      	movs	r3, #20
    a8b6:	18fb      	adds	r3, r7, r3
    a8b8:	220f      	movs	r2, #15
    a8ba:	18ba      	adds	r2, r7, r2
    a8bc:	7812      	ldrb	r2, [r2, #0]
    a8be:	701a      	strb	r2, [r3, #0]
	switch (cmd) {
    a8c0:	230f      	movs	r3, #15
    a8c2:	18fb      	adds	r3, r7, r3
    a8c4:	781b      	ldrb	r3, [r3, #0]
    a8c6:	3bc1      	subs	r3, #193	; 0xc1
    a8c8:	2b0e      	cmp	r3, #14
    a8ca:	d900      	bls.n	a8ce <spi_cmd+0x3e>
    a8cc:	e11b      	b.n	ab06 <spi_cmd+0x276>
    a8ce:	009a      	lsls	r2, r3, #2
    a8d0:	4baf      	ldr	r3, [pc, #700]	; (ab90 <spi_cmd+0x300>)
    a8d2:	18d3      	adds	r3, r2, r3
    a8d4:	681b      	ldr	r3, [r3, #0]
    a8d6:	469f      	mov	pc, r3
	case CMD_SINGLE_READ:				/* single word (4 bytes) read */
		bc[1] = (uint8)(adr >> 16);
    a8d8:	68bb      	ldr	r3, [r7, #8]
    a8da:	0c1b      	lsrs	r3, r3, #16
    a8dc:	b2da      	uxtb	r2, r3
    a8de:	2314      	movs	r3, #20
    a8e0:	18fb      	adds	r3, r7, r3
    a8e2:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    a8e4:	68bb      	ldr	r3, [r7, #8]
    a8e6:	0a1b      	lsrs	r3, r3, #8
    a8e8:	b2da      	uxtb	r2, r3
    a8ea:	2314      	movs	r3, #20
    a8ec:	18fb      	adds	r3, r7, r3
    a8ee:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)adr;
    a8f0:	68bb      	ldr	r3, [r7, #8]
    a8f2:	b2da      	uxtb	r2, r3
    a8f4:	2314      	movs	r3, #20
    a8f6:	18fb      	adds	r3, r7, r3
    a8f8:	70da      	strb	r2, [r3, #3]
		len = 5;
    a8fa:	231f      	movs	r3, #31
    a8fc:	18fb      	adds	r3, r7, r3
    a8fe:	2205      	movs	r2, #5
    a900:	701a      	strb	r2, [r3, #0]
		break;
    a902:	e105      	b.n	ab10 <spi_cmd+0x280>
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
    a904:	68bb      	ldr	r3, [r7, #8]
    a906:	0a1b      	lsrs	r3, r3, #8
    a908:	b2da      	uxtb	r2, r3
    a90a:	2314      	movs	r3, #20
    a90c:	18fb      	adds	r3, r7, r3
    a90e:	705a      	strb	r2, [r3, #1]
		if(clockless)  bc[1] |= (1 << 7);
    a910:	2330      	movs	r3, #48	; 0x30
    a912:	18fb      	adds	r3, r7, r3
    a914:	781b      	ldrb	r3, [r3, #0]
    a916:	2b00      	cmp	r3, #0
    a918:	d009      	beq.n	a92e <spi_cmd+0x9e>
    a91a:	2314      	movs	r3, #20
    a91c:	18fb      	adds	r3, r7, r3
    a91e:	785b      	ldrb	r3, [r3, #1]
    a920:	2280      	movs	r2, #128	; 0x80
    a922:	4252      	negs	r2, r2
    a924:	4313      	orrs	r3, r2
    a926:	b2da      	uxtb	r2, r3
    a928:	2314      	movs	r3, #20
    a92a:	18fb      	adds	r3, r7, r3
    a92c:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)adr;
    a92e:	68bb      	ldr	r3, [r7, #8]
    a930:	b2da      	uxtb	r2, r3
    a932:	2314      	movs	r3, #20
    a934:	18fb      	adds	r3, r7, r3
    a936:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    a938:	2314      	movs	r3, #20
    a93a:	18fb      	adds	r3, r7, r3
    a93c:	2200      	movs	r2, #0
    a93e:	70da      	strb	r2, [r3, #3]
		len = 5;
    a940:	231f      	movs	r3, #31
    a942:	18fb      	adds	r3, r7, r3
    a944:	2205      	movs	r2, #5
    a946:	701a      	strb	r2, [r3, #0]
		break;
    a948:	e0e2      	b.n	ab10 <spi_cmd+0x280>
	case CMD_TERMINATE:					/* termination */
		bc[1] = 0x00;
    a94a:	2314      	movs	r3, #20
    a94c:	18fb      	adds	r3, r7, r3
    a94e:	2200      	movs	r2, #0
    a950:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    a952:	2314      	movs	r3, #20
    a954:	18fb      	adds	r3, r7, r3
    a956:	2200      	movs	r2, #0
    a958:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    a95a:	2314      	movs	r3, #20
    a95c:	18fb      	adds	r3, r7, r3
    a95e:	2200      	movs	r2, #0
    a960:	70da      	strb	r2, [r3, #3]
		len = 5;
    a962:	231f      	movs	r3, #31
    a964:	18fb      	adds	r3, r7, r3
    a966:	2205      	movs	r2, #5
    a968:	701a      	strb	r2, [r3, #0]
		break;
    a96a:	e0d1      	b.n	ab10 <spi_cmd+0x280>
	case CMD_REPEAT:						/* repeat */
		bc[1] = 0x00;
    a96c:	2314      	movs	r3, #20
    a96e:	18fb      	adds	r3, r7, r3
    a970:	2200      	movs	r2, #0
    a972:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    a974:	2314      	movs	r3, #20
    a976:	18fb      	adds	r3, r7, r3
    a978:	2200      	movs	r2, #0
    a97a:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    a97c:	2314      	movs	r3, #20
    a97e:	18fb      	adds	r3, r7, r3
    a980:	2200      	movs	r2, #0
    a982:	70da      	strb	r2, [r3, #3]
		len = 5;
    a984:	231f      	movs	r3, #31
    a986:	18fb      	adds	r3, r7, r3
    a988:	2205      	movs	r2, #5
    a98a:	701a      	strb	r2, [r3, #0]
		break;
    a98c:	e0c0      	b.n	ab10 <spi_cmd+0x280>
	case CMD_RESET:							/* reset */
		bc[1] = 0xff;
    a98e:	2314      	movs	r3, #20
    a990:	18fb      	adds	r3, r7, r3
    a992:	22ff      	movs	r2, #255	; 0xff
    a994:	705a      	strb	r2, [r3, #1]
		bc[2] = 0xff;
    a996:	2314      	movs	r3, #20
    a998:	18fb      	adds	r3, r7, r3
    a99a:	22ff      	movs	r2, #255	; 0xff
    a99c:	709a      	strb	r2, [r3, #2]
		bc[3] = 0xff;
    a99e:	2314      	movs	r3, #20
    a9a0:	18fb      	adds	r3, r7, r3
    a9a2:	22ff      	movs	r2, #255	; 0xff
    a9a4:	70da      	strb	r2, [r3, #3]
		len = 5;
    a9a6:	231f      	movs	r3, #31
    a9a8:	18fb      	adds	r3, r7, r3
    a9aa:	2205      	movs	r2, #5
    a9ac:	701a      	strb	r2, [r3, #0]
		break;
    a9ae:	e0af      	b.n	ab10 <spi_cmd+0x280>
	case CMD_DMA_WRITE:					/* dma write */
	case CMD_DMA_READ:					/* dma read */
		bc[1] = (uint8)(adr >> 16);
    a9b0:	68bb      	ldr	r3, [r7, #8]
    a9b2:	0c1b      	lsrs	r3, r3, #16
    a9b4:	b2da      	uxtb	r2, r3
    a9b6:	2314      	movs	r3, #20
    a9b8:	18fb      	adds	r3, r7, r3
    a9ba:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    a9bc:	68bb      	ldr	r3, [r7, #8]
    a9be:	0a1b      	lsrs	r3, r3, #8
    a9c0:	b2da      	uxtb	r2, r3
    a9c2:	2314      	movs	r3, #20
    a9c4:	18fb      	adds	r3, r7, r3
    a9c6:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)adr;
    a9c8:	68bb      	ldr	r3, [r7, #8]
    a9ca:	b2da      	uxtb	r2, r3
    a9cc:	2314      	movs	r3, #20
    a9ce:	18fb      	adds	r3, r7, r3
    a9d0:	70da      	strb	r2, [r3, #3]
		bc[4] = (uint8)(sz >> 8);
    a9d2:	683b      	ldr	r3, [r7, #0]
    a9d4:	0a1b      	lsrs	r3, r3, #8
    a9d6:	b2da      	uxtb	r2, r3
    a9d8:	2314      	movs	r3, #20
    a9da:	18fb      	adds	r3, r7, r3
    a9dc:	711a      	strb	r2, [r3, #4]
		bc[5] = (uint8)(sz);
    a9de:	683b      	ldr	r3, [r7, #0]
    a9e0:	b2da      	uxtb	r2, r3
    a9e2:	2314      	movs	r3, #20
    a9e4:	18fb      	adds	r3, r7, r3
    a9e6:	715a      	strb	r2, [r3, #5]
		len = 7;
    a9e8:	231f      	movs	r3, #31
    a9ea:	18fb      	adds	r3, r7, r3
    a9ec:	2207      	movs	r2, #7
    a9ee:	701a      	strb	r2, [r3, #0]
		break;
    a9f0:	e08e      	b.n	ab10 <spi_cmd+0x280>
	case CMD_DMA_EXT_WRITE:		/* dma extended write */
	case CMD_DMA_EXT_READ:			/* dma extended read */
		bc[1] = (uint8)(adr >> 16);
    a9f2:	68bb      	ldr	r3, [r7, #8]
    a9f4:	0c1b      	lsrs	r3, r3, #16
    a9f6:	b2da      	uxtb	r2, r3
    a9f8:	2314      	movs	r3, #20
    a9fa:	18fb      	adds	r3, r7, r3
    a9fc:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    a9fe:	68bb      	ldr	r3, [r7, #8]
    aa00:	0a1b      	lsrs	r3, r3, #8
    aa02:	b2da      	uxtb	r2, r3
    aa04:	2314      	movs	r3, #20
    aa06:	18fb      	adds	r3, r7, r3
    aa08:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)adr;
    aa0a:	68bb      	ldr	r3, [r7, #8]
    aa0c:	b2da      	uxtb	r2, r3
    aa0e:	2314      	movs	r3, #20
    aa10:	18fb      	adds	r3, r7, r3
    aa12:	70da      	strb	r2, [r3, #3]
		bc[4] = (uint8)(sz >> 16);
    aa14:	683b      	ldr	r3, [r7, #0]
    aa16:	0c1b      	lsrs	r3, r3, #16
    aa18:	b2da      	uxtb	r2, r3
    aa1a:	2314      	movs	r3, #20
    aa1c:	18fb      	adds	r3, r7, r3
    aa1e:	711a      	strb	r2, [r3, #4]
		bc[5] = (uint8)(sz >> 8);
    aa20:	683b      	ldr	r3, [r7, #0]
    aa22:	0a1b      	lsrs	r3, r3, #8
    aa24:	b2da      	uxtb	r2, r3
    aa26:	2314      	movs	r3, #20
    aa28:	18fb      	adds	r3, r7, r3
    aa2a:	715a      	strb	r2, [r3, #5]
		bc[6] = (uint8)(sz);
    aa2c:	683b      	ldr	r3, [r7, #0]
    aa2e:	b2da      	uxtb	r2, r3
    aa30:	2314      	movs	r3, #20
    aa32:	18fb      	adds	r3, r7, r3
    aa34:	719a      	strb	r2, [r3, #6]
		len = 8;
    aa36:	231f      	movs	r3, #31
    aa38:	18fb      	adds	r3, r7, r3
    aa3a:	2208      	movs	r2, #8
    aa3c:	701a      	strb	r2, [r3, #0]
		break;
    aa3e:	e067      	b.n	ab10 <spi_cmd+0x280>
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
    aa40:	68bb      	ldr	r3, [r7, #8]
    aa42:	0a1b      	lsrs	r3, r3, #8
    aa44:	b2da      	uxtb	r2, r3
    aa46:	2314      	movs	r3, #20
    aa48:	18fb      	adds	r3, r7, r3
    aa4a:	705a      	strb	r2, [r3, #1]
		if(clockless)  bc[1] |= (1 << 7);
    aa4c:	2330      	movs	r3, #48	; 0x30
    aa4e:	18fb      	adds	r3, r7, r3
    aa50:	781b      	ldrb	r3, [r3, #0]
    aa52:	2b00      	cmp	r3, #0
    aa54:	d009      	beq.n	aa6a <spi_cmd+0x1da>
    aa56:	2314      	movs	r3, #20
    aa58:	18fb      	adds	r3, r7, r3
    aa5a:	785b      	ldrb	r3, [r3, #1]
    aa5c:	2280      	movs	r2, #128	; 0x80
    aa5e:	4252      	negs	r2, r2
    aa60:	4313      	orrs	r3, r2
    aa62:	b2da      	uxtb	r2, r3
    aa64:	2314      	movs	r3, #20
    aa66:	18fb      	adds	r3, r7, r3
    aa68:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr);
    aa6a:	68bb      	ldr	r3, [r7, #8]
    aa6c:	b2da      	uxtb	r2, r3
    aa6e:	2314      	movs	r3, #20
    aa70:	18fb      	adds	r3, r7, r3
    aa72:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)(u32data >> 24);
    aa74:	687b      	ldr	r3, [r7, #4]
    aa76:	0e1b      	lsrs	r3, r3, #24
    aa78:	b2da      	uxtb	r2, r3
    aa7a:	2314      	movs	r3, #20
    aa7c:	18fb      	adds	r3, r7, r3
    aa7e:	70da      	strb	r2, [r3, #3]
		bc[4] = (uint8)(u32data >> 16);
    aa80:	687b      	ldr	r3, [r7, #4]
    aa82:	0c1b      	lsrs	r3, r3, #16
    aa84:	b2da      	uxtb	r2, r3
    aa86:	2314      	movs	r3, #20
    aa88:	18fb      	adds	r3, r7, r3
    aa8a:	711a      	strb	r2, [r3, #4]
		bc[5] = (uint8)(u32data >> 8);
    aa8c:	687b      	ldr	r3, [r7, #4]
    aa8e:	0a1b      	lsrs	r3, r3, #8
    aa90:	b2da      	uxtb	r2, r3
    aa92:	2314      	movs	r3, #20
    aa94:	18fb      	adds	r3, r7, r3
    aa96:	715a      	strb	r2, [r3, #5]
		bc[6] = (uint8)(u32data);
    aa98:	687b      	ldr	r3, [r7, #4]
    aa9a:	b2da      	uxtb	r2, r3
    aa9c:	2314      	movs	r3, #20
    aa9e:	18fb      	adds	r3, r7, r3
    aaa0:	719a      	strb	r2, [r3, #6]
		len = 8;
    aaa2:	231f      	movs	r3, #31
    aaa4:	18fb      	adds	r3, r7, r3
    aaa6:	2208      	movs	r2, #8
    aaa8:	701a      	strb	r2, [r3, #0]
		break;
    aaaa:	e031      	b.n	ab10 <spi_cmd+0x280>
	case CMD_SINGLE_WRITE:			/* single word write */
		bc[1] = (uint8)(adr >> 16);
    aaac:	68bb      	ldr	r3, [r7, #8]
    aaae:	0c1b      	lsrs	r3, r3, #16
    aab0:	b2da      	uxtb	r2, r3
    aab2:	2314      	movs	r3, #20
    aab4:	18fb      	adds	r3, r7, r3
    aab6:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    aab8:	68bb      	ldr	r3, [r7, #8]
    aaba:	0a1b      	lsrs	r3, r3, #8
    aabc:	b2da      	uxtb	r2, r3
    aabe:	2314      	movs	r3, #20
    aac0:	18fb      	adds	r3, r7, r3
    aac2:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)(adr);
    aac4:	68bb      	ldr	r3, [r7, #8]
    aac6:	b2da      	uxtb	r2, r3
    aac8:	2314      	movs	r3, #20
    aaca:	18fb      	adds	r3, r7, r3
    aacc:	70da      	strb	r2, [r3, #3]
		bc[4] = (uint8)(u32data >> 24);
    aace:	687b      	ldr	r3, [r7, #4]
    aad0:	0e1b      	lsrs	r3, r3, #24
    aad2:	b2da      	uxtb	r2, r3
    aad4:	2314      	movs	r3, #20
    aad6:	18fb      	adds	r3, r7, r3
    aad8:	711a      	strb	r2, [r3, #4]
		bc[5] = (uint8)(u32data >> 16);
    aada:	687b      	ldr	r3, [r7, #4]
    aadc:	0c1b      	lsrs	r3, r3, #16
    aade:	b2da      	uxtb	r2, r3
    aae0:	2314      	movs	r3, #20
    aae2:	18fb      	adds	r3, r7, r3
    aae4:	715a      	strb	r2, [r3, #5]
		bc[6] = (uint8)(u32data >> 8);
    aae6:	687b      	ldr	r3, [r7, #4]
    aae8:	0a1b      	lsrs	r3, r3, #8
    aaea:	b2da      	uxtb	r2, r3
    aaec:	2314      	movs	r3, #20
    aaee:	18fb      	adds	r3, r7, r3
    aaf0:	719a      	strb	r2, [r3, #6]
		bc[7] = (uint8)(u32data);
    aaf2:	687b      	ldr	r3, [r7, #4]
    aaf4:	b2da      	uxtb	r2, r3
    aaf6:	2314      	movs	r3, #20
    aaf8:	18fb      	adds	r3, r7, r3
    aafa:	71da      	strb	r2, [r3, #7]
		len = 9;
    aafc:	231f      	movs	r3, #31
    aafe:	18fb      	adds	r3, r7, r3
    ab00:	2209      	movs	r2, #9
    ab02:	701a      	strb	r2, [r3, #0]
		break;
    ab04:	e004      	b.n	ab10 <spi_cmd+0x280>
	default:
		result = N_FAIL;
    ab06:	231e      	movs	r3, #30
    ab08:	18fb      	adds	r3, r7, r3
    ab0a:	2200      	movs	r2, #0
    ab0c:	701a      	strb	r2, [r3, #0]
		break;
    ab0e:	46c0      	nop			; (mov r8, r8)
	}

	if (result) {
    ab10:	231e      	movs	r3, #30
    ab12:	18fb      	adds	r3, r7, r3
    ab14:	781b      	ldrb	r3, [r3, #0]
    ab16:	b25b      	sxtb	r3, r3
    ab18:	2b00      	cmp	r3, #0
    ab1a:	d030      	beq.n	ab7e <spi_cmd+0x2ee>
		if (!gu8Crc_off)
    ab1c:	4b1d      	ldr	r3, [pc, #116]	; (ab94 <spi_cmd+0x304>)
    ab1e:	781b      	ldrb	r3, [r3, #0]
    ab20:	2b00      	cmp	r3, #0
    ab22:	d115      	bne.n	ab50 <spi_cmd+0x2c0>
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
    ab24:	231f      	movs	r3, #31
    ab26:	18fb      	adds	r3, r7, r3
    ab28:	781b      	ldrb	r3, [r3, #0]
    ab2a:	1e5c      	subs	r4, r3, #1
    ab2c:	231f      	movs	r3, #31
    ab2e:	18fb      	adds	r3, r7, r3
    ab30:	781b      	ldrb	r3, [r3, #0]
    ab32:	3b01      	subs	r3, #1
    ab34:	001a      	movs	r2, r3
    ab36:	2314      	movs	r3, #20
    ab38:	18fb      	adds	r3, r7, r3
    ab3a:	0019      	movs	r1, r3
    ab3c:	207f      	movs	r0, #127	; 0x7f
    ab3e:	4b16      	ldr	r3, [pc, #88]	; (ab98 <spi_cmd+0x308>)
    ab40:	4798      	blx	r3
    ab42:	0003      	movs	r3, r0
    ab44:	18db      	adds	r3, r3, r3
    ab46:	b2da      	uxtb	r2, r3
    ab48:	2314      	movs	r3, #20
    ab4a:	18fb      	adds	r3, r7, r3
    ab4c:	551a      	strb	r2, [r3, r4]
    ab4e:	e006      	b.n	ab5e <spi_cmd+0x2ce>
		else
			len-=1;
    ab50:	231f      	movs	r3, #31
    ab52:	18fb      	adds	r3, r7, r3
    ab54:	221f      	movs	r2, #31
    ab56:	18ba      	adds	r2, r7, r2
    ab58:	7812      	ldrb	r2, [r2, #0]
    ab5a:	3a01      	subs	r2, #1
    ab5c:	701a      	strb	r2, [r3, #0]

		if (M2M_SUCCESS != nmi_spi_write(bc, len)) {
    ab5e:	231f      	movs	r3, #31
    ab60:	18fb      	adds	r3, r7, r3
    ab62:	781b      	ldrb	r3, [r3, #0]
    ab64:	b29a      	uxth	r2, r3
    ab66:	2314      	movs	r3, #20
    ab68:	18fb      	adds	r3, r7, r3
    ab6a:	0011      	movs	r1, r2
    ab6c:	0018      	movs	r0, r3
    ab6e:	4b0b      	ldr	r3, [pc, #44]	; (ab9c <spi_cmd+0x30c>)
    ab70:	4798      	blx	r3
    ab72:	1e03      	subs	r3, r0, #0
    ab74:	d003      	beq.n	ab7e <spi_cmd+0x2ee>
			M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
			result = N_FAIL;
    ab76:	231e      	movs	r3, #30
    ab78:	18fb      	adds	r3, r7, r3
    ab7a:	2200      	movs	r2, #0
    ab7c:	701a      	strb	r2, [r3, #0]
		}
	}

	return result;
    ab7e:	231e      	movs	r3, #30
    ab80:	18fb      	adds	r3, r7, r3
    ab82:	781b      	ldrb	r3, [r3, #0]
    ab84:	b25b      	sxtb	r3, r3
}
    ab86:	0018      	movs	r0, r3
    ab88:	46bd      	mov	sp, r7
    ab8a:	b009      	add	sp, #36	; 0x24
    ab8c:	bd90      	pop	{r4, r7, pc}
    ab8e:	46c0      	nop			; (mov r8, r8)
    ab90:	00020d8c 	.word	0x00020d8c
    ab94:	2000052c 	.word	0x2000052c
    ab98:	0000a841 	.word	0x0000a841
    ab9c:	0000a7cd 	.word	0x0000a7cd

0000aba0 <spi_cmd_rsp>:

static sint8 spi_cmd_rsp(uint8 cmd)
{
    aba0:	b580      	push	{r7, lr}
    aba2:	b084      	sub	sp, #16
    aba4:	af00      	add	r7, sp, #0
    aba6:	0002      	movs	r2, r0
    aba8:	1dfb      	adds	r3, r7, #7
    abaa:	701a      	strb	r2, [r3, #0]
	uint8 rsp;
	sint8 result = N_OK;
    abac:	230f      	movs	r3, #15
    abae:	18fb      	adds	r3, r7, r3
    abb0:	2201      	movs	r2, #1
    abb2:	701a      	strb	r2, [r3, #0]
	sint8 s8RetryCnt;

	/**
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
    abb4:	1dfb      	adds	r3, r7, #7
    abb6:	781b      	ldrb	r3, [r3, #0]
    abb8:	2bcf      	cmp	r3, #207	; 0xcf
    abba:	d007      	beq.n	abcc <spi_cmd_rsp+0x2c>
    abbc:	1dfb      	adds	r3, r7, #7
    abbe:	781b      	ldrb	r3, [r3, #0]
    abc0:	2bc5      	cmp	r3, #197	; 0xc5
    abc2:	d003      	beq.n	abcc <spi_cmd_rsp+0x2c>
		 (cmd == CMD_TERMINATE) ||
    abc4:	1dfb      	adds	r3, r7, #7
    abc6:	781b      	ldrb	r3, [r3, #0]
    abc8:	2bc6      	cmp	r3, #198	; 0xc6
    abca:	d10c      	bne.n	abe6 <spi_cmd_rsp+0x46>
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    abcc:	230d      	movs	r3, #13
    abce:	18fb      	adds	r3, r7, r3
    abd0:	2101      	movs	r1, #1
    abd2:	0018      	movs	r0, r3
    abd4:	4b2b      	ldr	r3, [pc, #172]	; (ac84 <spi_cmd_rsp+0xe4>)
    abd6:	4798      	blx	r3
    abd8:	1e03      	subs	r3, r0, #0
    abda:	d004      	beq.n	abe6 <spi_cmd_rsp+0x46>
			result = N_FAIL;
    abdc:	230f      	movs	r3, #15
    abde:	18fb      	adds	r3, r7, r3
    abe0:	2200      	movs	r2, #0
    abe2:	701a      	strb	r2, [r3, #0]
			goto _fail_;
    abe4:	e045      	b.n	ac72 <spi_cmd_rsp+0xd2>
		}
	}

	/* wait for response */
	s8RetryCnt = 10;
    abe6:	230e      	movs	r3, #14
    abe8:	18fb      	adds	r3, r7, r3
    abea:	220a      	movs	r2, #10
    abec:	701a      	strb	r2, [r3, #0]
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    abee:	230d      	movs	r3, #13
    abf0:	18fb      	adds	r3, r7, r3
    abf2:	2101      	movs	r1, #1
    abf4:	0018      	movs	r0, r3
    abf6:	4b23      	ldr	r3, [pc, #140]	; (ac84 <spi_cmd_rsp+0xe4>)
    abf8:	4798      	blx	r3
    abfa:	1e03      	subs	r3, r0, #0
    abfc:	d004      	beq.n	ac08 <spi_cmd_rsp+0x68>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
			result = N_FAIL;
    abfe:	230f      	movs	r3, #15
    ac00:	18fb      	adds	r3, r7, r3
    ac02:	2200      	movs	r2, #0
    ac04:	701a      	strb	r2, [r3, #0]
			goto _fail_;
    ac06:	e034      	b.n	ac72 <spi_cmd_rsp+0xd2>
		}
	} while((rsp != cmd) && (s8RetryCnt-- >0));
    ac08:	230d      	movs	r3, #13
    ac0a:	18fb      	adds	r3, r7, r3
    ac0c:	781b      	ldrb	r3, [r3, #0]
    ac0e:	1dfa      	adds	r2, r7, #7
    ac10:	7812      	ldrb	r2, [r2, #0]
    ac12:	429a      	cmp	r2, r3
    ac14:	d00b      	beq.n	ac2e <spi_cmd_rsp+0x8e>
    ac16:	230e      	movs	r3, #14
    ac18:	18fb      	adds	r3, r7, r3
    ac1a:	781b      	ldrb	r3, [r3, #0]
    ac1c:	b25b      	sxtb	r3, r3
    ac1e:	b2da      	uxtb	r2, r3
    ac20:	3a01      	subs	r2, #1
    ac22:	b2d1      	uxtb	r1, r2
    ac24:	220e      	movs	r2, #14
    ac26:	18ba      	adds	r2, r7, r2
    ac28:	7011      	strb	r1, [r2, #0]
    ac2a:	2b00      	cmp	r3, #0
    ac2c:	dcdf      	bgt.n	abee <spi_cmd_rsp+0x4e>

	/**
		State response
	**/
	/* wait for response */
	s8RetryCnt = 10;
    ac2e:	230e      	movs	r3, #14
    ac30:	18fb      	adds	r3, r7, r3
    ac32:	220a      	movs	r2, #10
    ac34:	701a      	strb	r2, [r3, #0]
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    ac36:	230d      	movs	r3, #13
    ac38:	18fb      	adds	r3, r7, r3
    ac3a:	2101      	movs	r1, #1
    ac3c:	0018      	movs	r0, r3
    ac3e:	4b11      	ldr	r3, [pc, #68]	; (ac84 <spi_cmd_rsp+0xe4>)
    ac40:	4798      	blx	r3
    ac42:	1e03      	subs	r3, r0, #0
    ac44:	d004      	beq.n	ac50 <spi_cmd_rsp+0xb0>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
			result = N_FAIL;
    ac46:	230f      	movs	r3, #15
    ac48:	18fb      	adds	r3, r7, r3
    ac4a:	2200      	movs	r2, #0
    ac4c:	701a      	strb	r2, [r3, #0]
			goto _fail_;
    ac4e:	e010      	b.n	ac72 <spi_cmd_rsp+0xd2>
		}
	} while((rsp != 0x00) && (s8RetryCnt-- >0));
    ac50:	230d      	movs	r3, #13
    ac52:	18fb      	adds	r3, r7, r3
    ac54:	781b      	ldrb	r3, [r3, #0]
    ac56:	2b00      	cmp	r3, #0
    ac58:	d00b      	beq.n	ac72 <spi_cmd_rsp+0xd2>
    ac5a:	230e      	movs	r3, #14
    ac5c:	18fb      	adds	r3, r7, r3
    ac5e:	781b      	ldrb	r3, [r3, #0]
    ac60:	b25b      	sxtb	r3, r3
    ac62:	b2da      	uxtb	r2, r3
    ac64:	3a01      	subs	r2, #1
    ac66:	b2d1      	uxtb	r1, r2
    ac68:	220e      	movs	r2, #14
    ac6a:	18ba      	adds	r2, r7, r2
    ac6c:	7011      	strb	r1, [r2, #0]
    ac6e:	2b00      	cmp	r3, #0
    ac70:	dce1      	bgt.n	ac36 <spi_cmd_rsp+0x96>

_fail_:

	return result;
    ac72:	230f      	movs	r3, #15
    ac74:	18fb      	adds	r3, r7, r3
    ac76:	781b      	ldrb	r3, [r3, #0]
    ac78:	b25b      	sxtb	r3, r3
}
    ac7a:	0018      	movs	r0, r3
    ac7c:	46bd      	mov	sp, r7
    ac7e:	b004      	add	sp, #16
    ac80:	bd80      	pop	{r7, pc}
    ac82:	46c0      	nop			; (mov r8, r8)
    ac84:	0000a789 	.word	0x0000a789

0000ac88 <spi_data_read>:

static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
{
    ac88:	b580      	push	{r7, lr}
    ac8a:	b086      	sub	sp, #24
    ac8c:	af00      	add	r7, sp, #0
    ac8e:	6078      	str	r0, [r7, #4]
    ac90:	0008      	movs	r0, r1
    ac92:	0011      	movs	r1, r2
    ac94:	1cbb      	adds	r3, r7, #2
    ac96:	1c02      	adds	r2, r0, #0
    ac98:	801a      	strh	r2, [r3, #0]
    ac9a:	1c7b      	adds	r3, r7, #1
    ac9c:	1c0a      	adds	r2, r1, #0
    ac9e:	701a      	strb	r2, [r3, #0]
	sint16 retry, ix, nbytes;
	sint8 result = N_OK;
    aca0:	2311      	movs	r3, #17
    aca2:	18fb      	adds	r3, r7, r3
    aca4:	2201      	movs	r2, #1
    aca6:	701a      	strb	r2, [r3, #0]
	uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    aca8:	2314      	movs	r3, #20
    acaa:	18fb      	adds	r3, r7, r3
    acac:	2200      	movs	r2, #0
    acae:	801a      	strh	r2, [r3, #0]
	do {
		if (sz <= DATA_PKT_SZ)
    acb0:	1cbb      	adds	r3, r7, #2
    acb2:	881a      	ldrh	r2, [r3, #0]
    acb4:	2380      	movs	r3, #128	; 0x80
    acb6:	019b      	lsls	r3, r3, #6
    acb8:	429a      	cmp	r2, r3
    acba:	d805      	bhi.n	acc8 <spi_data_read+0x40>
			nbytes = sz;
    acbc:	2312      	movs	r3, #18
    acbe:	18fb      	adds	r3, r7, r3
    acc0:	1cba      	adds	r2, r7, #2
    acc2:	8812      	ldrh	r2, [r2, #0]
    acc4:	801a      	strh	r2, [r3, #0]
    acc6:	e004      	b.n	acd2 <spi_data_read+0x4a>
		else
			nbytes = DATA_PKT_SZ;
    acc8:	2312      	movs	r3, #18
    acca:	18fb      	adds	r3, r7, r3
    accc:	2280      	movs	r2, #128	; 0x80
    acce:	0192      	lsls	r2, r2, #6
    acd0:	801a      	strh	r2, [r3, #0]

		/**
			Data Respnose header
		**/
		retry = 10;
    acd2:	2316      	movs	r3, #22
    acd4:	18fb      	adds	r3, r7, r3
    acd6:	220a      	movs	r2, #10
    acd8:	801a      	strh	r2, [r3, #0]
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    acda:	230b      	movs	r3, #11
    acdc:	18fb      	adds	r3, r7, r3
    acde:	2101      	movs	r1, #1
    ace0:	0018      	movs	r0, r3
    ace2:	4b3e      	ldr	r3, [pc, #248]	; (addc <spi_data_read+0x154>)
    ace4:	4798      	blx	r3
    ace6:	1e03      	subs	r3, r0, #0
    ace8:	d004      	beq.n	acf4 <spi_data_read+0x6c>
				M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
				result = N_FAIL;
    acea:	2311      	movs	r3, #17
    acec:	18fb      	adds	r3, r7, r3
    acee:	2200      	movs	r2, #0
    acf0:	701a      	strb	r2, [r3, #0]
				break;
    acf2:	e017      	b.n	ad24 <spi_data_read+0x9c>
			}
			if (((rsp >> 4) & 0xf) == 0xf)
    acf4:	230b      	movs	r3, #11
    acf6:	18fb      	adds	r3, r7, r3
    acf8:	781b      	ldrb	r3, [r3, #0]
    acfa:	091b      	lsrs	r3, r3, #4
    acfc:	b2db      	uxtb	r3, r3
    acfe:	001a      	movs	r2, r3
    ad00:	230f      	movs	r3, #15
    ad02:	4013      	ands	r3, r2
    ad04:	2b0f      	cmp	r3, #15
    ad06:	d00c      	beq.n	ad22 <spi_data_read+0x9a>
				break;
		} while (retry--);
    ad08:	2316      	movs	r3, #22
    ad0a:	18fb      	adds	r3, r7, r3
    ad0c:	2200      	movs	r2, #0
    ad0e:	5e9b      	ldrsh	r3, [r3, r2]
    ad10:	b29a      	uxth	r2, r3
    ad12:	3a01      	subs	r2, #1
    ad14:	b291      	uxth	r1, r2
    ad16:	2216      	movs	r2, #22
    ad18:	18ba      	adds	r2, r7, r2
    ad1a:	8011      	strh	r1, [r2, #0]
    ad1c:	2b00      	cmp	r3, #0
    ad1e:	d1dc      	bne.n	acda <spi_data_read+0x52>
    ad20:	e000      	b.n	ad24 <spi_data_read+0x9c>
				M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
				result = N_FAIL;
				break;
			}
			if (((rsp >> 4) & 0xf) == 0xf)
				break;
    ad22:	46c0      	nop			; (mov r8, r8)
		} while (retry--);

		if (result == N_FAIL)
    ad24:	2311      	movs	r3, #17
    ad26:	18fb      	adds	r3, r7, r3
    ad28:	781b      	ldrb	r3, [r3, #0]
    ad2a:	b25b      	sxtb	r3, r3
    ad2c:	2b00      	cmp	r3, #0
    ad2e:	d04c      	beq.n	adca <spi_data_read+0x142>
			break;

		if (retry <= 0) {
    ad30:	2316      	movs	r3, #22
    ad32:	18fb      	adds	r3, r7, r3
    ad34:	2200      	movs	r2, #0
    ad36:	5e9b      	ldrsh	r3, [r3, r2]
    ad38:	2b00      	cmp	r3, #0
    ad3a:	dc04      	bgt.n	ad46 <spi_data_read+0xbe>
			M2M_ERR("[nmi spi]: Failed data response read...(%02x)\n", rsp);
			result = N_FAIL;
    ad3c:	2311      	movs	r3, #17
    ad3e:	18fb      	adds	r3, r7, r3
    ad40:	2200      	movs	r2, #0
    ad42:	701a      	strb	r2, [r3, #0]
			break;
    ad44:	e042      	b.n	adcc <spi_data_read+0x144>
		}

		/**
			Read bytes
		**/
		if (M2M_SUCCESS != nmi_spi_read(&b[ix], nbytes)) {
    ad46:	2314      	movs	r3, #20
    ad48:	18fb      	adds	r3, r7, r3
    ad4a:	2200      	movs	r2, #0
    ad4c:	5e9b      	ldrsh	r3, [r3, r2]
    ad4e:	687a      	ldr	r2, [r7, #4]
    ad50:	18d2      	adds	r2, r2, r3
    ad52:	2312      	movs	r3, #18
    ad54:	18fb      	adds	r3, r7, r3
    ad56:	881b      	ldrh	r3, [r3, #0]
    ad58:	0019      	movs	r1, r3
    ad5a:	0010      	movs	r0, r2
    ad5c:	4b1f      	ldr	r3, [pc, #124]	; (addc <spi_data_read+0x154>)
    ad5e:	4798      	blx	r3
    ad60:	1e03      	subs	r3, r0, #0
    ad62:	d004      	beq.n	ad6e <spi_data_read+0xe6>
			M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
			result = N_FAIL;
    ad64:	2311      	movs	r3, #17
    ad66:	18fb      	adds	r3, r7, r3
    ad68:	2200      	movs	r2, #0
    ad6a:	701a      	strb	r2, [r3, #0]
			break;
    ad6c:	e02e      	b.n	adcc <spi_data_read+0x144>
		}
		if(!clockless)
    ad6e:	1c7b      	adds	r3, r7, #1
    ad70:	781b      	ldrb	r3, [r3, #0]
    ad72:	2b00      	cmp	r3, #0
    ad74:	d110      	bne.n	ad98 <spi_data_read+0x110>
		{
			/**
			Read Crc
			**/
			if (!gu8Crc_off) {
    ad76:	4b1a      	ldr	r3, [pc, #104]	; (ade0 <spi_data_read+0x158>)
    ad78:	781b      	ldrb	r3, [r3, #0]
    ad7a:	2b00      	cmp	r3, #0
    ad7c:	d10c      	bne.n	ad98 <spi_data_read+0x110>
				if (M2M_SUCCESS != nmi_spi_read(crc, 2)) {
    ad7e:	230c      	movs	r3, #12
    ad80:	18fb      	adds	r3, r7, r3
    ad82:	2102      	movs	r1, #2
    ad84:	0018      	movs	r0, r3
    ad86:	4b15      	ldr	r3, [pc, #84]	; (addc <spi_data_read+0x154>)
    ad88:	4798      	blx	r3
    ad8a:	1e03      	subs	r3, r0, #0
    ad8c:	d004      	beq.n	ad98 <spi_data_read+0x110>
					M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
					result = N_FAIL;
    ad8e:	2311      	movs	r3, #17
    ad90:	18fb      	adds	r3, r7, r3
    ad92:	2200      	movs	r2, #0
    ad94:	701a      	strb	r2, [r3, #0]
					break;
    ad96:	e019      	b.n	adcc <spi_data_read+0x144>
				}
			}
		}
		ix += nbytes;
    ad98:	2314      	movs	r3, #20
    ad9a:	18fb      	adds	r3, r7, r3
    ad9c:	881a      	ldrh	r2, [r3, #0]
    ad9e:	2312      	movs	r3, #18
    ada0:	18fb      	adds	r3, r7, r3
    ada2:	881b      	ldrh	r3, [r3, #0]
    ada4:	18d3      	adds	r3, r2, r3
    ada6:	b29a      	uxth	r2, r3
    ada8:	2314      	movs	r3, #20
    adaa:	18fb      	adds	r3, r7, r3
    adac:	801a      	strh	r2, [r3, #0]
		sz -= nbytes;
    adae:	2312      	movs	r3, #18
    adb0:	18fb      	adds	r3, r7, r3
    adb2:	881a      	ldrh	r2, [r3, #0]
    adb4:	1cbb      	adds	r3, r7, #2
    adb6:	1cb9      	adds	r1, r7, #2
    adb8:	8809      	ldrh	r1, [r1, #0]
    adba:	1a8a      	subs	r2, r1, r2
    adbc:	801a      	strh	r2, [r3, #0]

	} while (sz);
    adbe:	1cbb      	adds	r3, r7, #2
    adc0:	881b      	ldrh	r3, [r3, #0]
    adc2:	2b00      	cmp	r3, #0
    adc4:	d000      	beq.n	adc8 <spi_data_read+0x140>
    adc6:	e773      	b.n	acb0 <spi_data_read+0x28>
    adc8:	e000      	b.n	adcc <spi_data_read+0x144>
			if (((rsp >> 4) & 0xf) == 0xf)
				break;
		} while (retry--);

		if (result == N_FAIL)
			break;
    adca:	46c0      	nop			; (mov r8, r8)
		ix += nbytes;
		sz -= nbytes;

	} while (sz);

	return result;
    adcc:	2311      	movs	r3, #17
    adce:	18fb      	adds	r3, r7, r3
    add0:	781b      	ldrb	r3, [r3, #0]
    add2:	b25b      	sxtb	r3, r3
}
    add4:	0018      	movs	r0, r3
    add6:	46bd      	mov	sp, r7
    add8:	b006      	add	sp, #24
    adda:	bd80      	pop	{r7, pc}
    addc:	0000a789 	.word	0x0000a789
    ade0:	2000052c 	.word	0x2000052c

0000ade4 <spi_data_write>:

static sint8 spi_data_write(uint8 *b, uint16 sz)
{
    ade4:	b580      	push	{r7, lr}
    ade6:	b086      	sub	sp, #24
    ade8:	af00      	add	r7, sp, #0
    adea:	6078      	str	r0, [r7, #4]
    adec:	000a      	movs	r2, r1
    adee:	1cbb      	adds	r3, r7, #2
    adf0:	801a      	strh	r2, [r3, #0]
	sint16 ix;
	uint16 nbytes;
	sint8 result = 1;
    adf2:	2313      	movs	r3, #19
    adf4:	18fb      	adds	r3, r7, r3
    adf6:	2201      	movs	r2, #1
    adf8:	701a      	strb	r2, [r3, #0]
	uint8 cmd, order, crc[2] = {0};
    adfa:	230c      	movs	r3, #12
    adfc:	18fb      	adds	r3, r7, r3
    adfe:	2200      	movs	r2, #0
    ae00:	801a      	strh	r2, [r3, #0]
	//uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    ae02:	2316      	movs	r3, #22
    ae04:	18fb      	adds	r3, r7, r3
    ae06:	2200      	movs	r2, #0
    ae08:	801a      	strh	r2, [r3, #0]
	do {
		if (sz <= DATA_PKT_SZ)
    ae0a:	1cbb      	adds	r3, r7, #2
    ae0c:	881a      	ldrh	r2, [r3, #0]
    ae0e:	2380      	movs	r3, #128	; 0x80
    ae10:	019b      	lsls	r3, r3, #6
    ae12:	429a      	cmp	r2, r3
    ae14:	d805      	bhi.n	ae22 <spi_data_write+0x3e>
			nbytes = sz;
    ae16:	2314      	movs	r3, #20
    ae18:	18fb      	adds	r3, r7, r3
    ae1a:	1cba      	adds	r2, r7, #2
    ae1c:	8812      	ldrh	r2, [r2, #0]
    ae1e:	801a      	strh	r2, [r3, #0]
    ae20:	e004      	b.n	ae2c <spi_data_write+0x48>
		else
			nbytes = DATA_PKT_SZ;
    ae22:	2314      	movs	r3, #20
    ae24:	18fb      	adds	r3, r7, r3
    ae26:	2280      	movs	r2, #128	; 0x80
    ae28:	0192      	lsls	r2, r2, #6
    ae2a:	801a      	strh	r2, [r3, #0]

		/**
			Write command
		**/
		cmd = 0xf0;
    ae2c:	2311      	movs	r3, #17
    ae2e:	18fb      	adds	r3, r7, r3
    ae30:	22f0      	movs	r2, #240	; 0xf0
    ae32:	701a      	strb	r2, [r3, #0]
		if (ix == 0)  {
    ae34:	2316      	movs	r3, #22
    ae36:	18fb      	adds	r3, r7, r3
    ae38:	2200      	movs	r2, #0
    ae3a:	5e9b      	ldrsh	r3, [r3, r2]
    ae3c:	2b00      	cmp	r3, #0
    ae3e:	d10f      	bne.n	ae60 <spi_data_write+0x7c>
			if (sz <= DATA_PKT_SZ)
    ae40:	1cbb      	adds	r3, r7, #2
    ae42:	881a      	ldrh	r2, [r3, #0]
    ae44:	2380      	movs	r3, #128	; 0x80
    ae46:	019b      	lsls	r3, r3, #6
    ae48:	429a      	cmp	r2, r3
    ae4a:	d804      	bhi.n	ae56 <spi_data_write+0x72>
				order = 0x3;
    ae4c:	2312      	movs	r3, #18
    ae4e:	18fb      	adds	r3, r7, r3
    ae50:	2203      	movs	r2, #3
    ae52:	701a      	strb	r2, [r3, #0]
    ae54:	e013      	b.n	ae7e <spi_data_write+0x9a>
			else
				order = 0x1;
    ae56:	2312      	movs	r3, #18
    ae58:	18fb      	adds	r3, r7, r3
    ae5a:	2201      	movs	r2, #1
    ae5c:	701a      	strb	r2, [r3, #0]
    ae5e:	e00e      	b.n	ae7e <spi_data_write+0x9a>
		} else {
			if (sz <= DATA_PKT_SZ)
    ae60:	1cbb      	adds	r3, r7, #2
    ae62:	881a      	ldrh	r2, [r3, #0]
    ae64:	2380      	movs	r3, #128	; 0x80
    ae66:	019b      	lsls	r3, r3, #6
    ae68:	429a      	cmp	r2, r3
    ae6a:	d804      	bhi.n	ae76 <spi_data_write+0x92>
				order = 0x3;
    ae6c:	2312      	movs	r3, #18
    ae6e:	18fb      	adds	r3, r7, r3
    ae70:	2203      	movs	r2, #3
    ae72:	701a      	strb	r2, [r3, #0]
    ae74:	e003      	b.n	ae7e <spi_data_write+0x9a>
			else
				order = 0x2;
    ae76:	2312      	movs	r3, #18
    ae78:	18fb      	adds	r3, r7, r3
    ae7a:	2202      	movs	r2, #2
    ae7c:	701a      	strb	r2, [r3, #0]
		}
		cmd |= order;
    ae7e:	2311      	movs	r3, #17
    ae80:	18fb      	adds	r3, r7, r3
    ae82:	781a      	ldrb	r2, [r3, #0]
    ae84:	2312      	movs	r3, #18
    ae86:	18fb      	adds	r3, r7, r3
    ae88:	781b      	ldrb	r3, [r3, #0]
    ae8a:	4313      	orrs	r3, r2
    ae8c:	b2da      	uxtb	r2, r3
    ae8e:	2311      	movs	r3, #17
    ae90:	18fb      	adds	r3, r7, r3
    ae92:	701a      	strb	r2, [r3, #0]
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
    ae94:	2311      	movs	r3, #17
    ae96:	18fb      	adds	r3, r7, r3
    ae98:	2101      	movs	r1, #1
    ae9a:	0018      	movs	r0, r3
    ae9c:	4b26      	ldr	r3, [pc, #152]	; (af38 <spi_data_write+0x154>)
    ae9e:	4798      	blx	r3
    aea0:	1e03      	subs	r3, r0, #0
    aea2:	d004      	beq.n	aeae <spi_data_write+0xca>
			M2M_ERR("[nmi spi]: Failed data block cmd write, bus error...\n");
			result = N_FAIL;
    aea4:	2313      	movs	r3, #19
    aea6:	18fb      	adds	r3, r7, r3
    aea8:	2200      	movs	r2, #0
    aeaa:	701a      	strb	r2, [r3, #0]
			break;
    aeac:	e03c      	b.n	af28 <spi_data_write+0x144>
		}

		/**
			Write data
		**/
		if (M2M_SUCCESS != nmi_spi_write(&b[ix], nbytes)) {
    aeae:	2316      	movs	r3, #22
    aeb0:	18fb      	adds	r3, r7, r3
    aeb2:	2200      	movs	r2, #0
    aeb4:	5e9b      	ldrsh	r3, [r3, r2]
    aeb6:	687a      	ldr	r2, [r7, #4]
    aeb8:	18d2      	adds	r2, r2, r3
    aeba:	2314      	movs	r3, #20
    aebc:	18fb      	adds	r3, r7, r3
    aebe:	881b      	ldrh	r3, [r3, #0]
    aec0:	0019      	movs	r1, r3
    aec2:	0010      	movs	r0, r2
    aec4:	4b1c      	ldr	r3, [pc, #112]	; (af38 <spi_data_write+0x154>)
    aec6:	4798      	blx	r3
    aec8:	1e03      	subs	r3, r0, #0
    aeca:	d004      	beq.n	aed6 <spi_data_write+0xf2>
			M2M_ERR("[nmi spi]: Failed data block write, bus error...\n");
			result = N_FAIL;
    aecc:	2313      	movs	r3, #19
    aece:	18fb      	adds	r3, r7, r3
    aed0:	2200      	movs	r2, #0
    aed2:	701a      	strb	r2, [r3, #0]
			break;
    aed4:	e028      	b.n	af28 <spi_data_write+0x144>
		}

		/**
			Write Crc
		**/
		if (!gu8Crc_off) {
    aed6:	4b19      	ldr	r3, [pc, #100]	; (af3c <spi_data_write+0x158>)
    aed8:	781b      	ldrb	r3, [r3, #0]
    aeda:	2b00      	cmp	r3, #0
    aedc:	d10c      	bne.n	aef8 <spi_data_write+0x114>
			if (M2M_SUCCESS != nmi_spi_write(crc, 2)) {
    aede:	230c      	movs	r3, #12
    aee0:	18fb      	adds	r3, r7, r3
    aee2:	2102      	movs	r1, #2
    aee4:	0018      	movs	r0, r3
    aee6:	4b14      	ldr	r3, [pc, #80]	; (af38 <spi_data_write+0x154>)
    aee8:	4798      	blx	r3
    aeea:	1e03      	subs	r3, r0, #0
    aeec:	d004      	beq.n	aef8 <spi_data_write+0x114>
				M2M_ERR("[nmi spi]: Failed data block crc write, bus error...\n");
				result = N_FAIL;
    aeee:	2313      	movs	r3, #19
    aef0:	18fb      	adds	r3, r7, r3
    aef2:	2200      	movs	r2, #0
    aef4:	701a      	strb	r2, [r3, #0]
				break;
    aef6:	e017      	b.n	af28 <spi_data_write+0x144>
			}
		}

		ix += nbytes;
    aef8:	2316      	movs	r3, #22
    aefa:	18fb      	adds	r3, r7, r3
    aefc:	881a      	ldrh	r2, [r3, #0]
    aefe:	2314      	movs	r3, #20
    af00:	18fb      	adds	r3, r7, r3
    af02:	881b      	ldrh	r3, [r3, #0]
    af04:	18d3      	adds	r3, r2, r3
    af06:	b29a      	uxth	r2, r3
    af08:	2316      	movs	r3, #22
    af0a:	18fb      	adds	r3, r7, r3
    af0c:	801a      	strh	r2, [r3, #0]
		sz -= nbytes;
    af0e:	1cbb      	adds	r3, r7, #2
    af10:	1cb9      	adds	r1, r7, #2
    af12:	2214      	movs	r2, #20
    af14:	18ba      	adds	r2, r7, r2
    af16:	8809      	ldrh	r1, [r1, #0]
    af18:	8812      	ldrh	r2, [r2, #0]
    af1a:	1a8a      	subs	r2, r1, r2
    af1c:	801a      	strh	r2, [r3, #0]
	} while (sz);
    af1e:	1cbb      	adds	r3, r7, #2
    af20:	881b      	ldrh	r3, [r3, #0]
    af22:	2b00      	cmp	r3, #0
    af24:	d000      	beq.n	af28 <spi_data_write+0x144>
    af26:	e770      	b.n	ae0a <spi_data_write+0x26>


	return result;
    af28:	2313      	movs	r3, #19
    af2a:	18fb      	adds	r3, r7, r3
    af2c:	781b      	ldrb	r3, [r3, #0]
    af2e:	b25b      	sxtb	r3, r3
}
    af30:	0018      	movs	r0, r3
    af32:	46bd      	mov	sp, r7
    af34:	b006      	add	sp, #24
    af36:	bd80      	pop	{r7, pc}
    af38:	0000a7cd 	.word	0x0000a7cd
    af3c:	2000052c 	.word	0x2000052c

0000af40 <spi_write_reg>:
	Spi interfaces

********************************************/

static sint8 spi_write_reg(uint32 addr, uint32 u32data)
{
    af40:	b5b0      	push	{r4, r5, r7, lr}
    af42:	b086      	sub	sp, #24
    af44:	af02      	add	r7, sp, #8
    af46:	6078      	str	r0, [r7, #4]
    af48:	6039      	str	r1, [r7, #0]
	sint8 result = N_OK;
    af4a:	230d      	movs	r3, #13
    af4c:	18fb      	adds	r3, r7, r3
    af4e:	2201      	movs	r2, #1
    af50:	701a      	strb	r2, [r3, #0]
	uint8 cmd = CMD_SINGLE_WRITE;
    af52:	230f      	movs	r3, #15
    af54:	18fb      	adds	r3, r7, r3
    af56:	22c9      	movs	r2, #201	; 0xc9
    af58:	701a      	strb	r2, [r3, #0]
	uint8 clockless = 0;
    af5a:	230e      	movs	r3, #14
    af5c:	18fb      	adds	r3, r7, r3
    af5e:	2200      	movs	r2, #0
    af60:	701a      	strb	r2, [r3, #0]
	if (addr <= 0x30)
    af62:	687b      	ldr	r3, [r7, #4]
    af64:	2b30      	cmp	r3, #48	; 0x30
    af66:	d808      	bhi.n	af7a <spi_write_reg+0x3a>
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_WRITE;
    af68:	230f      	movs	r3, #15
    af6a:	18fb      	adds	r3, r7, r3
    af6c:	22c3      	movs	r2, #195	; 0xc3
    af6e:	701a      	strb	r2, [r3, #0]
		clockless = 1;
    af70:	230e      	movs	r3, #14
    af72:	18fb      	adds	r3, r7, r3
    af74:	2201      	movs	r2, #1
    af76:	701a      	strb	r2, [r3, #0]
    af78:	e007      	b.n	af8a <spi_write_reg+0x4a>
	}
	else
	{
		cmd = CMD_SINGLE_WRITE;
    af7a:	230f      	movs	r3, #15
    af7c:	18fb      	adds	r3, r7, r3
    af7e:	22c9      	movs	r2, #201	; 0xc9
    af80:	701a      	strb	r2, [r3, #0]
		clockless = 0;
    af82:	230e      	movs	r3, #14
    af84:	18fb      	adds	r3, r7, r3
    af86:	2200      	movs	r2, #0
    af88:	701a      	strb	r2, [r3, #0]
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
    af8a:	230d      	movs	r3, #13
    af8c:	18fc      	adds	r4, r7, r3
    af8e:	683a      	ldr	r2, [r7, #0]
    af90:	6879      	ldr	r1, [r7, #4]
    af92:	230f      	movs	r3, #15
    af94:	18fb      	adds	r3, r7, r3
    af96:	7818      	ldrb	r0, [r3, #0]
    af98:	230e      	movs	r3, #14
    af9a:	18fb      	adds	r3, r7, r3
    af9c:	781b      	ldrb	r3, [r3, #0]
    af9e:	9300      	str	r3, [sp, #0]
    afa0:	2304      	movs	r3, #4
    afa2:	4d15      	ldr	r5, [pc, #84]	; (aff8 <spi_write_reg+0xb8>)
    afa4:	47a8      	blx	r5
    afa6:	0003      	movs	r3, r0
    afa8:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    afaa:	230d      	movs	r3, #13
    afac:	18fb      	adds	r3, r7, r3
    afae:	781b      	ldrb	r3, [r3, #0]
    afb0:	b25b      	sxtb	r3, r3
    afb2:	2b01      	cmp	r3, #1
    afb4:	d001      	beq.n	afba <spi_write_reg+0x7a>
		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
    afb6:	2300      	movs	r3, #0
    afb8:	e01a      	b.n	aff0 <spi_write_reg+0xb0>
	}

	result = spi_cmd_rsp(cmd);
    afba:	230d      	movs	r3, #13
    afbc:	18fc      	adds	r4, r7, r3
    afbe:	230f      	movs	r3, #15
    afc0:	18fb      	adds	r3, r7, r3
    afc2:	781b      	ldrb	r3, [r3, #0]
    afc4:	0018      	movs	r0, r3
    afc6:	4b0d      	ldr	r3, [pc, #52]	; (affc <spi_write_reg+0xbc>)
    afc8:	4798      	blx	r3
    afca:	0003      	movs	r3, r0
    afcc:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    afce:	230d      	movs	r3, #13
    afd0:	18fb      	adds	r3, r7, r3
    afd2:	781b      	ldrb	r3, [r3, #0]
    afd4:	b25b      	sxtb	r3, r3
    afd6:	2b01      	cmp	r3, #1
    afd8:	d009      	beq.n	afee <spi_write_reg+0xae>
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    afda:	2300      	movs	r3, #0
    afdc:	9300      	str	r3, [sp, #0]
    afde:	2300      	movs	r3, #0
    afe0:	2200      	movs	r2, #0
    afe2:	2100      	movs	r1, #0
    afe4:	20cf      	movs	r0, #207	; 0xcf
    afe6:	4c04      	ldr	r4, [pc, #16]	; (aff8 <spi_write_reg+0xb8>)
    afe8:	47a0      	blx	r4
		return N_FAIL;
    afea:	2300      	movs	r3, #0
    afec:	e000      	b.n	aff0 <spi_write_reg+0xb0>
	}

	return N_OK;
    afee:	2301      	movs	r3, #1
	}

	return result;

#endif
}
    aff0:	0018      	movs	r0, r3
    aff2:	46bd      	mov	sp, r7
    aff4:	b004      	add	sp, #16
    aff6:	bdb0      	pop	{r4, r5, r7, pc}
    aff8:	0000a891 	.word	0x0000a891
    affc:	0000aba1 	.word	0x0000aba1

0000b000 <nm_spi_write>:

static sint8 nm_spi_write(uint32 addr, uint8 *buf, uint16 size)
{
    b000:	b5b0      	push	{r4, r5, r7, lr}
    b002:	b088      	sub	sp, #32
    b004:	af02      	add	r7, sp, #8
    b006:	60f8      	str	r0, [r7, #12]
    b008:	60b9      	str	r1, [r7, #8]
    b00a:	1dbb      	adds	r3, r7, #6
    b00c:	801a      	strh	r2, [r3, #0]
	sint8 result;
	uint8 cmd = CMD_DMA_EXT_WRITE;
    b00e:	2317      	movs	r3, #23
    b010:	18fb      	adds	r3, r7, r3
    b012:	22c7      	movs	r2, #199	; 0xc7
    b014:	701a      	strb	r2, [r3, #0]

	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, size,0);
    b016:	1dbb      	adds	r3, r7, #6
    b018:	881a      	ldrh	r2, [r3, #0]
    b01a:	2316      	movs	r3, #22
    b01c:	18fc      	adds	r4, r7, r3
    b01e:	68f9      	ldr	r1, [r7, #12]
    b020:	2317      	movs	r3, #23
    b022:	18fb      	adds	r3, r7, r3
    b024:	7818      	ldrb	r0, [r3, #0]
    b026:	2300      	movs	r3, #0
    b028:	9300      	str	r3, [sp, #0]
    b02a:	0013      	movs	r3, r2
    b02c:	2200      	movs	r2, #0
    b02e:	4d22      	ldr	r5, [pc, #136]	; (b0b8 <nm_spi_write+0xb8>)
    b030:	47a8      	blx	r5
    b032:	0003      	movs	r3, r0
    b034:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    b036:	2316      	movs	r3, #22
    b038:	18fb      	adds	r3, r7, r3
    b03a:	781b      	ldrb	r3, [r3, #0]
    b03c:	b25b      	sxtb	r3, r3
    b03e:	2b01      	cmp	r3, #1
    b040:	d001      	beq.n	b046 <nm_spi_write+0x46>
		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
    b042:	2300      	movs	r3, #0
    b044:	e033      	b.n	b0ae <nm_spi_write+0xae>
	}

	result = spi_cmd_rsp(cmd);
    b046:	2316      	movs	r3, #22
    b048:	18fc      	adds	r4, r7, r3
    b04a:	2317      	movs	r3, #23
    b04c:	18fb      	adds	r3, r7, r3
    b04e:	781b      	ldrb	r3, [r3, #0]
    b050:	0018      	movs	r0, r3
    b052:	4b1a      	ldr	r3, [pc, #104]	; (b0bc <nm_spi_write+0xbc>)
    b054:	4798      	blx	r3
    b056:	0003      	movs	r3, r0
    b058:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    b05a:	2316      	movs	r3, #22
    b05c:	18fb      	adds	r3, r7, r3
    b05e:	781b      	ldrb	r3, [r3, #0]
    b060:	b25b      	sxtb	r3, r3
    b062:	2b01      	cmp	r3, #1
    b064:	d009      	beq.n	b07a <nm_spi_write+0x7a>
		M2M_ERR("[nmi spi ]: Failed cmd response, write block (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    b066:	2300      	movs	r3, #0
    b068:	9300      	str	r3, [sp, #0]
    b06a:	2300      	movs	r3, #0
    b06c:	2200      	movs	r2, #0
    b06e:	2100      	movs	r1, #0
    b070:	20cf      	movs	r0, #207	; 0xcf
    b072:	4c11      	ldr	r4, [pc, #68]	; (b0b8 <nm_spi_write+0xb8>)
    b074:	47a0      	blx	r4
		return N_FAIL;
    b076:	2300      	movs	r3, #0
    b078:	e019      	b.n	b0ae <nm_spi_write+0xae>
#endif

	/**
		Data
	**/
	result = spi_data_write(buf, size);
    b07a:	2316      	movs	r3, #22
    b07c:	18fc      	adds	r4, r7, r3
    b07e:	1dbb      	adds	r3, r7, #6
    b080:	881a      	ldrh	r2, [r3, #0]
    b082:	68bb      	ldr	r3, [r7, #8]
    b084:	0011      	movs	r1, r2
    b086:	0018      	movs	r0, r3
    b088:	4b0d      	ldr	r3, [pc, #52]	; (b0c0 <nm_spi_write+0xc0>)
    b08a:	4798      	blx	r3
    b08c:	0003      	movs	r3, r0
    b08e:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    b090:	2316      	movs	r3, #22
    b092:	18fb      	adds	r3, r7, r3
    b094:	781b      	ldrb	r3, [r3, #0]
    b096:	b25b      	sxtb	r3, r3
    b098:	2b01      	cmp	r3, #1
    b09a:	d007      	beq.n	b0ac <nm_spi_write+0xac>
		M2M_ERR("[nmi spi]: Failed block data write...\n");
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    b09c:	2300      	movs	r3, #0
    b09e:	9300      	str	r3, [sp, #0]
    b0a0:	2300      	movs	r3, #0
    b0a2:	2200      	movs	r2, #0
    b0a4:	2100      	movs	r1, #0
    b0a6:	20cf      	movs	r0, #207	; 0xcf
    b0a8:	4c03      	ldr	r4, [pc, #12]	; (b0b8 <nm_spi_write+0xb8>)
    b0aa:	47a0      	blx	r4
	}

	return N_OK;
    b0ac:	2301      	movs	r3, #1
}
    b0ae:	0018      	movs	r0, r3
    b0b0:	46bd      	mov	sp, r7
    b0b2:	b006      	add	sp, #24
    b0b4:	bdb0      	pop	{r4, r5, r7, pc}
    b0b6:	46c0      	nop			; (mov r8, r8)
    b0b8:	0000a891 	.word	0x0000a891
    b0bc:	0000aba1 	.word	0x0000aba1
    b0c0:	0000ade5 	.word	0x0000ade5

0000b0c4 <spi_read_reg>:

static sint8 spi_read_reg(uint32 addr, uint32 *u32data)
{
    b0c4:	b5b0      	push	{r4, r5, r7, lr}
    b0c6:	b086      	sub	sp, #24
    b0c8:	af02      	add	r7, sp, #8
    b0ca:	6078      	str	r0, [r7, #4]
    b0cc:	6039      	str	r1, [r7, #0]
	sint8 result = N_OK;
    b0ce:	230d      	movs	r3, #13
    b0d0:	18fb      	adds	r3, r7, r3
    b0d2:	2201      	movs	r2, #1
    b0d4:	701a      	strb	r2, [r3, #0]
	uint8 cmd = CMD_SINGLE_READ;
    b0d6:	230f      	movs	r3, #15
    b0d8:	18fb      	adds	r3, r7, r3
    b0da:	22ca      	movs	r2, #202	; 0xca
    b0dc:	701a      	strb	r2, [r3, #0]
	uint8 tmp[4];
	uint8 clockless = 0;
    b0de:	230e      	movs	r3, #14
    b0e0:	18fb      	adds	r3, r7, r3
    b0e2:	2200      	movs	r2, #0
    b0e4:	701a      	strb	r2, [r3, #0]

	if (addr <= 0xff)
    b0e6:	687b      	ldr	r3, [r7, #4]
    b0e8:	2bff      	cmp	r3, #255	; 0xff
    b0ea:	d808      	bhi.n	b0fe <spi_read_reg+0x3a>
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_READ;
    b0ec:	230f      	movs	r3, #15
    b0ee:	18fb      	adds	r3, r7, r3
    b0f0:	22c4      	movs	r2, #196	; 0xc4
    b0f2:	701a      	strb	r2, [r3, #0]
		clockless = 1;
    b0f4:	230e      	movs	r3, #14
    b0f6:	18fb      	adds	r3, r7, r3
    b0f8:	2201      	movs	r2, #1
    b0fa:	701a      	strb	r2, [r3, #0]
    b0fc:	e007      	b.n	b10e <spi_read_reg+0x4a>
	}
	else
	{
		cmd = CMD_SINGLE_READ;
    b0fe:	230f      	movs	r3, #15
    b100:	18fb      	adds	r3, r7, r3
    b102:	22ca      	movs	r2, #202	; 0xca
    b104:	701a      	strb	r2, [r3, #0]
		clockless = 0;
    b106:	230e      	movs	r3, #14
    b108:	18fb      	adds	r3, r7, r3
    b10a:	2200      	movs	r2, #0
    b10c:	701a      	strb	r2, [r3, #0]
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
    b10e:	230d      	movs	r3, #13
    b110:	18fc      	adds	r4, r7, r3
    b112:	6879      	ldr	r1, [r7, #4]
    b114:	230f      	movs	r3, #15
    b116:	18fb      	adds	r3, r7, r3
    b118:	7818      	ldrb	r0, [r3, #0]
    b11a:	230e      	movs	r3, #14
    b11c:	18fb      	adds	r3, r7, r3
    b11e:	781b      	ldrb	r3, [r3, #0]
    b120:	9300      	str	r3, [sp, #0]
    b122:	2304      	movs	r3, #4
    b124:	2200      	movs	r2, #0
    b126:	4d2e      	ldr	r5, [pc, #184]	; (b1e0 <spi_read_reg+0x11c>)
    b128:	47a8      	blx	r5
    b12a:	0003      	movs	r3, r0
    b12c:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    b12e:	230d      	movs	r3, #13
    b130:	18fb      	adds	r3, r7, r3
    b132:	781b      	ldrb	r3, [r3, #0]
    b134:	b25b      	sxtb	r3, r3
    b136:	2b01      	cmp	r3, #1
    b138:	d001      	beq.n	b13e <spi_read_reg+0x7a>
		M2M_ERR("[nmi spi]: Failed cmd, read reg (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
    b13a:	2300      	movs	r3, #0
    b13c:	e04c      	b.n	b1d8 <spi_read_reg+0x114>
	}

	result = spi_cmd_rsp(cmd);
    b13e:	230d      	movs	r3, #13
    b140:	18fc      	adds	r4, r7, r3
    b142:	230f      	movs	r3, #15
    b144:	18fb      	adds	r3, r7, r3
    b146:	781b      	ldrb	r3, [r3, #0]
    b148:	0018      	movs	r0, r3
    b14a:	4b26      	ldr	r3, [pc, #152]	; (b1e4 <spi_read_reg+0x120>)
    b14c:	4798      	blx	r3
    b14e:	0003      	movs	r3, r0
    b150:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    b152:	230d      	movs	r3, #13
    b154:	18fb      	adds	r3, r7, r3
    b156:	781b      	ldrb	r3, [r3, #0]
    b158:	b25b      	sxtb	r3, r3
    b15a:	2b01      	cmp	r3, #1
    b15c:	d009      	beq.n	b172 <spi_read_reg+0xae>
		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    b15e:	2300      	movs	r3, #0
    b160:	9300      	str	r3, [sp, #0]
    b162:	2300      	movs	r3, #0
    b164:	2200      	movs	r2, #0
    b166:	2100      	movs	r1, #0
    b168:	20cf      	movs	r0, #207	; 0xcf
    b16a:	4c1d      	ldr	r4, [pc, #116]	; (b1e0 <spi_read_reg+0x11c>)
    b16c:	47a0      	blx	r4
		return N_FAIL;
    b16e:	2300      	movs	r3, #0
    b170:	e032      	b.n	b1d8 <spi_read_reg+0x114>
	}

	/* to avoid endianess issues */
	result = spi_data_read(&tmp[0], 4, clockless);
    b172:	230d      	movs	r3, #13
    b174:	18fc      	adds	r4, r7, r3
    b176:	230e      	movs	r3, #14
    b178:	18fb      	adds	r3, r7, r3
    b17a:	781a      	ldrb	r2, [r3, #0]
    b17c:	2308      	movs	r3, #8
    b17e:	18fb      	adds	r3, r7, r3
    b180:	2104      	movs	r1, #4
    b182:	0018      	movs	r0, r3
    b184:	4b18      	ldr	r3, [pc, #96]	; (b1e8 <spi_read_reg+0x124>)
    b186:	4798      	blx	r3
    b188:	0003      	movs	r3, r0
    b18a:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    b18c:	230d      	movs	r3, #13
    b18e:	18fb      	adds	r3, r7, r3
    b190:	781b      	ldrb	r3, [r3, #0]
    b192:	b25b      	sxtb	r3, r3
    b194:	2b01      	cmp	r3, #1
    b196:	d009      	beq.n	b1ac <spi_read_reg+0xe8>
		M2M_ERR("[nmi spi]: Failed data read...\n");
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    b198:	2300      	movs	r3, #0
    b19a:	9300      	str	r3, [sp, #0]
    b19c:	2300      	movs	r3, #0
    b19e:	2200      	movs	r2, #0
    b1a0:	2100      	movs	r1, #0
    b1a2:	20cf      	movs	r0, #207	; 0xcf
    b1a4:	4c0e      	ldr	r4, [pc, #56]	; (b1e0 <spi_read_reg+0x11c>)
    b1a6:	47a0      	blx	r4
		return N_FAIL;
    b1a8:	2300      	movs	r3, #0
    b1aa:	e015      	b.n	b1d8 <spi_read_reg+0x114>
		return N_FAIL;
	}

#endif

	*u32data = tmp[0] |
    b1ac:	2308      	movs	r3, #8
    b1ae:	18fb      	adds	r3, r7, r3
    b1b0:	781b      	ldrb	r3, [r3, #0]
    b1b2:	001a      	movs	r2, r3
		((uint32)tmp[1] << 8) |
    b1b4:	2308      	movs	r3, #8
    b1b6:	18fb      	adds	r3, r7, r3
    b1b8:	785b      	ldrb	r3, [r3, #1]
    b1ba:	021b      	lsls	r3, r3, #8
		return N_FAIL;
	}

#endif

	*u32data = tmp[0] |
    b1bc:	431a      	orrs	r2, r3
		((uint32)tmp[1] << 8) |
		((uint32)tmp[2] << 16) |
    b1be:	2308      	movs	r3, #8
    b1c0:	18fb      	adds	r3, r7, r3
    b1c2:	789b      	ldrb	r3, [r3, #2]
    b1c4:	041b      	lsls	r3, r3, #16
	}

#endif

	*u32data = tmp[0] |
		((uint32)tmp[1] << 8) |
    b1c6:	431a      	orrs	r2, r3
		((uint32)tmp[2] << 16) |
		((uint32)tmp[3] << 24);
    b1c8:	2308      	movs	r3, #8
    b1ca:	18fb      	adds	r3, r7, r3
    b1cc:	78db      	ldrb	r3, [r3, #3]
    b1ce:	061b      	lsls	r3, r3, #24

#endif

	*u32data = tmp[0] |
		((uint32)tmp[1] << 8) |
		((uint32)tmp[2] << 16) |
    b1d0:	431a      	orrs	r2, r3
		return N_FAIL;
	}

#endif

	*u32data = tmp[0] |
    b1d2:	683b      	ldr	r3, [r7, #0]
    b1d4:	601a      	str	r2, [r3, #0]
		((uint32)tmp[1] << 8) |
		((uint32)tmp[2] << 16) |
		((uint32)tmp[3] << 24);

	return N_OK;
    b1d6:	2301      	movs	r3, #1
}
    b1d8:	0018      	movs	r0, r3
    b1da:	46bd      	mov	sp, r7
    b1dc:	b004      	add	sp, #16
    b1de:	bdb0      	pop	{r4, r5, r7, pc}
    b1e0:	0000a891 	.word	0x0000a891
    b1e4:	0000aba1 	.word	0x0000aba1
    b1e8:	0000ac89 	.word	0x0000ac89

0000b1ec <nm_spi_read>:

static sint8 nm_spi_read(uint32 addr, uint8 *buf, uint16 size)
{
    b1ec:	b5b0      	push	{r4, r5, r7, lr}
    b1ee:	b088      	sub	sp, #32
    b1f0:	af02      	add	r7, sp, #8
    b1f2:	60f8      	str	r0, [r7, #12]
    b1f4:	60b9      	str	r1, [r7, #8]
    b1f6:	1dbb      	adds	r3, r7, #6
    b1f8:	801a      	strh	r2, [r3, #0]
	uint8 cmd = CMD_DMA_EXT_READ;
    b1fa:	2317      	movs	r3, #23
    b1fc:	18fb      	adds	r3, r7, r3
    b1fe:	22c8      	movs	r2, #200	; 0xc8
    b200:	701a      	strb	r2, [r3, #0]

	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, size,0);
    b202:	1dbb      	adds	r3, r7, #6
    b204:	881a      	ldrh	r2, [r3, #0]
    b206:	2316      	movs	r3, #22
    b208:	18fc      	adds	r4, r7, r3
    b20a:	68f9      	ldr	r1, [r7, #12]
    b20c:	2317      	movs	r3, #23
    b20e:	18fb      	adds	r3, r7, r3
    b210:	7818      	ldrb	r0, [r3, #0]
    b212:	2300      	movs	r3, #0
    b214:	9300      	str	r3, [sp, #0]
    b216:	0013      	movs	r3, r2
    b218:	2200      	movs	r2, #0
    b21a:	4d23      	ldr	r5, [pc, #140]	; (b2a8 <nm_spi_read+0xbc>)
    b21c:	47a8      	blx	r5
    b21e:	0003      	movs	r3, r0
    b220:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    b222:	2316      	movs	r3, #22
    b224:	18fb      	adds	r3, r7, r3
    b226:	781b      	ldrb	r3, [r3, #0]
    b228:	b25b      	sxtb	r3, r3
    b22a:	2b01      	cmp	r3, #1
    b22c:	d001      	beq.n	b232 <nm_spi_read+0x46>
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
    b22e:	2300      	movs	r3, #0
    b230:	e035      	b.n	b29e <nm_spi_read+0xb2>
	}

	result = spi_cmd_rsp(cmd);
    b232:	2316      	movs	r3, #22
    b234:	18fc      	adds	r4, r7, r3
    b236:	2317      	movs	r3, #23
    b238:	18fb      	adds	r3, r7, r3
    b23a:	781b      	ldrb	r3, [r3, #0]
    b23c:	0018      	movs	r0, r3
    b23e:	4b1b      	ldr	r3, [pc, #108]	; (b2ac <nm_spi_read+0xc0>)
    b240:	4798      	blx	r3
    b242:	0003      	movs	r3, r0
    b244:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    b246:	2316      	movs	r3, #22
    b248:	18fb      	adds	r3, r7, r3
    b24a:	781b      	ldrb	r3, [r3, #0]
    b24c:	b25b      	sxtb	r3, r3
    b24e:	2b01      	cmp	r3, #1
    b250:	d009      	beq.n	b266 <nm_spi_read+0x7a>
		M2M_ERR("[nmi spi]: Failed cmd response, read block (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    b252:	2300      	movs	r3, #0
    b254:	9300      	str	r3, [sp, #0]
    b256:	2300      	movs	r3, #0
    b258:	2200      	movs	r2, #0
    b25a:	2100      	movs	r1, #0
    b25c:	20cf      	movs	r0, #207	; 0xcf
    b25e:	4c12      	ldr	r4, [pc, #72]	; (b2a8 <nm_spi_read+0xbc>)
    b260:	47a0      	blx	r4
		return N_FAIL;
    b262:	2300      	movs	r3, #0
    b264:	e01b      	b.n	b29e <nm_spi_read+0xb2>
	}

	/**
		Data
	**/
	result = spi_data_read(buf, size,0);
    b266:	2316      	movs	r3, #22
    b268:	18fc      	adds	r4, r7, r3
    b26a:	1dbb      	adds	r3, r7, #6
    b26c:	8819      	ldrh	r1, [r3, #0]
    b26e:	68bb      	ldr	r3, [r7, #8]
    b270:	2200      	movs	r2, #0
    b272:	0018      	movs	r0, r3
    b274:	4b0e      	ldr	r3, [pc, #56]	; (b2b0 <nm_spi_read+0xc4>)
    b276:	4798      	blx	r3
    b278:	0003      	movs	r3, r0
    b27a:	7023      	strb	r3, [r4, #0]
	if (result != N_OK) {
    b27c:	2316      	movs	r3, #22
    b27e:	18fb      	adds	r3, r7, r3
    b280:	781b      	ldrb	r3, [r3, #0]
    b282:	b25b      	sxtb	r3, r3
    b284:	2b01      	cmp	r3, #1
    b286:	d009      	beq.n	b29c <nm_spi_read+0xb0>
		M2M_ERR("[nmi spi]: Failed block data read...\n");
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    b288:	2300      	movs	r3, #0
    b28a:	9300      	str	r3, [sp, #0]
    b28c:	2300      	movs	r3, #0
    b28e:	2200      	movs	r2, #0
    b290:	2100      	movs	r1, #0
    b292:	20cf      	movs	r0, #207	; 0xcf
    b294:	4c04      	ldr	r4, [pc, #16]	; (b2a8 <nm_spi_read+0xbc>)
    b296:	47a0      	blx	r4
		return N_FAIL;
    b298:	2300      	movs	r3, #0
    b29a:	e000      	b.n	b29e <nm_spi_read+0xb2>
			M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", addr);
			return N_FAIL;
		}
#endif

	return N_OK;
    b29c:	2301      	movs	r3, #1
}
    b29e:	0018      	movs	r0, r3
    b2a0:	46bd      	mov	sp, r7
    b2a2:	b006      	add	sp, #24
    b2a4:	bdb0      	pop	{r4, r5, r7, pc}
    b2a6:	46c0      	nop			; (mov r8, r8)
    b2a8:	0000a891 	.word	0x0000a891
    b2ac:	0000aba1 	.word	0x0000aba1
    b2b0:	0000ac89 	.word	0x0000ac89

0000b2b4 <spi_init_pkt_sz>:
	Bus interfaces

********************************************/

static void spi_init_pkt_sz(void)
{
    b2b4:	b580      	push	{r7, lr}
    b2b6:	b082      	sub	sp, #8
    b2b8:	af00      	add	r7, sp, #0
	uint32 val32;

	/* Make sure SPI max. packet size fits the defined DATA_PKT_SZ.  */
	val32 = nm_spi_read_reg(SPI_BASE+0x24);
    b2ba:	4b0c      	ldr	r3, [pc, #48]	; (b2ec <spi_init_pkt_sz+0x38>)
    b2bc:	0018      	movs	r0, r3
    b2be:	4b0c      	ldr	r3, [pc, #48]	; (b2f0 <spi_init_pkt_sz+0x3c>)
    b2c0:	4798      	blx	r3
    b2c2:	0003      	movs	r3, r0
    b2c4:	607b      	str	r3, [r7, #4]
	val32 &= ~(0x7 << 4);
    b2c6:	687b      	ldr	r3, [r7, #4]
    b2c8:	2270      	movs	r2, #112	; 0x70
    b2ca:	4393      	bics	r3, r2
    b2cc:	607b      	str	r3, [r7, #4]
	case 256:  val32 |= (0 << 4); break;
	case 512:  val32 |= (1 << 4); break;
	case 1024: val32 |= (2 << 4); break;
	case 2048: val32 |= (3 << 4); break;
	case 4096: val32 |= (4 << 4); break;
	case 8192: val32 |= (5 << 4); break;
    b2ce:	687b      	ldr	r3, [r7, #4]
    b2d0:	2250      	movs	r2, #80	; 0x50
    b2d2:	4313      	orrs	r3, r2
    b2d4:	607b      	str	r3, [r7, #4]
    b2d6:	46c0      	nop			; (mov r8, r8)

	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
    b2d8:	687b      	ldr	r3, [r7, #4]
    b2da:	4a04      	ldr	r2, [pc, #16]	; (b2ec <spi_init_pkt_sz+0x38>)
    b2dc:	0019      	movs	r1, r3
    b2de:	0010      	movs	r0, r2
    b2e0:	4b04      	ldr	r3, [pc, #16]	; (b2f4 <spi_init_pkt_sz+0x40>)
    b2e2:	4798      	blx	r3
}
    b2e4:	46c0      	nop			; (mov r8, r8)
    b2e6:	46bd      	mov	sp, r7
    b2e8:	b002      	add	sp, #8
    b2ea:	bd80      	pop	{r7, pc}
    b2ec:	0000e824 	.word	0x0000e824
    b2f0:	0000b3c1 	.word	0x0000b3c1
    b2f4:	0000b435 	.word	0x0000b435

0000b2f8 <nm_spi_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_init(void)
{
    b2f8:	b580      	push	{r7, lr}
    b2fa:	b082      	sub	sp, #8
    b2fc:	af00      	add	r7, sp, #0
	uint32 chipid;
	uint32 reg =0;
    b2fe:	2300      	movs	r3, #0
    b300:	603b      	str	r3, [r7, #0]

	/**
		configure protocol
	**/
	gu8Crc_off = 0;
    b302:	4b24      	ldr	r3, [pc, #144]	; (b394 <nm_spi_init+0x9c>)
    b304:	2200      	movs	r2, #0
    b306:	701a      	strb	r2, [r3, #0]

	// TODO: We can remove the CRC trials if there is a definite way to reset
	// the SPI to it's initial value.
	if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)) {
    b308:	003b      	movs	r3, r7
    b30a:	4a23      	ldr	r2, [pc, #140]	; (b398 <nm_spi_init+0xa0>)
    b30c:	0019      	movs	r1, r3
    b30e:	0010      	movs	r0, r2
    b310:	4b22      	ldr	r3, [pc, #136]	; (b39c <nm_spi_init+0xa4>)
    b312:	4798      	blx	r3
    b314:	1e03      	subs	r3, r0, #0
    b316:	d10c      	bne.n	b332 <nm_spi_init+0x3a>
		/* Read failed. Try with CRC off. This might happen when module
		is removed but chip isn't reset*/
		gu8Crc_off = 1;
    b318:	4b1e      	ldr	r3, [pc, #120]	; (b394 <nm_spi_init+0x9c>)
    b31a:	2201      	movs	r2, #1
    b31c:	701a      	strb	r2, [r3, #0]
		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
		if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)){
    b31e:	003b      	movs	r3, r7
    b320:	4a1d      	ldr	r2, [pc, #116]	; (b398 <nm_spi_init+0xa0>)
    b322:	0019      	movs	r1, r3
    b324:	0010      	movs	r0, r2
    b326:	4b1d      	ldr	r3, [pc, #116]	; (b39c <nm_spi_init+0xa4>)
    b328:	4798      	blx	r3
    b32a:	1e03      	subs	r3, r0, #0
    b32c:	d101      	bne.n	b332 <nm_spi_init+0x3a>
			// Reaad failed with both CRC on and off, something went bad
			M2M_ERR( "[nmi spi]: Failed internal read protocol...\n");
			return 0;
    b32e:	2300      	movs	r3, #0
    b330:	e02b      	b.n	b38a <nm_spi_init+0x92>
		}
	}
	if(gu8Crc_off == 0)
    b332:	4b18      	ldr	r3, [pc, #96]	; (b394 <nm_spi_init+0x9c>)
    b334:	781b      	ldrb	r3, [r3, #0]
    b336:	2b00      	cmp	r3, #0
    b338:	d118      	bne.n	b36c <nm_spi_init+0x74>
	{
		reg &= ~0xc;	/* disable crc checking */
    b33a:	683b      	ldr	r3, [r7, #0]
    b33c:	220c      	movs	r2, #12
    b33e:	4393      	bics	r3, r2
    b340:	603b      	str	r3, [r7, #0]
		reg &= ~0x70;
    b342:	683b      	ldr	r3, [r7, #0]
    b344:	2270      	movs	r2, #112	; 0x70
    b346:	4393      	bics	r3, r2
    b348:	603b      	str	r3, [r7, #0]
		reg |= (0x5 << 4);
    b34a:	683b      	ldr	r3, [r7, #0]
    b34c:	2250      	movs	r2, #80	; 0x50
    b34e:	4313      	orrs	r3, r2
    b350:	603b      	str	r3, [r7, #0]
		if (!spi_write_reg(NMI_SPI_PROTOCOL_CONFIG, reg)) {
    b352:	683b      	ldr	r3, [r7, #0]
    b354:	4a10      	ldr	r2, [pc, #64]	; (b398 <nm_spi_init+0xa0>)
    b356:	0019      	movs	r1, r3
    b358:	0010      	movs	r0, r2
    b35a:	4b11      	ldr	r3, [pc, #68]	; (b3a0 <nm_spi_init+0xa8>)
    b35c:	4798      	blx	r3
    b35e:	1e03      	subs	r3, r0, #0
    b360:	d101      	bne.n	b366 <nm_spi_init+0x6e>
			M2M_ERR( "[nmi spi]: Failed internal write protocol reg...\n");
			return 0;
    b362:	2300      	movs	r3, #0
    b364:	e011      	b.n	b38a <nm_spi_init+0x92>
		}
		gu8Crc_off = 1;
    b366:	4b0b      	ldr	r3, [pc, #44]	; (b394 <nm_spi_init+0x9c>)
    b368:	2201      	movs	r2, #1
    b36a:	701a      	strb	r2, [r3, #0]
	}

	/**
		make sure can read back chip id correctly
	**/
	if (!spi_read_reg(0x1000, &chipid)) {
    b36c:	1d3a      	adds	r2, r7, #4
    b36e:	2380      	movs	r3, #128	; 0x80
    b370:	015b      	lsls	r3, r3, #5
    b372:	0011      	movs	r1, r2
    b374:	0018      	movs	r0, r3
    b376:	4b09      	ldr	r3, [pc, #36]	; (b39c <nm_spi_init+0xa4>)
    b378:	4798      	blx	r3
    b37a:	1e03      	subs	r3, r0, #0
    b37c:	d102      	bne.n	b384 <nm_spi_init+0x8c>
		M2M_ERR("[nmi spi]: Fail cmd read chip id...\n");
		return M2M_ERR_BUS_FAIL;
    b37e:	2306      	movs	r3, #6
    b380:	425b      	negs	r3, r3
    b382:	e002      	b.n	b38a <nm_spi_init+0x92>
	}

	M2M_DBG("[nmi spi]: chipid (%08x)\n", (unsigned int)chipid);
	spi_init_pkt_sz();
    b384:	4b07      	ldr	r3, [pc, #28]	; (b3a4 <nm_spi_init+0xac>)
    b386:	4798      	blx	r3


	return M2M_SUCCESS;
    b388:	2300      	movs	r3, #0
}
    b38a:	0018      	movs	r0, r3
    b38c:	46bd      	mov	sp, r7
    b38e:	b002      	add	sp, #8
    b390:	bd80      	pop	{r7, pc}
    b392:	46c0      	nop			; (mov r8, r8)
    b394:	2000052c 	.word	0x2000052c
    b398:	0000e824 	.word	0x0000e824
    b39c:	0000b0c5 	.word	0x0000b0c5
    b3a0:	0000af41 	.word	0x0000af41
    b3a4:	0000b2b5 	.word	0x0000b2b5

0000b3a8 <nm_spi_deinit>:
*	@author	Samer Sarhan
*	@date	27 Feb 2015
*	@version	1.0
*/
sint8 nm_spi_deinit(void)
{
    b3a8:	b580      	push	{r7, lr}
    b3aa:	af00      	add	r7, sp, #0
	gu8Crc_off = 0;
    b3ac:	4b03      	ldr	r3, [pc, #12]	; (b3bc <nm_spi_deinit+0x14>)
    b3ae:	2200      	movs	r2, #0
    b3b0:	701a      	strb	r2, [r3, #0]
	return M2M_SUCCESS;
    b3b2:	2300      	movs	r3, #0
}
    b3b4:	0018      	movs	r0, r3
    b3b6:	46bd      	mov	sp, r7
    b3b8:	bd80      	pop	{r7, pc}
    b3ba:	46c0      	nop			; (mov r8, r8)
    b3bc:	2000052c 	.word	0x2000052c

0000b3c0 <nm_spi_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_spi_read_reg(uint32 u32Addr)
{
    b3c0:	b580      	push	{r7, lr}
    b3c2:	b084      	sub	sp, #16
    b3c4:	af00      	add	r7, sp, #0
    b3c6:	6078      	str	r0, [r7, #4]
	uint32 u32Val;

	spi_read_reg(u32Addr, &u32Val);
    b3c8:	230c      	movs	r3, #12
    b3ca:	18fa      	adds	r2, r7, r3
    b3cc:	687b      	ldr	r3, [r7, #4]
    b3ce:	0011      	movs	r1, r2
    b3d0:	0018      	movs	r0, r3
    b3d2:	4b03      	ldr	r3, [pc, #12]	; (b3e0 <nm_spi_read_reg+0x20>)
    b3d4:	4798      	blx	r3

	return u32Val;
    b3d6:	68fb      	ldr	r3, [r7, #12]
}
    b3d8:	0018      	movs	r0, r3
    b3da:	46bd      	mov	sp, r7
    b3dc:	b004      	add	sp, #16
    b3de:	bd80      	pop	{r7, pc}
    b3e0:	0000b0c5 	.word	0x0000b0c5

0000b3e4 <nm_spi_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    b3e4:	b590      	push	{r4, r7, lr}
    b3e6:	b085      	sub	sp, #20
    b3e8:	af00      	add	r7, sp, #0
    b3ea:	6078      	str	r0, [r7, #4]
    b3ec:	6039      	str	r1, [r7, #0]
	sint8 s8Ret;

	s8Ret = spi_read_reg(u32Addr,pu32RetVal);
    b3ee:	230f      	movs	r3, #15
    b3f0:	18fc      	adds	r4, r7, r3
    b3f2:	683a      	ldr	r2, [r7, #0]
    b3f4:	687b      	ldr	r3, [r7, #4]
    b3f6:	0011      	movs	r1, r2
    b3f8:	0018      	movs	r0, r3
    b3fa:	4b0d      	ldr	r3, [pc, #52]	; (b430 <nm_spi_read_reg_with_ret+0x4c>)
    b3fc:	4798      	blx	r3
    b3fe:	0003      	movs	r3, r0
    b400:	7023      	strb	r3, [r4, #0]

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    b402:	230f      	movs	r3, #15
    b404:	18fb      	adds	r3, r7, r3
    b406:	781b      	ldrb	r3, [r3, #0]
    b408:	b25b      	sxtb	r3, r3
    b40a:	2b01      	cmp	r3, #1
    b40c:	d104      	bne.n	b418 <nm_spi_read_reg_with_ret+0x34>
    b40e:	230f      	movs	r3, #15
    b410:	18fb      	adds	r3, r7, r3
    b412:	2200      	movs	r2, #0
    b414:	701a      	strb	r2, [r3, #0]
    b416:	e003      	b.n	b420 <nm_spi_read_reg_with_ret+0x3c>
	else s8Ret = M2M_ERR_BUS_FAIL;
    b418:	230f      	movs	r3, #15
    b41a:	18fb      	adds	r3, r7, r3
    b41c:	22fa      	movs	r2, #250	; 0xfa
    b41e:	701a      	strb	r2, [r3, #0]

	return s8Ret;
    b420:	230f      	movs	r3, #15
    b422:	18fb      	adds	r3, r7, r3
    b424:	781b      	ldrb	r3, [r3, #0]
    b426:	b25b      	sxtb	r3, r3
}
    b428:	0018      	movs	r0, r3
    b42a:	46bd      	mov	sp, r7
    b42c:	b005      	add	sp, #20
    b42e:	bd90      	pop	{r4, r7, pc}
    b430:	0000b0c5 	.word	0x0000b0c5

0000b434 <nm_spi_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val)
{
    b434:	b590      	push	{r4, r7, lr}
    b436:	b085      	sub	sp, #20
    b438:	af00      	add	r7, sp, #0
    b43a:	6078      	str	r0, [r7, #4]
    b43c:	6039      	str	r1, [r7, #0]
	sint8 s8Ret;

	s8Ret = spi_write_reg(u32Addr, u32Val);
    b43e:	230f      	movs	r3, #15
    b440:	18fc      	adds	r4, r7, r3
    b442:	683a      	ldr	r2, [r7, #0]
    b444:	687b      	ldr	r3, [r7, #4]
    b446:	0011      	movs	r1, r2
    b448:	0018      	movs	r0, r3
    b44a:	4b0d      	ldr	r3, [pc, #52]	; (b480 <nm_spi_write_reg+0x4c>)
    b44c:	4798      	blx	r3
    b44e:	0003      	movs	r3, r0
    b450:	7023      	strb	r3, [r4, #0]

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    b452:	230f      	movs	r3, #15
    b454:	18fb      	adds	r3, r7, r3
    b456:	781b      	ldrb	r3, [r3, #0]
    b458:	b25b      	sxtb	r3, r3
    b45a:	2b01      	cmp	r3, #1
    b45c:	d104      	bne.n	b468 <nm_spi_write_reg+0x34>
    b45e:	230f      	movs	r3, #15
    b460:	18fb      	adds	r3, r7, r3
    b462:	2200      	movs	r2, #0
    b464:	701a      	strb	r2, [r3, #0]
    b466:	e003      	b.n	b470 <nm_spi_write_reg+0x3c>
	else s8Ret = M2M_ERR_BUS_FAIL;
    b468:	230f      	movs	r3, #15
    b46a:	18fb      	adds	r3, r7, r3
    b46c:	22fa      	movs	r2, #250	; 0xfa
    b46e:	701a      	strb	r2, [r3, #0]

	return s8Ret;
    b470:	230f      	movs	r3, #15
    b472:	18fb      	adds	r3, r7, r3
    b474:	781b      	ldrb	r3, [r3, #0]
    b476:	b25b      	sxtb	r3, r3
}
    b478:	0018      	movs	r0, r3
    b47a:	46bd      	mov	sp, r7
    b47c:	b005      	add	sp, #20
    b47e:	bd90      	pop	{r4, r7, pc}
    b480:	0000af41 	.word	0x0000af41

0000b484 <nm_spi_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    b484:	b590      	push	{r4, r7, lr}
    b486:	b087      	sub	sp, #28
    b488:	af00      	add	r7, sp, #0
    b48a:	60f8      	str	r0, [r7, #12]
    b48c:	60b9      	str	r1, [r7, #8]
    b48e:	1dbb      	adds	r3, r7, #6
    b490:	801a      	strh	r2, [r3, #0]
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);
    b492:	2317      	movs	r3, #23
    b494:	18fc      	adds	r4, r7, r3
    b496:	1dbb      	adds	r3, r7, #6
    b498:	881a      	ldrh	r2, [r3, #0]
    b49a:	68b9      	ldr	r1, [r7, #8]
    b49c:	68fb      	ldr	r3, [r7, #12]
    b49e:	0018      	movs	r0, r3
    b4a0:	4b0d      	ldr	r3, [pc, #52]	; (b4d8 <nm_spi_read_block+0x54>)
    b4a2:	4798      	blx	r3
    b4a4:	0003      	movs	r3, r0
    b4a6:	7023      	strb	r3, [r4, #0]

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    b4a8:	2317      	movs	r3, #23
    b4aa:	18fb      	adds	r3, r7, r3
    b4ac:	781b      	ldrb	r3, [r3, #0]
    b4ae:	b25b      	sxtb	r3, r3
    b4b0:	2b01      	cmp	r3, #1
    b4b2:	d104      	bne.n	b4be <nm_spi_read_block+0x3a>
    b4b4:	2317      	movs	r3, #23
    b4b6:	18fb      	adds	r3, r7, r3
    b4b8:	2200      	movs	r2, #0
    b4ba:	701a      	strb	r2, [r3, #0]
    b4bc:	e003      	b.n	b4c6 <nm_spi_read_block+0x42>
	else s8Ret = M2M_ERR_BUS_FAIL;
    b4be:	2317      	movs	r3, #23
    b4c0:	18fb      	adds	r3, r7, r3
    b4c2:	22fa      	movs	r2, #250	; 0xfa
    b4c4:	701a      	strb	r2, [r3, #0]

	return s8Ret;
    b4c6:	2317      	movs	r3, #23
    b4c8:	18fb      	adds	r3, r7, r3
    b4ca:	781b      	ldrb	r3, [r3, #0]
    b4cc:	b25b      	sxtb	r3, r3
}
    b4ce:	0018      	movs	r0, r3
    b4d0:	46bd      	mov	sp, r7
    b4d2:	b007      	add	sp, #28
    b4d4:	bd90      	pop	{r4, r7, pc}
    b4d6:	46c0      	nop			; (mov r8, r8)
    b4d8:	0000b1ed 	.word	0x0000b1ed

0000b4dc <nm_spi_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    b4dc:	b590      	push	{r4, r7, lr}
    b4de:	b087      	sub	sp, #28
    b4e0:	af00      	add	r7, sp, #0
    b4e2:	60f8      	str	r0, [r7, #12]
    b4e4:	60b9      	str	r1, [r7, #8]
    b4e6:	1dbb      	adds	r3, r7, #6
    b4e8:	801a      	strh	r2, [r3, #0]
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);
    b4ea:	2317      	movs	r3, #23
    b4ec:	18fc      	adds	r4, r7, r3
    b4ee:	1dbb      	adds	r3, r7, #6
    b4f0:	881a      	ldrh	r2, [r3, #0]
    b4f2:	68b9      	ldr	r1, [r7, #8]
    b4f4:	68fb      	ldr	r3, [r7, #12]
    b4f6:	0018      	movs	r0, r3
    b4f8:	4b0d      	ldr	r3, [pc, #52]	; (b530 <nm_spi_write_block+0x54>)
    b4fa:	4798      	blx	r3
    b4fc:	0003      	movs	r3, r0
    b4fe:	7023      	strb	r3, [r4, #0]

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    b500:	2317      	movs	r3, #23
    b502:	18fb      	adds	r3, r7, r3
    b504:	781b      	ldrb	r3, [r3, #0]
    b506:	b25b      	sxtb	r3, r3
    b508:	2b01      	cmp	r3, #1
    b50a:	d104      	bne.n	b516 <nm_spi_write_block+0x3a>
    b50c:	2317      	movs	r3, #23
    b50e:	18fb      	adds	r3, r7, r3
    b510:	2200      	movs	r2, #0
    b512:	701a      	strb	r2, [r3, #0]
    b514:	e003      	b.n	b51e <nm_spi_write_block+0x42>
	else s8Ret = M2M_ERR_BUS_FAIL;
    b516:	2317      	movs	r3, #23
    b518:	18fb      	adds	r3, r7, r3
    b51a:	22fa      	movs	r2, #250	; 0xfa
    b51c:	701a      	strb	r2, [r3, #0]

	return s8Ret;
    b51e:	2317      	movs	r3, #23
    b520:	18fb      	adds	r3, r7, r3
    b522:	781b      	ldrb	r3, [r3, #0]
    b524:	b25b      	sxtb	r3, r3
}
    b526:	0018      	movs	r0, r3
    b528:	46bd      	mov	sp, r7
    b52a:	b007      	add	sp, #28
    b52c:	bd90      	pop	{r4, r7, pc}
    b52e:	46c0      	nop			; (mov r8, r8)
    b530:	0000b001 	.word	0x0000b001

0000b534 <socket>:

Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
    b534:	b590      	push	{r4, r7, lr}
    b536:	b08b      	sub	sp, #44	; 0x2c
    b538:	af04      	add	r7, sp, #16
    b53a:	0004      	movs	r4, r0
    b53c:	0008      	movs	r0, r1
    b53e:	0011      	movs	r1, r2
    b540:	1dbb      	adds	r3, r7, #6
    b542:	1c22      	adds	r2, r4, #0
    b544:	801a      	strh	r2, [r3, #0]
    b546:	1d7b      	adds	r3, r7, #5
    b548:	1c02      	adds	r2, r0, #0
    b54a:	701a      	strb	r2, [r3, #0]
    b54c:	1d3b      	adds	r3, r7, #4
    b54e:	1c0a      	adds	r2, r1, #0
    b550:	701a      	strb	r2, [r3, #0]
	SOCKET		sock = -1;
    b552:	2317      	movs	r3, #23
    b554:	18fb      	adds	r3, r7, r3
    b556:	22ff      	movs	r2, #255	; 0xff
    b558:	701a      	strb	r2, [r3, #0]
	uint8		u8Count,u8SocketCount = MAX_SOCKET;
    b55a:	2315      	movs	r3, #21
    b55c:	18fb      	adds	r3, r7, r3
    b55e:	220b      	movs	r2, #11
    b560:	701a      	strb	r2, [r3, #0]
	volatile tstrSocket	*pstrSock;
	
	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
    b562:	1dbb      	adds	r3, r7, #6
    b564:	881b      	ldrh	r3, [r3, #0]
    b566:	2b02      	cmp	r3, #2
    b568:	d000      	beq.n	b56c <socket+0x38>
    b56a:	e07e      	b.n	b66a <socket+0x136>
	{
		if(u8Type == SOCK_STREAM)
    b56c:	1d7b      	adds	r3, r7, #5
    b56e:	781b      	ldrb	r3, [r3, #0]
    b570:	2b01      	cmp	r3, #1
    b572:	d108      	bne.n	b586 <socket+0x52>
		{
			u8SocketCount = TCP_SOCK_MAX;
    b574:	2315      	movs	r3, #21
    b576:	18fb      	adds	r3, r7, r3
    b578:	2207      	movs	r2, #7
    b57a:	701a      	strb	r2, [r3, #0]
			u8Count = 0;
    b57c:	2316      	movs	r3, #22
    b57e:	18fb      	adds	r3, r7, r3
    b580:	2200      	movs	r2, #0
    b582:	701a      	strb	r2, [r3, #0]
    b584:	e067      	b.n	b656 <socket+0x122>
		}
		else if(u8Type == SOCK_DGRAM)
    b586:	1d7b      	adds	r3, r7, #5
    b588:	781b      	ldrb	r3, [r3, #0]
    b58a:	2b02      	cmp	r3, #2
    b58c:	d108      	bne.n	b5a0 <socket+0x6c>
		{
			/*--- UDP SOCKET ---*/
			u8SocketCount = MAX_SOCKET;
    b58e:	2315      	movs	r3, #21
    b590:	18fb      	adds	r3, r7, r3
    b592:	220b      	movs	r2, #11
    b594:	701a      	strb	r2, [r3, #0]
			u8Count = TCP_SOCK_MAX;
    b596:	2316      	movs	r3, #22
    b598:	18fb      	adds	r3, r7, r3
    b59a:	2207      	movs	r2, #7
    b59c:	701a      	strb	r2, [r3, #0]
    b59e:	e05a      	b.n	b656 <socket+0x122>
		}
		else
			return sock;
    b5a0:	2317      	movs	r3, #23
    b5a2:	18fb      	adds	r3, r7, r3
    b5a4:	781b      	ldrb	r3, [r3, #0]
    b5a6:	b25b      	sxtb	r3, r3
    b5a8:	e063      	b.n	b672 <socket+0x13e>

		for(;u8Count < u8SocketCount; u8Count ++)
		{
			pstrSock = &gastrSockets[u8Count];
    b5aa:	2316      	movs	r3, #22
    b5ac:	18fb      	adds	r3, r7, r3
    b5ae:	781b      	ldrb	r3, [r3, #0]
    b5b0:	011a      	lsls	r2, r3, #4
    b5b2:	4b32      	ldr	r3, [pc, #200]	; (b67c <socket+0x148>)
    b5b4:	18d3      	adds	r3, r2, r3
    b5b6:	613b      	str	r3, [r7, #16]
			if(pstrSock->bIsUsed == 0)
    b5b8:	693b      	ldr	r3, [r7, #16]
    b5ba:	7a9b      	ldrb	r3, [r3, #10]
    b5bc:	b2db      	uxtb	r3, r3
    b5be:	2b00      	cmp	r3, #0
    b5c0:	d142      	bne.n	b648 <socket+0x114>
			{
				m2m_memset((uint8*)pstrSock, 0, sizeof(tstrSocket));
    b5c2:	693b      	ldr	r3, [r7, #16]
    b5c4:	2210      	movs	r2, #16
    b5c6:	2100      	movs	r1, #0
    b5c8:	0018      	movs	r0, r3
    b5ca:	4b2d      	ldr	r3, [pc, #180]	; (b680 <socket+0x14c>)
    b5cc:	4798      	blx	r3

				pstrSock->bIsUsed = 1;
    b5ce:	693b      	ldr	r3, [r7, #16]
    b5d0:	2201      	movs	r2, #1
    b5d2:	729a      	strb	r2, [r3, #10]

				/* The session ID is used to distinguish different socket connections
					by comparing the assigned session ID to the one reported by the firmware*/
				++gu16SessionID;
    b5d4:	4b2b      	ldr	r3, [pc, #172]	; (b684 <socket+0x150>)
    b5d6:	881b      	ldrh	r3, [r3, #0]
    b5d8:	b29b      	uxth	r3, r3
    b5da:	3301      	adds	r3, #1
    b5dc:	b29a      	uxth	r2, r3
    b5de:	4b29      	ldr	r3, [pc, #164]	; (b684 <socket+0x150>)
    b5e0:	801a      	strh	r2, [r3, #0]
				if(gu16SessionID == 0)
    b5e2:	4b28      	ldr	r3, [pc, #160]	; (b684 <socket+0x150>)
    b5e4:	881b      	ldrh	r3, [r3, #0]
    b5e6:	b29b      	uxth	r3, r3
    b5e8:	2b00      	cmp	r3, #0
    b5ea:	d106      	bne.n	b5fa <socket+0xc6>
					++gu16SessionID;
    b5ec:	4b25      	ldr	r3, [pc, #148]	; (b684 <socket+0x150>)
    b5ee:	881b      	ldrh	r3, [r3, #0]
    b5f0:	b29b      	uxth	r3, r3
    b5f2:	3301      	adds	r3, #1
    b5f4:	b29a      	uxth	r2, r3
    b5f6:	4b23      	ldr	r3, [pc, #140]	; (b684 <socket+0x150>)
    b5f8:	801a      	strh	r2, [r3, #0]
				
				pstrSock->u16SessionID = gu16SessionID;
    b5fa:	4b22      	ldr	r3, [pc, #136]	; (b684 <socket+0x150>)
    b5fc:	881b      	ldrh	r3, [r3, #0]
    b5fe:	b29a      	uxth	r2, r3
    b600:	693b      	ldr	r3, [r7, #16]
    b602:	80da      	strh	r2, [r3, #6]
				M2M_DBG("1 Socket %d session ID = %d\r\n",u8Count, gu16SessionID );
				sock = (SOCKET)u8Count;
    b604:	2317      	movs	r3, #23
    b606:	18fb      	adds	r3, r7, r3
    b608:	2216      	movs	r2, #22
    b60a:	18ba      	adds	r2, r7, r2
    b60c:	7812      	ldrb	r2, [r2, #0]
    b60e:	701a      	strb	r2, [r3, #0]

				if(u8Flags & SOCKET_FLAGS_SSL)
    b610:	1d3b      	adds	r3, r7, #4
    b612:	781b      	ldrb	r3, [r3, #0]
    b614:	2201      	movs	r2, #1
    b616:	4013      	ands	r3, r2
    b618:	d026      	beq.n	b668 <socket+0x134>
				{
					tstrSSLSocketCreateCmd	strSSLCreate;
					strSSLCreate.sslSock = sock;
    b61a:	230c      	movs	r3, #12
    b61c:	18fb      	adds	r3, r7, r3
    b61e:	2217      	movs	r2, #23
    b620:	18ba      	adds	r2, r7, r2
    b622:	7812      	ldrb	r2, [r2, #0]
    b624:	701a      	strb	r2, [r3, #0]
					pstrSock->u8SSLFlags = SSL_FLAGS_ACTIVE | SSL_FLAGS_NO_TX_COPY;
    b626:	693b      	ldr	r3, [r7, #16]
    b628:	2221      	movs	r2, #33	; 0x21
    b62a:	72da      	strb	r2, [r3, #11]
					SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
    b62c:	230c      	movs	r3, #12
    b62e:	18fa      	adds	r2, r7, r3
    b630:	2300      	movs	r3, #0
    b632:	9302      	str	r3, [sp, #8]
    b634:	2300      	movs	r3, #0
    b636:	9301      	str	r3, [sp, #4]
    b638:	2300      	movs	r3, #0
    b63a:	9300      	str	r3, [sp, #0]
    b63c:	2304      	movs	r3, #4
    b63e:	2150      	movs	r1, #80	; 0x50
    b640:	2002      	movs	r0, #2
    b642:	4c11      	ldr	r4, [pc, #68]	; (b688 <socket+0x154>)
    b644:	47a0      	blx	r4
				}
				break;
    b646:	e00f      	b.n	b668 <socket+0x134>
			u8Count = TCP_SOCK_MAX;
		}
		else
			return sock;

		for(;u8Count < u8SocketCount; u8Count ++)
    b648:	2316      	movs	r3, #22
    b64a:	18fb      	adds	r3, r7, r3
    b64c:	781a      	ldrb	r2, [r3, #0]
    b64e:	2316      	movs	r3, #22
    b650:	18fb      	adds	r3, r7, r3
    b652:	3201      	adds	r2, #1
    b654:	701a      	strb	r2, [r3, #0]
    b656:	2316      	movs	r3, #22
    b658:	18fa      	adds	r2, r7, r3
    b65a:	2315      	movs	r3, #21
    b65c:	18fb      	adds	r3, r7, r3
    b65e:	7812      	ldrb	r2, [r2, #0]
    b660:	781b      	ldrb	r3, [r3, #0]
    b662:	429a      	cmp	r2, r3
    b664:	d3a1      	bcc.n	b5aa <socket+0x76>
    b666:	e000      	b.n	b66a <socket+0x136>
					tstrSSLSocketCreateCmd	strSSLCreate;
					strSSLCreate.sslSock = sock;
					pstrSock->u8SSLFlags = SSL_FLAGS_ACTIVE | SSL_FLAGS_NO_TX_COPY;
					SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
				}
				break;
    b668:	46c0      	nop			; (mov r8, r8)
			}
		}
	}
	return sock;
    b66a:	2317      	movs	r3, #23
    b66c:	18fb      	adds	r3, r7, r3
    b66e:	781b      	ldrb	r3, [r3, #0]
    b670:	b25b      	sxtb	r3, r3
}
    b672:	0018      	movs	r0, r3
    b674:	46bd      	mov	sp, r7
    b676:	b007      	add	sp, #28
    b678:	bd90      	pop	{r4, r7, pc}
    b67a:	46c0      	nop			; (mov r8, r8)
    b67c:	20003d38 	.word	0x20003d38
    b680:	00008bd9 	.word	0x00008bd9
    b684:	2000052e 	.word	0x2000052e
    b688:	00008e91 	.word	0x00008e91

0000b68c <bind>:

Date
		5 June 2012
*********************************************************************/
sint8 bind(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
    b68c:	b5b0      	push	{r4, r5, r7, lr}
    b68e:	b08a      	sub	sp, #40	; 0x28
    b690:	af04      	add	r7, sp, #16
    b692:	6039      	str	r1, [r7, #0]
    b694:	0011      	movs	r1, r2
    b696:	1dfb      	adds	r3, r7, #7
    b698:	1c02      	adds	r2, r0, #0
    b69a:	701a      	strb	r2, [r3, #0]
    b69c:	1dbb      	adds	r3, r7, #6
    b69e:	1c0a      	adds	r2, r1, #0
    b6a0:	701a      	strb	r2, [r3, #0]
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    b6a2:	2317      	movs	r3, #23
    b6a4:	18fb      	adds	r3, r7, r3
    b6a6:	22fa      	movs	r2, #250	; 0xfa
    b6a8:	701a      	strb	r2, [r3, #0]
	if((pstrAddr != NULL) && (sock >= 0) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
    b6aa:	683b      	ldr	r3, [r7, #0]
    b6ac:	2b00      	cmp	r3, #0
    b6ae:	d057      	beq.n	b760 <bind+0xd4>
    b6b0:	1dfb      	adds	r3, r7, #7
    b6b2:	781b      	ldrb	r3, [r3, #0]
    b6b4:	2b7f      	cmp	r3, #127	; 0x7f
    b6b6:	d853      	bhi.n	b760 <bind+0xd4>
    b6b8:	1dfb      	adds	r3, r7, #7
    b6ba:	781b      	ldrb	r3, [r3, #0]
    b6bc:	b25b      	sxtb	r3, r3
    b6be:	4a2c      	ldr	r2, [pc, #176]	; (b770 <bind+0xe4>)
    b6c0:	011b      	lsls	r3, r3, #4
    b6c2:	18d3      	adds	r3, r2, r3
    b6c4:	330a      	adds	r3, #10
    b6c6:	781b      	ldrb	r3, [r3, #0]
    b6c8:	b2db      	uxtb	r3, r3
    b6ca:	2b01      	cmp	r3, #1
    b6cc:	d148      	bne.n	b760 <bind+0xd4>
    b6ce:	1dbb      	adds	r3, r7, #6
    b6d0:	781b      	ldrb	r3, [r3, #0]
    b6d2:	2b00      	cmp	r3, #0
    b6d4:	d044      	beq.n	b760 <bind+0xd4>
	{
		tstrBindCmd			strBind;

		/* Build the bind request. */
		strBind.sock = sock;
    b6d6:	2308      	movs	r3, #8
    b6d8:	18fb      	adds	r3, r7, r3
    b6da:	1dfa      	adds	r2, r7, #7
    b6dc:	7812      	ldrb	r2, [r2, #0]
    b6de:	721a      	strb	r2, [r3, #8]
		m2m_memcpy((uint8 *)&strBind.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
    b6e0:	6839      	ldr	r1, [r7, #0]
    b6e2:	2308      	movs	r3, #8
    b6e4:	18fb      	adds	r3, r7, r3
    b6e6:	2208      	movs	r2, #8
    b6e8:	0018      	movs	r0, r3
    b6ea:	4b22      	ldr	r3, [pc, #136]	; (b774 <bind+0xe8>)
    b6ec:	4798      	blx	r3

		strBind.strAddr.u16Family	= strBind.strAddr.u16Family;
    b6ee:	2308      	movs	r3, #8
    b6f0:	18fb      	adds	r3, r7, r3
    b6f2:	881a      	ldrh	r2, [r3, #0]
    b6f4:	2308      	movs	r3, #8
    b6f6:	18fb      	adds	r3, r7, r3
    b6f8:	801a      	strh	r2, [r3, #0]
		strBind.strAddr.u16Port		= strBind.strAddr.u16Port;
    b6fa:	2308      	movs	r3, #8
    b6fc:	18fb      	adds	r3, r7, r3
    b6fe:	885a      	ldrh	r2, [r3, #2]
    b700:	2308      	movs	r3, #8
    b702:	18fb      	adds	r3, r7, r3
    b704:	805a      	strh	r2, [r3, #2]
		strBind.strAddr.u32IPAddr	= strBind.strAddr.u32IPAddr;
    b706:	2308      	movs	r3, #8
    b708:	18fb      	adds	r3, r7, r3
    b70a:	685a      	ldr	r2, [r3, #4]
    b70c:	2308      	movs	r3, #8
    b70e:	18fb      	adds	r3, r7, r3
    b710:	605a      	str	r2, [r3, #4]
		strBind.u16SessionID		= gastrSockets[sock].u16SessionID;
    b712:	1dfb      	adds	r3, r7, #7
    b714:	781b      	ldrb	r3, [r3, #0]
    b716:	b25b      	sxtb	r3, r3
    b718:	4a15      	ldr	r2, [pc, #84]	; (b770 <bind+0xe4>)
    b71a:	011b      	lsls	r3, r3, #4
    b71c:	18d3      	adds	r3, r2, r3
    b71e:	3306      	adds	r3, #6
    b720:	881b      	ldrh	r3, [r3, #0]
    b722:	b29a      	uxth	r2, r3
    b724:	2308      	movs	r3, #8
    b726:	18fb      	adds	r3, r7, r3
    b728:	815a      	strh	r2, [r3, #10]
		
		/* Send the request. */
		s8Ret = SOCKET_REQUEST(SOCKET_CMD_BIND, (uint8*)&strBind,sizeof(tstrBindCmd) , NULL , 0, 0);
    b72a:	2317      	movs	r3, #23
    b72c:	18fc      	adds	r4, r7, r3
    b72e:	2308      	movs	r3, #8
    b730:	18fa      	adds	r2, r7, r3
    b732:	2300      	movs	r3, #0
    b734:	9302      	str	r3, [sp, #8]
    b736:	2300      	movs	r3, #0
    b738:	9301      	str	r3, [sp, #4]
    b73a:	2300      	movs	r3, #0
    b73c:	9300      	str	r3, [sp, #0]
    b73e:	230c      	movs	r3, #12
    b740:	2141      	movs	r1, #65	; 0x41
    b742:	2002      	movs	r0, #2
    b744:	4d0c      	ldr	r5, [pc, #48]	; (b778 <bind+0xec>)
    b746:	47a8      	blx	r5
    b748:	0003      	movs	r3, r0
    b74a:	7023      	strb	r3, [r4, #0]
		if(s8Ret != SOCK_ERR_NO_ERROR)
    b74c:	2317      	movs	r3, #23
    b74e:	18fb      	adds	r3, r7, r3
    b750:	781b      	ldrb	r3, [r3, #0]
    b752:	b25b      	sxtb	r3, r3
    b754:	2b00      	cmp	r3, #0
    b756:	d003      	beq.n	b760 <bind+0xd4>
		{
			s8Ret = SOCK_ERR_INVALID;
    b758:	2317      	movs	r3, #23
    b75a:	18fb      	adds	r3, r7, r3
    b75c:	22f7      	movs	r2, #247	; 0xf7
    b75e:	701a      	strb	r2, [r3, #0]
		}
	}
	return s8Ret;
    b760:	2317      	movs	r3, #23
    b762:	18fb      	adds	r3, r7, r3
    b764:	781b      	ldrb	r3, [r3, #0]
    b766:	b25b      	sxtb	r3, r3
}
    b768:	0018      	movs	r0, r3
    b76a:	46bd      	mov	sp, r7
    b76c:	b006      	add	sp, #24
    b76e:	bdb0      	pop	{r4, r5, r7, pc}
    b770:	20003d38 	.word	0x20003d38
    b774:	00008b9d 	.word	0x00008b9d
    b778:	00008e91 	.word	0x00008e91

0000b77c <send>:

Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
    b77c:	b590      	push	{r4, r7, lr}
    b77e:	b08f      	sub	sp, #60	; 0x3c
    b780:	af04      	add	r7, sp, #16
    b782:	0004      	movs	r4, r0
    b784:	60b9      	str	r1, [r7, #8]
    b786:	0010      	movs	r0, r2
    b788:	0019      	movs	r1, r3
    b78a:	230f      	movs	r3, #15
    b78c:	18fb      	adds	r3, r7, r3
    b78e:	1c22      	adds	r2, r4, #0
    b790:	701a      	strb	r2, [r3, #0]
    b792:	230c      	movs	r3, #12
    b794:	18fb      	adds	r3, r7, r3
    b796:	1c02      	adds	r2, r0, #0
    b798:	801a      	strh	r2, [r3, #0]
    b79a:	1dbb      	adds	r3, r7, #6
    b79c:	1c0a      	adds	r2, r1, #0
    b79e:	801a      	strh	r2, [r3, #0]
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    b7a0:	2326      	movs	r3, #38	; 0x26
    b7a2:	18fb      	adds	r3, r7, r3
    b7a4:	2206      	movs	r2, #6
    b7a6:	4252      	negs	r2, r2
    b7a8:	801a      	strh	r2, [r3, #0]
	
	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
    b7aa:	230f      	movs	r3, #15
    b7ac:	18fb      	adds	r3, r7, r3
    b7ae:	781b      	ldrb	r3, [r3, #0]
    b7b0:	2b7f      	cmp	r3, #127	; 0x7f
    b7b2:	d900      	bls.n	b7b6 <send+0x3a>
    b7b4:	e086      	b.n	b8c4 <send+0x148>
    b7b6:	68bb      	ldr	r3, [r7, #8]
    b7b8:	2b00      	cmp	r3, #0
    b7ba:	d100      	bne.n	b7be <send+0x42>
    b7bc:	e082      	b.n	b8c4 <send+0x148>
    b7be:	230c      	movs	r3, #12
    b7c0:	18fb      	adds	r3, r7, r3
    b7c2:	881b      	ldrh	r3, [r3, #0]
    b7c4:	4a43      	ldr	r2, [pc, #268]	; (b8d4 <send+0x158>)
    b7c6:	4293      	cmp	r3, r2
    b7c8:	d900      	bls.n	b7cc <send+0x50>
    b7ca:	e07b      	b.n	b8c4 <send+0x148>
    b7cc:	230f      	movs	r3, #15
    b7ce:	18fb      	adds	r3, r7, r3
    b7d0:	781b      	ldrb	r3, [r3, #0]
    b7d2:	b25b      	sxtb	r3, r3
    b7d4:	4a40      	ldr	r2, [pc, #256]	; (b8d8 <send+0x15c>)
    b7d6:	011b      	lsls	r3, r3, #4
    b7d8:	18d3      	adds	r3, r2, r3
    b7da:	330a      	adds	r3, #10
    b7dc:	781b      	ldrb	r3, [r3, #0]
    b7de:	b2db      	uxtb	r3, r3
    b7e0:	2b01      	cmp	r3, #1
    b7e2:	d16f      	bne.n	b8c4 <send+0x148>
	{
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
    b7e4:	2323      	movs	r3, #35	; 0x23
    b7e6:	18fb      	adds	r3, r7, r3
    b7e8:	2245      	movs	r2, #69	; 0x45
    b7ea:	701a      	strb	r2, [r3, #0]
		u16DataOffset	= TCP_TX_PACKET_OFFSET;
    b7ec:	2324      	movs	r3, #36	; 0x24
    b7ee:	18fb      	adds	r3, r7, r3
    b7f0:	2250      	movs	r2, #80	; 0x50
    b7f2:	801a      	strh	r2, [r3, #0]

		strSend.sock			= sock;
    b7f4:	2310      	movs	r3, #16
    b7f6:	18fb      	adds	r3, r7, r3
    b7f8:	220f      	movs	r2, #15
    b7fa:	18ba      	adds	r2, r7, r2
    b7fc:	7812      	ldrb	r2, [r2, #0]
    b7fe:	701a      	strb	r2, [r3, #0]
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
    b800:	2310      	movs	r3, #16
    b802:	18fb      	adds	r3, r7, r3
    b804:	220c      	movs	r2, #12
    b806:	18ba      	adds	r2, r7, r2
    b808:	8812      	ldrh	r2, [r2, #0]
    b80a:	805a      	strh	r2, [r3, #2]
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;
    b80c:	230f      	movs	r3, #15
    b80e:	18fb      	adds	r3, r7, r3
    b810:	781b      	ldrb	r3, [r3, #0]
    b812:	b25b      	sxtb	r3, r3
    b814:	4a30      	ldr	r2, [pc, #192]	; (b8d8 <send+0x15c>)
    b816:	011b      	lsls	r3, r3, #4
    b818:	18d3      	adds	r3, r2, r3
    b81a:	3306      	adds	r3, #6
    b81c:	881b      	ldrh	r3, [r3, #0]
    b81e:	b29a      	uxth	r2, r3
    b820:	2310      	movs	r3, #16
    b822:	18fb      	adds	r3, r7, r3
    b824:	819a      	strh	r2, [r3, #12]

		if(sock >= TCP_SOCK_MAX)
    b826:	230f      	movs	r3, #15
    b828:	18fb      	adds	r3, r7, r3
    b82a:	781b      	ldrb	r3, [r3, #0]
    b82c:	b25b      	sxtb	r3, r3
    b82e:	2b06      	cmp	r3, #6
    b830:	dd03      	ble.n	b83a <send+0xbe>
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
    b832:	2324      	movs	r3, #36	; 0x24
    b834:	18fb      	adds	r3, r7, r3
    b836:	2244      	movs	r2, #68	; 0x44
    b838:	801a      	strh	r2, [r3, #0]
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    b83a:	230f      	movs	r3, #15
    b83c:	18fb      	adds	r3, r7, r3
    b83e:	781b      	ldrb	r3, [r3, #0]
    b840:	b25b      	sxtb	r3, r3
    b842:	4a25      	ldr	r2, [pc, #148]	; (b8d8 <send+0x15c>)
    b844:	011b      	lsls	r3, r3, #4
    b846:	18d3      	adds	r3, r2, r3
    b848:	330b      	adds	r3, #11
    b84a:	781b      	ldrb	r3, [r3, #0]
    b84c:	b2db      	uxtb	r3, r3
    b84e:	001a      	movs	r2, r3
    b850:	2301      	movs	r3, #1
    b852:	4013      	ands	r3, r2
    b854:	d00f      	beq.n	b876 <send+0xfa>
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
    b856:	2323      	movs	r3, #35	; 0x23
    b858:	18fb      	adds	r3, r7, r3
    b85a:	224c      	movs	r2, #76	; 0x4c
    b85c:	701a      	strb	r2, [r3, #0]
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
    b85e:	230f      	movs	r3, #15
    b860:	18fb      	adds	r3, r7, r3
    b862:	2200      	movs	r2, #0
    b864:	569a      	ldrsb	r2, [r3, r2]
    b866:	2324      	movs	r3, #36	; 0x24
    b868:	18fb      	adds	r3, r7, r3
    b86a:	491b      	ldr	r1, [pc, #108]	; (b8d8 <send+0x15c>)
    b86c:	0112      	lsls	r2, r2, #4
    b86e:	188a      	adds	r2, r1, r2
    b870:	3208      	adds	r2, #8
    b872:	8812      	ldrh	r2, [r2, #0]
    b874:	801a      	strh	r2, [r3, #0]
		}

		s16Ret =  SOCKET_REQUEST(u8Cmd|M2M_REQ_DATA_PKT, (uint8*)&strSend, sizeof(tstrSendCmd), pvSendBuffer, u16SendLength, u16DataOffset);
    b876:	2323      	movs	r3, #35	; 0x23
    b878:	18fb      	adds	r3, r7, r3
    b87a:	781b      	ldrb	r3, [r3, #0]
    b87c:	2280      	movs	r2, #128	; 0x80
    b87e:	4252      	negs	r2, r2
    b880:	4313      	orrs	r3, r2
    b882:	b2d9      	uxtb	r1, r3
    b884:	2310      	movs	r3, #16
    b886:	18fa      	adds	r2, r7, r3
    b888:	2324      	movs	r3, #36	; 0x24
    b88a:	18fb      	adds	r3, r7, r3
    b88c:	881b      	ldrh	r3, [r3, #0]
    b88e:	9302      	str	r3, [sp, #8]
    b890:	230c      	movs	r3, #12
    b892:	18fb      	adds	r3, r7, r3
    b894:	881b      	ldrh	r3, [r3, #0]
    b896:	9301      	str	r3, [sp, #4]
    b898:	68bb      	ldr	r3, [r7, #8]
    b89a:	9300      	str	r3, [sp, #0]
    b89c:	2310      	movs	r3, #16
    b89e:	2002      	movs	r0, #2
    b8a0:	4c0e      	ldr	r4, [pc, #56]	; (b8dc <send+0x160>)
    b8a2:	47a0      	blx	r4
    b8a4:	0003      	movs	r3, r0
    b8a6:	001a      	movs	r2, r3
    b8a8:	2326      	movs	r3, #38	; 0x26
    b8aa:	18fb      	adds	r3, r7, r3
    b8ac:	801a      	strh	r2, [r3, #0]
		if(s16Ret != SOCK_ERR_NO_ERROR)
    b8ae:	2326      	movs	r3, #38	; 0x26
    b8b0:	18fb      	adds	r3, r7, r3
    b8b2:	2200      	movs	r2, #0
    b8b4:	5e9b      	ldrsh	r3, [r3, r2]
    b8b6:	2b00      	cmp	r3, #0
    b8b8:	d004      	beq.n	b8c4 <send+0x148>
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
    b8ba:	2326      	movs	r3, #38	; 0x26
    b8bc:	18fb      	adds	r3, r7, r3
    b8be:	220e      	movs	r2, #14
    b8c0:	4252      	negs	r2, r2
    b8c2:	801a      	strh	r2, [r3, #0]
		}
	}
	return s16Ret;
    b8c4:	2326      	movs	r3, #38	; 0x26
    b8c6:	18fb      	adds	r3, r7, r3
    b8c8:	2200      	movs	r2, #0
    b8ca:	5e9b      	ldrsh	r3, [r3, r2]
}
    b8cc:	0018      	movs	r0, r3
    b8ce:	46bd      	mov	sp, r7
    b8d0:	b00b      	add	sp, #44	; 0x2c
    b8d2:	bd90      	pop	{r4, r7, pc}
    b8d4:	000005b4 	.word	0x000005b4
    b8d8:	20003d38 	.word	0x20003d38
    b8dc:	00008e91 	.word	0x00008e91

0000b8e0 <recv>:

Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
    b8e0:	b590      	push	{r4, r7, lr}
    b8e2:	b08d      	sub	sp, #52	; 0x34
    b8e4:	af04      	add	r7, sp, #16
    b8e6:	60b9      	str	r1, [r7, #8]
    b8e8:	0011      	movs	r1, r2
    b8ea:	607b      	str	r3, [r7, #4]
    b8ec:	230f      	movs	r3, #15
    b8ee:	18fb      	adds	r3, r7, r3
    b8f0:	1c02      	adds	r2, r0, #0
    b8f2:	701a      	strb	r2, [r3, #0]
    b8f4:	230c      	movs	r3, #12
    b8f6:	18fb      	adds	r3, r7, r3
    b8f8:	1c0a      	adds	r2, r1, #0
    b8fa:	801a      	strh	r2, [r3, #0]
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    b8fc:	231e      	movs	r3, #30
    b8fe:	18fb      	adds	r3, r7, r3
    b900:	2206      	movs	r2, #6
    b902:	4252      	negs	r2, r2
    b904:	801a      	strh	r2, [r3, #0]
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
    b906:	230f      	movs	r3, #15
    b908:	18fb      	adds	r3, r7, r3
    b90a:	781b      	ldrb	r3, [r3, #0]
    b90c:	2b7f      	cmp	r3, #127	; 0x7f
    b90e:	d900      	bls.n	b912 <recv+0x32>
    b910:	e099      	b.n	ba46 <recv+0x166>
    b912:	68bb      	ldr	r3, [r7, #8]
    b914:	2b00      	cmp	r3, #0
    b916:	d100      	bne.n	b91a <recv+0x3a>
    b918:	e095      	b.n	ba46 <recv+0x166>
    b91a:	230c      	movs	r3, #12
    b91c:	18fb      	adds	r3, r7, r3
    b91e:	881b      	ldrh	r3, [r3, #0]
    b920:	2b00      	cmp	r3, #0
    b922:	d100      	bne.n	b926 <recv+0x46>
    b924:	e08f      	b.n	ba46 <recv+0x166>
    b926:	230f      	movs	r3, #15
    b928:	18fb      	adds	r3, r7, r3
    b92a:	781b      	ldrb	r3, [r3, #0]
    b92c:	b25b      	sxtb	r3, r3
    b92e:	4a4a      	ldr	r2, [pc, #296]	; (ba58 <recv+0x178>)
    b930:	011b      	lsls	r3, r3, #4
    b932:	18d3      	adds	r3, r2, r3
    b934:	330a      	adds	r3, #10
    b936:	781b      	ldrb	r3, [r3, #0]
    b938:	b2db      	uxtb	r3, r3
    b93a:	2b01      	cmp	r3, #1
    b93c:	d000      	beq.n	b940 <recv+0x60>
    b93e:	e082      	b.n	ba46 <recv+0x166>
	{
		s16Ret = SOCK_ERR_NO_ERROR;
    b940:	231e      	movs	r3, #30
    b942:	18fb      	adds	r3, r7, r3
    b944:	2200      	movs	r2, #0
    b946:	801a      	strh	r2, [r3, #0]
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
    b948:	230f      	movs	r3, #15
    b94a:	18fb      	adds	r3, r7, r3
    b94c:	2200      	movs	r2, #0
    b94e:	569a      	ldrsb	r2, [r3, r2]
    b950:	4b41      	ldr	r3, [pc, #260]	; (ba58 <recv+0x178>)
    b952:	0112      	lsls	r2, r2, #4
    b954:	68b9      	ldr	r1, [r7, #8]
    b956:	50d1      	str	r1, [r2, r3]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;
    b958:	230f      	movs	r3, #15
    b95a:	18fb      	adds	r3, r7, r3
    b95c:	781b      	ldrb	r3, [r3, #0]
    b95e:	b25b      	sxtb	r3, r3
    b960:	4a3d      	ldr	r2, [pc, #244]	; (ba58 <recv+0x178>)
    b962:	011b      	lsls	r3, r3, #4
    b964:	18d3      	adds	r3, r2, r3
    b966:	3304      	adds	r3, #4
    b968:	220c      	movs	r2, #12
    b96a:	18ba      	adds	r2, r7, r2
    b96c:	8812      	ldrh	r2, [r2, #0]
    b96e:	801a      	strh	r2, [r3, #0]

		if(!gastrSockets[sock].bIsRecvPending)
    b970:	230f      	movs	r3, #15
    b972:	18fb      	adds	r3, r7, r3
    b974:	781b      	ldrb	r3, [r3, #0]
    b976:	b25b      	sxtb	r3, r3
    b978:	4a37      	ldr	r2, [pc, #220]	; (ba58 <recv+0x178>)
    b97a:	011b      	lsls	r3, r3, #4
    b97c:	18d3      	adds	r3, r2, r3
    b97e:	330c      	adds	r3, #12
    b980:	781b      	ldrb	r3, [r3, #0]
    b982:	b2db      	uxtb	r3, r3
    b984:	2b00      	cmp	r3, #0
    b986:	d15e      	bne.n	ba46 <recv+0x166>
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;
    b988:	231d      	movs	r3, #29
    b98a:	18fb      	adds	r3, r7, r3
    b98c:	2246      	movs	r2, #70	; 0x46
    b98e:	701a      	strb	r2, [r3, #0]

			gastrSockets[sock].bIsRecvPending = 1;
    b990:	230f      	movs	r3, #15
    b992:	18fb      	adds	r3, r7, r3
    b994:	781b      	ldrb	r3, [r3, #0]
    b996:	b25b      	sxtb	r3, r3
    b998:	4a2f      	ldr	r2, [pc, #188]	; (ba58 <recv+0x178>)
    b99a:	011b      	lsls	r3, r3, #4
    b99c:	18d3      	adds	r3, r2, r3
    b99e:	330c      	adds	r3, #12
    b9a0:	2201      	movs	r2, #1
    b9a2:	701a      	strb	r2, [r3, #0]
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    b9a4:	230f      	movs	r3, #15
    b9a6:	18fb      	adds	r3, r7, r3
    b9a8:	781b      	ldrb	r3, [r3, #0]
    b9aa:	b25b      	sxtb	r3, r3
    b9ac:	4a2a      	ldr	r2, [pc, #168]	; (ba58 <recv+0x178>)
    b9ae:	011b      	lsls	r3, r3, #4
    b9b0:	18d3      	adds	r3, r2, r3
    b9b2:	330b      	adds	r3, #11
    b9b4:	781b      	ldrb	r3, [r3, #0]
    b9b6:	b2db      	uxtb	r3, r3
    b9b8:	001a      	movs	r2, r3
    b9ba:	2301      	movs	r3, #1
    b9bc:	4013      	ands	r3, r2
    b9be:	d003      	beq.n	b9c8 <recv+0xe8>
			{
				u8Cmd = SOCKET_CMD_SSL_RECV;
    b9c0:	231d      	movs	r3, #29
    b9c2:	18fb      	adds	r3, r7, r3
    b9c4:	224d      	movs	r2, #77	; 0x4d
    b9c6:	701a      	strb	r2, [r3, #0]
			}

			/* Check the timeout value. */
			if(u32Timeoutmsec == 0)
    b9c8:	687b      	ldr	r3, [r7, #4]
    b9ca:	2b00      	cmp	r3, #0
    b9cc:	d105      	bne.n	b9da <recv+0xfa>
				strRecv.u32Timeoutmsec = 0xFFFFFFFF;
    b9ce:	2314      	movs	r3, #20
    b9d0:	18fb      	adds	r3, r7, r3
    b9d2:	2201      	movs	r2, #1
    b9d4:	4252      	negs	r2, r2
    b9d6:	601a      	str	r2, [r3, #0]
    b9d8:	e003      	b.n	b9e2 <recv+0x102>
			else
				strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
    b9da:	2314      	movs	r3, #20
    b9dc:	18fb      	adds	r3, r7, r3
    b9de:	687a      	ldr	r2, [r7, #4]
    b9e0:	601a      	str	r2, [r3, #0]
			strRecv.sock = sock;
    b9e2:	2314      	movs	r3, #20
    b9e4:	18fb      	adds	r3, r7, r3
    b9e6:	220f      	movs	r2, #15
    b9e8:	18ba      	adds	r2, r7, r2
    b9ea:	7812      	ldrb	r2, [r2, #0]
    b9ec:	711a      	strb	r2, [r3, #4]
			strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
    b9ee:	230f      	movs	r3, #15
    b9f0:	18fb      	adds	r3, r7, r3
    b9f2:	781b      	ldrb	r3, [r3, #0]
    b9f4:	b25b      	sxtb	r3, r3
    b9f6:	4a18      	ldr	r2, [pc, #96]	; (ba58 <recv+0x178>)
    b9f8:	011b      	lsls	r3, r3, #4
    b9fa:	18d3      	adds	r3, r2, r3
    b9fc:	3306      	adds	r3, #6
    b9fe:	881b      	ldrh	r3, [r3, #0]
    ba00:	b29a      	uxth	r2, r3
    ba02:	2314      	movs	r3, #20
    ba04:	18fb      	adds	r3, r7, r3
    ba06:	80da      	strh	r2, [r3, #6]
		
			s16Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
    ba08:	2314      	movs	r3, #20
    ba0a:	18fa      	adds	r2, r7, r3
    ba0c:	231d      	movs	r3, #29
    ba0e:	18fb      	adds	r3, r7, r3
    ba10:	7819      	ldrb	r1, [r3, #0]
    ba12:	2300      	movs	r3, #0
    ba14:	9302      	str	r3, [sp, #8]
    ba16:	2300      	movs	r3, #0
    ba18:	9301      	str	r3, [sp, #4]
    ba1a:	2300      	movs	r3, #0
    ba1c:	9300      	str	r3, [sp, #0]
    ba1e:	2308      	movs	r3, #8
    ba20:	2002      	movs	r0, #2
    ba22:	4c0e      	ldr	r4, [pc, #56]	; (ba5c <recv+0x17c>)
    ba24:	47a0      	blx	r4
    ba26:	0003      	movs	r3, r0
    ba28:	001a      	movs	r2, r3
    ba2a:	231e      	movs	r3, #30
    ba2c:	18fb      	adds	r3, r7, r3
    ba2e:	801a      	strh	r2, [r3, #0]
			if(s16Ret != SOCK_ERR_NO_ERROR)
    ba30:	231e      	movs	r3, #30
    ba32:	18fb      	adds	r3, r7, r3
    ba34:	2200      	movs	r2, #0
    ba36:	5e9b      	ldrsh	r3, [r3, r2]
    ba38:	2b00      	cmp	r3, #0
    ba3a:	d004      	beq.n	ba46 <recv+0x166>
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
    ba3c:	231e      	movs	r3, #30
    ba3e:	18fb      	adds	r3, r7, r3
    ba40:	220e      	movs	r2, #14
    ba42:	4252      	negs	r2, r2
    ba44:	801a      	strh	r2, [r3, #0]
			}
		}
	}

	return s16Ret;
    ba46:	231e      	movs	r3, #30
    ba48:	18fb      	adds	r3, r7, r3
    ba4a:	2200      	movs	r2, #0
    ba4c:	5e9b      	ldrsh	r3, [r3, r2]
}
    ba4e:	0018      	movs	r0, r3
    ba50:	46bd      	mov	sp, r7
    ba52:	b009      	add	sp, #36	; 0x24
    ba54:	bd90      	pop	{r4, r7, pc}
    ba56:	46c0      	nop			; (mov r8, r8)
    ba58:	20003d38 	.word	0x20003d38
    ba5c:	00008e91 	.word	0x00008e91

0000ba60 <spi_flash_enter_low_power_mode>:
		spi_flash_write_enable();
		spi_flash_gang_unblock();
	}
}
#endif
static void spi_flash_enter_low_power_mode(void) {
    ba60:	b580      	push	{r7, lr}
    ba62:	b082      	sub	sp, #8
    ba64:	af00      	add	r7, sp, #0
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;
    ba66:	003b      	movs	r3, r7
    ba68:	607b      	str	r3, [r7, #4]

	cmd[0] = 0xb9;
    ba6a:	687b      	ldr	r3, [r7, #4]
    ba6c:	22b9      	movs	r2, #185	; 0xb9
    ba6e:	701a      	strb	r2, [r3, #0]

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    ba70:	4b13      	ldr	r3, [pc, #76]	; (bac0 <spi_flash_enter_low_power_mode+0x60>)
    ba72:	2100      	movs	r1, #0
    ba74:	0018      	movs	r0, r3
    ba76:	4b13      	ldr	r3, [pc, #76]	; (bac4 <spi_flash_enter_low_power_mode+0x64>)
    ba78:	4798      	blx	r3
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    ba7a:	687b      	ldr	r3, [r7, #4]
    ba7c:	781b      	ldrb	r3, [r3, #0]
    ba7e:	001a      	movs	r2, r3
    ba80:	4b11      	ldr	r3, [pc, #68]	; (bac8 <spi_flash_enter_low_power_mode+0x68>)
    ba82:	0011      	movs	r1, r2
    ba84:	0018      	movs	r0, r3
    ba86:	4b0f      	ldr	r3, [pc, #60]	; (bac4 <spi_flash_enter_low_power_mode+0x64>)
    ba88:	4798      	blx	r3
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    ba8a:	4b10      	ldr	r3, [pc, #64]	; (bacc <spi_flash_enter_low_power_mode+0x6c>)
    ba8c:	2101      	movs	r1, #1
    ba8e:	0018      	movs	r0, r3
    ba90:	4b0c      	ldr	r3, [pc, #48]	; (bac4 <spi_flash_enter_low_power_mode+0x64>)
    ba92:	4798      	blx	r3
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    ba94:	4b0e      	ldr	r3, [pc, #56]	; (bad0 <spi_flash_enter_low_power_mode+0x70>)
    ba96:	2100      	movs	r1, #0
    ba98:	0018      	movs	r0, r3
    ba9a:	4b0a      	ldr	r3, [pc, #40]	; (bac4 <spi_flash_enter_low_power_mode+0x64>)
    ba9c:	4798      	blx	r3
	nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1 << 7));
    ba9e:	4b0d      	ldr	r3, [pc, #52]	; (bad4 <spi_flash_enter_low_power_mode+0x74>)
    baa0:	2181      	movs	r1, #129	; 0x81
    baa2:	0018      	movs	r0, r3
    baa4:	4b07      	ldr	r3, [pc, #28]	; (bac4 <spi_flash_enter_low_power_mode+0x64>)
    baa6:	4798      	blx	r3
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    baa8:	46c0      	nop			; (mov r8, r8)
    baaa:	4b0b      	ldr	r3, [pc, #44]	; (bad8 <spi_flash_enter_low_power_mode+0x78>)
    baac:	0018      	movs	r0, r3
    baae:	4b0b      	ldr	r3, [pc, #44]	; (badc <spi_flash_enter_low_power_mode+0x7c>)
    bab0:	4798      	blx	r3
    bab2:	1e03      	subs	r3, r0, #0
    bab4:	2b01      	cmp	r3, #1
    bab6:	d1f8      	bne.n	baaa <spi_flash_enter_low_power_mode+0x4a>
}
    bab8:	46c0      	nop			; (mov r8, r8)
    baba:	46bd      	mov	sp, r7
    babc:	b002      	add	sp, #8
    babe:	bd80      	pop	{r7, pc}
    bac0:	00010208 	.word	0x00010208
    bac4:	0000a275 	.word	0x0000a275
    bac8:	0001020c 	.word	0x0001020c
    bacc:	00010214 	.word	0x00010214
    bad0:	0001021c 	.word	0x0001021c
    bad4:	00010204 	.word	0x00010204
    bad8:	00010218 	.word	0x00010218
    badc:	0000a231 	.word	0x0000a231

0000bae0 <spi_flash_leave_low_power_mode>:


static void spi_flash_leave_low_power_mode(void) {
    bae0:	b580      	push	{r7, lr}
    bae2:	b082      	sub	sp, #8
    bae4:	af00      	add	r7, sp, #0
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;
    bae6:	003b      	movs	r3, r7
    bae8:	607b      	str	r3, [r7, #4]

	cmd[0] = 0xab;
    baea:	687b      	ldr	r3, [r7, #4]
    baec:	22ab      	movs	r2, #171	; 0xab
    baee:	701a      	strb	r2, [r3, #0]

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    baf0:	4b13      	ldr	r3, [pc, #76]	; (bb40 <spi_flash_leave_low_power_mode+0x60>)
    baf2:	2100      	movs	r1, #0
    baf4:	0018      	movs	r0, r3
    baf6:	4b13      	ldr	r3, [pc, #76]	; (bb44 <spi_flash_leave_low_power_mode+0x64>)
    baf8:	4798      	blx	r3
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    bafa:	687b      	ldr	r3, [r7, #4]
    bafc:	781b      	ldrb	r3, [r3, #0]
    bafe:	001a      	movs	r2, r3
    bb00:	4b11      	ldr	r3, [pc, #68]	; (bb48 <spi_flash_leave_low_power_mode+0x68>)
    bb02:	0011      	movs	r1, r2
    bb04:	0018      	movs	r0, r3
    bb06:	4b0f      	ldr	r3, [pc, #60]	; (bb44 <spi_flash_leave_low_power_mode+0x64>)
    bb08:	4798      	blx	r3
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    bb0a:	4b10      	ldr	r3, [pc, #64]	; (bb4c <spi_flash_leave_low_power_mode+0x6c>)
    bb0c:	2101      	movs	r1, #1
    bb0e:	0018      	movs	r0, r3
    bb10:	4b0c      	ldr	r3, [pc, #48]	; (bb44 <spi_flash_leave_low_power_mode+0x64>)
    bb12:	4798      	blx	r3
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    bb14:	4b0e      	ldr	r3, [pc, #56]	; (bb50 <spi_flash_leave_low_power_mode+0x70>)
    bb16:	2100      	movs	r1, #0
    bb18:	0018      	movs	r0, r3
    bb1a:	4b0a      	ldr	r3, [pc, #40]	; (bb44 <spi_flash_leave_low_power_mode+0x64>)
    bb1c:	4798      	blx	r3
	nm_write_reg(SPI_FLASH_CMD_CNT,  1 | (1 << 7));
    bb1e:	4b0d      	ldr	r3, [pc, #52]	; (bb54 <spi_flash_leave_low_power_mode+0x74>)
    bb20:	2181      	movs	r1, #129	; 0x81
    bb22:	0018      	movs	r0, r3
    bb24:	4b07      	ldr	r3, [pc, #28]	; (bb44 <spi_flash_leave_low_power_mode+0x64>)
    bb26:	4798      	blx	r3
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    bb28:	46c0      	nop			; (mov r8, r8)
    bb2a:	4b0b      	ldr	r3, [pc, #44]	; (bb58 <spi_flash_leave_low_power_mode+0x78>)
    bb2c:	0018      	movs	r0, r3
    bb2e:	4b0b      	ldr	r3, [pc, #44]	; (bb5c <spi_flash_leave_low_power_mode+0x7c>)
    bb30:	4798      	blx	r3
    bb32:	1e03      	subs	r3, r0, #0
    bb34:	2b01      	cmp	r3, #1
    bb36:	d1f8      	bne.n	bb2a <spi_flash_leave_low_power_mode+0x4a>
}
    bb38:	46c0      	nop			; (mov r8, r8)
    bb3a:	46bd      	mov	sp, r7
    bb3c:	b002      	add	sp, #8
    bb3e:	bd80      	pop	{r7, pc}
    bb40:	00010208 	.word	0x00010208
    bb44:	0000a275 	.word	0x0000a275
    bb48:	0001020c 	.word	0x0001020c
    bb4c:	00010214 	.word	0x00010214
    bb50:	0001021c 	.word	0x0001021c
    bb54:	00010204 	.word	0x00010204
    bb58:	00010218 	.word	0x00010218
    bb5c:	0000a231 	.word	0x0000a231

0000bb60 <spi_flash_enable>:
/**
 *	@fn		spi_flash_enable
 *	@brief	Enable spi flash operations
 */
sint8 spi_flash_enable(uint8 enable)
{
    bb60:	b590      	push	{r4, r7, lr}
    bb62:	b085      	sub	sp, #20
    bb64:	af00      	add	r7, sp, #0
    bb66:	0002      	movs	r2, r0
    bb68:	1dfb      	adds	r3, r7, #7
    bb6a:	701a      	strb	r2, [r3, #0]
	sint8 s8Ret = M2M_SUCCESS;
    bb6c:	230f      	movs	r3, #15
    bb6e:	18fb      	adds	r3, r7, r3
    bb70:	2200      	movs	r2, #0
    bb72:	701a      	strb	r2, [r3, #0]
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
    bb74:	4b24      	ldr	r3, [pc, #144]	; (bc08 <spi_flash_enable+0xa8>)
    bb76:	4798      	blx	r3
    bb78:	0003      	movs	r3, r0
    bb7a:	051b      	lsls	r3, r3, #20
    bb7c:	0d1b      	lsrs	r3, r3, #20
    bb7e:	4a23      	ldr	r2, [pc, #140]	; (bc0c <spi_flash_enable+0xac>)
    bb80:	4293      	cmp	r3, r2
    bb82:	d938      	bls.n	bbf6 <spi_flash_enable+0x96>
		uint32 u32Val;
		
		/* Enable pinmux to SPI flash. */
		s8Ret = nm_read_reg_with_ret(0x1410, &u32Val);
    bb84:	230f      	movs	r3, #15
    bb86:	18fc      	adds	r4, r7, r3
    bb88:	2308      	movs	r3, #8
    bb8a:	18fb      	adds	r3, r7, r3
    bb8c:	4a20      	ldr	r2, [pc, #128]	; (bc10 <spi_flash_enable+0xb0>)
    bb8e:	0019      	movs	r1, r3
    bb90:	0010      	movs	r0, r2
    bb92:	4b20      	ldr	r3, [pc, #128]	; (bc14 <spi_flash_enable+0xb4>)
    bb94:	4798      	blx	r3
    bb96:	0003      	movs	r3, r0
    bb98:	7023      	strb	r3, [r4, #0]
		if(s8Ret != M2M_SUCCESS) {
    bb9a:	230f      	movs	r3, #15
    bb9c:	18fb      	adds	r3, r7, r3
    bb9e:	781b      	ldrb	r3, [r3, #0]
    bba0:	b25b      	sxtb	r3, r3
    bba2:	2b00      	cmp	r3, #0
    bba4:	d126      	bne.n	bbf4 <spi_flash_enable+0x94>
			goto ERR1;
		}
		/* GPIO15/16/17/18 */
		u32Val &= ~((0x7777ul) << 12);
    bba6:	68bb      	ldr	r3, [r7, #8]
    bba8:	4a1b      	ldr	r2, [pc, #108]	; (bc18 <spi_flash_enable+0xb8>)
    bbaa:	4013      	ands	r3, r2
    bbac:	60bb      	str	r3, [r7, #8]
		u32Val |= ((0x1111ul) << 12);
    bbae:	68bb      	ldr	r3, [r7, #8]
    bbb0:	4a1a      	ldr	r2, [pc, #104]	; (bc1c <spi_flash_enable+0xbc>)
    bbb2:	4313      	orrs	r3, r2
    bbb4:	60bb      	str	r3, [r7, #8]
		nm_write_reg(0x1410, u32Val);
    bbb6:	68bb      	ldr	r3, [r7, #8]
    bbb8:	4a15      	ldr	r2, [pc, #84]	; (bc10 <spi_flash_enable+0xb0>)
    bbba:	0019      	movs	r1, r3
    bbbc:	0010      	movs	r0, r2
    bbbe:	4b18      	ldr	r3, [pc, #96]	; (bc20 <spi_flash_enable+0xc0>)
    bbc0:	4798      	blx	r3
		if(enable) {
    bbc2:	1dfb      	adds	r3, r7, #7
    bbc4:	781b      	ldrb	r3, [r3, #0]
    bbc6:	2b00      	cmp	r3, #0
    bbc8:	d002      	beq.n	bbd0 <spi_flash_enable+0x70>
			spi_flash_leave_low_power_mode();
    bbca:	4b16      	ldr	r3, [pc, #88]	; (bc24 <spi_flash_enable+0xc4>)
    bbcc:	4798      	blx	r3
    bbce:	e001      	b.n	bbd4 <spi_flash_enable+0x74>
		} else {
			spi_flash_enter_low_power_mode();
    bbd0:	4b15      	ldr	r3, [pc, #84]	; (bc28 <spi_flash_enable+0xc8>)
    bbd2:	4798      	blx	r3
		}
		/* Disable pinmux to SPI flash to minimize leakage. */
		u32Val &= ~((0x7777ul) << 12);
    bbd4:	68bb      	ldr	r3, [r7, #8]
    bbd6:	4a10      	ldr	r2, [pc, #64]	; (bc18 <spi_flash_enable+0xb8>)
    bbd8:	4013      	ands	r3, r2
    bbda:	60bb      	str	r3, [r7, #8]
		u32Val |= ((0x0010ul) << 12);
    bbdc:	68bb      	ldr	r3, [r7, #8]
    bbde:	2280      	movs	r2, #128	; 0x80
    bbe0:	0252      	lsls	r2, r2, #9
    bbe2:	4313      	orrs	r3, r2
    bbe4:	60bb      	str	r3, [r7, #8]
		nm_write_reg(0x1410, u32Val);
    bbe6:	68bb      	ldr	r3, [r7, #8]
    bbe8:	4a09      	ldr	r2, [pc, #36]	; (bc10 <spi_flash_enable+0xb0>)
    bbea:	0019      	movs	r1, r3
    bbec:	0010      	movs	r0, r2
    bbee:	4b0c      	ldr	r3, [pc, #48]	; (bc20 <spi_flash_enable+0xc0>)
    bbf0:	4798      	blx	r3
    bbf2:	e000      	b.n	bbf6 <spi_flash_enable+0x96>
		uint32 u32Val;
		
		/* Enable pinmux to SPI flash. */
		s8Ret = nm_read_reg_with_ret(0x1410, &u32Val);
		if(s8Ret != M2M_SUCCESS) {
			goto ERR1;
    bbf4:	46c0      	nop			; (mov r8, r8)
		u32Val &= ~((0x7777ul) << 12);
		u32Val |= ((0x0010ul) << 12);
		nm_write_reg(0x1410, u32Val);
	}
ERR1:
	return s8Ret;
    bbf6:	230f      	movs	r3, #15
    bbf8:	18fb      	adds	r3, r7, r3
    bbfa:	781b      	ldrb	r3, [r3, #0]
    bbfc:	b25b      	sxtb	r3, r3
}
    bbfe:	0018      	movs	r0, r3
    bc00:	46bd      	mov	sp, r7
    bc02:	b005      	add	sp, #20
    bc04:	bd90      	pop	{r4, r7, pc}
    bc06:	46c0      	nop			; (mov r8, r8)
    bc08:	00009e11 	.word	0x00009e11
    bc0c:	0000039f 	.word	0x0000039f
    bc10:	00001410 	.word	0x00001410
    bc14:	0000a251 	.word	0x0000a251
    bc18:	f8888fff 	.word	0xf8888fff
    bc1c:	01111000 	.word	0x01111000
    bc20:	0000a275 	.word	0x0000a275
    bc24:	0000bae1 	.word	0x0000bae1
    bc28:	0000ba61 	.word	0x0000ba61

0000bc2c <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    bc2c:	b580      	push	{r7, lr}
    bc2e:	b084      	sub	sp, #16
    bc30:	af00      	add	r7, sp, #0
    bc32:	0002      	movs	r2, r0
    bc34:	1dfb      	adds	r3, r7, #7
    bc36:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    bc38:	230f      	movs	r3, #15
    bc3a:	18fb      	adds	r3, r7, r3
    bc3c:	1dfa      	adds	r2, r7, #7
    bc3e:	7812      	ldrb	r2, [r2, #0]
    bc40:	09d2      	lsrs	r2, r2, #7
    bc42:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    bc44:	230e      	movs	r3, #14
    bc46:	18fb      	adds	r3, r7, r3
    bc48:	1dfa      	adds	r2, r7, #7
    bc4a:	7812      	ldrb	r2, [r2, #0]
    bc4c:	0952      	lsrs	r2, r2, #5
    bc4e:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    bc50:	4b0d      	ldr	r3, [pc, #52]	; (bc88 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    bc52:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    bc54:	230f      	movs	r3, #15
    bc56:	18fb      	adds	r3, r7, r3
    bc58:	781b      	ldrb	r3, [r3, #0]
    bc5a:	2b00      	cmp	r3, #0
    bc5c:	d10f      	bne.n	bc7e <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    bc5e:	230f      	movs	r3, #15
    bc60:	18fb      	adds	r3, r7, r3
    bc62:	781b      	ldrb	r3, [r3, #0]
    bc64:	009b      	lsls	r3, r3, #2
    bc66:	2210      	movs	r2, #16
    bc68:	4694      	mov	ip, r2
    bc6a:	44bc      	add	ip, r7
    bc6c:	4463      	add	r3, ip
    bc6e:	3b08      	subs	r3, #8
    bc70:	681a      	ldr	r2, [r3, #0]
    bc72:	230e      	movs	r3, #14
    bc74:	18fb      	adds	r3, r7, r3
    bc76:	781b      	ldrb	r3, [r3, #0]
    bc78:	01db      	lsls	r3, r3, #7
    bc7a:	18d3      	adds	r3, r2, r3
    bc7c:	e000      	b.n	bc80 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    bc7e:	2300      	movs	r3, #0
	}
}
    bc80:	0018      	movs	r0, r3
    bc82:	46bd      	mov	sp, r7
    bc84:	b004      	add	sp, #16
    bc86:	bd80      	pop	{r7, pc}
    bc88:	41004400 	.word	0x41004400

0000bc8c <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    bc8c:	b580      	push	{r7, lr}
    bc8e:	b082      	sub	sp, #8
    bc90:	af00      	add	r7, sp, #0
    bc92:	0002      	movs	r2, r0
    bc94:	1dfb      	adds	r3, r7, #7
    bc96:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    bc98:	1dfb      	adds	r3, r7, #7
    bc9a:	781b      	ldrb	r3, [r3, #0]
    bc9c:	0018      	movs	r0, r3
    bc9e:	4b03      	ldr	r3, [pc, #12]	; (bcac <port_get_group_from_gpio_pin+0x20>)
    bca0:	4798      	blx	r3
    bca2:	0003      	movs	r3, r0
}
    bca4:	0018      	movs	r0, r3
    bca6:	46bd      	mov	sp, r7
    bca8:	b002      	add	sp, #8
    bcaa:	bd80      	pop	{r7, pc}
    bcac:	0000bc2d 	.word	0x0000bc2d

0000bcb0 <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    bcb0:	b580      	push	{r7, lr}
    bcb2:	b082      	sub	sp, #8
    bcb4:	af00      	add	r7, sp, #0
    bcb6:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    bcb8:	687b      	ldr	r3, [r7, #4]
    bcba:	2200      	movs	r2, #0
    bcbc:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    bcbe:	687b      	ldr	r3, [r7, #4]
    bcc0:	2201      	movs	r2, #1
    bcc2:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    bcc4:	687b      	ldr	r3, [r7, #4]
    bcc6:	2200      	movs	r2, #0
    bcc8:	709a      	strb	r2, [r3, #2]
}
    bcca:	46c0      	nop			; (mov r8, r8)
    bccc:	46bd      	mov	sp, r7
    bcce:	b002      	add	sp, #8
    bcd0:	bd80      	pop	{r7, pc}
    bcd2:	46c0      	nop			; (mov r8, r8)

0000bcd4 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    bcd4:	b580      	push	{r7, lr}
    bcd6:	b084      	sub	sp, #16
    bcd8:	af00      	add	r7, sp, #0
    bcda:	0002      	movs	r2, r0
    bcdc:	1dfb      	adds	r3, r7, #7
    bcde:	701a      	strb	r2, [r3, #0]
    bce0:	1dbb      	adds	r3, r7, #6
    bce2:	1c0a      	adds	r2, r1, #0
    bce4:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    bce6:	1dfb      	adds	r3, r7, #7
    bce8:	781b      	ldrb	r3, [r3, #0]
    bcea:	0018      	movs	r0, r3
    bcec:	4b0d      	ldr	r3, [pc, #52]	; (bd24 <port_pin_set_output_level+0x50>)
    bcee:	4798      	blx	r3
    bcf0:	0003      	movs	r3, r0
    bcf2:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    bcf4:	1dfb      	adds	r3, r7, #7
    bcf6:	781b      	ldrb	r3, [r3, #0]
    bcf8:	221f      	movs	r2, #31
    bcfa:	4013      	ands	r3, r2
    bcfc:	2201      	movs	r2, #1
    bcfe:	409a      	lsls	r2, r3
    bd00:	0013      	movs	r3, r2
    bd02:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    bd04:	1dbb      	adds	r3, r7, #6
    bd06:	781b      	ldrb	r3, [r3, #0]
    bd08:	2b00      	cmp	r3, #0
    bd0a:	d003      	beq.n	bd14 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    bd0c:	68fb      	ldr	r3, [r7, #12]
    bd0e:	68ba      	ldr	r2, [r7, #8]
    bd10:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    bd12:	e002      	b.n	bd1a <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    bd14:	68fb      	ldr	r3, [r7, #12]
    bd16:	68ba      	ldr	r2, [r7, #8]
    bd18:	615a      	str	r2, [r3, #20]
	}
}
    bd1a:	46c0      	nop			; (mov r8, r8)
    bd1c:	46bd      	mov	sp, r7
    bd1e:	b004      	add	sp, #16
    bd20:	bd80      	pop	{r7, pc}
    bd22:	46c0      	nop			; (mov r8, r8)
    bd24:	0000bc8d 	.word	0x0000bc8d

0000bd28 <vResetPort>:
uint8_t data[5];

////////////////////////////////////////////////////////////////////////////////////////////////////////

static void vResetPort(void)
{ struct port_config pin_conf;
    bd28:	b580      	push	{r7, lr}
    bd2a:	b082      	sub	sp, #8
    bd2c:	af00      	add	r7, sp, #0
	
	port_get_config_defaults(&pin_conf);
    bd2e:	1d3b      	adds	r3, r7, #4
    bd30:	0018      	movs	r0, r3
    bd32:	4b0b      	ldr	r3, [pc, #44]	; (bd60 <vResetPort+0x38>)
    bd34:	4798      	blx	r3
	portENABLE_INTERRUPTS();
    bd36:	b662      	cpsie	i
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    bd38:	1d3b      	adds	r3, r7, #4
    bd3a:	2201      	movs	r2, #1
    bd3c:	701a      	strb	r2, [r3, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    bd3e:	1d3b      	adds	r3, r7, #4
    bd40:	2201      	movs	r2, #1
    bd42:	705a      	strb	r2, [r3, #1]
	port_pin_set_config(DHT22PIN, &pin_conf);
    bd44:	1d3b      	adds	r3, r7, #4
    bd46:	0019      	movs	r1, r3
    bd48:	203e      	movs	r0, #62	; 0x3e
    bd4a:	4b06      	ldr	r3, [pc, #24]	; (bd64 <vResetPort+0x3c>)
    bd4c:	4798      	blx	r3
	port_pin_set_output_level(DHT22PIN,true);
    bd4e:	2101      	movs	r1, #1
    bd50:	203e      	movs	r0, #62	; 0x3e
    bd52:	4b05      	ldr	r3, [pc, #20]	; (bd68 <vResetPort+0x40>)
    bd54:	4798      	blx	r3
}
    bd56:	46c0      	nop			; (mov r8, r8)
    bd58:	46bd      	mov	sp, r7
    bd5a:	b002      	add	sp, #8
    bd5c:	bd80      	pop	{r7, pc}
    bd5e:	46c0      	nop			; (mov r8, r8)
    bd60:	0000bcb1 	.word	0x0000bcb1
    bd64:	0001355d 	.word	0x0001355d
    bd68:	0000bcd5 	.word	0x0000bcd5

0000bd6c <expectPulseH>:

///////////////////////////////////////////////////////////////////////////

static uint16_t expectPulseH(void) 
{
    bd6c:	b580      	push	{r7, lr}
    bd6e:	b082      	sub	sp, #8
    bd70:	af00      	add	r7, sp, #0
	uint16_t count = 0;
    bd72:	1dbb      	adds	r3, r7, #6
    bd74:	2200      	movs	r2, #0
    bd76:	801a      	strh	r2, [r3, #0]

	while ((PORT->Group[1].IN.bit.IN & DHT22PIN_ABSOLUTE))
    bd78:	e009      	b.n	bd8e <expectPulseH+0x22>
	 if (count++ == 0x01FF) return 0; // Exceeded timeout, fail.
    bd7a:	1dbb      	adds	r3, r7, #6
    bd7c:	881b      	ldrh	r3, [r3, #0]
    bd7e:	1dba      	adds	r2, r7, #6
    bd80:	1c59      	adds	r1, r3, #1
    bd82:	8011      	strh	r1, [r2, #0]
    bd84:	4a08      	ldr	r2, [pc, #32]	; (bda8 <expectPulseH+0x3c>)
    bd86:	4293      	cmp	r3, r2
    bd88:	d101      	bne.n	bd8e <expectPulseH+0x22>
    bd8a:	2300      	movs	r3, #0
    bd8c:	e008      	b.n	bda0 <expectPulseH+0x34>

static uint16_t expectPulseH(void) 
{
	uint16_t count = 0;

	while ((PORT->Group[1].IN.bit.IN & DHT22PIN_ABSOLUTE))
    bd8e:	4a07      	ldr	r2, [pc, #28]	; (bdac <expectPulseH+0x40>)
    bd90:	23a0      	movs	r3, #160	; 0xa0
    bd92:	58d2      	ldr	r2, [r2, r3]
    bd94:	2380      	movs	r3, #128	; 0x80
    bd96:	05db      	lsls	r3, r3, #23
    bd98:	4013      	ands	r3, r2
    bd9a:	d1ee      	bne.n	bd7a <expectPulseH+0xe>
	 if (count++ == 0x01FF) return 0; // Exceeded timeout, fail.
	 
	return count;
    bd9c:	1dbb      	adds	r3, r7, #6
    bd9e:	881b      	ldrh	r3, [r3, #0]
}
    bda0:	0018      	movs	r0, r3
    bda2:	46bd      	mov	sp, r7
    bda4:	b002      	add	sp, #8
    bda6:	bd80      	pop	{r7, pc}
    bda8:	000001ff 	.word	0x000001ff
    bdac:	41004400 	.word	0x41004400

0000bdb0 <expectPulseL>:

///////////////////////////////////////////////////////////////////////////

static uint16_t expectPulseL(void) 
{
    bdb0:	b580      	push	{r7, lr}
    bdb2:	b082      	sub	sp, #8
    bdb4:	af00      	add	r7, sp, #0
	uint16_t count = 0;
    bdb6:	1dbb      	adds	r3, r7, #6
    bdb8:	2200      	movs	r2, #0
    bdba:	801a      	strh	r2, [r3, #0]

	while (!(PORT->Group[1].IN.bit.IN & DHT22PIN_ABSOLUTE))
    bdbc:	e009      	b.n	bdd2 <expectPulseL+0x22>
	 if (count++ == 0x01FF) return 0; // Exceeded timeout, fail.
    bdbe:	1dbb      	adds	r3, r7, #6
    bdc0:	881b      	ldrh	r3, [r3, #0]
    bdc2:	1dba      	adds	r2, r7, #6
    bdc4:	1c59      	adds	r1, r3, #1
    bdc6:	8011      	strh	r1, [r2, #0]
    bdc8:	4a08      	ldr	r2, [pc, #32]	; (bdec <expectPulseL+0x3c>)
    bdca:	4293      	cmp	r3, r2
    bdcc:	d101      	bne.n	bdd2 <expectPulseL+0x22>
    bdce:	2300      	movs	r3, #0
    bdd0:	e008      	b.n	bde4 <expectPulseL+0x34>

static uint16_t expectPulseL(void) 
{
	uint16_t count = 0;

	while (!(PORT->Group[1].IN.bit.IN & DHT22PIN_ABSOLUTE))
    bdd2:	4a07      	ldr	r2, [pc, #28]	; (bdf0 <expectPulseL+0x40>)
    bdd4:	23a0      	movs	r3, #160	; 0xa0
    bdd6:	58d2      	ldr	r2, [r2, r3]
    bdd8:	2380      	movs	r3, #128	; 0x80
    bdda:	05db      	lsls	r3, r3, #23
    bddc:	4013      	ands	r3, r2
    bdde:	d0ee      	beq.n	bdbe <expectPulseL+0xe>
	 if (count++ == 0x01FF) return 0; // Exceeded timeout, fail.
	 
	return count;
    bde0:	1dbb      	adds	r3, r7, #6
    bde2:	881b      	ldrh	r3, [r3, #0]
}
    bde4:	0018      	movs	r0, r3
    bde6:	46bd      	mov	sp, r7
    bde8:	b002      	add	sp, #8
    bdea:	bd80      	pop	{r7, pc}
    bdec:	000001ff 	.word	0x000001ff
    bdf0:	41004400 	.word	0x41004400

0000bdf4 <read>:
	//return count;
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool read(void) {
    bdf4:	b590      	push	{r4, r7, lr}
    bdf6:	b085      	sub	sp, #20
    bdf8:	af00      	add	r7, sp, #0

	struct port_config pin_conf;
	uint16_t lowCycles,highCycles;
	
	port_get_config_defaults(&pin_conf);
    bdfa:	1d3b      	adds	r3, r7, #4
    bdfc:	0018      	movs	r0, r3
    bdfe:	4b4e      	ldr	r3, [pc, #312]	; (bf38 <read+0x144>)
    be00:	4798      	blx	r3
	memset(data,0x00,sizeof(data));
    be02:	4b4e      	ldr	r3, [pc, #312]	; (bf3c <read+0x148>)
    be04:	2205      	movs	r2, #5
    be06:	2100      	movs	r1, #0
    be08:	0018      	movs	r0, r3
    be0a:	4b4d      	ldr	r3, [pc, #308]	; (bf40 <read+0x14c>)
    be0c:	4798      	blx	r3

	port_pin_set_output_level(DHT22PIN,false);
    be0e:	2100      	movs	r1, #0
    be10:	203e      	movs	r0, #62	; 0x3e
    be12:	4b4c      	ldr	r3, [pc, #304]	; (bf44 <read+0x150>)
    be14:	4798      	blx	r3
	vTaskDelay(TASK_DELAY_MS(2));
    be16:	2002      	movs	r0, #2
    be18:	4b4b      	ldr	r3, [pc, #300]	; (bf48 <read+0x154>)
    be1a:	4798      	blx	r3
	portDISABLE_INTERRUPTS();
    be1c:	b672      	cpsid	i
	port_pin_set_output_level(DHT22PIN,true);
    be1e:	2101      	movs	r1, #1
    be20:	203e      	movs	r0, #62	; 0x3e
    be22:	4b48      	ldr	r3, [pc, #288]	; (bf44 <read+0x150>)
    be24:	4798      	blx	r3

	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    be26:	1d3b      	adds	r3, r7, #4
    be28:	2200      	movs	r2, #0
    be2a:	701a      	strb	r2, [r3, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    be2c:	1d3b      	adds	r3, r7, #4
    be2e:	2201      	movs	r2, #1
    be30:	705a      	strb	r2, [r3, #1]
	port_pin_set_config(DHT22PIN, &pin_conf);
    be32:	1d3b      	adds	r3, r7, #4
    be34:	0019      	movs	r1, r3
    be36:	203e      	movs	r0, #62	; 0x3e
    be38:	4b44      	ldr	r3, [pc, #272]	; (bf4c <read+0x158>)
    be3a:	4798      	blx	r3
	
	if (!expectPulseH())
    be3c:	4b44      	ldr	r3, [pc, #272]	; (bf50 <read+0x15c>)
    be3e:	4798      	blx	r3
    be40:	1e03      	subs	r3, r0, #0
    be42:	d103      	bne.n	be4c <read+0x58>
	{
		vResetPort();
    be44:	4b43      	ldr	r3, [pc, #268]	; (bf54 <read+0x160>)
    be46:	4798      	blx	r3
		return false;
    be48:	2300      	movs	r3, #0
    be4a:	e070      	b.n	bf2e <read+0x13a>
	}	
	
	if (!expectPulseL())
    be4c:	4b42      	ldr	r3, [pc, #264]	; (bf58 <read+0x164>)
    be4e:	4798      	blx	r3
    be50:	1e03      	subs	r3, r0, #0
    be52:	d103      	bne.n	be5c <read+0x68>
	{
		vResetPort();
    be54:	4b3f      	ldr	r3, [pc, #252]	; (bf54 <read+0x160>)
    be56:	4798      	blx	r3
		return false;
    be58:	2300      	movs	r3, #0
    be5a:	e068      	b.n	bf2e <read+0x13a>
	}
	
	if (!expectPulseH())
    be5c:	4b3c      	ldr	r3, [pc, #240]	; (bf50 <read+0x15c>)
    be5e:	4798      	blx	r3
    be60:	1e03      	subs	r3, r0, #0
    be62:	d103      	bne.n	be6c <read+0x78>
	{
		vResetPort();
    be64:	4b3b      	ldr	r3, [pc, #236]	; (bf54 <read+0x160>)
    be66:	4798      	blx	r3
		return false;
    be68:	2300      	movs	r3, #0
    be6a:	e060      	b.n	bf2e <read+0x13a>
	}

	for (uint16_t i=0; i<40; i++)
    be6c:	230e      	movs	r3, #14
    be6e:	18fb      	adds	r3, r7, r3
    be70:	2200      	movs	r2, #0
    be72:	801a      	strh	r2, [r3, #0]
    be74:	e03f      	b.n	bef6 <read+0x102>
	{
		lowCycles  = expectPulseL();
    be76:	230c      	movs	r3, #12
    be78:	18fc      	adds	r4, r7, r3
    be7a:	4b37      	ldr	r3, [pc, #220]	; (bf58 <read+0x164>)
    be7c:	4798      	blx	r3
    be7e:	0003      	movs	r3, r0
    be80:	8023      	strh	r3, [r4, #0]
		highCycles = expectPulseH();
    be82:	230a      	movs	r3, #10
    be84:	18fc      	adds	r4, r7, r3
    be86:	4b32      	ldr	r3, [pc, #200]	; (bf50 <read+0x15c>)
    be88:	4798      	blx	r3
    be8a:	0003      	movs	r3, r0
    be8c:	8023      	strh	r3, [r4, #0]
		data[i>>3] <<= 1;
    be8e:	230e      	movs	r3, #14
    be90:	18fb      	adds	r3, r7, r3
    be92:	881b      	ldrh	r3, [r3, #0]
    be94:	08db      	lsrs	r3, r3, #3
    be96:	b29b      	uxth	r3, r3
    be98:	001a      	movs	r2, r3
    be9a:	230e      	movs	r3, #14
    be9c:	18fb      	adds	r3, r7, r3
    be9e:	881b      	ldrh	r3, [r3, #0]
    bea0:	08db      	lsrs	r3, r3, #3
    bea2:	b29b      	uxth	r3, r3
    bea4:	0019      	movs	r1, r3
    bea6:	4b25      	ldr	r3, [pc, #148]	; (bf3c <read+0x148>)
    bea8:	5c5b      	ldrb	r3, [r3, r1]
    beaa:	18db      	adds	r3, r3, r3
    beac:	b2d9      	uxtb	r1, r3
    beae:	4b23      	ldr	r3, [pc, #140]	; (bf3c <read+0x148>)
    beb0:	5499      	strb	r1, [r3, r2]
		if (highCycles > lowCycles) data[i>>3] |= 1;
    beb2:	230a      	movs	r3, #10
    beb4:	18fa      	adds	r2, r7, r3
    beb6:	230c      	movs	r3, #12
    beb8:	18fb      	adds	r3, r7, r3
    beba:	8812      	ldrh	r2, [r2, #0]
    bebc:	881b      	ldrh	r3, [r3, #0]
    bebe:	429a      	cmp	r2, r3
    bec0:	d912      	bls.n	bee8 <read+0xf4>
    bec2:	230e      	movs	r3, #14
    bec4:	18fb      	adds	r3, r7, r3
    bec6:	881b      	ldrh	r3, [r3, #0]
    bec8:	08db      	lsrs	r3, r3, #3
    beca:	b29b      	uxth	r3, r3
    becc:	0019      	movs	r1, r3
    bece:	230e      	movs	r3, #14
    bed0:	18fb      	adds	r3, r7, r3
    bed2:	881b      	ldrh	r3, [r3, #0]
    bed4:	08db      	lsrs	r3, r3, #3
    bed6:	b29b      	uxth	r3, r3
    bed8:	001a      	movs	r2, r3
    beda:	4b18      	ldr	r3, [pc, #96]	; (bf3c <read+0x148>)
    bedc:	5c9b      	ldrb	r3, [r3, r2]
    bede:	2201      	movs	r2, #1
    bee0:	4313      	orrs	r3, r2
    bee2:	b2da      	uxtb	r2, r3
    bee4:	4b15      	ldr	r3, [pc, #84]	; (bf3c <read+0x148>)
    bee6:	545a      	strb	r2, [r3, r1]
	{
		vResetPort();
		return false;
	}

	for (uint16_t i=0; i<40; i++)
    bee8:	230e      	movs	r3, #14
    beea:	18fb      	adds	r3, r7, r3
    beec:	881a      	ldrh	r2, [r3, #0]
    beee:	230e      	movs	r3, #14
    bef0:	18fb      	adds	r3, r7, r3
    bef2:	3201      	adds	r2, #1
    bef4:	801a      	strh	r2, [r3, #0]
    bef6:	230e      	movs	r3, #14
    bef8:	18fb      	adds	r3, r7, r3
    befa:	881b      	ldrh	r3, [r3, #0]
    befc:	2b27      	cmp	r3, #39	; 0x27
    befe:	d9ba      	bls.n	be76 <read+0x82>
		highCycles = expectPulseH();
		data[i>>3] <<= 1;
		if (highCycles > lowCycles) data[i>>3] |= 1;
	}
	
	vResetPort();
    bf00:	4b14      	ldr	r3, [pc, #80]	; (bf54 <read+0x160>)
    bf02:	4798      	blx	r3
	
	return (data[4] == ((data[0] + data[1] + data[2] + data[3]) & 0xFF)) ? true : false;
    bf04:	4b0d      	ldr	r3, [pc, #52]	; (bf3c <read+0x148>)
    bf06:	791b      	ldrb	r3, [r3, #4]
    bf08:	0019      	movs	r1, r3
    bf0a:	4b0c      	ldr	r3, [pc, #48]	; (bf3c <read+0x148>)
    bf0c:	781b      	ldrb	r3, [r3, #0]
    bf0e:	001a      	movs	r2, r3
    bf10:	4b0a      	ldr	r3, [pc, #40]	; (bf3c <read+0x148>)
    bf12:	785b      	ldrb	r3, [r3, #1]
    bf14:	18d3      	adds	r3, r2, r3
    bf16:	4a09      	ldr	r2, [pc, #36]	; (bf3c <read+0x148>)
    bf18:	7892      	ldrb	r2, [r2, #2]
    bf1a:	189b      	adds	r3, r3, r2
    bf1c:	4a07      	ldr	r2, [pc, #28]	; (bf3c <read+0x148>)
    bf1e:	78d2      	ldrb	r2, [r2, #3]
    bf20:	189b      	adds	r3, r3, r2
    bf22:	22ff      	movs	r2, #255	; 0xff
    bf24:	4013      	ands	r3, r2
    bf26:	1acb      	subs	r3, r1, r3
    bf28:	425a      	negs	r2, r3
    bf2a:	4153      	adcs	r3, r2
    bf2c:	b2db      	uxtb	r3, r3
}
    bf2e:	0018      	movs	r0, r3
    bf30:	46bd      	mov	sp, r7
    bf32:	b005      	add	sp, #20
    bf34:	bd90      	pop	{r4, r7, pc}
    bf36:	46c0      	nop			; (mov r8, r8)
    bf38:	0000bcb1 	.word	0x0000bcb1
    bf3c:	20003df4 	.word	0x20003df4
    bf40:	0001eead 	.word	0x0001eead
    bf44:	0000bcd5 	.word	0x0000bcd5
    bf48:	000101fd 	.word	0x000101fd
    bf4c:	0001355d 	.word	0x0001355d
    bf50:	0000bd6d 	.word	0x0000bd6d
    bf54:	0000bd29 	.word	0x0000bd29
    bf58:	0000bdb1 	.word	0x0000bdb1

0000bf5c <DHT_Init>:

////////////////////////////////////////////////////////////////////////////////////////////////////////////

void DHT_Init(void) {
    bf5c:	b580      	push	{r7, lr}
    bf5e:	b082      	sub	sp, #8
    bf60:	af00      	add	r7, sp, #0

	struct port_config pin_conf;
	
	port_get_config_defaults(&pin_conf);
    bf62:	1d3b      	adds	r3, r7, #4
    bf64:	0018      	movs	r0, r3
    bf66:	4b0a      	ldr	r3, [pc, #40]	; (bf90 <DHT_Init+0x34>)
    bf68:	4798      	blx	r3
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    bf6a:	1d3b      	adds	r3, r7, #4
    bf6c:	2201      	movs	r2, #1
    bf6e:	701a      	strb	r2, [r3, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    bf70:	1d3b      	adds	r3, r7, #4
    bf72:	2201      	movs	r2, #1
    bf74:	705a      	strb	r2, [r3, #1]
	port_pin_set_config(DHT22PIN, &pin_conf);
    bf76:	1d3b      	adds	r3, r7, #4
    bf78:	0019      	movs	r1, r3
    bf7a:	203e      	movs	r0, #62	; 0x3e
    bf7c:	4b05      	ldr	r3, [pc, #20]	; (bf94 <DHT_Init+0x38>)
    bf7e:	4798      	blx	r3
	port_pin_set_output_level(DHT22PIN,true);
    bf80:	2101      	movs	r1, #1
    bf82:	203e      	movs	r0, #62	; 0x3e
    bf84:	4b04      	ldr	r3, [pc, #16]	; (bf98 <DHT_Init+0x3c>)
    bf86:	4798      	blx	r3

}
    bf88:	46c0      	nop			; (mov r8, r8)
    bf8a:	46bd      	mov	sp, r7
    bf8c:	b002      	add	sp, #8
    bf8e:	bd80      	pop	{r7, pc}
    bf90:	0000bcb1 	.word	0x0000bcb1
    bf94:	0001355d 	.word	0x0001355d
    bf98:	0000bcd5 	.word	0x0000bcd5

0000bf9c <vReadTHAll>:
//}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void vReadTHAll (float *Tem,float *Hum)
{float f= 0;
    bf9c:	b590      	push	{r4, r7, lr}
    bf9e:	b085      	sub	sp, #20
    bfa0:	af00      	add	r7, sp, #0
    bfa2:	6078      	str	r0, [r7, #4]
    bfa4:	6039      	str	r1, [r7, #0]
    bfa6:	2300      	movs	r3, #0
    bfa8:	60fb      	str	r3, [r7, #12]
 
 if (read()) 
    bfaa:	4b3d      	ldr	r3, [pc, #244]	; (c0a0 <vReadTHAll+0x104>)
    bfac:	4798      	blx	r3
    bfae:	1e03      	subs	r3, r0, #0
    bfb0:	d06b      	beq.n	c08a <vReadTHAll+0xee>
 {
  f = data[2] & 0x7F;
    bfb2:	4b3c      	ldr	r3, [pc, #240]	; (c0a4 <vReadTHAll+0x108>)
    bfb4:	789b      	ldrb	r3, [r3, #2]
    bfb6:	001a      	movs	r2, r3
    bfb8:	237f      	movs	r3, #127	; 0x7f
    bfba:	401a      	ands	r2, r3
    bfbc:	4b3a      	ldr	r3, [pc, #232]	; (c0a8 <vReadTHAll+0x10c>)
    bfbe:	0010      	movs	r0, r2
    bfc0:	4798      	blx	r3
    bfc2:	1c03      	adds	r3, r0, #0
    bfc4:	60fb      	str	r3, [r7, #12]
  f *= 256;
    bfc6:	4b39      	ldr	r3, [pc, #228]	; (c0ac <vReadTHAll+0x110>)
    bfc8:	2187      	movs	r1, #135	; 0x87
    bfca:	05c9      	lsls	r1, r1, #23
    bfcc:	68f8      	ldr	r0, [r7, #12]
    bfce:	4798      	blx	r3
    bfd0:	1c03      	adds	r3, r0, #0
    bfd2:	60fb      	str	r3, [r7, #12]
  f += data[3];
    bfd4:	4b33      	ldr	r3, [pc, #204]	; (c0a4 <vReadTHAll+0x108>)
    bfd6:	78db      	ldrb	r3, [r3, #3]
    bfd8:	001a      	movs	r2, r3
    bfda:	4b33      	ldr	r3, [pc, #204]	; (c0a8 <vReadTHAll+0x10c>)
    bfdc:	0010      	movs	r0, r2
    bfde:	4798      	blx	r3
    bfe0:	1c02      	adds	r2, r0, #0
    bfe2:	4b33      	ldr	r3, [pc, #204]	; (c0b0 <vReadTHAll+0x114>)
    bfe4:	1c11      	adds	r1, r2, #0
    bfe6:	68f8      	ldr	r0, [r7, #12]
    bfe8:	4798      	blx	r3
    bfea:	1c03      	adds	r3, r0, #0
    bfec:	60fb      	str	r3, [r7, #12]
  f *= 0.1;
    bfee:	4b31      	ldr	r3, [pc, #196]	; (c0b4 <vReadTHAll+0x118>)
    bff0:	68f8      	ldr	r0, [r7, #12]
    bff2:	4798      	blx	r3
    bff4:	4c30      	ldr	r4, [pc, #192]	; (c0b8 <vReadTHAll+0x11c>)
    bff6:	4a31      	ldr	r2, [pc, #196]	; (c0bc <vReadTHAll+0x120>)
    bff8:	4b31      	ldr	r3, [pc, #196]	; (c0c0 <vReadTHAll+0x124>)
    bffa:	47a0      	blx	r4
    bffc:	0003      	movs	r3, r0
    bffe:	000c      	movs	r4, r1
    c000:	0019      	movs	r1, r3
    c002:	0022      	movs	r2, r4
    c004:	4b2f      	ldr	r3, [pc, #188]	; (c0c4 <vReadTHAll+0x128>)
    c006:	0008      	movs	r0, r1
    c008:	0011      	movs	r1, r2
    c00a:	4798      	blx	r3
    c00c:	1c03      	adds	r3, r0, #0
    c00e:	60fb      	str	r3, [r7, #12]
  if (data[2] & 0x80) f *= -1;
    c010:	4b24      	ldr	r3, [pc, #144]	; (c0a4 <vReadTHAll+0x108>)
    c012:	789b      	ldrb	r3, [r3, #2]
    c014:	b25b      	sxtb	r3, r3
    c016:	2b00      	cmp	r3, #0
    c018:	da04      	bge.n	c024 <vReadTHAll+0x88>
    c01a:	68fb      	ldr	r3, [r7, #12]
    c01c:	2280      	movs	r2, #128	; 0x80
    c01e:	0612      	lsls	r2, r2, #24
    c020:	4053      	eors	r3, r2
    c022:	60fb      	str	r3, [r7, #12]
  //if(S) {
  //	f = convertCtoF(f);
  //}
  *Tem=f;
    c024:	687b      	ldr	r3, [r7, #4]
    c026:	68fa      	ldr	r2, [r7, #12]
    c028:	601a      	str	r2, [r3, #0]
  f = data[0];
    c02a:	4b1e      	ldr	r3, [pc, #120]	; (c0a4 <vReadTHAll+0x108>)
    c02c:	781a      	ldrb	r2, [r3, #0]
    c02e:	4b26      	ldr	r3, [pc, #152]	; (c0c8 <vReadTHAll+0x12c>)
    c030:	0010      	movs	r0, r2
    c032:	4798      	blx	r3
    c034:	1c03      	adds	r3, r0, #0
    c036:	60fb      	str	r3, [r7, #12]
  f *= 256;
    c038:	4b1c      	ldr	r3, [pc, #112]	; (c0ac <vReadTHAll+0x110>)
    c03a:	2187      	movs	r1, #135	; 0x87
    c03c:	05c9      	lsls	r1, r1, #23
    c03e:	68f8      	ldr	r0, [r7, #12]
    c040:	4798      	blx	r3
    c042:	1c03      	adds	r3, r0, #0
    c044:	60fb      	str	r3, [r7, #12]
  f += data[1];
    c046:	4b17      	ldr	r3, [pc, #92]	; (c0a4 <vReadTHAll+0x108>)
    c048:	785b      	ldrb	r3, [r3, #1]
    c04a:	001a      	movs	r2, r3
    c04c:	4b16      	ldr	r3, [pc, #88]	; (c0a8 <vReadTHAll+0x10c>)
    c04e:	0010      	movs	r0, r2
    c050:	4798      	blx	r3
    c052:	1c02      	adds	r2, r0, #0
    c054:	4b16      	ldr	r3, [pc, #88]	; (c0b0 <vReadTHAll+0x114>)
    c056:	1c11      	adds	r1, r2, #0
    c058:	68f8      	ldr	r0, [r7, #12]
    c05a:	4798      	blx	r3
    c05c:	1c03      	adds	r3, r0, #0
    c05e:	60fb      	str	r3, [r7, #12]
  f *= 0.1; 
    c060:	4b14      	ldr	r3, [pc, #80]	; (c0b4 <vReadTHAll+0x118>)
    c062:	68f8      	ldr	r0, [r7, #12]
    c064:	4798      	blx	r3
    c066:	4c14      	ldr	r4, [pc, #80]	; (c0b8 <vReadTHAll+0x11c>)
    c068:	4a14      	ldr	r2, [pc, #80]	; (c0bc <vReadTHAll+0x120>)
    c06a:	4b15      	ldr	r3, [pc, #84]	; (c0c0 <vReadTHAll+0x124>)
    c06c:	47a0      	blx	r4
    c06e:	0003      	movs	r3, r0
    c070:	000c      	movs	r4, r1
    c072:	0019      	movs	r1, r3
    c074:	0022      	movs	r2, r4
    c076:	4b13      	ldr	r3, [pc, #76]	; (c0c4 <vReadTHAll+0x128>)
    c078:	0008      	movs	r0, r1
    c07a:	0011      	movs	r1, r2
    c07c:	4798      	blx	r3
    c07e:	1c03      	adds	r3, r0, #0
    c080:	60fb      	str	r3, [r7, #12]
  *Hum=f;
    c082:	683b      	ldr	r3, [r7, #0]
    c084:	68fa      	ldr	r2, [r7, #12]
    c086:	601a      	str	r2, [r3, #0]
 else
 {
   *Tem=0;
   *Hum=0; 
 }
}
    c088:	e005      	b.n	c096 <vReadTHAll+0xfa>
  f *= 0.1; 
  *Hum=f;
 }
 else
 {
   *Tem=0;
    c08a:	687b      	ldr	r3, [r7, #4]
    c08c:	2200      	movs	r2, #0
    c08e:	601a      	str	r2, [r3, #0]
   *Hum=0; 
    c090:	683b      	ldr	r3, [r7, #0]
    c092:	2200      	movs	r2, #0
    c094:	601a      	str	r2, [r3, #0]
 }
}
    c096:	46c0      	nop			; (mov r8, r8)
    c098:	46bd      	mov	sp, r7
    c09a:	b005      	add	sp, #20
    c09c:	bd90      	pop	{r4, r7, pc}
    c09e:	46c0      	nop			; (mov r8, r8)
    c0a0:	0000bdf5 	.word	0x0000bdf5
    c0a4:	20003df4 	.word	0x20003df4
    c0a8:	0001e21d 	.word	0x0001e21d
    c0ac:	0001dca5 	.word	0x0001dca5
    c0b0:	0001d9b9 	.word	0x0001d9b9
    c0b4:	0001e81d 	.word	0x0001e81d
    c0b8:	0001e329 	.word	0x0001e329
    c0bc:	9999999a 	.word	0x9999999a
    c0c0:	3fb99999 	.word	0x3fb99999
    c0c4:	0001e8c5 	.word	0x0001e8c5
    c0c8:	0001e2ad 	.word	0x0001e2ad

0000c0cc <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    c0cc:	b580      	push	{r7, lr}
    c0ce:	b084      	sub	sp, #16
    c0d0:	af00      	add	r7, sp, #0
    c0d2:	0002      	movs	r2, r0
    c0d4:	1dfb      	adds	r3, r7, #7
    c0d6:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    c0d8:	230f      	movs	r3, #15
    c0da:	18fb      	adds	r3, r7, r3
    c0dc:	1dfa      	adds	r2, r7, #7
    c0de:	7812      	ldrb	r2, [r2, #0]
    c0e0:	09d2      	lsrs	r2, r2, #7
    c0e2:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    c0e4:	230e      	movs	r3, #14
    c0e6:	18fb      	adds	r3, r7, r3
    c0e8:	1dfa      	adds	r2, r7, #7
    c0ea:	7812      	ldrb	r2, [r2, #0]
    c0ec:	0952      	lsrs	r2, r2, #5
    c0ee:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    c0f0:	4b0d      	ldr	r3, [pc, #52]	; (c128 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    c0f2:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    c0f4:	230f      	movs	r3, #15
    c0f6:	18fb      	adds	r3, r7, r3
    c0f8:	781b      	ldrb	r3, [r3, #0]
    c0fa:	2b00      	cmp	r3, #0
    c0fc:	d10f      	bne.n	c11e <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    c0fe:	230f      	movs	r3, #15
    c100:	18fb      	adds	r3, r7, r3
    c102:	781b      	ldrb	r3, [r3, #0]
    c104:	009b      	lsls	r3, r3, #2
    c106:	2210      	movs	r2, #16
    c108:	4694      	mov	ip, r2
    c10a:	44bc      	add	ip, r7
    c10c:	4463      	add	r3, ip
    c10e:	3b08      	subs	r3, #8
    c110:	681a      	ldr	r2, [r3, #0]
    c112:	230e      	movs	r3, #14
    c114:	18fb      	adds	r3, r7, r3
    c116:	781b      	ldrb	r3, [r3, #0]
    c118:	01db      	lsls	r3, r3, #7
    c11a:	18d3      	adds	r3, r2, r3
    c11c:	e000      	b.n	c120 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    c11e:	2300      	movs	r3, #0
	}
}
    c120:	0018      	movs	r0, r3
    c122:	46bd      	mov	sp, r7
    c124:	b004      	add	sp, #16
    c126:	bd80      	pop	{r7, pc}
    c128:	41004400 	.word	0x41004400

0000c12c <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    c12c:	b580      	push	{r7, lr}
    c12e:	b082      	sub	sp, #8
    c130:	af00      	add	r7, sp, #0
    c132:	0002      	movs	r2, r0
    c134:	1dfb      	adds	r3, r7, #7
    c136:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    c138:	1dfb      	adds	r3, r7, #7
    c13a:	781b      	ldrb	r3, [r3, #0]
    c13c:	0018      	movs	r0, r3
    c13e:	4b03      	ldr	r3, [pc, #12]	; (c14c <port_get_group_from_gpio_pin+0x20>)
    c140:	4798      	blx	r3
    c142:	0003      	movs	r3, r0
}
    c144:	0018      	movs	r0, r3
    c146:	46bd      	mov	sp, r7
    c148:	b002      	add	sp, #8
    c14a:	bd80      	pop	{r7, pc}
    c14c:	0000c0cd 	.word	0x0000c0cd

0000c150 <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    c150:	b580      	push	{r7, lr}
    c152:	b082      	sub	sp, #8
    c154:	af00      	add	r7, sp, #0
    c156:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    c158:	687b      	ldr	r3, [r7, #4]
    c15a:	2200      	movs	r2, #0
    c15c:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    c15e:	687b      	ldr	r3, [r7, #4]
    c160:	2201      	movs	r2, #1
    c162:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    c164:	687b      	ldr	r3, [r7, #4]
    c166:	2200      	movs	r2, #0
    c168:	709a      	strb	r2, [r3, #2]
}
    c16a:	46c0      	nop			; (mov r8, r8)
    c16c:	46bd      	mov	sp, r7
    c16e:	b002      	add	sp, #8
    c170:	bd80      	pop	{r7, pc}
    c172:	46c0      	nop			; (mov r8, r8)

0000c174 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    c174:	b580      	push	{r7, lr}
    c176:	b084      	sub	sp, #16
    c178:	af00      	add	r7, sp, #0
    c17a:	0002      	movs	r2, r0
    c17c:	1dfb      	adds	r3, r7, #7
    c17e:	701a      	strb	r2, [r3, #0]
    c180:	1dbb      	adds	r3, r7, #6
    c182:	1c0a      	adds	r2, r1, #0
    c184:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    c186:	1dfb      	adds	r3, r7, #7
    c188:	781b      	ldrb	r3, [r3, #0]
    c18a:	0018      	movs	r0, r3
    c18c:	4b0d      	ldr	r3, [pc, #52]	; (c1c4 <port_pin_set_output_level+0x50>)
    c18e:	4798      	blx	r3
    c190:	0003      	movs	r3, r0
    c192:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    c194:	1dfb      	adds	r3, r7, #7
    c196:	781b      	ldrb	r3, [r3, #0]
    c198:	221f      	movs	r2, #31
    c19a:	4013      	ands	r3, r2
    c19c:	2201      	movs	r2, #1
    c19e:	409a      	lsls	r2, r3
    c1a0:	0013      	movs	r3, r2
    c1a2:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    c1a4:	1dbb      	adds	r3, r7, #6
    c1a6:	781b      	ldrb	r3, [r3, #0]
    c1a8:	2b00      	cmp	r3, #0
    c1aa:	d003      	beq.n	c1b4 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    c1ac:	68fb      	ldr	r3, [r7, #12]
    c1ae:	68ba      	ldr	r2, [r7, #8]
    c1b0:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    c1b2:	e002      	b.n	c1ba <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    c1b4:	68fb      	ldr	r3, [r7, #12]
    c1b6:	68ba      	ldr	r2, [r7, #8]
    c1b8:	615a      	str	r2, [r3, #20]
	}
}
    c1ba:	46c0      	nop			; (mov r8, r8)
    c1bc:	46bd      	mov	sp, r7
    c1be:	b004      	add	sp, #16
    c1c0:	bd80      	pop	{r7, pc}
    c1c2:	46c0      	nop			; (mov r8, r8)
    c1c4:	0000c12d 	.word	0x0000c12d

0000c1c8 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
    c1c8:	b580      	push	{r7, lr}
    c1ca:	b082      	sub	sp, #8
    c1cc:	af00      	add	r7, sp, #0
    c1ce:	0002      	movs	r2, r0
    c1d0:	1dfb      	adds	r3, r7, #7
    c1d2:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    c1d4:	4b06      	ldr	r3, [pc, #24]	; (c1f0 <system_interrupt_enable+0x28>)
    c1d6:	1dfa      	adds	r2, r7, #7
    c1d8:	7812      	ldrb	r2, [r2, #0]
    c1da:	0011      	movs	r1, r2
    c1dc:	221f      	movs	r2, #31
    c1de:	400a      	ands	r2, r1
    c1e0:	2101      	movs	r1, #1
    c1e2:	4091      	lsls	r1, r2
    c1e4:	000a      	movs	r2, r1
    c1e6:	601a      	str	r2, [r3, #0]
}
    c1e8:	46c0      	nop			; (mov r8, r8)
    c1ea:	46bd      	mov	sp, r7
    c1ec:	b002      	add	sp, #8
    c1ee:	bd80      	pop	{r7, pc}
    c1f0:	e000e100 	.word	0xe000e100

0000c1f4 <spi_is_syncing>:
 * \retval false  Module synchronization is not ongoing
 *
 */
static inline bool spi_is_syncing(
		struct spi_module *const module)
{
    c1f4:	b580      	push	{r7, lr}
    c1f6:	b084      	sub	sp, #16
    c1f8:	af00      	add	r7, sp, #0
    c1fa:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    c1fc:	687b      	ldr	r3, [r7, #4]
    c1fe:	681b      	ldr	r3, [r3, #0]
    c200:	60fb      	str	r3, [r7, #12]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    c202:	68fb      	ldr	r3, [r7, #12]
    c204:	69db      	ldr	r3, [r3, #28]
    c206:	1e5a      	subs	r2, r3, #1
    c208:	4193      	sbcs	r3, r2
    c20a:	b2db      	uxtb	r3, r3
#  else
	/* Return synchronization status */
	return (spi_module->STATUS.reg & SERCOM_SPI_STATUS_SYNCBUSY);
#  endif
}
    c20c:	0018      	movs	r0, r3
    c20e:	46bd      	mov	sp, r7
    c210:	b004      	add	sp, #16
    c212:	bd80      	pop	{r7, pc}

0000c214 <spi_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void spi_get_config_defaults(
		struct spi_config *const config)
{
    c214:	b580      	push	{r7, lr}
    c216:	b082      	sub	sp, #8
    c218:	af00      	add	r7, sp, #0
    c21a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
    c21c:	687b      	ldr	r3, [r7, #4]
    c21e:	2201      	movs	r2, #1
    c220:	701a      	strb	r2, [r3, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
    c222:	687b      	ldr	r3, [r7, #4]
    c224:	2200      	movs	r2, #0
    c226:	605a      	str	r2, [r3, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
    c228:	687b      	ldr	r3, [r7, #4]
    c22a:	2200      	movs	r2, #0
    c22c:	609a      	str	r2, [r3, #8]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
    c22e:	687b      	ldr	r3, [r7, #4]
    c230:	22c0      	movs	r2, #192	; 0xc0
    c232:	0392      	lsls	r2, r2, #14
    c234:	60da      	str	r2, [r3, #12]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
    c236:	687b      	ldr	r3, [r7, #4]
    c238:	2200      	movs	r2, #0
    c23a:	741a      	strb	r2, [r3, #16]
	config->run_in_standby   = false;
    c23c:	687b      	ldr	r3, [r7, #4]
    c23e:	2200      	movs	r2, #0
    c240:	745a      	strb	r2, [r3, #17]
	config->receiver_enable  = true;
    c242:	687b      	ldr	r3, [r7, #4]
    c244:	2201      	movs	r2, #1
    c246:	749a      	strb	r2, [r3, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
    c248:	687b      	ldr	r3, [r7, #4]
    c24a:	2201      	movs	r2, #1
    c24c:	74da      	strb	r2, [r3, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
    c24e:	687b      	ldr	r3, [r7, #4]
    c250:	2200      	movs	r2, #0
    c252:	751a      	strb	r2, [r3, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    c254:	687b      	ldr	r3, [r7, #4]
    c256:	2224      	movs	r2, #36	; 0x24
    c258:	2100      	movs	r1, #0
    c25a:	5499      	strb	r1, [r3, r2]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
    c25c:	687b      	ldr	r3, [r7, #4]
    c25e:	3318      	adds	r3, #24
    c260:	220c      	movs	r2, #12
    c262:	2100      	movs	r1, #0
    c264:	0018      	movs	r0, r3
    c266:	4b0a      	ldr	r3, [pc, #40]	; (c290 <spi_get_config_defaults+0x7c>)
    c268:	4798      	blx	r3

	/* Master config defaults */
	config->mode_specific.master.baudrate = 100000;
    c26a:	687b      	ldr	r3, [r7, #4]
    c26c:	4a09      	ldr	r2, [pc, #36]	; (c294 <spi_get_config_defaults+0x80>)
    c26e:	619a      	str	r2, [r3, #24]

	/* pinmux config defaults */
	config->pinmux_pad0 = PINMUX_DEFAULT;
    c270:	687b      	ldr	r3, [r7, #4]
    c272:	2200      	movs	r2, #0
    c274:	629a      	str	r2, [r3, #40]	; 0x28
	config->pinmux_pad1 = PINMUX_DEFAULT;
    c276:	687b      	ldr	r3, [r7, #4]
    c278:	2200      	movs	r2, #0
    c27a:	62da      	str	r2, [r3, #44]	; 0x2c
	config->pinmux_pad2 = PINMUX_DEFAULT;
    c27c:	687b      	ldr	r3, [r7, #4]
    c27e:	2200      	movs	r2, #0
    c280:	631a      	str	r2, [r3, #48]	; 0x30
	config->pinmux_pad3 = PINMUX_DEFAULT;
    c282:	687b      	ldr	r3, [r7, #4]
    c284:	2200      	movs	r2, #0
    c286:	635a      	str	r2, [r3, #52]	; 0x34

};
    c288:	46c0      	nop			; (mov r8, r8)
    c28a:	46bd      	mov	sp, r7
    c28c:	b002      	add	sp, #8
    c28e:	bd80      	pop	{r7, pc}
    c290:	0001eead 	.word	0x0001eead
    c294:	000186a0 	.word	0x000186a0

0000c298 <spi_enable>:
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
static inline void spi_enable(
		struct spi_module *const module)
{
    c298:	b580      	push	{r7, lr}
    c29a:	b084      	sub	sp, #16
    c29c:	af00      	add	r7, sp, #0
    c29e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    c2a0:	687b      	ldr	r3, [r7, #4]
    c2a2:	681b      	ldr	r3, [r3, #0]
    c2a4:	60fb      	str	r3, [r7, #12]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    c2a6:	687b      	ldr	r3, [r7, #4]
    c2a8:	681b      	ldr	r3, [r3, #0]
    c2aa:	0018      	movs	r0, r3
    c2ac:	4b0b      	ldr	r3, [pc, #44]	; (c2dc <spi_enable+0x44>)
    c2ae:	4798      	blx	r3
    c2b0:	0003      	movs	r3, r0
    c2b2:	0018      	movs	r0, r3
    c2b4:	4b0a      	ldr	r3, [pc, #40]	; (c2e0 <spi_enable+0x48>)
    c2b6:	4798      	blx	r3
#  endif

	while (spi_is_syncing(module)) {
    c2b8:	46c0      	nop			; (mov r8, r8)
    c2ba:	687b      	ldr	r3, [r7, #4]
    c2bc:	0018      	movs	r0, r3
    c2be:	4b09      	ldr	r3, [pc, #36]	; (c2e4 <spi_enable+0x4c>)
    c2c0:	4798      	blx	r3
    c2c2:	1e03      	subs	r3, r0, #0
    c2c4:	d1f9      	bne.n	c2ba <spi_enable+0x22>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    c2c6:	68fb      	ldr	r3, [r7, #12]
    c2c8:	681b      	ldr	r3, [r3, #0]
    c2ca:	2202      	movs	r2, #2
    c2cc:	431a      	orrs	r2, r3
    c2ce:	68fb      	ldr	r3, [r7, #12]
    c2d0:	601a      	str	r2, [r3, #0]
}
    c2d2:	46c0      	nop			; (mov r8, r8)
    c2d4:	46bd      	mov	sp, r7
    c2d6:	b004      	add	sp, #16
    c2d8:	bd80      	pop	{r7, pc}
    c2da:	46c0      	nop			; (mov r8, r8)
    c2dc:	00014119 	.word	0x00014119
    c2e0:	0000c1c9 	.word	0x0000c1c9
    c2e4:	0000c1f5 	.word	0x0000c1f5

0000c2e8 <usart_is_syncing>:
 * \retval false  Peripheral is not busy syncing and can be read/written without
 *                stalling the bus
 */
static inline bool usart_is_syncing(
		const struct usart_module *const module)
{
    c2e8:	b580      	push	{r7, lr}
    c2ea:	b084      	sub	sp, #16
    c2ec:	af00      	add	r7, sp, #0
    c2ee:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    c2f0:	687b      	ldr	r3, [r7, #4]
    c2f2:	681b      	ldr	r3, [r3, #0]
    c2f4:	60fb      	str	r3, [r7, #12]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    c2f6:	68fb      	ldr	r3, [r7, #12]
    c2f8:	69db      	ldr	r3, [r3, #28]
    c2fa:	1e5a      	subs	r2, r3, #1
    c2fc:	4193      	sbcs	r3, r2
    c2fe:	b2db      	uxtb	r3, r3
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
#endif
}
    c300:	0018      	movs	r0, r3
    c302:	46bd      	mov	sp, r7
    c304:	b004      	add	sp, #16
    c306:	bd80      	pop	{r7, pc}

0000c308 <_usart_wait_for_sync>:
 * \internal
 * Waits until synchronization is complete
 */
static inline void _usart_wait_for_sync(
		const struct usart_module *const module)
{
    c308:	b580      	push	{r7, lr}
    c30a:	b082      	sub	sp, #8
    c30c:	af00      	add	r7, sp, #0
    c30e:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    c310:	46c0      	nop			; (mov r8, r8)
    c312:	687b      	ldr	r3, [r7, #4]
    c314:	0018      	movs	r0, r3
    c316:	4b04      	ldr	r3, [pc, #16]	; (c328 <_usart_wait_for_sync+0x20>)
    c318:	4798      	blx	r3
    c31a:	1e03      	subs	r3, r0, #0
    c31c:	d1f9      	bne.n	c312 <_usart_wait_for_sync+0xa>
		/* Wait until the synchronization is complete */
	}
}
    c31e:	46c0      	nop			; (mov r8, r8)
    c320:	46bd      	mov	sp, r7
    c322:	b002      	add	sp, #8
    c324:	bd80      	pop	{r7, pc}
    c326:	46c0      	nop			; (mov r8, r8)
    c328:	0000c2e9 	.word	0x0000c2e9

0000c32c <usart_get_config_defaults>:
 *
 * \param[in,out] config  Pointer to configuration struct
 */
static inline void usart_get_config_defaults(
		struct usart_config *const config)
{
    c32c:	b580      	push	{r7, lr}
    c32e:	b082      	sub	sp, #8
    c330:	af00      	add	r7, sp, #0
    c332:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    c334:	687b      	ldr	r3, [r7, #4]
    c336:	2280      	movs	r2, #128	; 0x80
    c338:	05d2      	lsls	r2, r2, #23
    c33a:	601a      	str	r2, [r3, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    c33c:	687b      	ldr	r3, [r7, #4]
    c33e:	2200      	movs	r2, #0
    c340:	605a      	str	r2, [r3, #4]
	config->parity           = USART_PARITY_NONE;
    c342:	687b      	ldr	r3, [r7, #4]
    c344:	22ff      	movs	r2, #255	; 0xff
    c346:	811a      	strh	r2, [r3, #8]
	config->stopbits         = USART_STOPBITS_1;
    c348:	687b      	ldr	r3, [r7, #4]
    c34a:	2200      	movs	r2, #0
    c34c:	729a      	strb	r2, [r3, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    c34e:	687b      	ldr	r3, [r7, #4]
    c350:	2200      	movs	r2, #0
    c352:	72da      	strb	r2, [r3, #11]
	config->baudrate         = 9600;
    c354:	687b      	ldr	r3, [r7, #4]
    c356:	2296      	movs	r2, #150	; 0x96
    c358:	0192      	lsls	r2, r2, #6
    c35a:	621a      	str	r2, [r3, #32]
	config->receiver_enable  = true;
    c35c:	687b      	ldr	r3, [r7, #4]
    c35e:	2224      	movs	r2, #36	; 0x24
    c360:	2101      	movs	r1, #1
    c362:	5499      	strb	r1, [r3, r2]
	config->transmitter_enable = true;
    c364:	687b      	ldr	r3, [r7, #4]
    c366:	2225      	movs	r2, #37	; 0x25
    c368:	2101      	movs	r1, #1
    c36a:	5499      	strb	r1, [r3, r2]
	config->clock_polarity_inverted = false;
    c36c:	687b      	ldr	r3, [r7, #4]
    c36e:	2226      	movs	r2, #38	; 0x26
    c370:	2100      	movs	r1, #0
    c372:	5499      	strb	r1, [r3, r2]
	config->use_external_clock = false;
    c374:	687b      	ldr	r3, [r7, #4]
    c376:	2227      	movs	r2, #39	; 0x27
    c378:	2100      	movs	r1, #0
    c37a:	5499      	strb	r1, [r3, r2]
	config->ext_clock_freq   = 0;
    c37c:	687b      	ldr	r3, [r7, #4]
    c37e:	2200      	movs	r2, #0
    c380:	629a      	str	r2, [r3, #40]	; 0x28
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
    c382:	687b      	ldr	r3, [r7, #4]
    c384:	2288      	movs	r2, #136	; 0x88
    c386:	0352      	lsls	r2, r2, #13
    c388:	60da      	str	r2, [r3, #12]
	config->run_in_standby   = false;
    c38a:	687b      	ldr	r3, [r7, #4]
    c38c:	222c      	movs	r2, #44	; 0x2c
    c38e:	2100      	movs	r1, #0
    c390:	5499      	strb	r1, [r3, r2]
	config->generator_source = GCLK_GENERATOR_0;
    c392:	687b      	ldr	r3, [r7, #4]
    c394:	222d      	movs	r2, #45	; 0x2d
    c396:	2100      	movs	r1, #0
    c398:	5499      	strb	r1, [r3, r2]
	config->pinmux_pad0      = PINMUX_DEFAULT;
    c39a:	687b      	ldr	r3, [r7, #4]
    c39c:	2200      	movs	r2, #0
    c39e:	631a      	str	r2, [r3, #48]	; 0x30
	config->pinmux_pad1      = PINMUX_DEFAULT;
    c3a0:	687b      	ldr	r3, [r7, #4]
    c3a2:	2200      	movs	r2, #0
    c3a4:	635a      	str	r2, [r3, #52]	; 0x34
	config->pinmux_pad2      = PINMUX_DEFAULT;
    c3a6:	687b      	ldr	r3, [r7, #4]
    c3a8:	2200      	movs	r2, #0
    c3aa:	639a      	str	r2, [r3, #56]	; 0x38
	config->pinmux_pad3      = PINMUX_DEFAULT;
    c3ac:	687b      	ldr	r3, [r7, #4]
    c3ae:	2200      	movs	r2, #0
    c3b0:	63da      	str	r2, [r3, #60]	; 0x3c
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    c3b2:	687b      	ldr	r3, [r7, #4]
    c3b4:	2200      	movs	r2, #0
    c3b6:	615a      	str	r2, [r3, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    c3b8:	687b      	ldr	r3, [r7, #4]
    c3ba:	2200      	movs	r2, #0
    c3bc:	821a      	strh	r2, [r3, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    c3be:	687b      	ldr	r3, [r7, #4]
    c3c0:	2200      	movs	r2, #0
    c3c2:	76da      	strb	r2, [r3, #27]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    c3c4:	687b      	ldr	r3, [r7, #4]
    c3c6:	2200      	movs	r2, #0
    c3c8:	761a      	strb	r2, [r3, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    c3ca:	687b      	ldr	r3, [r7, #4]
    c3cc:	2200      	movs	r2, #0
    c3ce:	771a      	strb	r2, [r3, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    c3d0:	687b      	ldr	r3, [r7, #4]
    c3d2:	2200      	movs	r2, #0
    c3d4:	765a      	strb	r2, [r3, #25]
	config->receive_pulse_length                    = 19;
    c3d6:	687b      	ldr	r3, [r7, #4]
    c3d8:	2213      	movs	r2, #19
    c3da:	769a      	strb	r2, [r3, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    c3dc:	687b      	ldr	r3, [r7, #4]
    c3de:	2200      	movs	r2, #0
    c3e0:	775a      	strb	r2, [r3, #29]
#endif
#ifdef FEATURE_USART_RS485
	config->rs485_guard_time = RS485_GUARD_TIME_0_BIT;
#endif
}
    c3e2:	46c0      	nop			; (mov r8, r8)
    c3e4:	46bd      	mov	sp, r7
    c3e6:	b002      	add	sp, #8
    c3e8:	bd80      	pop	{r7, pc}
    c3ea:	46c0      	nop			; (mov r8, r8)

0000c3ec <usart_enable>:
 *
 * \param[in]  module  Pointer to USART software instance struct
 */
static inline void usart_enable(
		const struct usart_module *const module)
{
    c3ec:	b580      	push	{r7, lr}
    c3ee:	b084      	sub	sp, #16
    c3f0:	af00      	add	r7, sp, #0
    c3f2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    c3f4:	687b      	ldr	r3, [r7, #4]
    c3f6:	681b      	ldr	r3, [r3, #0]
    c3f8:	60fb      	str	r3, [r7, #12]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    c3fa:	687b      	ldr	r3, [r7, #4]
    c3fc:	681b      	ldr	r3, [r3, #0]
    c3fe:	0018      	movs	r0, r3
    c400:	4b09      	ldr	r3, [pc, #36]	; (c428 <usart_enable+0x3c>)
    c402:	4798      	blx	r3
    c404:	0003      	movs	r3, r0
    c406:	0018      	movs	r0, r3
    c408:	4b08      	ldr	r3, [pc, #32]	; (c42c <usart_enable+0x40>)
    c40a:	4798      	blx	r3
	//system_interrupt_set_priority(_sercom_get_interrupt_vector(module->hw),SYSTEM_INTERRUPT_PRIORITY_LEVEL_3);
#endif

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);
    c40c:	687b      	ldr	r3, [r7, #4]
    c40e:	0018      	movs	r0, r3
    c410:	4b07      	ldr	r3, [pc, #28]	; (c430 <usart_enable+0x44>)
    c412:	4798      	blx	r3

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    c414:	68fb      	ldr	r3, [r7, #12]
    c416:	681b      	ldr	r3, [r3, #0]
    c418:	2202      	movs	r2, #2
    c41a:	431a      	orrs	r2, r3
    c41c:	68fb      	ldr	r3, [r7, #12]
    c41e:	601a      	str	r2, [r3, #0]
}
    c420:	46c0      	nop			; (mov r8, r8)
    c422:	46bd      	mov	sp, r7
    c424:	b004      	add	sp, #16
    c426:	bd80      	pop	{r7, pc}
    c428:	00014119 	.word	0x00014119
    c42c:	0000c1c9 	.word	0x0000c1c9
    c430:	0000c309 	.word	0x0000c309

0000c434 <usart_enable_callback>:
 * \param[in]  callback_type  Callback type given by an enum
 */
static inline void usart_enable_callback(
		struct usart_module *const module,
		enum usart_callback callback_type)
{
    c434:	b580      	push	{r7, lr}
    c436:	b082      	sub	sp, #8
    c438:	af00      	add	r7, sp, #0
    c43a:	6078      	str	r0, [r7, #4]
    c43c:	000a      	movs	r2, r1
    c43e:	1cfb      	adds	r3, r7, #3
    c440:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);

	/* Enable callback */
	module->callback_enable_mask |= (1 << callback_type);
    c442:	687b      	ldr	r3, [r7, #4]
    c444:	2231      	movs	r2, #49	; 0x31
    c446:	5c9b      	ldrb	r3, [r3, r2]
    c448:	b25a      	sxtb	r2, r3
    c44a:	1cfb      	adds	r3, r7, #3
    c44c:	781b      	ldrb	r3, [r3, #0]
    c44e:	2101      	movs	r1, #1
    c450:	4099      	lsls	r1, r3
    c452:	000b      	movs	r3, r1
    c454:	b25b      	sxtb	r3, r3
    c456:	4313      	orrs	r3, r2
    c458:	b25b      	sxtb	r3, r3
    c45a:	b2d9      	uxtb	r1, r3
    c45c:	687b      	ldr	r3, [r7, #4]
    c45e:	2231      	movs	r2, #49	; 0x31
    c460:	5499      	strb	r1, [r3, r2]

}
    c462:	46c0      	nop			; (mov r8, r8)
    c464:	46bd      	mov	sp, r7
    c466:	b002      	add	sp, #8
    c468:	bd80      	pop	{r7, pc}
    c46a:	46c0      	nop			; (mov r8, r8)

0000c46c <usart_disable_callback>:
 * \param[in]  callback_type  Callback type given by an enum
 */
static inline void usart_disable_callback(
		struct usart_module *const module,
		enum usart_callback callback_type)
{
    c46c:	b580      	push	{r7, lr}
    c46e:	b082      	sub	sp, #8
    c470:	af00      	add	r7, sp, #0
    c472:	6078      	str	r0, [r7, #4]
    c474:	000a      	movs	r2, r1
    c476:	1cfb      	adds	r3, r7, #3
    c478:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);

	/* Disable callback */
	module->callback_enable_mask &= ~(1 << callback_type);
    c47a:	687b      	ldr	r3, [r7, #4]
    c47c:	2231      	movs	r2, #49	; 0x31
    c47e:	5c9b      	ldrb	r3, [r3, r2]
    c480:	b25b      	sxtb	r3, r3
    c482:	1cfa      	adds	r2, r7, #3
    c484:	7812      	ldrb	r2, [r2, #0]
    c486:	2101      	movs	r1, #1
    c488:	4091      	lsls	r1, r2
    c48a:	000a      	movs	r2, r1
    c48c:	b252      	sxtb	r2, r2
    c48e:	43d2      	mvns	r2, r2
    c490:	b252      	sxtb	r2, r2
    c492:	4013      	ands	r3, r2
    c494:	b25b      	sxtb	r3, r3
    c496:	b2d9      	uxtb	r1, r3
    c498:	687b      	ldr	r3, [r7, #4]
    c49a:	2231      	movs	r2, #49	; 0x31
    c49c:	5499      	strb	r1, [r3, r2]
}
    c49e:	46c0      	nop			; (mov r8, r8)
    c4a0:	46bd      	mov	sp, r7
    c4a2:	b002      	add	sp, #8
    c4a4:	bd80      	pop	{r7, pc}
    c4a6:	46c0      	nop			; (mov r8, r8)

0000c4a8 <ucGetBytes>:
void usart_received_callback(struct usart_module *const );

///////////////////////////////////////////////////////////////////////////////////////////////////////

static uint8_t ucGetBytes(uint8_t ucStr[])
{
    c4a8:	b580      	push	{r7, lr}
    c4aa:	b084      	sub	sp, #16
    c4ac:	af00      	add	r7, sp, #0
    c4ae:	6078      	str	r0, [r7, #4]
 uint8_t ucTemp=0x00;
    c4b0:	230f      	movs	r3, #15
    c4b2:	18fb      	adds	r3, r7, r3
    c4b4:	2200      	movs	r2, #0
    c4b6:	701a      	strb	r2, [r3, #0]
 
 if (ucStr[0]<=0x39) ucTemp=ucStr[0]-0x30;
    c4b8:	687b      	ldr	r3, [r7, #4]
    c4ba:	781b      	ldrb	r3, [r3, #0]
    c4bc:	2b39      	cmp	r3, #57	; 0x39
    c4be:	d806      	bhi.n	c4ce <ucGetBytes+0x26>
    c4c0:	687b      	ldr	r3, [r7, #4]
    c4c2:	781a      	ldrb	r2, [r3, #0]
    c4c4:	230f      	movs	r3, #15
    c4c6:	18fb      	adds	r3, r7, r3
    c4c8:	3a30      	subs	r2, #48	; 0x30
    c4ca:	701a      	strb	r2, [r3, #0]
    c4cc:	e005      	b.n	c4da <ucGetBytes+0x32>
 else ucTemp=ucStr[0]-0x37;
    c4ce:	687b      	ldr	r3, [r7, #4]
    c4d0:	781a      	ldrb	r2, [r3, #0]
    c4d2:	230f      	movs	r3, #15
    c4d4:	18fb      	adds	r3, r7, r3
    c4d6:	3a37      	subs	r2, #55	; 0x37
    c4d8:	701a      	strb	r2, [r3, #0]
 
 if (ucStr[1]<=0x39) ucTemp|=(ucStr[1]-0x30)<<4;
    c4da:	687b      	ldr	r3, [r7, #4]
    c4dc:	3301      	adds	r3, #1
    c4de:	781b      	ldrb	r3, [r3, #0]
    c4e0:	2b39      	cmp	r3, #57	; 0x39
    c4e2:	d80f      	bhi.n	c504 <ucGetBytes+0x5c>
    c4e4:	687b      	ldr	r3, [r7, #4]
    c4e6:	3301      	adds	r3, #1
    c4e8:	781b      	ldrb	r3, [r3, #0]
    c4ea:	3b30      	subs	r3, #48	; 0x30
    c4ec:	011b      	lsls	r3, r3, #4
    c4ee:	b25a      	sxtb	r2, r3
    c4f0:	230f      	movs	r3, #15
    c4f2:	18fb      	adds	r3, r7, r3
    c4f4:	781b      	ldrb	r3, [r3, #0]
    c4f6:	b25b      	sxtb	r3, r3
    c4f8:	4313      	orrs	r3, r2
    c4fa:	b25a      	sxtb	r2, r3
    c4fc:	230f      	movs	r3, #15
    c4fe:	18fb      	adds	r3, r7, r3
    c500:	701a      	strb	r2, [r3, #0]
    c502:	e00e      	b.n	c522 <ucGetBytes+0x7a>
 else ucTemp|=(ucStr[1]-0x37)<<4;
    c504:	687b      	ldr	r3, [r7, #4]
    c506:	3301      	adds	r3, #1
    c508:	781b      	ldrb	r3, [r3, #0]
    c50a:	3b37      	subs	r3, #55	; 0x37
    c50c:	011b      	lsls	r3, r3, #4
    c50e:	b25a      	sxtb	r2, r3
    c510:	230f      	movs	r3, #15
    c512:	18fb      	adds	r3, r7, r3
    c514:	781b      	ldrb	r3, [r3, #0]
    c516:	b25b      	sxtb	r3, r3
    c518:	4313      	orrs	r3, r2
    c51a:	b25a      	sxtb	r2, r3
    c51c:	230f      	movs	r3, #15
    c51e:	18fb      	adds	r3, r7, r3
    c520:	701a      	strb	r2, [r3, #0]
 
 return ucTemp;
    c522:	230f      	movs	r3, #15
    c524:	18fb      	adds	r3, r7, r3
    c526:	781b      	ldrb	r3, [r3, #0]
}
    c528:	0018      	movs	r0, r3
    c52a:	46bd      	mov	sp, r7
    c52c:	b004      	add	sp, #16
    c52e:	bd80      	pop	{r7, pc}

0000c530 <usart_received_callback>:

/////////////////////////////////////////////////////////////////////////////////////////////////////// 

void usart_received_callback(struct usart_module *const usart_module)
{
    c530:	b590      	push	{r4, r7, lr}
    c532:	b085      	sub	sp, #20
    c534:	af00      	add	r7, sp, #0
    c536:	6078      	str	r0, [r7, #4]
	
	if (!xStart)
    c538:	4b3f      	ldr	r3, [pc, #252]	; (c638 <usart_received_callback+0x108>)
    c53a:	781b      	ldrb	r3, [r3, #0]
    c53c:	2201      	movs	r2, #1
    c53e:	4053      	eors	r3, r2
    c540:	b2db      	uxtb	r3, r3
    c542:	2b00      	cmp	r3, #0
    c544:	d00a      	beq.n	c55c <usart_received_callback+0x2c>
	{
	 if (usRxBuffer==0x02) {xStart=true;ucBufferPointer=0x00;}
    c546:	4b3d      	ldr	r3, [pc, #244]	; (c63c <usart_received_callback+0x10c>)
    c548:	881b      	ldrh	r3, [r3, #0]
    c54a:	2b02      	cmp	r3, #2
    c54c:	d16a      	bne.n	c624 <usart_received_callback+0xf4>
    c54e:	4b3a      	ldr	r3, [pc, #232]	; (c638 <usart_received_callback+0x108>)
    c550:	2201      	movs	r2, #1
    c552:	701a      	strb	r2, [r3, #0]
    c554:	4b3a      	ldr	r3, [pc, #232]	; (c640 <usart_received_callback+0x110>)
    c556:	2200      	movs	r2, #0
    c558:	701a      	strb	r2, [r3, #0]
    c55a:	e063      	b.n	c624 <usart_received_callback+0xf4>
	}
	else
	{
	 if (usRxBuffer==0x03)
    c55c:	4b37      	ldr	r3, [pc, #220]	; (c63c <usart_received_callback+0x10c>)
    c55e:	881b      	ldrh	r3, [r3, #0]
    c560:	2b03      	cmp	r3, #3
    c562:	d14f      	bne.n	c604 <usart_received_callback+0xd4>
	 {
	  xStart=false;
    c564:	4b34      	ldr	r3, [pc, #208]	; (c638 <usart_received_callback+0x108>)
    c566:	2200      	movs	r2, #0
    c568:	701a      	strb	r2, [r3, #0]
	  uint8_t ucChecksum=0x00;
    c56a:	230f      	movs	r3, #15
    c56c:	18fb      	adds	r3, r7, r3
    c56e:	2200      	movs	r2, #0
    c570:	701a      	strb	r2, [r3, #0]
	  for (uint8_t ucIndex=0x00;ucIndex<0x05;ucIndex++)
    c572:	230e      	movs	r3, #14
    c574:	18fb      	adds	r3, r7, r3
    c576:	2200      	movs	r2, #0
    c578:	701a      	strb	r2, [r3, #0]
    c57a:	e025      	b.n	c5c8 <usart_received_callback+0x98>
	  {
	   uint8_t ucTemp=ucGetBytes(&rdm_buffer[ucIndex<<1]);
    c57c:	230e      	movs	r3, #14
    c57e:	18fb      	adds	r3, r7, r3
    c580:	781b      	ldrb	r3, [r3, #0]
    c582:	005a      	lsls	r2, r3, #1
    c584:	4b2f      	ldr	r3, [pc, #188]	; (c644 <usart_received_callback+0x114>)
    c586:	18d3      	adds	r3, r2, r3
    c588:	220d      	movs	r2, #13
    c58a:	18bc      	adds	r4, r7, r2
    c58c:	0018      	movs	r0, r3
    c58e:	4b2e      	ldr	r3, [pc, #184]	; (c648 <usart_received_callback+0x118>)
    c590:	4798      	blx	r3
    c592:	0003      	movs	r3, r0
    c594:	7023      	strb	r3, [r4, #0]
	   ucChecksum ^= ucTemp;
    c596:	230f      	movs	r3, #15
    c598:	18fb      	adds	r3, r7, r3
    c59a:	220f      	movs	r2, #15
    c59c:	18b9      	adds	r1, r7, r2
    c59e:	220d      	movs	r2, #13
    c5a0:	18ba      	adds	r2, r7, r2
    c5a2:	7809      	ldrb	r1, [r1, #0]
    c5a4:	7812      	ldrb	r2, [r2, #0]
    c5a6:	404a      	eors	r2, r1
    c5a8:	701a      	strb	r2, [r3, #0]
	   rdm_buffer[ucIndex]=ucTemp;
    c5aa:	230e      	movs	r3, #14
    c5ac:	18fb      	adds	r3, r7, r3
    c5ae:	781b      	ldrb	r3, [r3, #0]
    c5b0:	4a24      	ldr	r2, [pc, #144]	; (c644 <usart_received_callback+0x114>)
    c5b2:	210d      	movs	r1, #13
    c5b4:	1879      	adds	r1, r7, r1
    c5b6:	7809      	ldrb	r1, [r1, #0]
    c5b8:	54d1      	strb	r1, [r2, r3]
	{
	 if (usRxBuffer==0x03)
	 {
	  xStart=false;
	  uint8_t ucChecksum=0x00;
	  for (uint8_t ucIndex=0x00;ucIndex<0x05;ucIndex++)
    c5ba:	230e      	movs	r3, #14
    c5bc:	18fb      	adds	r3, r7, r3
    c5be:	781a      	ldrb	r2, [r3, #0]
    c5c0:	230e      	movs	r3, #14
    c5c2:	18fb      	adds	r3, r7, r3
    c5c4:	3201      	adds	r2, #1
    c5c6:	701a      	strb	r2, [r3, #0]
    c5c8:	230e      	movs	r3, #14
    c5ca:	18fb      	adds	r3, r7, r3
    c5cc:	781b      	ldrb	r3, [r3, #0]
    c5ce:	2b04      	cmp	r3, #4
    c5d0:	d9d4      	bls.n	c57c <usart_received_callback+0x4c>
	  {
	   uint8_t ucTemp=ucGetBytes(&rdm_buffer[ucIndex<<1]);
	   ucChecksum ^= ucTemp;
	   rdm_buffer[ucIndex]=ucTemp;
	  }
	  if (ucChecksum==ucGetBytes(&rdm_buffer[0x0A])) 
    c5d2:	4b1e      	ldr	r3, [pc, #120]	; (c64c <usart_received_callback+0x11c>)
    c5d4:	0018      	movs	r0, r3
    c5d6:	4b1c      	ldr	r3, [pc, #112]	; (c648 <usart_received_callback+0x118>)
    c5d8:	4798      	blx	r3
    c5da:	0003      	movs	r3, r0
    c5dc:	001a      	movs	r2, r3
    c5de:	230f      	movs	r3, #15
    c5e0:	18fb      	adds	r3, r7, r3
    c5e2:	781b      	ldrb	r3, [r3, #0]
    c5e4:	4293      	cmp	r3, r2
    c5e6:	d11d      	bne.n	c624 <usart_received_callback+0xf4>
	  {
	   xTagRECV=true;
    c5e8:	4b19      	ldr	r3, [pc, #100]	; (c650 <usart_received_callback+0x120>)
    c5ea:	2201      	movs	r2, #1
    c5ec:	701a      	strb	r2, [r3, #0]
	   usart_disable_callback(&usart_instance,USART_CALLBACK_BUFFER_RECEIVED); 
    c5ee:	4b19      	ldr	r3, [pc, #100]	; (c654 <usart_received_callback+0x124>)
    c5f0:	2101      	movs	r1, #1
    c5f2:	0018      	movs	r0, r3
    c5f4:	4b18      	ldr	r3, [pc, #96]	; (c658 <usart_received_callback+0x128>)
    c5f6:	4798      	blx	r3
	   xTaskAbortDelay(xRFIDTask);
    c5f8:	4b18      	ldr	r3, [pc, #96]	; (c65c <usart_received_callback+0x12c>)
    c5fa:	681b      	ldr	r3, [r3, #0]
    c5fc:	0018      	movs	r0, r3
    c5fe:	4b18      	ldr	r3, [pc, #96]	; (c660 <usart_received_callback+0x130>)
    c600:	4798      	blx	r3
    c602:	e00f      	b.n	c624 <usart_received_callback+0xf4>
	  }
	 }
	 else if (ucBufferPointer<RDM_BUFFER) rdm_buffer[ucBufferPointer++]=usRxBuffer;
    c604:	4b0e      	ldr	r3, [pc, #56]	; (c640 <usart_received_callback+0x110>)
    c606:	781b      	ldrb	r3, [r3, #0]
    c608:	2b13      	cmp	r3, #19
    c60a:	d80b      	bhi.n	c624 <usart_received_callback+0xf4>
    c60c:	4b0c      	ldr	r3, [pc, #48]	; (c640 <usart_received_callback+0x110>)
    c60e:	781b      	ldrb	r3, [r3, #0]
    c610:	1c5a      	adds	r2, r3, #1
    c612:	b2d1      	uxtb	r1, r2
    c614:	4a0a      	ldr	r2, [pc, #40]	; (c640 <usart_received_callback+0x110>)
    c616:	7011      	strb	r1, [r2, #0]
    c618:	001a      	movs	r2, r3
    c61a:	4b08      	ldr	r3, [pc, #32]	; (c63c <usart_received_callback+0x10c>)
    c61c:	881b      	ldrh	r3, [r3, #0]
    c61e:	b2d9      	uxtb	r1, r3
    c620:	4b08      	ldr	r3, [pc, #32]	; (c644 <usart_received_callback+0x114>)
    c622:	5499      	strb	r1, [r3, r2]
	}
	
	usart_read_job(usart_module,&usRxBuffer);
    c624:	4a05      	ldr	r2, [pc, #20]	; (c63c <usart_received_callback+0x10c>)
    c626:	687b      	ldr	r3, [r7, #4]
    c628:	0011      	movs	r1, r2
    c62a:	0018      	movs	r0, r3
    c62c:	4b0d      	ldr	r3, [pc, #52]	; (c664 <usart_received_callback+0x134>)
    c62e:	4798      	blx	r3
		
}
    c630:	46c0      	nop			; (mov r8, r8)
    c632:	46bd      	mov	sp, r7
    c634:	b005      	add	sp, #20
    c636:	bd90      	pop	{r4, r7, pc}
    c638:	200046e4 	.word	0x200046e4
    c63c:	200049e4 	.word	0x200049e4
    c640:	20004499 	.word	0x20004499
    c644:	20003dfc 	.word	0x20003dfc
    c648:	0000c4a9 	.word	0x0000c4a9
    c64c:	20003e06 	.word	0x20003e06
    c650:	20004a64 	.word	0x20004a64
    c654:	20003e14 	.word	0x20003e14
    c658:	0000c46d 	.word	0x0000c46d
    c65c:	20004a34 	.word	0x20004a34
    c660:	000106a1 	.word	0x000106a1
    c664:	000159cd 	.word	0x000159cd

0000c668 <vInitRDM6300>:

///////////////////////////////////////////////////////////////////////

void vInitRDM6300(void)
{
    c668:	b580      	push	{r7, lr}
    c66a:	b090      	sub	sp, #64	; 0x40
    c66c:	af00      	add	r7, sp, #0
	struct usart_config config_usart;
	usart_get_config_defaults(&config_usart);
    c66e:	003b      	movs	r3, r7
    c670:	0018      	movs	r0, r3
    c672:	4b1f      	ldr	r3, [pc, #124]	; (c6f0 <vInitRDM6300+0x88>)
    c674:	4798      	blx	r3
	config_usart.baudrate = 9600;
    c676:	003b      	movs	r3, r7
    c678:	2296      	movs	r2, #150	; 0x96
    c67a:	0192      	lsls	r2, r2, #6
    c67c:	621a      	str	r2, [r3, #32]
	config_usart.data_order  = USART_DATAORDER_LSB;
    c67e:	003b      	movs	r3, r7
    c680:	2280      	movs	r2, #128	; 0x80
    c682:	05d2      	lsls	r2, r2, #23
    c684:	601a      	str	r2, [r3, #0]
	config_usart.parity = USART_PARITY_NONE;
    c686:	003b      	movs	r3, r7
    c688:	22ff      	movs	r2, #255	; 0xff
    c68a:	811a      	strh	r2, [r3, #8]
	config_usart.stopbits = USART_STOPBITS_1;
    c68c:	003b      	movs	r3, r7
    c68e:	2200      	movs	r2, #0
    c690:	729a      	strb	r2, [r3, #10]
	config_usart.mux_setting = USART_RX_3_TX_0_XCK_1;
    c692:	003b      	movs	r3, r7
    c694:	22c0      	movs	r2, #192	; 0xc0
    c696:	0392      	lsls	r2, r2, #14
    c698:	60da      	str	r2, [r3, #12]
	config_usart.pinmux_pad0 = PINMUX_UNUSED;
    c69a:	003b      	movs	r3, r7
    c69c:	2201      	movs	r2, #1
    c69e:	4252      	negs	r2, r2
    c6a0:	631a      	str	r2, [r3, #48]	; 0x30
	config_usart.pinmux_pad1 = PINMUX_UNUSED;
    c6a2:	003b      	movs	r3, r7
    c6a4:	2201      	movs	r2, #1
    c6a6:	4252      	negs	r2, r2
    c6a8:	635a      	str	r2, [r3, #52]	; 0x34
	config_usart.pinmux_pad2 = PINMUX_UNUSED;
    c6aa:	003b      	movs	r3, r7
    c6ac:	2201      	movs	r2, #1
    c6ae:	4252      	negs	r2, r2
    c6b0:	639a      	str	r2, [r3, #56]	; 0x38
	config_usart.pinmux_pad3 = PINMUX_PB11D_SERCOM4_PAD3;
    c6b2:	003b      	movs	r3, r7
    c6b4:	4a0f      	ldr	r2, [pc, #60]	; (c6f4 <vInitRDM6300+0x8c>)
    c6b6:	63da      	str	r2, [r3, #60]	; 0x3c
	while (usart_init(&usart_instance,
    c6b8:	46c0      	nop			; (mov r8, r8)
    c6ba:	003a      	movs	r2, r7
    c6bc:	490e      	ldr	r1, [pc, #56]	; (c6f8 <vInitRDM6300+0x90>)
    c6be:	4b0f      	ldr	r3, [pc, #60]	; (c6fc <vInitRDM6300+0x94>)
    c6c0:	0018      	movs	r0, r3
    c6c2:	4b0f      	ldr	r3, [pc, #60]	; (c700 <vInitRDM6300+0x98>)
    c6c4:	4798      	blx	r3
    c6c6:	1e03      	subs	r3, r0, #0
    c6c8:	d1f7      	bne.n	c6ba <vInitRDM6300+0x52>
	SERCOM4, &config_usart) != STATUS_OK) {};
    usart_enable(&usart_instance);
    c6ca:	4b0c      	ldr	r3, [pc, #48]	; (c6fc <vInitRDM6300+0x94>)
    c6cc:	0018      	movs	r0, r3
    c6ce:	4b0d      	ldr	r3, [pc, #52]	; (c704 <vInitRDM6300+0x9c>)
    c6d0:	4798      	blx	r3
	
	usart_register_callback(&usart_instance,usart_received_callback, USART_CALLBACK_BUFFER_RECEIVED);
    c6d2:	490d      	ldr	r1, [pc, #52]	; (c708 <vInitRDM6300+0xa0>)
    c6d4:	4b09      	ldr	r3, [pc, #36]	; (c6fc <vInitRDM6300+0x94>)
    c6d6:	2201      	movs	r2, #1
    c6d8:	0018      	movs	r0, r3
    c6da:	4b0c      	ldr	r3, [pc, #48]	; (c70c <vInitRDM6300+0xa4>)
    c6dc:	4798      	blx	r3
	usart_disable_callback(&usart_instance,USART_CALLBACK_BUFFER_RECEIVED);
    c6de:	4b07      	ldr	r3, [pc, #28]	; (c6fc <vInitRDM6300+0x94>)
    c6e0:	2101      	movs	r1, #1
    c6e2:	0018      	movs	r0, r3
    c6e4:	4b0a      	ldr	r3, [pc, #40]	; (c710 <vInitRDM6300+0xa8>)
    c6e6:	4798      	blx	r3
	
	//ucBufferPointer=0x00;
	//xStart=false;xTagRECV=false;
    //usart_read_job(&usart_instance,&usRxBuffer);
		
}
    c6e8:	46c0      	nop			; (mov r8, r8)
    c6ea:	46bd      	mov	sp, r7
    c6ec:	b010      	add	sp, #64	; 0x40
    c6ee:	bd80      	pop	{r7, pc}
    c6f0:	0000c32d 	.word	0x0000c32d
    c6f4:	002b0003 	.word	0x002b0003
    c6f8:	42001800 	.word	0x42001800
    c6fc:	20003e14 	.word	0x20003e14
    c700:	0001562d 	.word	0x0001562d
    c704:	0000c3ed 	.word	0x0000c3ed
    c708:	0000c531 	.word	0x0000c531
    c70c:	00015985 	.word	0x00015985
    c710:	0000c46d 	.word	0x0000c46d

0000c714 <vCreateRFIDTask>:

///////////////////////////////////////////////////////////////////////

void vCreateRFIDTask(void)
{
    c714:	b590      	push	{r4, r7, lr}
    c716:	b083      	sub	sp, #12
    c718:	af02      	add	r7, sp, #8
 xTaskCreate(RFID_task,(const char *)"RFID",configMINIMAL_STACK_SIZE,NULL, RFID_TASK_PRIORITY,&xRFIDTask);
    c71a:	4907      	ldr	r1, [pc, #28]	; (c738 <vCreateRFIDTask+0x24>)
    c71c:	4807      	ldr	r0, [pc, #28]	; (c73c <vCreateRFIDTask+0x28>)
    c71e:	4b08      	ldr	r3, [pc, #32]	; (c740 <vCreateRFIDTask+0x2c>)
    c720:	9301      	str	r3, [sp, #4]
    c722:	2301      	movs	r3, #1
    c724:	9300      	str	r3, [sp, #0]
    c726:	2300      	movs	r3, #0
    c728:	22c8      	movs	r2, #200	; 0xc8
    c72a:	4c06      	ldr	r4, [pc, #24]	; (c744 <vCreateRFIDTask+0x30>)
    c72c:	47a0      	blx	r4
}
    c72e:	46c0      	nop			; (mov r8, r8)
    c730:	46bd      	mov	sp, r7
    c732:	b001      	add	sp, #4
    c734:	bd90      	pop	{r4, r7, pc}
    c736:	46c0      	nop			; (mov r8, r8)
    c738:	00020dc8 	.word	0x00020dc8
    c73c:	0000c749 	.word	0x0000c749
    c740:	20004a34 	.word	0x20004a34
    c744:	0000ff91 	.word	0x0000ff91

0000c748 <RFID_task>:

///////////////////////////////////////////////////////////////////////

static void RFID_task(void *params)
{
    c748:	b580      	push	{r7, lr}
    c74a:	b084      	sub	sp, #16
    c74c:	af00      	add	r7, sp, #0
    c74e:	6078      	str	r0, [r7, #4]
 
  vTaskSuspend(NULL);
    c750:	2000      	movs	r0, #0
    c752:	4b28      	ldr	r3, [pc, #160]	; (c7f4 <RFID_task+0xac>)
    c754:	4798      	blx	r3
  
  for (;;)	
  {
   xStart=false;ucBufferPointer=0x00;xTagRECV=false;
    c756:	4b28      	ldr	r3, [pc, #160]	; (c7f8 <RFID_task+0xb0>)
    c758:	2200      	movs	r2, #0
    c75a:	701a      	strb	r2, [r3, #0]
    c75c:	4b27      	ldr	r3, [pc, #156]	; (c7fc <RFID_task+0xb4>)
    c75e:	2200      	movs	r2, #0
    c760:	701a      	strb	r2, [r3, #0]
    c762:	4b27      	ldr	r3, [pc, #156]	; (c800 <RFID_task+0xb8>)
    c764:	2200      	movs	r2, #0
    c766:	701a      	strb	r2, [r3, #0]
   usart_enable_callback(&usart_instance,USART_CALLBACK_BUFFER_RECEIVED);  
    c768:	4b26      	ldr	r3, [pc, #152]	; (c804 <RFID_task+0xbc>)
    c76a:	2101      	movs	r1, #1
    c76c:	0018      	movs	r0, r3
    c76e:	4b26      	ldr	r3, [pc, #152]	; (c808 <RFID_task+0xc0>)
    c770:	4798      	blx	r3
   usart_read_job(&usart_instance,&usRxBuffer);  
    c772:	4a26      	ldr	r2, [pc, #152]	; (c80c <RFID_task+0xc4>)
    c774:	4b23      	ldr	r3, [pc, #140]	; (c804 <RFID_task+0xbc>)
    c776:	0011      	movs	r1, r2
    c778:	0018      	movs	r0, r3
    c77a:	4b25      	ldr	r3, [pc, #148]	; (c810 <RFID_task+0xc8>)
    c77c:	4798      	blx	r3
   vTaskDelay(TASK_DELAY_MS(1000));
    c77e:	23fa      	movs	r3, #250	; 0xfa
    c780:	009b      	lsls	r3, r3, #2
    c782:	0018      	movs	r0, r3
    c784:	4b23      	ldr	r3, [pc, #140]	; (c814 <RFID_task+0xcc>)
    c786:	4798      	blx	r3
   if (xTagRECV) 
    c788:	4b1d      	ldr	r3, [pc, #116]	; (c800 <RFID_task+0xb8>)
    c78a:	781b      	ldrb	r3, [r3, #0]
    c78c:	2b00      	cmp	r3, #0
    c78e:	d02c      	beq.n	c7ea <RFID_task+0xa2>
   {
	xValidTAG=false;
    c790:	4b21      	ldr	r3, [pc, #132]	; (c818 <RFID_task+0xd0>)
    c792:	2200      	movs	r2, #0
    c794:	701a      	strb	r2, [r3, #0]
	for (uint8_t ucIndex=0x00;ucIndex<MAX_TAGS;ucIndex++)
    c796:	230f      	movs	r3, #15
    c798:	18fb      	adds	r3, r7, r3
    c79a:	2200      	movs	r2, #0
    c79c:	701a      	strb	r2, [r3, #0]
    c79e:	e019      	b.n	c7d4 <RFID_task+0x8c>
	{
	 if (!memcmp(&xTags[ucIndex].ucTag,rdm_buffer,5))
    c7a0:	230f      	movs	r3, #15
    c7a2:	18fb      	adds	r3, r7, r3
    c7a4:	781a      	ldrb	r2, [r3, #0]
    c7a6:	0013      	movs	r3, r2
    c7a8:	00db      	lsls	r3, r3, #3
    c7aa:	189b      	adds	r3, r3, r2
    c7ac:	4a1b      	ldr	r2, [pc, #108]	; (c81c <RFID_task+0xd4>)
    c7ae:	189b      	adds	r3, r3, r2
    c7b0:	491b      	ldr	r1, [pc, #108]	; (c820 <RFID_task+0xd8>)
    c7b2:	2205      	movs	r2, #5
    c7b4:	0018      	movs	r0, r3
    c7b6:	4b1b      	ldr	r3, [pc, #108]	; (c824 <RFID_task+0xdc>)
    c7b8:	4798      	blx	r3
    c7ba:	1e03      	subs	r3, r0, #0
    c7bc:	d103      	bne.n	c7c6 <RFID_task+0x7e>
	 {
	  xValidTAG=true;
    c7be:	4b16      	ldr	r3, [pc, #88]	; (c818 <RFID_task+0xd0>)
    c7c0:	2201      	movs	r2, #1
    c7c2:	701a      	strb	r2, [r3, #0]
	  break;	 
    c7c4:	e00b      	b.n	c7de <RFID_task+0x96>
   usart_read_job(&usart_instance,&usRxBuffer);  
   vTaskDelay(TASK_DELAY_MS(1000));
   if (xTagRECV) 
   {
	xValidTAG=false;
	for (uint8_t ucIndex=0x00;ucIndex<MAX_TAGS;ucIndex++)
    c7c6:	230f      	movs	r3, #15
    c7c8:	18fb      	adds	r3, r7, r3
    c7ca:	781a      	ldrb	r2, [r3, #0]
    c7cc:	230f      	movs	r3, #15
    c7ce:	18fb      	adds	r3, r7, r3
    c7d0:	3201      	adds	r2, #1
    c7d2:	701a      	strb	r2, [r3, #0]
    c7d4:	230f      	movs	r3, #15
    c7d6:	18fb      	adds	r3, r7, r3
    c7d8:	781b      	ldrb	r3, [r3, #0]
    c7da:	2b13      	cmp	r3, #19
    c7dc:	d9e0      	bls.n	c7a0 <RFID_task+0x58>
	 {
	  xValidTAG=true;
	  break;	 
	 }
	}
	vTaskDelay(TASK_DELAY_MS(1000));
    c7de:	23fa      	movs	r3, #250	; 0xfa
    c7e0:	009b      	lsls	r3, r3, #2
    c7e2:	0018      	movs	r0, r3
    c7e4:	4b0b      	ldr	r3, [pc, #44]	; (c814 <RFID_task+0xcc>)
    c7e6:	4798      	blx	r3
    c7e8:	e7b5      	b.n	c756 <RFID_task+0xe>
   }
   else xValidTAG=false;
    c7ea:	4b0b      	ldr	r3, [pc, #44]	; (c818 <RFID_task+0xd0>)
    c7ec:	2200      	movs	r2, #0
    c7ee:	701a      	strb	r2, [r3, #0]
  }
    c7f0:	e7b1      	b.n	c756 <RFID_task+0xe>
    c7f2:	46c0      	nop			; (mov r8, r8)
    c7f4:	0001031d 	.word	0x0001031d
    c7f8:	200046e4 	.word	0x200046e4
    c7fc:	20004499 	.word	0x20004499
    c800:	20004a64 	.word	0x20004a64
    c804:	20003e14 	.word	0x20003e14
    c808:	0000c435 	.word	0x0000c435
    c80c:	200049e4 	.word	0x200049e4
    c810:	000159cd 	.word	0x000159cd
    c814:	000101fd 	.word	0x000101fd
    c818:	20004a24 	.word	0x20004a24
    c81c:	20004928 	.word	0x20004928
    c820:	20003dfc 	.word	0x20003dfc
    c824:	0001ee7d 	.word	0x0001ee7d

0000c828 <vInitRC522SPI>:
}

///////////////////////////////////////////////////////////////////////

void vInitRC522SPI(void)
{
    c828:	b580      	push	{r7, lr}
    c82a:	b090      	sub	sp, #64	; 0x40
    c82c:	af00      	add	r7, sp, #0
	struct spi_config config_spi_master;
	struct port_config pin_conf;
	
	port_get_config_defaults(&pin_conf);
    c82e:	1d3b      	adds	r3, r7, #4
    c830:	0018      	movs	r0, r3
    c832:	4b2c      	ldr	r3, [pc, #176]	; (c8e4 <vInitRC522SPI+0xbc>)
    c834:	4798      	blx	r3
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    c836:	1d3b      	adds	r3, r7, #4
    c838:	2201      	movs	r2, #1
    c83a:	701a      	strb	r2, [r3, #0]
	port_pin_set_config(RC522_SS, &pin_conf);
    c83c:	1d3b      	adds	r3, r7, #4
    c83e:	0019      	movs	r1, r3
    c840:	2031      	movs	r0, #49	; 0x31
    c842:	4b29      	ldr	r3, [pc, #164]	; (c8e8 <vInitRC522SPI+0xc0>)
    c844:	4798      	blx	r3
	port_pin_set_output_level(RC522_SS,true);
    c846:	2101      	movs	r1, #1
    c848:	2031      	movs	r0, #49	; 0x31
    c84a:	4b28      	ldr	r3, [pc, #160]	; (c8ec <vInitRC522SPI+0xc4>)
    c84c:	4798      	blx	r3
	port_pin_set_config(RC522_RST, &pin_conf);
    c84e:	1d3b      	adds	r3, r7, #4
    c850:	0019      	movs	r1, r3
    c852:	2008      	movs	r0, #8
    c854:	4b24      	ldr	r3, [pc, #144]	; (c8e8 <vInitRC522SPI+0xc0>)
    c856:	4798      	blx	r3
	port_pin_set_output_level(RC522_RST,true);
    c858:	2101      	movs	r1, #1
    c85a:	2008      	movs	r0, #8
    c85c:	4b23      	ldr	r3, [pc, #140]	; (c8ec <vInitRC522SPI+0xc4>)
    c85e:	4798      	blx	r3
	port_pin_set_config(RTC_CS, &pin_conf);
    c860:	1d3b      	adds	r3, r7, #4
    c862:	0019      	movs	r1, r3
    c864:	202a      	movs	r0, #42	; 0x2a
    c866:	4b20      	ldr	r3, [pc, #128]	; (c8e8 <vInitRC522SPI+0xc0>)
    c868:	4798      	blx	r3
	port_pin_set_output_level(RTC_CS,true);
    c86a:	2101      	movs	r1, #1
    c86c:	202a      	movs	r0, #42	; 0x2a
    c86e:	4b1f      	ldr	r3, [pc, #124]	; (c8ec <vInitRC522SPI+0xc4>)
    c870:	4798      	blx	r3
		
	spi_get_config_defaults(&config_spi_master);
    c872:	2308      	movs	r3, #8
    c874:	18fb      	adds	r3, r7, r3
    c876:	0018      	movs	r0, r3
    c878:	4b1d      	ldr	r3, [pc, #116]	; (c8f0 <vInitRC522SPI+0xc8>)
    c87a:	4798      	blx	r3
	config_spi_master.mux_setting = SPI_SIGNAL_MUX_SETTING_E;
    c87c:	2308      	movs	r3, #8
    c87e:	18fb      	adds	r3, r7, r3
    c880:	2280      	movs	r2, #128	; 0x80
    c882:	0252      	lsls	r2, r2, #9
    c884:	60da      	str	r2, [r3, #12]

	/* Configure pad 0 for MOSI */
	config_spi_master.pinmux_pad0 = PINMUX_PB16C_SERCOM5_PAD0;
    c886:	2308      	movs	r3, #8
    c888:	18fb      	adds	r3, r7, r3
    c88a:	4a1a      	ldr	r2, [pc, #104]	; (c8f4 <vInitRC522SPI+0xcc>)
    c88c:	629a      	str	r2, [r3, #40]	; 0x28
	/* Configure pad 1 as unused */
	config_spi_master.pinmux_pad1 = PINMUX_UNUSED;
    c88e:	2308      	movs	r3, #8
    c890:	18fb      	adds	r3, r7, r3
    c892:	2201      	movs	r2, #1
    c894:	4252      	negs	r2, r2
    c896:	62da      	str	r2, [r3, #44]	; 0x2c
	/* Configure pad 2 for MISO*/
	config_spi_master.pinmux_pad2 = PINMUX_PB22D_SERCOM5_PAD2;
    c898:	2308      	movs	r3, #8
    c89a:	18fb      	adds	r3, r7, r3
    c89c:	4a16      	ldr	r2, [pc, #88]	; (c8f8 <vInitRC522SPI+0xd0>)
    c89e:	631a      	str	r2, [r3, #48]	; 0x30
	/* Configure pad 3 for SCK */
	config_spi_master.pinmux_pad3 = PINMUX_PB23D_SERCOM5_PAD3;
    c8a0:	2308      	movs	r3, #8
    c8a2:	18fb      	adds	r3, r7, r3
    c8a4:	4a15      	ldr	r2, [pc, #84]	; (c8fc <vInitRC522SPI+0xd4>)
    c8a6:	635a      	str	r2, [r3, #52]	; 0x34
	config_spi_master.transfer_mode = SPI_TRANSFER_MODE_0;
    c8a8:	2308      	movs	r3, #8
    c8aa:	18fb      	adds	r3, r7, r3
    c8ac:	2200      	movs	r2, #0
    c8ae:	609a      	str	r2, [r3, #8]
	config_spi_master.generator_source = GCLK_GENERATOR_0;
    c8b0:	2308      	movs	r3, #8
    c8b2:	18fb      	adds	r3, r7, r3
    c8b4:	2224      	movs	r2, #36	; 0x24
    c8b6:	2100      	movs	r1, #0
    c8b8:	5499      	strb	r1, [r3, r2]
	//config_spi_master.data_order = SPI_DATA_ORDER_MSB;
	spi_init(&service_spi_master_instance,SERCOM5, &config_spi_master);
    c8ba:	2308      	movs	r3, #8
    c8bc:	18fa      	adds	r2, r7, r3
    c8be:	4910      	ldr	r1, [pc, #64]	; (c900 <vInitRC522SPI+0xd8>)
    c8c0:	4b10      	ldr	r3, [pc, #64]	; (c904 <vInitRC522SPI+0xdc>)
    c8c2:	0018      	movs	r0, r3
    c8c4:	4b10      	ldr	r3, [pc, #64]	; (c908 <vInitRC522SPI+0xe0>)
    c8c6:	4798      	blx	r3
	spi_set_baudrate(&service_spi_master_instance,1000000);
    c8c8:	4a10      	ldr	r2, [pc, #64]	; (c90c <vInitRC522SPI+0xe4>)
    c8ca:	4b0e      	ldr	r3, [pc, #56]	; (c904 <vInitRC522SPI+0xdc>)
    c8cc:	0011      	movs	r1, r2
    c8ce:	0018      	movs	r0, r3
    c8d0:	4b0f      	ldr	r3, [pc, #60]	; (c910 <vInitRC522SPI+0xe8>)
    c8d2:	4798      	blx	r3
	spi_enable(&service_spi_master_instance);
    c8d4:	4b0b      	ldr	r3, [pc, #44]	; (c904 <vInitRC522SPI+0xdc>)
    c8d6:	0018      	movs	r0, r3
    c8d8:	4b0e      	ldr	r3, [pc, #56]	; (c914 <vInitRC522SPI+0xec>)
    c8da:	4798      	blx	r3
	
}
    c8dc:	46c0      	nop			; (mov r8, r8)
    c8de:	46bd      	mov	sp, r7
    c8e0:	b010      	add	sp, #64	; 0x40
    c8e2:	bd80      	pop	{r7, pc}
    c8e4:	0000c151 	.word	0x0000c151
    c8e8:	0001355d 	.word	0x0001355d
    c8ec:	0000c175 	.word	0x0000c175
    c8f0:	0000c215 	.word	0x0000c215
    c8f4:	00300002 	.word	0x00300002
    c8f8:	00360003 	.word	0x00360003
    c8fc:	00370003 	.word	0x00370003
    c900:	42001c00 	.word	0x42001c00
    c904:	200049e8 	.word	0x200049e8
    c908:	000148cd 	.word	0x000148cd
    c90c:	000f4240 	.word	0x000f4240
    c910:	000145f5 	.word	0x000145f5
    c914:	0000c299 	.word	0x0000c299

0000c918 <PCD_WriteRegister>:
 * Writes a byte to the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
static void PCD_WriteRegister(	uint8_t reg,		///< The register to write to. One of the PCD_Register enums.
						uint8_t value		///< The value to write.
					   ) {
    c918:	b580      	push	{r7, lr}
    c91a:	b084      	sub	sp, #16
    c91c:	af00      	add	r7, sp, #0
    c91e:	0002      	movs	r2, r0
    c920:	1dfb      	adds	r3, r7, #7
    c922:	701a      	strb	r2, [r3, #0]
    c924:	1dbb      	adds	r3, r7, #6
    c926:	1c0a      	adds	r2, r1, #0
    c928:	701a      	strb	r2, [r3, #0]
	uint16_t LocalValue;				   
	//SPI.beginTransaction(SPISettings(SPI_CLOCK_DIV4, MSBFIRST, SPI_MODE0));	// Set the settings to work with SPI bus
	//digitalWrite(_chipSelectPin, LOW);		// Select slave
	port_pin_set_output_level(RC522_SS,false);
    c92a:	2100      	movs	r1, #0
    c92c:	2031      	movs	r0, #49	; 0x31
    c92e:	4b0f      	ldr	r3, [pc, #60]	; (c96c <PCD_WriteRegister+0x54>)
    c930:	4798      	blx	r3
	//SPI.transfer(reg & 0x7E);				// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
	spi_transceive_wait(&service_spi_master_instance,reg & 0x7E,&LocalValue);
    c932:	1dfb      	adds	r3, r7, #7
    c934:	781b      	ldrb	r3, [r3, #0]
    c936:	b29b      	uxth	r3, r3
    c938:	227e      	movs	r2, #126	; 0x7e
    c93a:	4013      	ands	r3, r2
    c93c:	b299      	uxth	r1, r3
    c93e:	230e      	movs	r3, #14
    c940:	18fa      	adds	r2, r7, r3
    c942:	4b0b      	ldr	r3, [pc, #44]	; (c970 <PCD_WriteRegister+0x58>)
    c944:	0018      	movs	r0, r3
    c946:	4b0b      	ldr	r3, [pc, #44]	; (c974 <PCD_WriteRegister+0x5c>)
    c948:	4798      	blx	r3
    //SPI.transfer(value);
    spi_transceive_wait(&service_spi_master_instance,value,&LocalValue);
    c94a:	1dbb      	adds	r3, r7, #6
    c94c:	781b      	ldrb	r3, [r3, #0]
    c94e:	b299      	uxth	r1, r3
    c950:	230e      	movs	r3, #14
    c952:	18fa      	adds	r2, r7, r3
    c954:	4b06      	ldr	r3, [pc, #24]	; (c970 <PCD_WriteRegister+0x58>)
    c956:	0018      	movs	r0, r3
    c958:	4b06      	ldr	r3, [pc, #24]	; (c974 <PCD_WriteRegister+0x5c>)
    c95a:	4798      	blx	r3
	//digitalWrite(_chipSelectPin, HIGH);		// Release slave again
	port_pin_set_output_level(RC522_SS,true);
    c95c:	2101      	movs	r1, #1
    c95e:	2031      	movs	r0, #49	; 0x31
    c960:	4b02      	ldr	r3, [pc, #8]	; (c96c <PCD_WriteRegister+0x54>)
    c962:	4798      	blx	r3
	//SPI.endTransaction(); // Stop using the SPI bus
} // End PCD_WriteRegister()
    c964:	46c0      	nop			; (mov r8, r8)
    c966:	46bd      	mov	sp, r7
    c968:	b004      	add	sp, #16
    c96a:	bd80      	pop	{r7, pc}
    c96c:	0000c175 	.word	0x0000c175
    c970:	200049e8 	.word	0x200049e8
    c974:	00014b91 	.word	0x00014b91

0000c978 <PCD_ReadRegister>:
/**
 * Reads a byte from the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
static uint8_t PCD_ReadRegister(	uint8_t reg	///< The register to read from. One of the PCD_Register enums.
								) {
    c978:	b580      	push	{r7, lr}
    c97a:	b084      	sub	sp, #16
    c97c:	af00      	add	r7, sp, #0
    c97e:	0002      	movs	r2, r0
    c980:	1dfb      	adds	r3, r7, #7
    c982:	701a      	strb	r2, [r3, #0]
	uint16_t value=0;
    c984:	230e      	movs	r3, #14
    c986:	18fb      	adds	r3, r7, r3
    c988:	2200      	movs	r2, #0
    c98a:	801a      	strh	r2, [r3, #0]
	//SPI.beginTransaction(SPISettings(SPI_CLOCK_DIV4, MSBFIRST, SPI_MODE0));	// Set the settings to work with SPI bus
	//digitalWrite(_chipSelectPin, LOW);			// Select slave
	port_pin_set_output_level(RC522_SS,false);
    c98c:	2100      	movs	r1, #0
    c98e:	2031      	movs	r0, #49	; 0x31
    c990:	4b12      	ldr	r3, [pc, #72]	; (c9dc <PCD_ReadRegister+0x64>)
    c992:	4798      	blx	r3
	//SPI.transfer(0x80 | (reg & 0x7E));			// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
	spi_transceive_wait(&service_spi_master_instance,0x80 | (reg & 0x7E),&value);
    c994:	1dfb      	adds	r3, r7, #7
    c996:	781b      	ldrb	r3, [r3, #0]
    c998:	b21b      	sxth	r3, r3
    c99a:	227e      	movs	r2, #126	; 0x7e
    c99c:	4013      	ands	r3, r2
    c99e:	b21b      	sxth	r3, r3
    c9a0:	2280      	movs	r2, #128	; 0x80
    c9a2:	4313      	orrs	r3, r2
    c9a4:	b21b      	sxth	r3, r3
    c9a6:	b299      	uxth	r1, r3
    c9a8:	230e      	movs	r3, #14
    c9aa:	18fa      	adds	r2, r7, r3
    c9ac:	4b0c      	ldr	r3, [pc, #48]	; (c9e0 <PCD_ReadRegister+0x68>)
    c9ae:	0018      	movs	r0, r3
    c9b0:	4b0c      	ldr	r3, [pc, #48]	; (c9e4 <PCD_ReadRegister+0x6c>)
    c9b2:	4798      	blx	r3
	//value = SPI.transfer(0);					    // Read the value back. Send 0 to stop reading.
	spi_transceive_wait(&service_spi_master_instance,0x00,&value);
    c9b4:	230e      	movs	r3, #14
    c9b6:	18fa      	adds	r2, r7, r3
    c9b8:	4b09      	ldr	r3, [pc, #36]	; (c9e0 <PCD_ReadRegister+0x68>)
    c9ba:	2100      	movs	r1, #0
    c9bc:	0018      	movs	r0, r3
    c9be:	4b09      	ldr	r3, [pc, #36]	; (c9e4 <PCD_ReadRegister+0x6c>)
    c9c0:	4798      	blx	r3
	//digitalWrite(_chipSelectPin, HIGH);			// Release slave again
	port_pin_set_output_level(RC522_SS,true);
    c9c2:	2101      	movs	r1, #1
    c9c4:	2031      	movs	r0, #49	; 0x31
    c9c6:	4b05      	ldr	r3, [pc, #20]	; (c9dc <PCD_ReadRegister+0x64>)
    c9c8:	4798      	blx	r3
	//SPI.endTransaction(); // Stop using the SPI bus
	return (uint8_t)value;
    c9ca:	230e      	movs	r3, #14
    c9cc:	18fb      	adds	r3, r7, r3
    c9ce:	881b      	ldrh	r3, [r3, #0]
    c9d0:	b2db      	uxtb	r3, r3
} // End PCD_ReadRegister()
    c9d2:	0018      	movs	r0, r3
    c9d4:	46bd      	mov	sp, r7
    c9d6:	b004      	add	sp, #16
    c9d8:	bd80      	pop	{r7, pc}
    c9da:	46c0      	nop			; (mov r8, r8)
    c9dc:	0000c175 	.word	0x0000c175
    c9e0:	200049e8 	.word	0x200049e8
    c9e4:	00014b91 	.word	0x00014b91

0000c9e8 <PCD_AntennaOn>:

/**
 * Turns the antenna on by enabling pins TX1 and TX2.
 * After a reset these pins are disabled.
 */
static void PCD_AntennaOn(void) {
    c9e8:	b590      	push	{r4, r7, lr}
    c9ea:	b083      	sub	sp, #12
    c9ec:	af00      	add	r7, sp, #0
	uint8_t value = PCD_ReadRegister(TxControlReg);
    c9ee:	1dfc      	adds	r4, r7, #7
    c9f0:	2028      	movs	r0, #40	; 0x28
    c9f2:	4b0b      	ldr	r3, [pc, #44]	; (ca20 <PCD_AntennaOn+0x38>)
    c9f4:	4798      	blx	r3
    c9f6:	0003      	movs	r3, r0
    c9f8:	7023      	strb	r3, [r4, #0]
	if ((value & 0x03) != 0x03) {
    c9fa:	1dfb      	adds	r3, r7, #7
    c9fc:	781b      	ldrb	r3, [r3, #0]
    c9fe:	2203      	movs	r2, #3
    ca00:	4013      	ands	r3, r2
    ca02:	2b03      	cmp	r3, #3
    ca04:	d008      	beq.n	ca18 <PCD_AntennaOn+0x30>
		PCD_WriteRegister(TxControlReg, value | 0x03);
    ca06:	1dfb      	adds	r3, r7, #7
    ca08:	781b      	ldrb	r3, [r3, #0]
    ca0a:	2203      	movs	r2, #3
    ca0c:	4313      	orrs	r3, r2
    ca0e:	b2db      	uxtb	r3, r3
    ca10:	0019      	movs	r1, r3
    ca12:	2028      	movs	r0, #40	; 0x28
    ca14:	4b03      	ldr	r3, [pc, #12]	; (ca24 <PCD_AntennaOn+0x3c>)
    ca16:	4798      	blx	r3
	}
} // End PCD_AntennaOn()
    ca18:	46c0      	nop			; (mov r8, r8)
    ca1a:	46bd      	mov	sp, r7
    ca1c:	b003      	add	sp, #12
    ca1e:	bd90      	pop	{r4, r7, pc}
    ca20:	0000c979 	.word	0x0000c979
    ca24:	0000c919 	.word	0x0000c919

0000ca28 <MFRC522_PCD_Init>:
	return (result == RC522_STATUS_OK);
} // End 

/////////////////////////////////////////////////////////////////////////////////////////////////////////

void MFRC522_PCD_Init(void) {
    ca28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ca2a:	af00      	add	r7, sp, #0
	//}
	//else { // Perform a soft reset
		//PCD_Reset();
	//}
	
	port_pin_set_output_level(RC522_RST,false);
    ca2c:	2100      	movs	r1, #0
    ca2e:	2008      	movs	r0, #8
    ca30:	4b23      	ldr	r3, [pc, #140]	; (cac0 <MFRC522_PCD_Init+0x98>)
    ca32:	4798      	blx	r3
	delay_ms(50);
    ca34:	2000      	movs	r0, #0
    ca36:	4b23      	ldr	r3, [pc, #140]	; (cac4 <MFRC522_PCD_Init+0x9c>)
    ca38:	4798      	blx	r3
    ca3a:	0003      	movs	r3, r0
    ca3c:	001d      	movs	r5, r3
    ca3e:	2300      	movs	r3, #0
    ca40:	001e      	movs	r6, r3
    ca42:	4c21      	ldr	r4, [pc, #132]	; (cac8 <MFRC522_PCD_Init+0xa0>)
    ca44:	2232      	movs	r2, #50	; 0x32
    ca46:	2300      	movs	r3, #0
    ca48:	0028      	movs	r0, r5
    ca4a:	0031      	movs	r1, r6
    ca4c:	47a0      	blx	r4
    ca4e:	0003      	movs	r3, r0
    ca50:	000c      	movs	r4, r1
    ca52:	0019      	movs	r1, r3
    ca54:	0022      	movs	r2, r4
    ca56:	4b1d      	ldr	r3, [pc, #116]	; (cacc <MFRC522_PCD_Init+0xa4>)
    ca58:	2400      	movs	r4, #0
    ca5a:	18c9      	adds	r1, r1, r3
    ca5c:	4162      	adcs	r2, r4
    ca5e:	0008      	movs	r0, r1
    ca60:	0011      	movs	r1, r2
    ca62:	4c1b      	ldr	r4, [pc, #108]	; (cad0 <MFRC522_PCD_Init+0xa8>)
    ca64:	4a1b      	ldr	r2, [pc, #108]	; (cad4 <MFRC522_PCD_Init+0xac>)
    ca66:	2300      	movs	r3, #0
    ca68:	47a0      	blx	r4
    ca6a:	0003      	movs	r3, r0
    ca6c:	000c      	movs	r4, r1
    ca6e:	0018      	movs	r0, r3
    ca70:	4b19      	ldr	r3, [pc, #100]	; (cad8 <MFRC522_PCD_Init+0xb0>)
    ca72:	4798      	blx	r3
	port_pin_set_output_level(RC522_RST,true);	
    ca74:	2101      	movs	r1, #1
    ca76:	2008      	movs	r0, #8
    ca78:	4b11      	ldr	r3, [pc, #68]	; (cac0 <MFRC522_PCD_Init+0x98>)
    ca7a:	4798      	blx	r3
	
	// When communicating with a PICC we need a timeout if something goes wrong.
	// f_timer = 13.56 MHz / (2*TPreScaler+1) where TPreScaler = [TPrescaler_Hi:TPrescaler_Lo].
	// TPrescaler_Hi are the four low bits in TModeReg. TPrescaler_Lo is TPrescalerReg.
	PCD_WriteRegister(TModeReg, 0x80);			// TAuto=1; timer starts automatically at the end of the transmission in all communication modes at all speeds
    ca7c:	2180      	movs	r1, #128	; 0x80
    ca7e:	2054      	movs	r0, #84	; 0x54
    ca80:	4b16      	ldr	r3, [pc, #88]	; (cadc <MFRC522_PCD_Init+0xb4>)
    ca82:	4798      	blx	r3
	PCD_WriteRegister(TPrescalerReg, 0xA9);		// TPreScaler = TModeReg[3..0]:TPrescalerReg, ie 0x0A9 = 169 => f_timer=40kHz, ie a timer period of 25?s.
    ca84:	21a9      	movs	r1, #169	; 0xa9
    ca86:	2056      	movs	r0, #86	; 0x56
    ca88:	4b14      	ldr	r3, [pc, #80]	; (cadc <MFRC522_PCD_Init+0xb4>)
    ca8a:	4798      	blx	r3
	PCD_WriteRegister(TReloadRegH, 0x03);		// Reload timer with 0x3E8 = 1000, ie 25ms before timeout.
    ca8c:	2103      	movs	r1, #3
    ca8e:	2058      	movs	r0, #88	; 0x58
    ca90:	4b12      	ldr	r3, [pc, #72]	; (cadc <MFRC522_PCD_Init+0xb4>)
    ca92:	4798      	blx	r3
	PCD_WriteRegister(TReloadRegL, 0xE8);
    ca94:	21e8      	movs	r1, #232	; 0xe8
    ca96:	205a      	movs	r0, #90	; 0x5a
    ca98:	4b10      	ldr	r3, [pc, #64]	; (cadc <MFRC522_PCD_Init+0xb4>)
    ca9a:	4798      	blx	r3
	
	PCD_WriteRegister(TxASKReg, 0x40);		// Default 0x00. Force a 100 % ASK modulation independent of the ModGsPReg register setting
    ca9c:	2140      	movs	r1, #64	; 0x40
    ca9e:	202a      	movs	r0, #42	; 0x2a
    caa0:	4b0e      	ldr	r3, [pc, #56]	; (cadc <MFRC522_PCD_Init+0xb4>)
    caa2:	4798      	blx	r3
	PCD_WriteRegister(ModeReg, 0x3D);		// Default 0x3F. Set the preset value for the CRC coprocessor for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)
    caa4:	213d      	movs	r1, #61	; 0x3d
    caa6:	2022      	movs	r0, #34	; 0x22
    caa8:	4b0c      	ldr	r3, [pc, #48]	; (cadc <MFRC522_PCD_Init+0xb4>)
    caaa:	4798      	blx	r3
	PCD_WriteRegister(RFCfgReg, 0x70);      //RxGain = 48dB
    caac:	2170      	movs	r1, #112	; 0x70
    caae:	204c      	movs	r0, #76	; 0x4c
    cab0:	4b0a      	ldr	r3, [pc, #40]	; (cadc <MFRC522_PCD_Init+0xb4>)
    cab2:	4798      	blx	r3
	PCD_AntennaOn();						// Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)
    cab4:	4b0a      	ldr	r3, [pc, #40]	; (cae0 <MFRC522_PCD_Init+0xb8>)
    cab6:	4798      	blx	r3
} // End PCD_Init()
    cab8:	46c0      	nop			; (mov r8, r8)
    caba:	46bd      	mov	sp, r7
    cabc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    cabe:	46c0      	nop			; (mov r8, r8)
    cac0:	0000c175 	.word	0x0000c175
    cac4:	00016909 	.word	0x00016909
    cac8:	0001d7b1 	.word	0x0001d7b1
    cacc:	00001b57 	.word	0x00001b57
    cad0:	0001d771 	.word	0x0001d771
    cad4:	00001b58 	.word	0x00001b58
    cad8:	20000001 	.word	0x20000001
    cadc:	0000c919 	.word	0x0000c919
    cae0:	0000c9e9 	.word	0x0000c9e9

0000cae4 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    cae4:	b580      	push	{r7, lr}
    cae6:	b084      	sub	sp, #16
    cae8:	af00      	add	r7, sp, #0
    caea:	0002      	movs	r2, r0
    caec:	1dfb      	adds	r3, r7, #7
    caee:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    caf0:	230f      	movs	r3, #15
    caf2:	18fb      	adds	r3, r7, r3
    caf4:	1dfa      	adds	r2, r7, #7
    caf6:	7812      	ldrb	r2, [r2, #0]
    caf8:	09d2      	lsrs	r2, r2, #7
    cafa:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    cafc:	230e      	movs	r3, #14
    cafe:	18fb      	adds	r3, r7, r3
    cb00:	1dfa      	adds	r2, r7, #7
    cb02:	7812      	ldrb	r2, [r2, #0]
    cb04:	0952      	lsrs	r2, r2, #5
    cb06:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    cb08:	4b0d      	ldr	r3, [pc, #52]	; (cb40 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    cb0a:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    cb0c:	230f      	movs	r3, #15
    cb0e:	18fb      	adds	r3, r7, r3
    cb10:	781b      	ldrb	r3, [r3, #0]
    cb12:	2b00      	cmp	r3, #0
    cb14:	d10f      	bne.n	cb36 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    cb16:	230f      	movs	r3, #15
    cb18:	18fb      	adds	r3, r7, r3
    cb1a:	781b      	ldrb	r3, [r3, #0]
    cb1c:	009b      	lsls	r3, r3, #2
    cb1e:	2210      	movs	r2, #16
    cb20:	4694      	mov	ip, r2
    cb22:	44bc      	add	ip, r7
    cb24:	4463      	add	r3, ip
    cb26:	3b08      	subs	r3, #8
    cb28:	681a      	ldr	r2, [r3, #0]
    cb2a:	230e      	movs	r3, #14
    cb2c:	18fb      	adds	r3, r7, r3
    cb2e:	781b      	ldrb	r3, [r3, #0]
    cb30:	01db      	lsls	r3, r3, #7
    cb32:	18d3      	adds	r3, r2, r3
    cb34:	e000      	b.n	cb38 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    cb36:	2300      	movs	r3, #0
	}
}
    cb38:	0018      	movs	r0, r3
    cb3a:	46bd      	mov	sp, r7
    cb3c:	b004      	add	sp, #16
    cb3e:	bd80      	pop	{r7, pc}
    cb40:	41004400 	.word	0x41004400

0000cb44 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    cb44:	b580      	push	{r7, lr}
    cb46:	b082      	sub	sp, #8
    cb48:	af00      	add	r7, sp, #0
    cb4a:	0002      	movs	r2, r0
    cb4c:	1dfb      	adds	r3, r7, #7
    cb4e:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    cb50:	1dfb      	adds	r3, r7, #7
    cb52:	781b      	ldrb	r3, [r3, #0]
    cb54:	0018      	movs	r0, r3
    cb56:	4b03      	ldr	r3, [pc, #12]	; (cb64 <port_get_group_from_gpio_pin+0x20>)
    cb58:	4798      	blx	r3
    cb5a:	0003      	movs	r3, r0
}
    cb5c:	0018      	movs	r0, r3
    cb5e:	46bd      	mov	sp, r7
    cb60:	b002      	add	sp, #8
    cb62:	bd80      	pop	{r7, pc}
    cb64:	0000cae5 	.word	0x0000cae5

0000cb68 <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    cb68:	b580      	push	{r7, lr}
    cb6a:	b082      	sub	sp, #8
    cb6c:	af00      	add	r7, sp, #0
    cb6e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    cb70:	687b      	ldr	r3, [r7, #4]
    cb72:	2200      	movs	r2, #0
    cb74:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    cb76:	687b      	ldr	r3, [r7, #4]
    cb78:	2201      	movs	r2, #1
    cb7a:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    cb7c:	687b      	ldr	r3, [r7, #4]
    cb7e:	2200      	movs	r2, #0
    cb80:	709a      	strb	r2, [r3, #2]
}
    cb82:	46c0      	nop			; (mov r8, r8)
    cb84:	46bd      	mov	sp, r7
    cb86:	b002      	add	sp, #8
    cb88:	bd80      	pop	{r7, pc}
    cb8a:	46c0      	nop			; (mov r8, r8)

0000cb8c <port_pin_get_input_level>:
 *
 *  \return Status of the port pin's input buffer.
 */
static inline bool port_pin_get_input_level(
		const uint8_t gpio_pin)
{
    cb8c:	b580      	push	{r7, lr}
    cb8e:	b084      	sub	sp, #16
    cb90:	af00      	add	r7, sp, #0
    cb92:	0002      	movs	r2, r0
    cb94:	1dfb      	adds	r3, r7, #7
    cb96:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    cb98:	1dfb      	adds	r3, r7, #7
    cb9a:	781b      	ldrb	r3, [r3, #0]
    cb9c:	0018      	movs	r0, r3
    cb9e:	4b0b      	ldr	r3, [pc, #44]	; (cbcc <port_pin_get_input_level+0x40>)
    cba0:	4798      	blx	r3
    cba2:	0003      	movs	r3, r0
    cba4:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    cba6:	1dfb      	adds	r3, r7, #7
    cba8:	781b      	ldrb	r3, [r3, #0]
    cbaa:	221f      	movs	r2, #31
    cbac:	4013      	ands	r3, r2
    cbae:	2201      	movs	r2, #1
    cbb0:	409a      	lsls	r2, r3
    cbb2:	0013      	movs	r3, r2
    cbb4:	60bb      	str	r3, [r7, #8]

	return (port_base->IN.reg & pin_mask);
    cbb6:	68fb      	ldr	r3, [r7, #12]
    cbb8:	6a1b      	ldr	r3, [r3, #32]
    cbba:	68ba      	ldr	r2, [r7, #8]
    cbbc:	4013      	ands	r3, r2
    cbbe:	1e5a      	subs	r2, r3, #1
    cbc0:	4193      	sbcs	r3, r2
    cbc2:	b2db      	uxtb	r3, r3
}
    cbc4:	0018      	movs	r0, r3
    cbc6:	46bd      	mov	sp, r7
    cbc8:	b004      	add	sp, #16
    cbca:	bd80      	pop	{r7, pc}
    cbcc:	0000cb45 	.word	0x0000cb45

0000cbd0 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    cbd0:	b580      	push	{r7, lr}
    cbd2:	b084      	sub	sp, #16
    cbd4:	af00      	add	r7, sp, #0
    cbd6:	0002      	movs	r2, r0
    cbd8:	1dfb      	adds	r3, r7, #7
    cbda:	701a      	strb	r2, [r3, #0]
    cbdc:	1dbb      	adds	r3, r7, #6
    cbde:	1c0a      	adds	r2, r1, #0
    cbe0:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    cbe2:	1dfb      	adds	r3, r7, #7
    cbe4:	781b      	ldrb	r3, [r3, #0]
    cbe6:	0018      	movs	r0, r3
    cbe8:	4b0d      	ldr	r3, [pc, #52]	; (cc20 <port_pin_set_output_level+0x50>)
    cbea:	4798      	blx	r3
    cbec:	0003      	movs	r3, r0
    cbee:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    cbf0:	1dfb      	adds	r3, r7, #7
    cbf2:	781b      	ldrb	r3, [r3, #0]
    cbf4:	221f      	movs	r2, #31
    cbf6:	4013      	ands	r3, r2
    cbf8:	2201      	movs	r2, #1
    cbfa:	409a      	lsls	r2, r3
    cbfc:	0013      	movs	r3, r2
    cbfe:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    cc00:	1dbb      	adds	r3, r7, #6
    cc02:	781b      	ldrb	r3, [r3, #0]
    cc04:	2b00      	cmp	r3, #0
    cc06:	d003      	beq.n	cc10 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    cc08:	68fb      	ldr	r3, [r7, #12]
    cc0a:	68ba      	ldr	r2, [r7, #8]
    cc0c:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    cc0e:	e002      	b.n	cc16 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    cc10:	68fb      	ldr	r3, [r7, #12]
    cc12:	68ba      	ldr	r2, [r7, #8]
    cc14:	615a      	str	r2, [r3, #20]
	}
}
    cc16:	46c0      	nop			; (mov r8, r8)
    cc18:	46bd      	mov	sp, r7
    cc1a:	b004      	add	sp, #16
    cc1c:	bd80      	pop	{r7, pc}
    cc1e:	46c0      	nop			; (mov r8, r8)
    cc20:	0000cb45 	.word	0x0000cb45

0000cc24 <lcd_read_byte>:

unsigned char lcd_read_byte(void);
unsigned char lcd_read_nibble(void);

unsigned char lcd_read_byte(void)
{
    cc24:	b5f0      	push	{r4, r5, r6, r7, lr}
    cc26:	b089      	sub	sp, #36	; 0x24
    cc28:	af00      	add	r7, sp, #0
   unsigned char low,high;
   struct port_config pin_conf;
   

   port_get_config_defaults(&pin_conf);
    cc2a:	2318      	movs	r3, #24
    cc2c:	18fb      	adds	r3, r7, r3
    cc2e:	0018      	movs	r0, r3
    cc30:	4b62      	ldr	r3, [pc, #392]	; (cdbc <lcd_read_byte+0x198>)
    cc32:	4798      	blx	r3
   pin_conf.direction  = PORT_PIN_DIR_INPUT;
    cc34:	2318      	movs	r3, #24
    cc36:	18fb      	adds	r3, r7, r3
    cc38:	2200      	movs	r2, #0
    cc3a:	701a      	strb	r2, [r3, #0]
   pin_conf.input_pull = PORT_PIN_PULL_UP;
    cc3c:	2318      	movs	r3, #24
    cc3e:	18fb      	adds	r3, r7, r3
    cc40:	2201      	movs	r2, #1
    cc42:	705a      	strb	r2, [r3, #1]
   port_pin_set_config(PORT_LCD_DATA4, &pin_conf);
    cc44:	2318      	movs	r3, #24
    cc46:	18fb      	adds	r3, r7, r3
    cc48:	0019      	movs	r1, r3
    cc4a:	200c      	movs	r0, #12
    cc4c:	4b5c      	ldr	r3, [pc, #368]	; (cdc0 <lcd_read_byte+0x19c>)
    cc4e:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA5, &pin_conf);
    cc50:	2318      	movs	r3, #24
    cc52:	18fb      	adds	r3, r7, r3
    cc54:	0019      	movs	r1, r3
    cc56:	200d      	movs	r0, #13
    cc58:	4b59      	ldr	r3, [pc, #356]	; (cdc0 <lcd_read_byte+0x19c>)
    cc5a:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA6, &pin_conf);
    cc5c:	2318      	movs	r3, #24
    cc5e:	18fb      	adds	r3, r7, r3
    cc60:	0019      	movs	r1, r3
    cc62:	200f      	movs	r0, #15
    cc64:	4b56      	ldr	r3, [pc, #344]	; (cdc0 <lcd_read_byte+0x19c>)
    cc66:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA7, &pin_conf);
    cc68:	2318      	movs	r3, #24
    cc6a:	18fb      	adds	r3, r7, r3
    cc6c:	0019      	movs	r1, r3
    cc6e:	2009      	movs	r0, #9
    cc70:	4b53      	ldr	r3, [pc, #332]	; (cdc0 <lcd_read_byte+0x19c>)
    cc72:	4798      	blx	r3
   //TRIS_LCD_DATA5(1);
   //TRIS_LCD_DATA6(1);
   //TRIS_LCD_DATA7(1);
   
   //lcd_output_rw(1);
   port_pin_set_output_level(PORT_LCD_RW_PIN,1);
    cc74:	2101      	movs	r1, #1
    cc76:	201b      	movs	r0, #27
    cc78:	4b52      	ldr	r3, [pc, #328]	; (cdc4 <lcd_read_byte+0x1a0>)
    cc7a:	4798      	blx	r3
   delay_us(1);
    cc7c:	2000      	movs	r0, #0
    cc7e:	4b52      	ldr	r3, [pc, #328]	; (cdc8 <lcd_read_byte+0x1a4>)
    cc80:	4798      	blx	r3
    cc82:	0003      	movs	r3, r0
    cc84:	613b      	str	r3, [r7, #16]
    cc86:	2300      	movs	r3, #0
    cc88:	617b      	str	r3, [r7, #20]
    cc8a:	4b50      	ldr	r3, [pc, #320]	; (cdcc <lcd_read_byte+0x1a8>)
    cc8c:	2400      	movs	r4, #0
    cc8e:	6938      	ldr	r0, [r7, #16]
    cc90:	6979      	ldr	r1, [r7, #20]
    cc92:	18c0      	adds	r0, r0, r3
    cc94:	4161      	adcs	r1, r4
    cc96:	4c4e      	ldr	r4, [pc, #312]	; (cdd0 <lcd_read_byte+0x1ac>)
    cc98:	4a4e      	ldr	r2, [pc, #312]	; (cdd4 <lcd_read_byte+0x1b0>)
    cc9a:	2300      	movs	r3, #0
    cc9c:	47a0      	blx	r4
    cc9e:	0003      	movs	r3, r0
    cca0:	000c      	movs	r4, r1
    cca2:	0018      	movs	r0, r3
    cca4:	4b4c      	ldr	r3, [pc, #304]	; (cdd8 <lcd_read_byte+0x1b4>)
    cca6:	4798      	blx	r3
   //lcd_output_enable(1);
   port_pin_set_output_level(PORT_LCD_ENABLE_PIN,1);
    cca8:	2101      	movs	r1, #1
    ccaa:	2002      	movs	r0, #2
    ccac:	4b45      	ldr	r3, [pc, #276]	; (cdc4 <lcd_read_byte+0x1a0>)
    ccae:	4798      	blx	r3
   delay_us(1);
    ccb0:	2000      	movs	r0, #0
    ccb2:	4b45      	ldr	r3, [pc, #276]	; (cdc8 <lcd_read_byte+0x1a4>)
    ccb4:	4798      	blx	r3
    ccb6:	0003      	movs	r3, r0
    ccb8:	60bb      	str	r3, [r7, #8]
    ccba:	2300      	movs	r3, #0
    ccbc:	60fb      	str	r3, [r7, #12]
    ccbe:	4b43      	ldr	r3, [pc, #268]	; (cdcc <lcd_read_byte+0x1a8>)
    ccc0:	2400      	movs	r4, #0
    ccc2:	68b8      	ldr	r0, [r7, #8]
    ccc4:	68f9      	ldr	r1, [r7, #12]
    ccc6:	18c0      	adds	r0, r0, r3
    ccc8:	4161      	adcs	r1, r4
    ccca:	4c41      	ldr	r4, [pc, #260]	; (cdd0 <lcd_read_byte+0x1ac>)
    cccc:	4a41      	ldr	r2, [pc, #260]	; (cdd4 <lcd_read_byte+0x1b0>)
    ccce:	2300      	movs	r3, #0
    ccd0:	47a0      	blx	r4
    ccd2:	0003      	movs	r3, r0
    ccd4:	000c      	movs	r4, r1
    ccd6:	0018      	movs	r0, r3
    ccd8:	4b3f      	ldr	r3, [pc, #252]	; (cdd8 <lcd_read_byte+0x1b4>)
    ccda:	4798      	blx	r3
   high = lcd_read_nibble();
    ccdc:	231f      	movs	r3, #31
    ccde:	18fc      	adds	r4, r7, r3
    cce0:	4b3e      	ldr	r3, [pc, #248]	; (cddc <lcd_read_byte+0x1b8>)
    cce2:	4798      	blx	r3
    cce4:	0003      	movs	r3, r0
    cce6:	7023      	strb	r3, [r4, #0]

   //lcd_output_enable(0);
   port_pin_set_output_level(PORT_LCD_ENABLE_PIN,0);
    cce8:	2100      	movs	r1, #0
    ccea:	2002      	movs	r0, #2
    ccec:	4b35      	ldr	r3, [pc, #212]	; (cdc4 <lcd_read_byte+0x1a0>)
    ccee:	4798      	blx	r3
   delay_us(1);
    ccf0:	2000      	movs	r0, #0
    ccf2:	4b35      	ldr	r3, [pc, #212]	; (cdc8 <lcd_read_byte+0x1a4>)
    ccf4:	4798      	blx	r3
    ccf6:	0003      	movs	r3, r0
    ccf8:	603b      	str	r3, [r7, #0]
    ccfa:	2300      	movs	r3, #0
    ccfc:	607b      	str	r3, [r7, #4]
    ccfe:	4b33      	ldr	r3, [pc, #204]	; (cdcc <lcd_read_byte+0x1a8>)
    cd00:	2400      	movs	r4, #0
    cd02:	6838      	ldr	r0, [r7, #0]
    cd04:	6879      	ldr	r1, [r7, #4]
    cd06:	18c0      	adds	r0, r0, r3
    cd08:	4161      	adcs	r1, r4
    cd0a:	4c31      	ldr	r4, [pc, #196]	; (cdd0 <lcd_read_byte+0x1ac>)
    cd0c:	4a31      	ldr	r2, [pc, #196]	; (cdd4 <lcd_read_byte+0x1b0>)
    cd0e:	2300      	movs	r3, #0
    cd10:	47a0      	blx	r4
    cd12:	0003      	movs	r3, r0
    cd14:	000c      	movs	r4, r1
    cd16:	0018      	movs	r0, r3
    cd18:	4b2f      	ldr	r3, [pc, #188]	; (cdd8 <lcd_read_byte+0x1b4>)
    cd1a:	4798      	blx	r3
   //lcd_output_enable(1);
   port_pin_set_output_level(PORT_LCD_ENABLE_PIN,1);
    cd1c:	2101      	movs	r1, #1
    cd1e:	2002      	movs	r0, #2
    cd20:	4b28      	ldr	r3, [pc, #160]	; (cdc4 <lcd_read_byte+0x1a0>)
    cd22:	4798      	blx	r3
   delay_us(1);
    cd24:	2000      	movs	r0, #0
    cd26:	4b28      	ldr	r3, [pc, #160]	; (cdc8 <lcd_read_byte+0x1a4>)
    cd28:	4798      	blx	r3
    cd2a:	0003      	movs	r3, r0
    cd2c:	001d      	movs	r5, r3
    cd2e:	2300      	movs	r3, #0
    cd30:	001e      	movs	r6, r3
    cd32:	4b26      	ldr	r3, [pc, #152]	; (cdcc <lcd_read_byte+0x1a8>)
    cd34:	2400      	movs	r4, #0
    cd36:	0028      	movs	r0, r5
    cd38:	0031      	movs	r1, r6
    cd3a:	18c0      	adds	r0, r0, r3
    cd3c:	4161      	adcs	r1, r4
    cd3e:	4c24      	ldr	r4, [pc, #144]	; (cdd0 <lcd_read_byte+0x1ac>)
    cd40:	4a24      	ldr	r2, [pc, #144]	; (cdd4 <lcd_read_byte+0x1b0>)
    cd42:	2300      	movs	r3, #0
    cd44:	47a0      	blx	r4
    cd46:	0003      	movs	r3, r0
    cd48:	000c      	movs	r4, r1
    cd4a:	0018      	movs	r0, r3
    cd4c:	4b22      	ldr	r3, [pc, #136]	; (cdd8 <lcd_read_byte+0x1b4>)
    cd4e:	4798      	blx	r3
   low = lcd_read_nibble();
    cd50:	231e      	movs	r3, #30
    cd52:	18fc      	adds	r4, r7, r3
    cd54:	4b21      	ldr	r3, [pc, #132]	; (cddc <lcd_read_byte+0x1b8>)
    cd56:	4798      	blx	r3
    cd58:	0003      	movs	r3, r0
    cd5a:	7023      	strb	r3, [r4, #0]

   //lcd_output_enable(0);
   port_pin_set_output_level(PORT_LCD_ENABLE_PIN,0);
    cd5c:	2100      	movs	r1, #0
    cd5e:	2002      	movs	r0, #2
    cd60:	4b18      	ldr	r3, [pc, #96]	; (cdc4 <lcd_read_byte+0x1a0>)
    cd62:	4798      	blx	r3

   pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    cd64:	2318      	movs	r3, #24
    cd66:	18fb      	adds	r3, r7, r3
    cd68:	2201      	movs	r2, #1
    cd6a:	701a      	strb	r2, [r3, #0]
   port_pin_set_config(PORT_LCD_DATA4, &pin_conf);
    cd6c:	2318      	movs	r3, #24
    cd6e:	18fb      	adds	r3, r7, r3
    cd70:	0019      	movs	r1, r3
    cd72:	200c      	movs	r0, #12
    cd74:	4b12      	ldr	r3, [pc, #72]	; (cdc0 <lcd_read_byte+0x19c>)
    cd76:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA5, &pin_conf);
    cd78:	2318      	movs	r3, #24
    cd7a:	18fb      	adds	r3, r7, r3
    cd7c:	0019      	movs	r1, r3
    cd7e:	200d      	movs	r0, #13
    cd80:	4b0f      	ldr	r3, [pc, #60]	; (cdc0 <lcd_read_byte+0x19c>)
    cd82:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA6, &pin_conf);
    cd84:	2318      	movs	r3, #24
    cd86:	18fb      	adds	r3, r7, r3
    cd88:	0019      	movs	r1, r3
    cd8a:	200f      	movs	r0, #15
    cd8c:	4b0c      	ldr	r3, [pc, #48]	; (cdc0 <lcd_read_byte+0x19c>)
    cd8e:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA7, &pin_conf);  
    cd90:	2318      	movs	r3, #24
    cd92:	18fb      	adds	r3, r7, r3
    cd94:	0019      	movs	r1, r3
    cd96:	2009      	movs	r0, #9
    cd98:	4b09      	ldr	r3, [pc, #36]	; (cdc0 <lcd_read_byte+0x19c>)
    cd9a:	4798      	blx	r3
   //TRIS_LCD_DATA4(0);
   //TRIS_LCD_DATA5(0);
   //TRIS_LCD_DATA6(0);
   //TRIS_LCD_DATA7(0);

   return( (high<<4) | low);
    cd9c:	231f      	movs	r3, #31
    cd9e:	18fb      	adds	r3, r7, r3
    cda0:	781b      	ldrb	r3, [r3, #0]
    cda2:	011b      	lsls	r3, r3, #4
    cda4:	b25a      	sxtb	r2, r3
    cda6:	231e      	movs	r3, #30
    cda8:	18fb      	adds	r3, r7, r3
    cdaa:	781b      	ldrb	r3, [r3, #0]
    cdac:	b25b      	sxtb	r3, r3
    cdae:	4313      	orrs	r3, r2
    cdb0:	b25b      	sxtb	r3, r3
    cdb2:	b2db      	uxtb	r3, r3
}
    cdb4:	0018      	movs	r0, r3
    cdb6:	46bd      	mov	sp, r7
    cdb8:	b009      	add	sp, #36	; 0x24
    cdba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cdbc:	0000cb69 	.word	0x0000cb69
    cdc0:	0001355d 	.word	0x0001355d
    cdc4:	0000cbd1 	.word	0x0000cbd1
    cdc8:	00016909 	.word	0x00016909
    cdcc:	006acfbf 	.word	0x006acfbf
    cdd0:	0001d771 	.word	0x0001d771
    cdd4:	006acfc0 	.word	0x006acfc0
    cdd8:	20000001 	.word	0x20000001
    cddc:	0000cde1 	.word	0x0000cde1

0000cde0 <lcd_read_nibble>:

unsigned char lcd_read_nibble(void)
{
    cde0:	b580      	push	{r7, lr}
    cde2:	b082      	sub	sp, #8
    cde4:	af00      	add	r7, sp, #0
  //#if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
   unsigned char n = 0x00;
    cde6:	1dfb      	adds	r3, r7, #7
    cde8:	2200      	movs	r2, #0
    cdea:	701a      	strb	r2, [r3, #0]

   /* Read the data port */
   n |= port_pin_get_input_level(PORT_LCD_DATA4);
    cdec:	200c      	movs	r0, #12
    cdee:	4b1b      	ldr	r3, [pc, #108]	; (ce5c <lcd_read_nibble+0x7c>)
    cdf0:	4798      	blx	r3
    cdf2:	0003      	movs	r3, r0
    cdf4:	0019      	movs	r1, r3
    cdf6:	1dfb      	adds	r3, r7, #7
    cdf8:	1dfa      	adds	r2, r7, #7
    cdfa:	7812      	ldrb	r2, [r2, #0]
    cdfc:	430a      	orrs	r2, r1
    cdfe:	701a      	strb	r2, [r3, #0]
   n |= port_pin_get_input_level(PORT_LCD_DATA5) << 1;
    ce00:	200d      	movs	r0, #13
    ce02:	4b16      	ldr	r3, [pc, #88]	; (ce5c <lcd_read_nibble+0x7c>)
    ce04:	4798      	blx	r3
    ce06:	0003      	movs	r3, r0
    ce08:	005b      	lsls	r3, r3, #1
    ce0a:	b25a      	sxtb	r2, r3
    ce0c:	1dfb      	adds	r3, r7, #7
    ce0e:	781b      	ldrb	r3, [r3, #0]
    ce10:	b25b      	sxtb	r3, r3
    ce12:	4313      	orrs	r3, r2
    ce14:	b25a      	sxtb	r2, r3
    ce16:	1dfb      	adds	r3, r7, #7
    ce18:	701a      	strb	r2, [r3, #0]
   n |= port_pin_get_input_level(PORT_LCD_DATA6) << 2;
    ce1a:	200f      	movs	r0, #15
    ce1c:	4b0f      	ldr	r3, [pc, #60]	; (ce5c <lcd_read_nibble+0x7c>)
    ce1e:	4798      	blx	r3
    ce20:	0003      	movs	r3, r0
    ce22:	009b      	lsls	r3, r3, #2
    ce24:	b25a      	sxtb	r2, r3
    ce26:	1dfb      	adds	r3, r7, #7
    ce28:	781b      	ldrb	r3, [r3, #0]
    ce2a:	b25b      	sxtb	r3, r3
    ce2c:	4313      	orrs	r3, r2
    ce2e:	b25a      	sxtb	r2, r3
    ce30:	1dfb      	adds	r3, r7, #7
    ce32:	701a      	strb	r2, [r3, #0]
   n |= port_pin_get_input_level(PORT_LCD_DATA7) << 3;
    ce34:	2009      	movs	r0, #9
    ce36:	4b09      	ldr	r3, [pc, #36]	; (ce5c <lcd_read_nibble+0x7c>)
    ce38:	4798      	blx	r3
    ce3a:	0003      	movs	r3, r0
    ce3c:	00db      	lsls	r3, r3, #3
    ce3e:	b25a      	sxtb	r2, r3
    ce40:	1dfb      	adds	r3, r7, #7
    ce42:	781b      	ldrb	r3, [r3, #0]
    ce44:	b25b      	sxtb	r3, r3
    ce46:	4313      	orrs	r3, r2
    ce48:	b25a      	sxtb	r2, r3
    ce4a:	1dfb      	adds	r3, r7, #7
    ce4c:	701a      	strb	r2, [r3, #0]

   return(n);
    ce4e:	1dfb      	adds	r3, r7, #7
    ce50:	781b      	ldrb	r3, [r3, #0]
  //#else
   //return(lcd.data);
  //#endif
}
    ce52:	0018      	movs	r0, r3
    ce54:	46bd      	mov	sp, r7
    ce56:	b002      	add	sp, #8
    ce58:	bd80      	pop	{r7, pc}
    ce5a:	46c0      	nop			; (mov r8, r8)
    ce5c:	0000cb8d 	.word	0x0000cb8d

0000ce60 <lcd_send_nibble>:

static void lcd_send_nibble(unsigned char n)
{
    ce60:	b5f0      	push	{r4, r5, r6, r7, lr}
    ce62:	b085      	sub	sp, #20
    ce64:	af00      	add	r7, sp, #0
    ce66:	0002      	movs	r2, r0
    ce68:	230f      	movs	r3, #15
    ce6a:	18fb      	adds	r3, r7, r3
    ce6c:	701a      	strb	r2, [r3, #0]
   //output_bit(LCD_DATA5, bit_test(n, 1));
   //output_bit(LCD_DATA6, bit_test(n, 2));
   //output_bit(LCD_DATA7, bit_test(n, 3));
   
   //LCD_DATA4((n & (1<<0)) ? 1 : 0);
   port_pin_set_output_level(PORT_LCD_DATA4,(n & (1<<0)) ? 1 : 0);
    ce6e:	230f      	movs	r3, #15
    ce70:	18fb      	adds	r3, r7, r3
    ce72:	781b      	ldrb	r3, [r3, #0]
    ce74:	2201      	movs	r2, #1
    ce76:	4013      	ands	r3, r2
    ce78:	1e5a      	subs	r2, r3, #1
    ce7a:	4193      	sbcs	r3, r2
    ce7c:	b2db      	uxtb	r3, r3
    ce7e:	0019      	movs	r1, r3
    ce80:	200c      	movs	r0, #12
    ce82:	4b33      	ldr	r3, [pc, #204]	; (cf50 <lcd_send_nibble+0xf0>)
    ce84:	4798      	blx	r3
   //LCD_DATA5((n & (1<<1)) ? 1 : 0);
   port_pin_set_output_level(PORT_LCD_DATA5,(n & (1<<1)) ? 1 : 0);
    ce86:	230f      	movs	r3, #15
    ce88:	18fb      	adds	r3, r7, r3
    ce8a:	781b      	ldrb	r3, [r3, #0]
    ce8c:	2202      	movs	r2, #2
    ce8e:	4013      	ands	r3, r2
    ce90:	1e5a      	subs	r2, r3, #1
    ce92:	4193      	sbcs	r3, r2
    ce94:	b2db      	uxtb	r3, r3
    ce96:	0019      	movs	r1, r3
    ce98:	200d      	movs	r0, #13
    ce9a:	4b2d      	ldr	r3, [pc, #180]	; (cf50 <lcd_send_nibble+0xf0>)
    ce9c:	4798      	blx	r3
   //LCD_DATA6((n & (1<<2)) ? 1 : 0);
   port_pin_set_output_level(PORT_LCD_DATA6,(n & (1<<2)) ? 1 : 0);
    ce9e:	230f      	movs	r3, #15
    cea0:	18fb      	adds	r3, r7, r3
    cea2:	781b      	ldrb	r3, [r3, #0]
    cea4:	2204      	movs	r2, #4
    cea6:	4013      	ands	r3, r2
    cea8:	1e5a      	subs	r2, r3, #1
    ceaa:	4193      	sbcs	r3, r2
    ceac:	b2db      	uxtb	r3, r3
    ceae:	0019      	movs	r1, r3
    ceb0:	200f      	movs	r0, #15
    ceb2:	4b27      	ldr	r3, [pc, #156]	; (cf50 <lcd_send_nibble+0xf0>)
    ceb4:	4798      	blx	r3
   //LCD_DATA7((n & (1<<3)) ? 1 : 0);
   port_pin_set_output_level(PORT_LCD_DATA7,(n & (1<<3)) ? 1 : 0);
    ceb6:	230f      	movs	r3, #15
    ceb8:	18fb      	adds	r3, r7, r3
    ceba:	781b      	ldrb	r3, [r3, #0]
    cebc:	2208      	movs	r2, #8
    cebe:	4013      	ands	r3, r2
    cec0:	1e5a      	subs	r2, r3, #1
    cec2:	4193      	sbcs	r3, r2
    cec4:	b2db      	uxtb	r3, r3
    cec6:	0019      	movs	r1, r3
    cec8:	2009      	movs	r0, #9
    ceca:	4b21      	ldr	r3, [pc, #132]	; (cf50 <lcd_send_nibble+0xf0>)
    cecc:	4798      	blx	r3

   delay_us(1);
    cece:	2000      	movs	r0, #0
    ced0:	4b20      	ldr	r3, [pc, #128]	; (cf54 <lcd_send_nibble+0xf4>)
    ced2:	4798      	blx	r3
    ced4:	0003      	movs	r3, r0
    ced6:	603b      	str	r3, [r7, #0]
    ced8:	2300      	movs	r3, #0
    ceda:	607b      	str	r3, [r7, #4]
    cedc:	4a1e      	ldr	r2, [pc, #120]	; (cf58 <lcd_send_nibble+0xf8>)
    cede:	2300      	movs	r3, #0
    cee0:	6838      	ldr	r0, [r7, #0]
    cee2:	6879      	ldr	r1, [r7, #4]
    cee4:	1880      	adds	r0, r0, r2
    cee6:	4159      	adcs	r1, r3
    cee8:	4e1c      	ldr	r6, [pc, #112]	; (cf5c <lcd_send_nibble+0xfc>)
    ceea:	4a1d      	ldr	r2, [pc, #116]	; (cf60 <lcd_send_nibble+0x100>)
    ceec:	2300      	movs	r3, #0
    ceee:	47b0      	blx	r6
    cef0:	0002      	movs	r2, r0
    cef2:	000b      	movs	r3, r1
    cef4:	0013      	movs	r3, r2
    cef6:	0018      	movs	r0, r3
    cef8:	4b1a      	ldr	r3, [pc, #104]	; (cf64 <lcd_send_nibble+0x104>)
    cefa:	4798      	blx	r3
   //lcd_output_enable(1);
   port_pin_set_output_level(PORT_LCD_ENABLE_PIN,1);
    cefc:	2101      	movs	r1, #1
    cefe:	2002      	movs	r0, #2
    cf00:	4b13      	ldr	r3, [pc, #76]	; (cf50 <lcd_send_nibble+0xf0>)
    cf02:	4798      	blx	r3
   delay_us(2);
    cf04:	2000      	movs	r0, #0
    cf06:	4b13      	ldr	r3, [pc, #76]	; (cf54 <lcd_send_nibble+0xf4>)
    cf08:	4798      	blx	r3
    cf0a:	0003      	movs	r3, r0
    cf0c:	001c      	movs	r4, r3
    cf0e:	2300      	movs	r3, #0
    cf10:	001d      	movs	r5, r3
    cf12:	0022      	movs	r2, r4
    cf14:	002b      	movs	r3, r5
    cf16:	1912      	adds	r2, r2, r4
    cf18:	416b      	adcs	r3, r5
    cf1a:	001c      	movs	r4, r3
    cf1c:	0013      	movs	r3, r2
    cf1e:	0019      	movs	r1, r3
    cf20:	0022      	movs	r2, r4
    cf22:	4b0d      	ldr	r3, [pc, #52]	; (cf58 <lcd_send_nibble+0xf8>)
    cf24:	2400      	movs	r4, #0
    cf26:	18c9      	adds	r1, r1, r3
    cf28:	4162      	adcs	r2, r4
    cf2a:	0008      	movs	r0, r1
    cf2c:	0011      	movs	r1, r2
    cf2e:	4c0b      	ldr	r4, [pc, #44]	; (cf5c <lcd_send_nibble+0xfc>)
    cf30:	4a0b      	ldr	r2, [pc, #44]	; (cf60 <lcd_send_nibble+0x100>)
    cf32:	2300      	movs	r3, #0
    cf34:	47a0      	blx	r4
    cf36:	0003      	movs	r3, r0
    cf38:	000c      	movs	r4, r1
    cf3a:	0018      	movs	r0, r3
    cf3c:	4b09      	ldr	r3, [pc, #36]	; (cf64 <lcd_send_nibble+0x104>)
    cf3e:	4798      	blx	r3
   //lcd_output_enable(0);
   port_pin_set_output_level(PORT_LCD_ENABLE_PIN,0);
    cf40:	2100      	movs	r1, #0
    cf42:	2002      	movs	r0, #2
    cf44:	4b02      	ldr	r3, [pc, #8]	; (cf50 <lcd_send_nibble+0xf0>)
    cf46:	4798      	blx	r3
}
    cf48:	46c0      	nop			; (mov r8, r8)
    cf4a:	46bd      	mov	sp, r7
    cf4c:	b005      	add	sp, #20
    cf4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cf50:	0000cbd1 	.word	0x0000cbd1
    cf54:	00016909 	.word	0x00016909
    cf58:	006acfbf 	.word	0x006acfbf
    cf5c:	0001d771 	.word	0x0001d771
    cf60:	006acfc0 	.word	0x006acfc0
    cf64:	20000001 	.word	0x20000001

0000cf68 <lcd_send_byte>:

void lcd_send_byte(unsigned char address, unsigned char n)
{
    cf68:	b5f0      	push	{r4, r5, r6, r7, lr}
    cf6a:	b085      	sub	sp, #20
    cf6c:	af00      	add	r7, sp, #0
    cf6e:	0002      	movs	r2, r0
    cf70:	230f      	movs	r3, #15
    cf72:	18fb      	adds	r3, r7, r3
    cf74:	701a      	strb	r2, [r3, #0]
    cf76:	230e      	movs	r3, #14
    cf78:	18fb      	adds	r3, r7, r3
    cf7a:	1c0a      	adds	r2, r1, #0
    cf7c:	701a      	strb	r2, [r3, #0]
   //lcd_rs_tris();
   //lcd_rw_tris();
  //#endif

   //lcd_output_rs(0);
   port_pin_set_output_level(PORT_LCD_RS_PIN,0);
    cf7e:	2100      	movs	r1, #0
    cf80:	2003      	movs	r0, #3
    cf82:	4b2e      	ldr	r3, [pc, #184]	; (d03c <lcd_send_byte+0xd4>)
    cf84:	4798      	blx	r3
   while (lcd_read_byte() & (1<<7)) ;
    cf86:	46c0      	nop			; (mov r8, r8)
    cf88:	4b2d      	ldr	r3, [pc, #180]	; (d040 <lcd_send_byte+0xd8>)
    cf8a:	4798      	blx	r3
    cf8c:	0003      	movs	r3, r0
    cf8e:	b25b      	sxtb	r3, r3
    cf90:	2b00      	cmp	r3, #0
    cf92:	dbf9      	blt.n	cf88 <lcd_send_byte+0x20>
   //lcd_output_rs(address);
   port_pin_set_output_level(PORT_LCD_RS_PIN,address);
    cf94:	230f      	movs	r3, #15
    cf96:	18fb      	adds	r3, r7, r3
    cf98:	781b      	ldrb	r3, [r3, #0]
    cf9a:	1e5a      	subs	r2, r3, #1
    cf9c:	4193      	sbcs	r3, r2
    cf9e:	b2db      	uxtb	r3, r3
    cfa0:	0019      	movs	r1, r3
    cfa2:	2003      	movs	r0, #3
    cfa4:	4b25      	ldr	r3, [pc, #148]	; (d03c <lcd_send_byte+0xd4>)
    cfa6:	4798      	blx	r3
   delay_us(1);
    cfa8:	2000      	movs	r0, #0
    cfaa:	4b26      	ldr	r3, [pc, #152]	; (d044 <lcd_send_byte+0xdc>)
    cfac:	4798      	blx	r3
    cfae:	0003      	movs	r3, r0
    cfb0:	603b      	str	r3, [r7, #0]
    cfb2:	2300      	movs	r3, #0
    cfb4:	607b      	str	r3, [r7, #4]
    cfb6:	4b24      	ldr	r3, [pc, #144]	; (d048 <lcd_send_byte+0xe0>)
    cfb8:	2400      	movs	r4, #0
    cfba:	6838      	ldr	r0, [r7, #0]
    cfbc:	6879      	ldr	r1, [r7, #4]
    cfbe:	18c0      	adds	r0, r0, r3
    cfc0:	4161      	adcs	r1, r4
    cfc2:	4c22      	ldr	r4, [pc, #136]	; (d04c <lcd_send_byte+0xe4>)
    cfc4:	4a22      	ldr	r2, [pc, #136]	; (d050 <lcd_send_byte+0xe8>)
    cfc6:	2300      	movs	r3, #0
    cfc8:	47a0      	blx	r4
    cfca:	0003      	movs	r3, r0
    cfcc:	000c      	movs	r4, r1
    cfce:	0018      	movs	r0, r3
    cfd0:	4b20      	ldr	r3, [pc, #128]	; (d054 <lcd_send_byte+0xec>)
    cfd2:	4798      	blx	r3
   //lcd_output_rw(0);
   port_pin_set_output_level(PORT_LCD_RW_PIN,0);
    cfd4:	2100      	movs	r1, #0
    cfd6:	201b      	movs	r0, #27
    cfd8:	4b18      	ldr	r3, [pc, #96]	; (d03c <lcd_send_byte+0xd4>)
    cfda:	4798      	blx	r3
   delay_us(1);
    cfdc:	2000      	movs	r0, #0
    cfde:	4b19      	ldr	r3, [pc, #100]	; (d044 <lcd_send_byte+0xdc>)
    cfe0:	4798      	blx	r3
    cfe2:	0003      	movs	r3, r0
    cfe4:	001d      	movs	r5, r3
    cfe6:	2300      	movs	r3, #0
    cfe8:	001e      	movs	r6, r3
    cfea:	4b17      	ldr	r3, [pc, #92]	; (d048 <lcd_send_byte+0xe0>)
    cfec:	2400      	movs	r4, #0
    cfee:	0028      	movs	r0, r5
    cff0:	0031      	movs	r1, r6
    cff2:	18c0      	adds	r0, r0, r3
    cff4:	4161      	adcs	r1, r4
    cff6:	4c15      	ldr	r4, [pc, #84]	; (d04c <lcd_send_byte+0xe4>)
    cff8:	4a15      	ldr	r2, [pc, #84]	; (d050 <lcd_send_byte+0xe8>)
    cffa:	2300      	movs	r3, #0
    cffc:	47a0      	blx	r4
    cffe:	0003      	movs	r3, r0
    d000:	000c      	movs	r4, r1
    d002:	0018      	movs	r0, r3
    d004:	4b13      	ldr	r3, [pc, #76]	; (d054 <lcd_send_byte+0xec>)
    d006:	4798      	blx	r3
   //lcd_output_enable(0);
   port_pin_set_output_level(PORT_LCD_ENABLE_PIN,0);
    d008:	2100      	movs	r1, #0
    d00a:	2002      	movs	r0, #2
    d00c:	4b0b      	ldr	r3, [pc, #44]	; (d03c <lcd_send_byte+0xd4>)
    d00e:	4798      	blx	r3
   lcd_send_nibble(n >> 4);
    d010:	230e      	movs	r3, #14
    d012:	18fb      	adds	r3, r7, r3
    d014:	781b      	ldrb	r3, [r3, #0]
    d016:	091b      	lsrs	r3, r3, #4
    d018:	b2db      	uxtb	r3, r3
    d01a:	0018      	movs	r0, r3
    d01c:	4b0e      	ldr	r3, [pc, #56]	; (d058 <lcd_send_byte+0xf0>)
    d01e:	4798      	blx	r3
   lcd_send_nibble(n & 0xf);
    d020:	230e      	movs	r3, #14
    d022:	18fb      	adds	r3, r7, r3
    d024:	781b      	ldrb	r3, [r3, #0]
    d026:	220f      	movs	r2, #15
    d028:	4013      	ands	r3, r2
    d02a:	b2db      	uxtb	r3, r3
    d02c:	0018      	movs	r0, r3
    d02e:	4b0a      	ldr	r3, [pc, #40]	; (d058 <lcd_send_byte+0xf0>)
    d030:	4798      	blx	r3
}
    d032:	46c0      	nop			; (mov r8, r8)
    d034:	46bd      	mov	sp, r7
    d036:	b005      	add	sp, #20
    d038:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d03a:	46c0      	nop			; (mov r8, r8)
    d03c:	0000cbd1 	.word	0x0000cbd1
    d040:	0000cc25 	.word	0x0000cc25
    d044:	00016909 	.word	0x00016909
    d048:	006acfbf 	.word	0x006acfbf
    d04c:	0001d771 	.word	0x0001d771
    d050:	006acfc0 	.word	0x006acfc0
    d054:	20000001 	.word	0x20000001
    d058:	0000ce61 	.word	0x0000ce61

0000d05c <lcd_init>:
#if defined(LCD_EXTENDED_NEWLINE)
unsigned int8_t g_LcdX, g_LcdY;
#endif

void lcd_init(void)
{
    d05c:	b5f0      	push	{r4, r5, r6, r7, lr}
    d05e:	b08d      	sub	sp, #52	; 0x34
    d060:	af00      	add	r7, sp, #0
   //lcd_rs_tris();
   //lcd_rw_tris();
// #endif

   struct port_config pin_conf;
   port_get_config_defaults(&pin_conf);
    d062:	232c      	movs	r3, #44	; 0x2c
    d064:	18fb      	adds	r3, r7, r3
    d066:	0018      	movs	r0, r3
    d068:	4b84      	ldr	r3, [pc, #528]	; (d27c <lcd_init+0x220>)
    d06a:	4798      	blx	r3

	///* Configure LEDs as outputs, turn them off */
   pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    d06c:	232c      	movs	r3, #44	; 0x2c
    d06e:	18fa      	adds	r2, r7, r3
    d070:	2301      	movs	r3, #1
    d072:	7013      	strb	r3, [r2, #0]
   port_pin_set_config(PORT_LCD_RS_PIN, &pin_conf);
    d074:	232c      	movs	r3, #44	; 0x2c
    d076:	18fb      	adds	r3, r7, r3
    d078:	0019      	movs	r1, r3
    d07a:	2003      	movs	r0, #3
    d07c:	4b80      	ldr	r3, [pc, #512]	; (d280 <lcd_init+0x224>)
    d07e:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_RW_PIN, &pin_conf); 
    d080:	232c      	movs	r3, #44	; 0x2c
    d082:	18fb      	adds	r3, r7, r3
    d084:	0019      	movs	r1, r3
    d086:	201b      	movs	r0, #27
    d088:	4b7d      	ldr	r3, [pc, #500]	; (d280 <lcd_init+0x224>)
    d08a:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_ENABLE_PIN, &pin_conf);
    d08c:	232c      	movs	r3, #44	; 0x2c
    d08e:	18fb      	adds	r3, r7, r3
    d090:	0019      	movs	r1, r3
    d092:	2002      	movs	r0, #2
    d094:	4b7a      	ldr	r3, [pc, #488]	; (d280 <lcd_init+0x224>)
    d096:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA4, &pin_conf);
    d098:	232c      	movs	r3, #44	; 0x2c
    d09a:	18fb      	adds	r3, r7, r3
    d09c:	0019      	movs	r1, r3
    d09e:	200c      	movs	r0, #12
    d0a0:	4b77      	ldr	r3, [pc, #476]	; (d280 <lcd_init+0x224>)
    d0a2:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA5, &pin_conf);
    d0a4:	232c      	movs	r3, #44	; 0x2c
    d0a6:	18fb      	adds	r3, r7, r3
    d0a8:	0019      	movs	r1, r3
    d0aa:	200d      	movs	r0, #13
    d0ac:	4b74      	ldr	r3, [pc, #464]	; (d280 <lcd_init+0x224>)
    d0ae:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA6, &pin_conf);
    d0b0:	232c      	movs	r3, #44	; 0x2c
    d0b2:	18fb      	adds	r3, r7, r3
    d0b4:	0019      	movs	r1, r3
    d0b6:	200f      	movs	r0, #15
    d0b8:	4b71      	ldr	r3, [pc, #452]	; (d280 <lcd_init+0x224>)
    d0ba:	4798      	blx	r3
   port_pin_set_config(PORT_LCD_DATA7, &pin_conf);
    d0bc:	232c      	movs	r3, #44	; 0x2c
    d0be:	18fb      	adds	r3, r7, r3
    d0c0:	0019      	movs	r1, r3
    d0c2:	2009      	movs	r0, #9
    d0c4:	4b6e      	ldr	r3, [pc, #440]	; (d280 <lcd_init+0x224>)
    d0c6:	4798      	blx	r3
	
   //lcd_output_rs(0);
   port_pin_set_output_level(PORT_LCD_RS_PIN,0);
    d0c8:	2100      	movs	r1, #0
    d0ca:	2003      	movs	r0, #3
    d0cc:	4b6d      	ldr	r3, [pc, #436]	; (d284 <lcd_init+0x228>)
    d0ce:	4798      	blx	r3
   //lcd_output_rw(0);
   port_pin_set_output_level(PORT_LCD_RW_PIN,0);
    d0d0:	2100      	movs	r1, #0
    d0d2:	201b      	movs	r0, #27
    d0d4:	4b6b      	ldr	r3, [pc, #428]	; (d284 <lcd_init+0x228>)
    d0d6:	4798      	blx	r3
   //lcd_output_enable(0);
   port_pin_set_output_level(PORT_LCD_ENABLE_PIN,0);
    d0d8:	2100      	movs	r1, #0
    d0da:	2002      	movs	r0, #2
    d0dc:	4b69      	ldr	r3, [pc, #420]	; (d284 <lcd_init+0x228>)
    d0de:	4798      	blx	r3
   
   delay_ms(15);
    d0e0:	2000      	movs	r0, #0
    d0e2:	4b69      	ldr	r3, [pc, #420]	; (d288 <lcd_init+0x22c>)
    d0e4:	4798      	blx	r3
    d0e6:	0003      	movs	r3, r0
    d0e8:	613b      	str	r3, [r7, #16]
    d0ea:	2300      	movs	r3, #0
    d0ec:	617b      	str	r3, [r7, #20]
    d0ee:	6938      	ldr	r0, [r7, #16]
    d0f0:	6979      	ldr	r1, [r7, #20]
    d0f2:	0003      	movs	r3, r0
    d0f4:	000c      	movs	r4, r1
    d0f6:	0f1a      	lsrs	r2, r3, #28
    d0f8:	0126      	lsls	r6, r4, #4
    d0fa:	4316      	orrs	r6, r2
    d0fc:	011d      	lsls	r5, r3, #4
    d0fe:	002b      	movs	r3, r5
    d100:	0034      	movs	r4, r6
    d102:	000a      	movs	r2, r1
    d104:	0001      	movs	r1, r0
    d106:	1a5b      	subs	r3, r3, r1
    d108:	4194      	sbcs	r4, r2
    d10a:	4960      	ldr	r1, [pc, #384]	; (d28c <lcd_init+0x230>)
    d10c:	2200      	movs	r2, #0
    d10e:	185b      	adds	r3, r3, r1
    d110:	4154      	adcs	r4, r2
    d112:	0018      	movs	r0, r3
    d114:	0021      	movs	r1, r4
    d116:	4c5e      	ldr	r4, [pc, #376]	; (d290 <lcd_init+0x234>)
    d118:	4a5e      	ldr	r2, [pc, #376]	; (d294 <lcd_init+0x238>)
    d11a:	2300      	movs	r3, #0
    d11c:	47a0      	blx	r4
    d11e:	0003      	movs	r3, r0
    d120:	000c      	movs	r4, r1
    d122:	0018      	movs	r0, r3
    d124:	4b5c      	ldr	r3, [pc, #368]	; (d298 <lcd_init+0x23c>)
    d126:	4798      	blx	r3
   for(i=1;i<=3;++i)
    d128:	232f      	movs	r3, #47	; 0x2f
    d12a:	18fb      	adds	r3, r7, r3
    d12c:	2201      	movs	r2, #1
    d12e:	701a      	strb	r2, [r3, #0]
    d130:	e031      	b.n	d196 <lcd_init+0x13a>
   {
       lcd_send_nibble(3);
    d132:	2003      	movs	r0, #3
    d134:	4b59      	ldr	r3, [pc, #356]	; (d29c <lcd_init+0x240>)
    d136:	4798      	blx	r3
       delay_ms(5);
    d138:	2000      	movs	r0, #0
    d13a:	4b53      	ldr	r3, [pc, #332]	; (d288 <lcd_init+0x22c>)
    d13c:	4798      	blx	r3
    d13e:	0003      	movs	r3, r0
    d140:	60bb      	str	r3, [r7, #8]
    d142:	2300      	movs	r3, #0
    d144:	60fb      	str	r3, [r7, #12]
    d146:	68b8      	ldr	r0, [r7, #8]
    d148:	68f9      	ldr	r1, [r7, #12]
    d14a:	0003      	movs	r3, r0
    d14c:	000c      	movs	r4, r1
    d14e:	0f9a      	lsrs	r2, r3, #30
    d150:	00a5      	lsls	r5, r4, #2
    d152:	627d      	str	r5, [r7, #36]	; 0x24
    d154:	6a7d      	ldr	r5, [r7, #36]	; 0x24
    d156:	4315      	orrs	r5, r2
    d158:	627d      	str	r5, [r7, #36]	; 0x24
    d15a:	009b      	lsls	r3, r3, #2
    d15c:	623b      	str	r3, [r7, #32]
    d15e:	6a3b      	ldr	r3, [r7, #32]
    d160:	6a7c      	ldr	r4, [r7, #36]	; 0x24
    d162:	000a      	movs	r2, r1
    d164:	0001      	movs	r1, r0
    d166:	185b      	adds	r3, r3, r1
    d168:	4154      	adcs	r4, r2
    d16a:	4948      	ldr	r1, [pc, #288]	; (d28c <lcd_init+0x230>)
    d16c:	2200      	movs	r2, #0
    d16e:	185b      	adds	r3, r3, r1
    d170:	4154      	adcs	r4, r2
    d172:	0018      	movs	r0, r3
    d174:	0021      	movs	r1, r4
    d176:	4c46      	ldr	r4, [pc, #280]	; (d290 <lcd_init+0x234>)
    d178:	4a46      	ldr	r2, [pc, #280]	; (d294 <lcd_init+0x238>)
    d17a:	2300      	movs	r3, #0
    d17c:	47a0      	blx	r4
    d17e:	0003      	movs	r3, r0
    d180:	000c      	movs	r4, r1
    d182:	0018      	movs	r0, r3
    d184:	4b44      	ldr	r3, [pc, #272]	; (d298 <lcd_init+0x23c>)
    d186:	4798      	blx	r3
   port_pin_set_output_level(PORT_LCD_RW_PIN,0);
   //lcd_output_enable(0);
   port_pin_set_output_level(PORT_LCD_ENABLE_PIN,0);
   
   delay_ms(15);
   for(i=1;i<=3;++i)
    d188:	232f      	movs	r3, #47	; 0x2f
    d18a:	18fb      	adds	r3, r7, r3
    d18c:	222f      	movs	r2, #47	; 0x2f
    d18e:	18ba      	adds	r2, r7, r2
    d190:	7812      	ldrb	r2, [r2, #0]
    d192:	3201      	adds	r2, #1
    d194:	701a      	strb	r2, [r3, #0]
    d196:	232f      	movs	r3, #47	; 0x2f
    d198:	18fb      	adds	r3, r7, r3
    d19a:	781b      	ldrb	r3, [r3, #0]
    d19c:	2b03      	cmp	r3, #3
    d19e:	d9c8      	bls.n	d132 <lcd_init+0xd6>
   {
       lcd_send_nibble(3);
       delay_ms(5);
   }

   lcd_send_nibble(2);
    d1a0:	2002      	movs	r0, #2
    d1a2:	4b3e      	ldr	r3, [pc, #248]	; (d29c <lcd_init+0x240>)
    d1a4:	4798      	blx	r3
   delay_ms(5);
    d1a6:	2000      	movs	r0, #0
    d1a8:	4b37      	ldr	r3, [pc, #220]	; (d288 <lcd_init+0x22c>)
    d1aa:	4798      	blx	r3
    d1ac:	0003      	movs	r3, r0
    d1ae:	603b      	str	r3, [r7, #0]
    d1b0:	2300      	movs	r3, #0
    d1b2:	607b      	str	r3, [r7, #4]
    d1b4:	6838      	ldr	r0, [r7, #0]
    d1b6:	6879      	ldr	r1, [r7, #4]
    d1b8:	0003      	movs	r3, r0
    d1ba:	000c      	movs	r4, r1
    d1bc:	0f9a      	lsrs	r2, r3, #30
    d1be:	00a5      	lsls	r5, r4, #2
    d1c0:	61fd      	str	r5, [r7, #28]
    d1c2:	69fd      	ldr	r5, [r7, #28]
    d1c4:	4315      	orrs	r5, r2
    d1c6:	61fd      	str	r5, [r7, #28]
    d1c8:	009b      	lsls	r3, r3, #2
    d1ca:	61bb      	str	r3, [r7, #24]
    d1cc:	69bb      	ldr	r3, [r7, #24]
    d1ce:	69fc      	ldr	r4, [r7, #28]
    d1d0:	000a      	movs	r2, r1
    d1d2:	0001      	movs	r1, r0
    d1d4:	185b      	adds	r3, r3, r1
    d1d6:	4154      	adcs	r4, r2
    d1d8:	492c      	ldr	r1, [pc, #176]	; (d28c <lcd_init+0x230>)
    d1da:	2200      	movs	r2, #0
    d1dc:	185b      	adds	r3, r3, r1
    d1de:	4154      	adcs	r4, r2
    d1e0:	0018      	movs	r0, r3
    d1e2:	0021      	movs	r1, r4
    d1e4:	4c2a      	ldr	r4, [pc, #168]	; (d290 <lcd_init+0x234>)
    d1e6:	4a2b      	ldr	r2, [pc, #172]	; (d294 <lcd_init+0x238>)
    d1e8:	2300      	movs	r3, #0
    d1ea:	47a0      	blx	r4
    d1ec:	0003      	movs	r3, r0
    d1ee:	000c      	movs	r4, r1
    d1f0:	0018      	movs	r0, r3
    d1f2:	4b29      	ldr	r3, [pc, #164]	; (d298 <lcd_init+0x23c>)
    d1f4:	4798      	blx	r3
   for(i=0;i<=3;++i)
    d1f6:	232f      	movs	r3, #47	; 0x2f
    d1f8:	18fb      	adds	r3, r7, r3
    d1fa:	2200      	movs	r2, #0
    d1fc:	701a      	strb	r2, [r3, #0]
    d1fe:	e00f      	b.n	d220 <lcd_init+0x1c4>
      lcd_send_byte(0,LCD_INIT_STRING[i]);
    d200:	232f      	movs	r3, #47	; 0x2f
    d202:	18fb      	adds	r3, r7, r3
    d204:	781b      	ldrb	r3, [r3, #0]
    d206:	4a26      	ldr	r2, [pc, #152]	; (d2a0 <lcd_init+0x244>)
    d208:	5cd3      	ldrb	r3, [r2, r3]
    d20a:	0019      	movs	r1, r3
    d20c:	2000      	movs	r0, #0
    d20e:	4b25      	ldr	r3, [pc, #148]	; (d2a4 <lcd_init+0x248>)
    d210:	4798      	blx	r3
       delay_ms(5);
   }

   lcd_send_nibble(2);
   delay_ms(5);
   for(i=0;i<=3;++i)
    d212:	232f      	movs	r3, #47	; 0x2f
    d214:	18fb      	adds	r3, r7, r3
    d216:	222f      	movs	r2, #47	; 0x2f
    d218:	18ba      	adds	r2, r7, r2
    d21a:	7812      	ldrb	r2, [r2, #0]
    d21c:	3201      	adds	r2, #1
    d21e:	701a      	strb	r2, [r3, #0]
    d220:	232f      	movs	r3, #47	; 0x2f
    d222:	18fb      	adds	r3, r7, r3
    d224:	781b      	ldrb	r3, [r3, #0]
    d226:	2b03      	cmp	r3, #3
    d228:	d9ea      	bls.n	d200 <lcd_init+0x1a4>
  #if defined(LCD_EXTENDED_NEWLINE)
   g_LcdX = 0;
   g_LcdY = 0;
  #endif
  
  lcd_set_cgram_char(0,pt[0]);
    d22a:	4b1f      	ldr	r3, [pc, #124]	; (d2a8 <lcd_init+0x24c>)
    d22c:	0019      	movs	r1, r3
    d22e:	2000      	movs	r0, #0
    d230:	4b1e      	ldr	r3, [pc, #120]	; (d2ac <lcd_init+0x250>)
    d232:	4798      	blx	r3
  lcd_set_cgram_char(1,pt[1]);
    d234:	4b1e      	ldr	r3, [pc, #120]	; (d2b0 <lcd_init+0x254>)
    d236:	0019      	movs	r1, r3
    d238:	2001      	movs	r0, #1
    d23a:	4b1c      	ldr	r3, [pc, #112]	; (d2ac <lcd_init+0x250>)
    d23c:	4798      	blx	r3
  lcd_set_cgram_char(2,pt[2]);
    d23e:	4b1d      	ldr	r3, [pc, #116]	; (d2b4 <lcd_init+0x258>)
    d240:	0019      	movs	r1, r3
    d242:	2002      	movs	r0, #2
    d244:	4b19      	ldr	r3, [pc, #100]	; (d2ac <lcd_init+0x250>)
    d246:	4798      	blx	r3
  lcd_set_cgram_char(3,pt[3]);
    d248:	4b1b      	ldr	r3, [pc, #108]	; (d2b8 <lcd_init+0x25c>)
    d24a:	0019      	movs	r1, r3
    d24c:	2003      	movs	r0, #3
    d24e:	4b17      	ldr	r3, [pc, #92]	; (d2ac <lcd_init+0x250>)
    d250:	4798      	blx	r3
  lcd_set_cgram_char(4,pt[4]);
    d252:	4b1a      	ldr	r3, [pc, #104]	; (d2bc <lcd_init+0x260>)
    d254:	0019      	movs	r1, r3
    d256:	2004      	movs	r0, #4
    d258:	4b14      	ldr	r3, [pc, #80]	; (d2ac <lcd_init+0x250>)
    d25a:	4798      	blx	r3
  lcd_set_cgram_char(5,pt[5]);
    d25c:	4b18      	ldr	r3, [pc, #96]	; (d2c0 <lcd_init+0x264>)
    d25e:	0019      	movs	r1, r3
    d260:	2005      	movs	r0, #5
    d262:	4b12      	ldr	r3, [pc, #72]	; (d2ac <lcd_init+0x250>)
    d264:	4798      	blx	r3
  
  memset(LCDData,0x00,sizeof(LCDData));
    d266:	4b17      	ldr	r3, [pc, #92]	; (d2c4 <lcd_init+0x268>)
    d268:	2222      	movs	r2, #34	; 0x22
    d26a:	2100      	movs	r1, #0
    d26c:	0018      	movs	r0, r3
    d26e:	4b16      	ldr	r3, [pc, #88]	; (d2c8 <lcd_init+0x26c>)
    d270:	4798      	blx	r3
  
}
    d272:	46c0      	nop			; (mov r8, r8)
    d274:	46bd      	mov	sp, r7
    d276:	b00d      	add	sp, #52	; 0x34
    d278:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d27a:	46c0      	nop			; (mov r8, r8)
    d27c:	0000cb69 	.word	0x0000cb69
    d280:	0001355d 	.word	0x0001355d
    d284:	0000cbd1 	.word	0x0000cbd1
    d288:	00016909 	.word	0x00016909
    d28c:	00001b57 	.word	0x00001b57
    d290:	0001d771 	.word	0x0001d771
    d294:	00001b58 	.word	0x00001b58
    d298:	20000001 	.word	0x20000001
    d29c:	0000ce61 	.word	0x0000ce61
    d2a0:	00020e00 	.word	0x00020e00
    d2a4:	0000cf69 	.word	0x0000cf69
    d2a8:	00020dd0 	.word	0x00020dd0
    d2ac:	0000d359 	.word	0x0000d359
    d2b0:	00020dd8 	.word	0x00020dd8
    d2b4:	00020de0 	.word	0x00020de0
    d2b8:	00020de8 	.word	0x00020de8
    d2bc:	00020df0 	.word	0x00020df0
    d2c0:	00020df8 	.word	0x00020df8
    d2c4:	20004aac 	.word	0x20004aac
    d2c8:	0001eead 	.word	0x0001eead

0000d2cc <lcd_gotoxy>:

void lcd_gotoxy(unsigned char x, unsigned char y)
{
    d2cc:	b580      	push	{r7, lr}
    d2ce:	b084      	sub	sp, #16
    d2d0:	af00      	add	r7, sp, #0
    d2d2:	0002      	movs	r2, r0
    d2d4:	1dfb      	adds	r3, r7, #7
    d2d6:	701a      	strb	r2, [r3, #0]
    d2d8:	1dbb      	adds	r3, r7, #6
    d2da:	1c0a      	adds	r2, r1, #0
    d2dc:	701a      	strb	r2, [r3, #0]
   unsigned char address;

   switch (y)
    d2de:	1dbb      	adds	r3, r7, #6
    d2e0:	781b      	ldrb	r3, [r3, #0]
    d2e2:	2b01      	cmp	r3, #1
    d2e4:	d00d      	beq.n	d302 <lcd_gotoxy+0x36>
    d2e6:	dc02      	bgt.n	d2ee <lcd_gotoxy+0x22>
    d2e8:	2b00      	cmp	r3, #0
    d2ea:	d005      	beq.n	d2f8 <lcd_gotoxy+0x2c>
    d2ec:	e018      	b.n	d320 <lcd_gotoxy+0x54>
    d2ee:	2b02      	cmp	r3, #2
    d2f0:	d00c      	beq.n	d30c <lcd_gotoxy+0x40>
    d2f2:	2b03      	cmp	r3, #3
    d2f4:	d00f      	beq.n	d316 <lcd_gotoxy+0x4a>
    d2f6:	e013      	b.n	d320 <lcd_gotoxy+0x54>
   {
    case 0x00: address=0x00; break;
    d2f8:	230f      	movs	r3, #15
    d2fa:	18fb      	adds	r3, r7, r3
    d2fc:	2200      	movs	r2, #0
    d2fe:	701a      	strb	r2, [r3, #0]
    d300:	e00e      	b.n	d320 <lcd_gotoxy+0x54>
    case 0x01: address=0x40; break;
    d302:	230f      	movs	r3, #15
    d304:	18fb      	adds	r3, r7, r3
    d306:	2240      	movs	r2, #64	; 0x40
    d308:	701a      	strb	r2, [r3, #0]
    d30a:	e009      	b.n	d320 <lcd_gotoxy+0x54>
    case 0x02: address=0x10; break;
    d30c:	230f      	movs	r3, #15
    d30e:	18fb      	adds	r3, r7, r3
    d310:	2210      	movs	r2, #16
    d312:	701a      	strb	r2, [r3, #0]
    d314:	e004      	b.n	d320 <lcd_gotoxy+0x54>
    case 0x03: address=0x50; break;
    d316:	230f      	movs	r3, #15
    d318:	18fb      	adds	r3, r7, r3
    d31a:	2250      	movs	r2, #80	; 0x50
    d31c:	701a      	strb	r2, [r3, #0]
    d31e:	46c0      	nop			; (mov r8, r8)
   //if(y!=1)
   //   address=LCD_LINE_TWO;
   //else
   //   address=0;

   address+=x-1;
    d320:	1dfa      	adds	r2, r7, #7
    d322:	230f      	movs	r3, #15
    d324:	18fb      	adds	r3, r7, r3
    d326:	7812      	ldrb	r2, [r2, #0]
    d328:	781b      	ldrb	r3, [r3, #0]
    d32a:	18d3      	adds	r3, r2, r3
    d32c:	b2da      	uxtb	r2, r3
    d32e:	230f      	movs	r3, #15
    d330:	18fb      	adds	r3, r7, r3
    d332:	3a01      	subs	r2, #1
    d334:	701a      	strb	r2, [r3, #0]
   lcd_send_byte(0,0x80|address);
    d336:	230f      	movs	r3, #15
    d338:	18fb      	adds	r3, r7, r3
    d33a:	781b      	ldrb	r3, [r3, #0]
    d33c:	2280      	movs	r2, #128	; 0x80
    d33e:	4252      	negs	r2, r2
    d340:	4313      	orrs	r3, r2
    d342:	b2db      	uxtb	r3, r3
    d344:	0019      	movs	r1, r3
    d346:	2000      	movs	r0, #0
    d348:	4b02      	ldr	r3, [pc, #8]	; (d354 <lcd_gotoxy+0x88>)
    d34a:	4798      	blx	r3

  #if defined(LCD_EXTENDED_NEWLINE)
   g_LcdX = x - 1;
   g_LcdY = y - 1;
  #endif
}
    d34c:	46c0      	nop			; (mov r8, r8)
    d34e:	46bd      	mov	sp, r7
    d350:	b004      	add	sp, #16
    d352:	bd80      	pop	{r7, pc}
    d354:	0000cf69 	.word	0x0000cf69

0000d358 <lcd_set_cgram_char>:
// ptr points to an array of 8 bytes, where each byte is the next row of
//    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
//    usually you will want to leave this byte 0x00.

void lcd_set_cgram_char(unsigned char which, char const *ptr)
{
    d358:	b580      	push	{r7, lr}
    d35a:	b084      	sub	sp, #16
    d35c:	af00      	add	r7, sp, #0
    d35e:	0002      	movs	r2, r0
    d360:	6039      	str	r1, [r7, #0]
    d362:	1dfb      	adds	r3, r7, #7
    d364:	701a      	strb	r2, [r3, #0]
   unsigned int i;

   which <<= 3;
    d366:	1dfb      	adds	r3, r7, #7
    d368:	1dfa      	adds	r2, r7, #7
    d36a:	7812      	ldrb	r2, [r2, #0]
    d36c:	00d2      	lsls	r2, r2, #3
    d36e:	701a      	strb	r2, [r3, #0]
   which &= 0x38;
    d370:	1dfb      	adds	r3, r7, #7
    d372:	1dfa      	adds	r2, r7, #7
    d374:	7812      	ldrb	r2, [r2, #0]
    d376:	2138      	movs	r1, #56	; 0x38
    d378:	400a      	ands	r2, r1
    d37a:	701a      	strb	r2, [r3, #0]

   lcd_send_byte(0, 0x40 | which);  //set cgram address
    d37c:	1dfb      	adds	r3, r7, #7
    d37e:	781b      	ldrb	r3, [r3, #0]
    d380:	2240      	movs	r2, #64	; 0x40
    d382:	4313      	orrs	r3, r2
    d384:	b2db      	uxtb	r3, r3
    d386:	0019      	movs	r1, r3
    d388:	2000      	movs	r0, #0
    d38a:	4b0b      	ldr	r3, [pc, #44]	; (d3b8 <lcd_set_cgram_char+0x60>)
    d38c:	4798      	blx	r3

   for(i=0; i<8; i++)
    d38e:	2300      	movs	r3, #0
    d390:	60fb      	str	r3, [r7, #12]
    d392:	e00a      	b.n	d3aa <lcd_set_cgram_char+0x52>
   {
      lcd_send_byte(1, *ptr++);
    d394:	683b      	ldr	r3, [r7, #0]
    d396:	1c5a      	adds	r2, r3, #1
    d398:	603a      	str	r2, [r7, #0]
    d39a:	781b      	ldrb	r3, [r3, #0]
    d39c:	0019      	movs	r1, r3
    d39e:	2001      	movs	r0, #1
    d3a0:	4b05      	ldr	r3, [pc, #20]	; (d3b8 <lcd_set_cgram_char+0x60>)
    d3a2:	4798      	blx	r3
   which <<= 3;
   which &= 0x38;

   lcd_send_byte(0, 0x40 | which);  //set cgram address

   for(i=0; i<8; i++)
    d3a4:	68fb      	ldr	r3, [r7, #12]
    d3a6:	3301      	adds	r3, #1
    d3a8:	60fb      	str	r3, [r7, #12]
    d3aa:	68fb      	ldr	r3, [r7, #12]
    d3ac:	2b07      	cmp	r3, #7
    d3ae:	d9f1      	bls.n	d394 <lcd_set_cgram_char+0x3c>
   }

   #if defined(LCD_EXTENDED_NEWLINE)
    lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
   #endif
}
    d3b0:	46c0      	nop			; (mov r8, r8)
    d3b2:	46bd      	mov	sp, r7
    d3b4:	b004      	add	sp, #16
    d3b6:	bd80      	pop	{r7, pc}
    d3b8:	0000cf69 	.word	0x0000cf69

0000d3bc <vLCDUpdate>:
      //lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
   //}
//}

void vLCDUpdate()
{
    d3bc:	b580      	push	{r7, lr}
    d3be:	b082      	sub	sp, #8
    d3c0:	af00      	add	r7, sp, #0
    //static uint8_t ucRow=0;

    lcd_gotoxy(1,0);
    d3c2:	2100      	movs	r1, #0
    d3c4:	2001      	movs	r0, #1
    d3c6:	4b26      	ldr	r3, [pc, #152]	; (d460 <vLCDUpdate+0xa4>)
    d3c8:	4798      	blx	r3
    for (uint8_t i=0;i<0x10;i++)
    d3ca:	1dfb      	adds	r3, r7, #7
    d3cc:	2200      	movs	r2, #0
    d3ce:	701a      	strb	r2, [r3, #0]
    d3d0:	e017      	b.n	d402 <vLCDUpdate+0x46>
    {
        if (!LCDData[0][i]) LCDData[0][i]=0x20;
    d3d2:	1dfb      	adds	r3, r7, #7
    d3d4:	781b      	ldrb	r3, [r3, #0]
    d3d6:	4a23      	ldr	r2, [pc, #140]	; (d464 <vLCDUpdate+0xa8>)
    d3d8:	5cd3      	ldrb	r3, [r2, r3]
    d3da:	2b00      	cmp	r3, #0
    d3dc:	d104      	bne.n	d3e8 <vLCDUpdate+0x2c>
    d3de:	1dfb      	adds	r3, r7, #7
    d3e0:	781b      	ldrb	r3, [r3, #0]
    d3e2:	4a20      	ldr	r2, [pc, #128]	; (d464 <vLCDUpdate+0xa8>)
    d3e4:	2120      	movs	r1, #32
    d3e6:	54d1      	strb	r1, [r2, r3]
     lcd_send_byte (1,LCDData[0][i]);
    d3e8:	1dfb      	adds	r3, r7, #7
    d3ea:	781b      	ldrb	r3, [r3, #0]
    d3ec:	4a1d      	ldr	r2, [pc, #116]	; (d464 <vLCDUpdate+0xa8>)
    d3ee:	5cd3      	ldrb	r3, [r2, r3]
    d3f0:	0019      	movs	r1, r3
    d3f2:	2001      	movs	r0, #1
    d3f4:	4b1c      	ldr	r3, [pc, #112]	; (d468 <vLCDUpdate+0xac>)
    d3f6:	4798      	blx	r3
void vLCDUpdate()
{
    //static uint8_t ucRow=0;

    lcd_gotoxy(1,0);
    for (uint8_t i=0;i<0x10;i++)
    d3f8:	1dfb      	adds	r3, r7, #7
    d3fa:	781a      	ldrb	r2, [r3, #0]
    d3fc:	1dfb      	adds	r3, r7, #7
    d3fe:	3201      	adds	r2, #1
    d400:	701a      	strb	r2, [r3, #0]
    d402:	1dfb      	adds	r3, r7, #7
    d404:	781b      	ldrb	r3, [r3, #0]
    d406:	2b0f      	cmp	r3, #15
    d408:	d9e3      	bls.n	d3d2 <vLCDUpdate+0x16>
    {
        if (!LCDData[0][i]) LCDData[0][i]=0x20;
     lcd_send_byte (1,LCDData[0][i]);
    }
    lcd_gotoxy(1,1);
    d40a:	2101      	movs	r1, #1
    d40c:	2001      	movs	r0, #1
    d40e:	4b14      	ldr	r3, [pc, #80]	; (d460 <vLCDUpdate+0xa4>)
    d410:	4798      	blx	r3
    for (uint8_t i=0;i<0x10;i++)
    d412:	1dbb      	adds	r3, r7, #6
    d414:	2200      	movs	r2, #0
    d416:	701a      	strb	r2, [r3, #0]
    d418:	e01a      	b.n	d450 <vLCDUpdate+0x94>
    {
        if (!LCDData[1][i]) LCDData[1][i]=0x20;
    d41a:	1dbb      	adds	r3, r7, #6
    d41c:	781b      	ldrb	r3, [r3, #0]
    d41e:	4a11      	ldr	r2, [pc, #68]	; (d464 <vLCDUpdate+0xa8>)
    d420:	18d3      	adds	r3, r2, r3
    d422:	7c5b      	ldrb	r3, [r3, #17]
    d424:	2b00      	cmp	r3, #0
    d426:	d105      	bne.n	d434 <vLCDUpdate+0x78>
    d428:	1dbb      	adds	r3, r7, #6
    d42a:	781b      	ldrb	r3, [r3, #0]
    d42c:	4a0d      	ldr	r2, [pc, #52]	; (d464 <vLCDUpdate+0xa8>)
    d42e:	18d3      	adds	r3, r2, r3
    d430:	2220      	movs	r2, #32
    d432:	745a      	strb	r2, [r3, #17]
     lcd_send_byte (1,LCDData[1][i]);
    d434:	1dbb      	adds	r3, r7, #6
    d436:	781b      	ldrb	r3, [r3, #0]
    d438:	4a0a      	ldr	r2, [pc, #40]	; (d464 <vLCDUpdate+0xa8>)
    d43a:	18d3      	adds	r3, r2, r3
    d43c:	7c5b      	ldrb	r3, [r3, #17]
    d43e:	0019      	movs	r1, r3
    d440:	2001      	movs	r0, #1
    d442:	4b09      	ldr	r3, [pc, #36]	; (d468 <vLCDUpdate+0xac>)
    d444:	4798      	blx	r3
    {
        if (!LCDData[0][i]) LCDData[0][i]=0x20;
     lcd_send_byte (1,LCDData[0][i]);
    }
    lcd_gotoxy(1,1);
    for (uint8_t i=0;i<0x10;i++)
    d446:	1dbb      	adds	r3, r7, #6
    d448:	781a      	ldrb	r2, [r3, #0]
    d44a:	1dbb      	adds	r3, r7, #6
    d44c:	3201      	adds	r2, #1
    d44e:	701a      	strb	r2, [r3, #0]
    d450:	1dbb      	adds	r3, r7, #6
    d452:	781b      	ldrb	r3, [r3, #0]
    d454:	2b0f      	cmp	r3, #15
    d456:	d9e0      	bls.n	d41a <vLCDUpdate+0x5e>
    {
        if (!LCDData[1][i]) LCDData[1][i]=0x20;
     lcd_send_byte (1,LCDData[1][i]);
    }  

}
    d458:	46c0      	nop			; (mov r8, r8)
    d45a:	46bd      	mov	sp, r7
    d45c:	b002      	add	sp, #8
    d45e:	bd80      	pop	{r7, pc}
    d460:	0000d2cd 	.word	0x0000d2cd
    d464:	20004aac 	.word	0x20004aac
    d468:	0000cf69 	.word	0x0000cf69

0000d46c <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    d46c:	b580      	push	{r7, lr}
    d46e:	b084      	sub	sp, #16
    d470:	af00      	add	r7, sp, #0
    d472:	0002      	movs	r2, r0
    d474:	1dfb      	adds	r3, r7, #7
    d476:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    d478:	230f      	movs	r3, #15
    d47a:	18fb      	adds	r3, r7, r3
    d47c:	1dfa      	adds	r2, r7, #7
    d47e:	7812      	ldrb	r2, [r2, #0]
    d480:	09d2      	lsrs	r2, r2, #7
    d482:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    d484:	230e      	movs	r3, #14
    d486:	18fb      	adds	r3, r7, r3
    d488:	1dfa      	adds	r2, r7, #7
    d48a:	7812      	ldrb	r2, [r2, #0]
    d48c:	0952      	lsrs	r2, r2, #5
    d48e:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    d490:	4b0d      	ldr	r3, [pc, #52]	; (d4c8 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    d492:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    d494:	230f      	movs	r3, #15
    d496:	18fb      	adds	r3, r7, r3
    d498:	781b      	ldrb	r3, [r3, #0]
    d49a:	2b00      	cmp	r3, #0
    d49c:	d10f      	bne.n	d4be <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    d49e:	230f      	movs	r3, #15
    d4a0:	18fb      	adds	r3, r7, r3
    d4a2:	781b      	ldrb	r3, [r3, #0]
    d4a4:	009b      	lsls	r3, r3, #2
    d4a6:	2210      	movs	r2, #16
    d4a8:	4694      	mov	ip, r2
    d4aa:	44bc      	add	ip, r7
    d4ac:	4463      	add	r3, ip
    d4ae:	3b08      	subs	r3, #8
    d4b0:	681a      	ldr	r2, [r3, #0]
    d4b2:	230e      	movs	r3, #14
    d4b4:	18fb      	adds	r3, r7, r3
    d4b6:	781b      	ldrb	r3, [r3, #0]
    d4b8:	01db      	lsls	r3, r3, #7
    d4ba:	18d3      	adds	r3, r2, r3
    d4bc:	e000      	b.n	d4c0 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    d4be:	2300      	movs	r3, #0
	}
}
    d4c0:	0018      	movs	r0, r3
    d4c2:	46bd      	mov	sp, r7
    d4c4:	b004      	add	sp, #16
    d4c6:	bd80      	pop	{r7, pc}
    d4c8:	41004400 	.word	0x41004400

0000d4cc <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    d4cc:	b580      	push	{r7, lr}
    d4ce:	b082      	sub	sp, #8
    d4d0:	af00      	add	r7, sp, #0
    d4d2:	0002      	movs	r2, r0
    d4d4:	1dfb      	adds	r3, r7, #7
    d4d6:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    d4d8:	1dfb      	adds	r3, r7, #7
    d4da:	781b      	ldrb	r3, [r3, #0]
    d4dc:	0018      	movs	r0, r3
    d4de:	4b03      	ldr	r3, [pc, #12]	; (d4ec <port_get_group_from_gpio_pin+0x20>)
    d4e0:	4798      	blx	r3
    d4e2:	0003      	movs	r3, r0
}
    d4e4:	0018      	movs	r0, r3
    d4e6:	46bd      	mov	sp, r7
    d4e8:	b002      	add	sp, #8
    d4ea:	bd80      	pop	{r7, pc}
    d4ec:	0000d46d 	.word	0x0000d46d

0000d4f0 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    d4f0:	b580      	push	{r7, lr}
    d4f2:	b084      	sub	sp, #16
    d4f4:	af00      	add	r7, sp, #0
    d4f6:	0002      	movs	r2, r0
    d4f8:	1dfb      	adds	r3, r7, #7
    d4fa:	701a      	strb	r2, [r3, #0]
    d4fc:	1dbb      	adds	r3, r7, #6
    d4fe:	1c0a      	adds	r2, r1, #0
    d500:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    d502:	1dfb      	adds	r3, r7, #7
    d504:	781b      	ldrb	r3, [r3, #0]
    d506:	0018      	movs	r0, r3
    d508:	4b0d      	ldr	r3, [pc, #52]	; (d540 <port_pin_set_output_level+0x50>)
    d50a:	4798      	blx	r3
    d50c:	0003      	movs	r3, r0
    d50e:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    d510:	1dfb      	adds	r3, r7, #7
    d512:	781b      	ldrb	r3, [r3, #0]
    d514:	221f      	movs	r2, #31
    d516:	4013      	ands	r3, r2
    d518:	2201      	movs	r2, #1
    d51a:	409a      	lsls	r2, r3
    d51c:	0013      	movs	r3, r2
    d51e:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    d520:	1dbb      	adds	r3, r7, #6
    d522:	781b      	ldrb	r3, [r3, #0]
    d524:	2b00      	cmp	r3, #0
    d526:	d003      	beq.n	d530 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    d528:	68fb      	ldr	r3, [r7, #12]
    d52a:	68ba      	ldr	r2, [r7, #8]
    d52c:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    d52e:	e002      	b.n	d536 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    d530:	68fb      	ldr	r3, [r7, #12]
    d532:	68ba      	ldr	r2, [r7, #8]
    d534:	615a      	str	r2, [r3, #20]
	}
}
    d536:	46c0      	nop			; (mov r8, r8)
    d538:	46bd      	mov	sp, r7
    d53a:	b004      	add	sp, #16
    d53c:	bd80      	pop	{r7, pc}
    d53e:	46c0      	nop			; (mov r8, r8)
    d540:	0000d4cd 	.word	0x0000d4cd

0000d544 <rtc_calendar_get_time_defaults>:
 *
 * \param[out] time  Time structure to initialize
 */
static inline void rtc_calendar_get_time_defaults(
		struct rtc_calendar_time *const time)
{
    d544:	b580      	push	{r7, lr}
    d546:	b082      	sub	sp, #8
    d548:	af00      	add	r7, sp, #0
    d54a:	6078      	str	r0, [r7, #4]
	time->second = 0;
    d54c:	687b      	ldr	r3, [r7, #4]
    d54e:	2200      	movs	r2, #0
    d550:	701a      	strb	r2, [r3, #0]
	time->minute = 0;
    d552:	687b      	ldr	r3, [r7, #4]
    d554:	2200      	movs	r2, #0
    d556:	705a      	strb	r2, [r3, #1]
	time->hour   = 0;
    d558:	687b      	ldr	r3, [r7, #4]
    d55a:	2200      	movs	r2, #0
    d55c:	709a      	strb	r2, [r3, #2]
	time->pm     = 0;
    d55e:	687b      	ldr	r3, [r7, #4]
    d560:	2200      	movs	r2, #0
    d562:	70da      	strb	r2, [r3, #3]
	time->day    = 1;
    d564:	687b      	ldr	r3, [r7, #4]
    d566:	2201      	movs	r2, #1
    d568:	711a      	strb	r2, [r3, #4]
	time->month  = 1;
    d56a:	687b      	ldr	r3, [r7, #4]
    d56c:	2201      	movs	r2, #1
    d56e:	715a      	strb	r2, [r3, #5]
	time->year   = 2000;
    d570:	687b      	ldr	r3, [r7, #4]
    d572:	22fa      	movs	r2, #250	; 0xfa
    d574:	00d2      	lsls	r2, r2, #3
    d576:	80da      	strh	r2, [r3, #6]
}
    d578:	46c0      	nop			; (mov r8, r8)
    d57a:	46bd      	mov	sp, r7
    d57c:	b002      	add	sp, #8
    d57e:	bd80      	pop	{r7, pc}

0000d580 <RTC_WriteRegister>:
//} 

//////////////////////////////////////////////////////////////////////////////

void RTC_WriteRegister(uint8_t reg, uint8_t value) 
{
    d580:	b580      	push	{r7, lr}
    d582:	b084      	sub	sp, #16
    d584:	af00      	add	r7, sp, #0
    d586:	0002      	movs	r2, r0
    d588:	1dfb      	adds	r3, r7, #7
    d58a:	701a      	strb	r2, [r3, #0]
    d58c:	1dbb      	adds	r3, r7, #6
    d58e:	1c0a      	adds	r2, r1, #0
    d590:	701a      	strb	r2, [r3, #0]
	uint16_t LocalValue;

	port_pin_set_output_level(RTC_CS,false);
    d592:	2100      	movs	r1, #0
    d594:	202a      	movs	r0, #42	; 0x2a
    d596:	4b11      	ldr	r3, [pc, #68]	; (d5dc <RTC_WriteRegister+0x5c>)
    d598:	4798      	blx	r3
	spi_transceive_wait(&service_spi_master_instance,REG_WRITE,&LocalValue);
    d59a:	230e      	movs	r3, #14
    d59c:	18fa      	adds	r2, r7, r3
    d59e:	4b10      	ldr	r3, [pc, #64]	; (d5e0 <RTC_WriteRegister+0x60>)
    d5a0:	2112      	movs	r1, #18
    d5a2:	0018      	movs	r0, r3
    d5a4:	4b0f      	ldr	r3, [pc, #60]	; (d5e4 <RTC_WriteRegister+0x64>)
    d5a6:	4798      	blx	r3
	spi_transceive_wait(&service_spi_master_instance,reg,&LocalValue);
    d5a8:	1dfb      	adds	r3, r7, #7
    d5aa:	781b      	ldrb	r3, [r3, #0]
    d5ac:	b299      	uxth	r1, r3
    d5ae:	230e      	movs	r3, #14
    d5b0:	18fa      	adds	r2, r7, r3
    d5b2:	4b0b      	ldr	r3, [pc, #44]	; (d5e0 <RTC_WriteRegister+0x60>)
    d5b4:	0018      	movs	r0, r3
    d5b6:	4b0b      	ldr	r3, [pc, #44]	; (d5e4 <RTC_WriteRegister+0x64>)
    d5b8:	4798      	blx	r3
	spi_transceive_wait(&service_spi_master_instance,value,&LocalValue);
    d5ba:	1dbb      	adds	r3, r7, #6
    d5bc:	781b      	ldrb	r3, [r3, #0]
    d5be:	b299      	uxth	r1, r3
    d5c0:	230e      	movs	r3, #14
    d5c2:	18fa      	adds	r2, r7, r3
    d5c4:	4b06      	ldr	r3, [pc, #24]	; (d5e0 <RTC_WriteRegister+0x60>)
    d5c6:	0018      	movs	r0, r3
    d5c8:	4b06      	ldr	r3, [pc, #24]	; (d5e4 <RTC_WriteRegister+0x64>)
    d5ca:	4798      	blx	r3
	port_pin_set_output_level(RTC_CS,true);
    d5cc:	2101      	movs	r1, #1
    d5ce:	202a      	movs	r0, #42	; 0x2a
    d5d0:	4b02      	ldr	r3, [pc, #8]	; (d5dc <RTC_WriteRegister+0x5c>)
    d5d2:	4798      	blx	r3

} 
    d5d4:	46c0      	nop			; (mov r8, r8)
    d5d6:	46bd      	mov	sp, r7
    d5d8:	b004      	add	sp, #16
    d5da:	bd80      	pop	{r7, pc}
    d5dc:	0000d4f1 	.word	0x0000d4f1
    d5e0:	200049e8 	.word	0x200049e8
    d5e4:	00014b91 	.word	0x00014b91

0000d5e8 <RTC_WriteRegisters>:

//////////////////////////////////////////////////////////////////////////////

void RTC_WriteRegisters(xRTCStruct *xRTCValue)
{
    d5e8:	b580      	push	{r7, lr}
    d5ea:	b084      	sub	sp, #16
    d5ec:	af00      	add	r7, sp, #0
    d5ee:	6078      	str	r0, [r7, #4]
	uint16_t LocalValue;

	port_pin_set_output_level(RTC_CS,false);
    d5f0:	2100      	movs	r1, #0
    d5f2:	202a      	movs	r0, #42	; 0x2a
    d5f4:	4b0e      	ldr	r3, [pc, #56]	; (d630 <RTC_WriteRegisters+0x48>)
    d5f6:	4798      	blx	r3
	spi_transceive_wait(&service_spi_master_instance,REG_WRITE,&LocalValue);
    d5f8:	230e      	movs	r3, #14
    d5fa:	18fa      	adds	r2, r7, r3
    d5fc:	4b0d      	ldr	r3, [pc, #52]	; (d634 <RTC_WriteRegisters+0x4c>)
    d5fe:	2112      	movs	r1, #18
    d600:	0018      	movs	r0, r3
    d602:	4b0d      	ldr	r3, [pc, #52]	; (d638 <RTC_WriteRegisters+0x50>)
    d604:	4798      	blx	r3
	spi_transceive_wait(&service_spi_master_instance,0x01,&LocalValue);
    d606:	230e      	movs	r3, #14
    d608:	18fa      	adds	r2, r7, r3
    d60a:	4b0a      	ldr	r3, [pc, #40]	; (d634 <RTC_WriteRegisters+0x4c>)
    d60c:	2101      	movs	r1, #1
    d60e:	0018      	movs	r0, r3
    d610:	4b09      	ldr	r3, [pc, #36]	; (d638 <RTC_WriteRegisters+0x50>)
    d612:	4798      	blx	r3
	spi_write_buffer_wait(&service_spi_master_instance,(uint8_t *)xRTCValue,0x07);
    d614:	6879      	ldr	r1, [r7, #4]
    d616:	4b07      	ldr	r3, [pc, #28]	; (d634 <RTC_WriteRegisters+0x4c>)
    d618:	2207      	movs	r2, #7
    d61a:	0018      	movs	r0, r3
    d61c:	4b07      	ldr	r3, [pc, #28]	; (d63c <RTC_WriteRegisters+0x54>)
    d61e:	4798      	blx	r3
	port_pin_set_output_level(RTC_CS,true);
    d620:	2101      	movs	r1, #1
    d622:	202a      	movs	r0, #42	; 0x2a
    d624:	4b02      	ldr	r3, [pc, #8]	; (d630 <RTC_WriteRegisters+0x48>)
    d626:	4798      	blx	r3
}
    d628:	46c0      	nop			; (mov r8, r8)
    d62a:	46bd      	mov	sp, r7
    d62c:	b004      	add	sp, #16
    d62e:	bd80      	pop	{r7, pc}
    d630:	0000d4f1 	.word	0x0000d4f1
    d634:	200049e8 	.word	0x200049e8
    d638:	00014b91 	.word	0x00014b91
    d63c:	00014d31 	.word	0x00014d31

0000d640 <RTC_ReadRegisters>:

//////////////////////////////////////////////////////////////////////////////

static void RTC_ReadRegisters(xRTCStruct *xRTCValue) 
{
    d640:	b590      	push	{r4, r7, lr}
    d642:	b085      	sub	sp, #20
    d644:	af00      	add	r7, sp, #0
    d646:	6078      	str	r0, [r7, #4]
	uint16_t LocalValue;
	
	port_pin_set_output_level(RTC_CS,false);
    d648:	2100      	movs	r1, #0
    d64a:	202a      	movs	r0, #42	; 0x2a
    d64c:	4b5b      	ldr	r3, [pc, #364]	; (d7bc <RTC_ReadRegisters+0x17c>)
    d64e:	4798      	blx	r3
	spi_transceive_wait(&service_spi_master_instance,REG_READ,&LocalValue);
    d650:	230e      	movs	r3, #14
    d652:	18fa      	adds	r2, r7, r3
    d654:	4b5a      	ldr	r3, [pc, #360]	; (d7c0 <RTC_ReadRegisters+0x180>)
    d656:	2113      	movs	r1, #19
    d658:	0018      	movs	r0, r3
    d65a:	4b5a      	ldr	r3, [pc, #360]	; (d7c4 <RTC_ReadRegisters+0x184>)
    d65c:	4798      	blx	r3
	spi_transceive_wait(&service_spi_master_instance,0x01,&LocalValue);
    d65e:	230e      	movs	r3, #14
    d660:	18fa      	adds	r2, r7, r3
    d662:	4b57      	ldr	r3, [pc, #348]	; (d7c0 <RTC_ReadRegisters+0x180>)
    d664:	2101      	movs	r1, #1
    d666:	0018      	movs	r0, r3
    d668:	4b56      	ldr	r3, [pc, #344]	; (d7c4 <RTC_ReadRegisters+0x184>)
    d66a:	4798      	blx	r3
	spi_read_buffer_wait(&service_spi_master_instance,(uint8_t *)xRTCValue,0x07,0x00);
    d66c:	6879      	ldr	r1, [r7, #4]
    d66e:	4854      	ldr	r0, [pc, #336]	; (d7c0 <RTC_ReadRegisters+0x180>)
    d670:	2300      	movs	r3, #0
    d672:	2207      	movs	r2, #7
    d674:	4c54      	ldr	r4, [pc, #336]	; (d7c8 <RTC_ReadRegisters+0x188>)
    d676:	47a0      	blx	r4
	port_pin_set_output_level(RTC_CS,true);
    d678:	2101      	movs	r1, #1
    d67a:	202a      	movs	r0, #42	; 0x2a
    d67c:	4b4f      	ldr	r3, [pc, #316]	; (d7bc <RTC_ReadRegisters+0x17c>)
    d67e:	4798      	blx	r3
	
    if (!xRTCValue->xStart)
    d680:	687b      	ldr	r3, [r7, #4]
    d682:	781b      	ldrb	r3, [r3, #0]
    d684:	227f      	movs	r2, #127	; 0x7f
    d686:	4393      	bics	r3, r2
    d688:	b2db      	uxtb	r3, r3
    d68a:	2b00      	cmp	r3, #0
    d68c:	d000      	beq.n	d690 <RTC_ReadRegisters+0x50>
    d68e:	e088      	b.n	d7a2 <RTC_ReadRegisters+0x162>
	{
	 xRTCValue->xSec=0;
    d690:	687b      	ldr	r3, [r7, #4]
    d692:	781a      	ldrb	r2, [r3, #0]
    d694:	210f      	movs	r1, #15
    d696:	438a      	bics	r2, r1
    d698:	701a      	strb	r2, [r3, #0]
	 xRTCValue->xSec10=0;
    d69a:	687b      	ldr	r3, [r7, #4]
    d69c:	781a      	ldrb	r2, [r3, #0]
    d69e:	2170      	movs	r1, #112	; 0x70
    d6a0:	438a      	bics	r2, r1
    d6a2:	701a      	strb	r2, [r3, #0]
	 xRTCValue->xStart=0;
    d6a4:	687b      	ldr	r3, [r7, #4]
    d6a6:	781a      	ldrb	r2, [r3, #0]
    d6a8:	217f      	movs	r1, #127	; 0x7f
    d6aa:	400a      	ands	r2, r1
    d6ac:	701a      	strb	r2, [r3, #0]
	 xRTCValue->xMin=0;
    d6ae:	687b      	ldr	r3, [r7, #4]
    d6b0:	785a      	ldrb	r2, [r3, #1]
    d6b2:	210f      	movs	r1, #15
    d6b4:	438a      	bics	r2, r1
    d6b6:	705a      	strb	r2, [r3, #1]
	 xRTCValue->xMin10=0;
    d6b8:	687b      	ldr	r3, [r7, #4]
    d6ba:	785a      	ldrb	r2, [r3, #1]
    d6bc:	2170      	movs	r1, #112	; 0x70
    d6be:	438a      	bics	r2, r1
    d6c0:	705a      	strb	r2, [r3, #1]
	 xRTCValue->xHour=0;
    d6c2:	687b      	ldr	r3, [r7, #4]
    d6c4:	789a      	ldrb	r2, [r3, #2]
    d6c6:	210f      	movs	r1, #15
    d6c8:	438a      	bics	r2, r1
    d6ca:	709a      	strb	r2, [r3, #2]
	 xRTCValue->xHour10=0;
    d6cc:	687b      	ldr	r3, [r7, #4]
    d6ce:	789a      	ldrb	r2, [r3, #2]
    d6d0:	2130      	movs	r1, #48	; 0x30
    d6d2:	438a      	bics	r2, r1
    d6d4:	709a      	strb	r2, [r3, #2]
	 xRTCValue->x1224=0;
    d6d6:	687b      	ldr	r3, [r7, #4]
    d6d8:	789a      	ldrb	r2, [r3, #2]
    d6da:	2140      	movs	r1, #64	; 0x40
    d6dc:	438a      	bics	r2, r1
    d6de:	709a      	strb	r2, [r3, #2]
	 xRTCValue->xCalSign=0;
    d6e0:	687b      	ldr	r3, [r7, #4]
    d6e2:	789a      	ldrb	r2, [r3, #2]
    d6e4:	217f      	movs	r1, #127	; 0x7f
    d6e6:	400a      	ands	r2, r1
    d6e8:	709a      	strb	r2, [r3, #2]
     xRTCValue->xDay=1;
    d6ea:	687b      	ldr	r3, [r7, #4]
    d6ec:	78da      	ldrb	r2, [r3, #3]
    d6ee:	2107      	movs	r1, #7
    d6f0:	438a      	bics	r2, r1
    d6f2:	1c11      	adds	r1, r2, #0
    d6f4:	2201      	movs	r2, #1
    d6f6:	430a      	orrs	r2, r1
    d6f8:	70da      	strb	r2, [r3, #3]
	 xRTCValue->xBatEN=1;
    d6fa:	687b      	ldr	r3, [r7, #4]
    d6fc:	78da      	ldrb	r2, [r3, #3]
    d6fe:	2108      	movs	r1, #8
    d700:	430a      	orrs	r2, r1
    d702:	70da      	strb	r2, [r3, #3]
	 xRTCValue->xVBat=0;
    d704:	687b      	ldr	r3, [r7, #4]
    d706:	78da      	ldrb	r2, [r3, #3]
    d708:	2110      	movs	r1, #16
    d70a:	438a      	bics	r2, r1
    d70c:	70da      	strb	r2, [r3, #3]
	 xRTCValue->xOSCon=0;			
    d70e:	687b      	ldr	r3, [r7, #4]
    d710:	78da      	ldrb	r2, [r3, #3]
    d712:	2120      	movs	r1, #32
    d714:	438a      	bics	r2, r1
    d716:	70da      	strb	r2, [r3, #3]
	 xRTCValue->xDate=1;
    d718:	687b      	ldr	r3, [r7, #4]
    d71a:	791a      	ldrb	r2, [r3, #4]
    d71c:	210f      	movs	r1, #15
    d71e:	438a      	bics	r2, r1
    d720:	1c11      	adds	r1, r2, #0
    d722:	2201      	movs	r2, #1
    d724:	430a      	orrs	r2, r1
    d726:	711a      	strb	r2, [r3, #4]
	 xRTCValue->xDate10=0;	
    d728:	687b      	ldr	r3, [r7, #4]
    d72a:	791a      	ldrb	r2, [r3, #4]
    d72c:	2130      	movs	r1, #48	; 0x30
    d72e:	438a      	bics	r2, r1
    d730:	711a      	strb	r2, [r3, #4]
	 xRTCValue->xMonth=1;
    d732:	687b      	ldr	r3, [r7, #4]
    d734:	795a      	ldrb	r2, [r3, #5]
    d736:	210f      	movs	r1, #15
    d738:	438a      	bics	r2, r1
    d73a:	1c11      	adds	r1, r2, #0
    d73c:	2201      	movs	r2, #1
    d73e:	430a      	orrs	r2, r1
    d740:	715a      	strb	r2, [r3, #5]
	 xRTCValue->xMonth10=0;
    d742:	687b      	ldr	r3, [r7, #4]
    d744:	795a      	ldrb	r2, [r3, #5]
    d746:	2110      	movs	r1, #16
    d748:	438a      	bics	r2, r1
    d74a:	715a      	strb	r2, [r3, #5]
     xRTCValue->xLeap=0;
    d74c:	687b      	ldr	r3, [r7, #4]
    d74e:	795a      	ldrb	r2, [r3, #5]
    d750:	2120      	movs	r1, #32
    d752:	438a      	bics	r2, r1
    d754:	715a      	strb	r2, [r3, #5]
	 xRTCValue->xYear=0;
    d756:	687b      	ldr	r3, [r7, #4]
    d758:	799a      	ldrb	r2, [r3, #6]
    d75a:	210f      	movs	r1, #15
    d75c:	438a      	bics	r2, r1
    d75e:	719a      	strb	r2, [r3, #6]
	 xRTCValue->xYear10=0;
    d760:	687b      	ldr	r3, [r7, #4]
    d762:	799a      	ldrb	r2, [r3, #6]
    d764:	210f      	movs	r1, #15
    d766:	400a      	ands	r2, r1
    d768:	719a      	strb	r2, [r3, #6]
	 RTC_WriteRegisters(xRTCValue);
    d76a:	687b      	ldr	r3, [r7, #4]
    d76c:	0018      	movs	r0, r3
    d76e:	4b17      	ldr	r3, [pc, #92]	; (d7cc <RTC_ReadRegisters+0x18c>)
    d770:	4798      	blx	r3
	 RTC_WriteRegister(0x00,0x00);
    d772:	2100      	movs	r1, #0
    d774:	2000      	movs	r0, #0
    d776:	4b16      	ldr	r3, [pc, #88]	; (d7d0 <RTC_ReadRegisters+0x190>)
    d778:	4798      	blx	r3
	 RTC_WriteRegister(0x01,(1<<7)+(xRTCValue->xSec10<<4)+xRTCValue->xSec);
    d77a:	687b      	ldr	r3, [r7, #4]
    d77c:	781b      	ldrb	r3, [r3, #0]
    d77e:	065b      	lsls	r3, r3, #25
    d780:	0f5b      	lsrs	r3, r3, #29
    d782:	b2db      	uxtb	r3, r3
    d784:	011b      	lsls	r3, r3, #4
    d786:	b2db      	uxtb	r3, r3
    d788:	687a      	ldr	r2, [r7, #4]
    d78a:	7812      	ldrb	r2, [r2, #0]
    d78c:	0712      	lsls	r2, r2, #28
    d78e:	0f12      	lsrs	r2, r2, #28
    d790:	b2d2      	uxtb	r2, r2
    d792:	189b      	adds	r3, r3, r2
    d794:	b2db      	uxtb	r3, r3
    d796:	3b80      	subs	r3, #128	; 0x80
    d798:	b2db      	uxtb	r3, r3
    d79a:	0019      	movs	r1, r3
    d79c:	2001      	movs	r0, #1
    d79e:	4b0c      	ldr	r3, [pc, #48]	; (d7d0 <RTC_ReadRegisters+0x190>)
    d7a0:	4798      	blx	r3
	}
	
	RTC_WriteRegister(0x08,(0<<6) | (0<<1) | (0<<0));
    d7a2:	2100      	movs	r1, #0
    d7a4:	2008      	movs	r0, #8
    d7a6:	4b0a      	ldr	r3, [pc, #40]	; (d7d0 <RTC_ReadRegisters+0x190>)
    d7a8:	4798      	blx	r3
	RTC_WriteRegister(0x09,00);
    d7aa:	2100      	movs	r1, #0
    d7ac:	2009      	movs	r0, #9
    d7ae:	4b08      	ldr	r3, [pc, #32]	; (d7d0 <RTC_ReadRegisters+0x190>)
    d7b0:	4798      	blx	r3
} 
    d7b2:	46c0      	nop			; (mov r8, r8)
    d7b4:	46bd      	mov	sp, r7
    d7b6:	b005      	add	sp, #20
    d7b8:	bd90      	pop	{r4, r7, pc}
    d7ba:	46c0      	nop			; (mov r8, r8)
    d7bc:	0000d4f1 	.word	0x0000d4f1
    d7c0:	200049e8 	.word	0x200049e8
    d7c4:	00014b91 	.word	0x00014b91
    d7c8:	00014a5d 	.word	0x00014a5d
    d7cc:	0000d5e9 	.word	0x0000d5e9
    d7d0:	0000d581 	.word	0x0000d581

0000d7d4 <RTCRead>:

///////////////////////////////////////////////////////////////////////////////

void RTCRead(void)
{
    d7d4:	b580      	push	{r7, lr}
    d7d6:	b082      	sub	sp, #8
    d7d8:	af00      	add	r7, sp, #0
  xRTCStruct xRTCValue;
  
  RTC_ReadRegisters(&xRTCValue);
    d7da:	003b      	movs	r3, r7
    d7dc:	0018      	movs	r0, r3
    d7de:	4b5a      	ldr	r3, [pc, #360]	; (d948 <RTCRead+0x174>)
    d7e0:	4798      	blx	r3
  rtc_calendar_get_time_defaults(&Machinetime);
    d7e2:	4b5a      	ldr	r3, [pc, #360]	; (d94c <RTCRead+0x178>)
    d7e4:	0018      	movs	r0, r3
    d7e6:	4b5a      	ldr	r3, [pc, #360]	; (d950 <RTCRead+0x17c>)
    d7e8:	4798      	blx	r3
  Machinetime.year=xRTCValue.xYear+xRTCValue.xYear10*10+2000;
    d7ea:	003b      	movs	r3, r7
    d7ec:	799b      	ldrb	r3, [r3, #6]
    d7ee:	071b      	lsls	r3, r3, #28
    d7f0:	0f1b      	lsrs	r3, r3, #28
    d7f2:	b2db      	uxtb	r3, r3
    d7f4:	b29a      	uxth	r2, r3
    d7f6:	003b      	movs	r3, r7
    d7f8:	799b      	ldrb	r3, [r3, #6]
    d7fa:	061b      	lsls	r3, r3, #24
    d7fc:	0f1b      	lsrs	r3, r3, #28
    d7fe:	b2db      	uxtb	r3, r3
    d800:	b29b      	uxth	r3, r3
    d802:	1c19      	adds	r1, r3, #0
    d804:	0089      	lsls	r1, r1, #2
    d806:	18cb      	adds	r3, r1, r3
    d808:	18db      	adds	r3, r3, r3
    d80a:	b29b      	uxth	r3, r3
    d80c:	18d3      	adds	r3, r2, r3
    d80e:	b29b      	uxth	r3, r3
    d810:	22fa      	movs	r2, #250	; 0xfa
    d812:	00d2      	lsls	r2, r2, #3
    d814:	4694      	mov	ip, r2
    d816:	4463      	add	r3, ip
    d818:	b29a      	uxth	r2, r3
    d81a:	4b4c      	ldr	r3, [pc, #304]	; (d94c <RTCRead+0x178>)
    d81c:	80da      	strh	r2, [r3, #6]
  Machinetime.hour=xRTCValue.xHour+xRTCValue.xHour10*10;
    d81e:	003b      	movs	r3, r7
    d820:	789b      	ldrb	r3, [r3, #2]
    d822:	071b      	lsls	r3, r3, #28
    d824:	0f1b      	lsrs	r3, r3, #28
    d826:	b2db      	uxtb	r3, r3
    d828:	001a      	movs	r2, r3
    d82a:	003b      	movs	r3, r7
    d82c:	789b      	ldrb	r3, [r3, #2]
    d82e:	069b      	lsls	r3, r3, #26
    d830:	0f9b      	lsrs	r3, r3, #30
    d832:	b2db      	uxtb	r3, r3
    d834:	1c19      	adds	r1, r3, #0
    d836:	0089      	lsls	r1, r1, #2
    d838:	18cb      	adds	r3, r1, r3
    d83a:	18db      	adds	r3, r3, r3
    d83c:	b2db      	uxtb	r3, r3
    d83e:	18d3      	adds	r3, r2, r3
    d840:	b2da      	uxtb	r2, r3
    d842:	4b42      	ldr	r3, [pc, #264]	; (d94c <RTCRead+0x178>)
    d844:	709a      	strb	r2, [r3, #2]
  Machinetime.minute=xRTCValue.xMin+xRTCValue.xMin10*10;
    d846:	003b      	movs	r3, r7
    d848:	785b      	ldrb	r3, [r3, #1]
    d84a:	071b      	lsls	r3, r3, #28
    d84c:	0f1b      	lsrs	r3, r3, #28
    d84e:	b2db      	uxtb	r3, r3
    d850:	001a      	movs	r2, r3
    d852:	003b      	movs	r3, r7
    d854:	785b      	ldrb	r3, [r3, #1]
    d856:	065b      	lsls	r3, r3, #25
    d858:	0f5b      	lsrs	r3, r3, #29
    d85a:	b2db      	uxtb	r3, r3
    d85c:	1c19      	adds	r1, r3, #0
    d85e:	0089      	lsls	r1, r1, #2
    d860:	18cb      	adds	r3, r1, r3
    d862:	18db      	adds	r3, r3, r3
    d864:	b2db      	uxtb	r3, r3
    d866:	18d3      	adds	r3, r2, r3
    d868:	b2da      	uxtb	r2, r3
    d86a:	4b38      	ldr	r3, [pc, #224]	; (d94c <RTCRead+0x178>)
    d86c:	705a      	strb	r2, [r3, #1]
  Machinetime.second=xRTCValue.xSec+xRTCValue.xSec10*10;
    d86e:	003b      	movs	r3, r7
    d870:	781b      	ldrb	r3, [r3, #0]
    d872:	071b      	lsls	r3, r3, #28
    d874:	0f1b      	lsrs	r3, r3, #28
    d876:	b2db      	uxtb	r3, r3
    d878:	001a      	movs	r2, r3
    d87a:	003b      	movs	r3, r7
    d87c:	781b      	ldrb	r3, [r3, #0]
    d87e:	065b      	lsls	r3, r3, #25
    d880:	0f5b      	lsrs	r3, r3, #29
    d882:	b2db      	uxtb	r3, r3
    d884:	1c19      	adds	r1, r3, #0
    d886:	0089      	lsls	r1, r1, #2
    d888:	18cb      	adds	r3, r1, r3
    d88a:	18db      	adds	r3, r3, r3
    d88c:	b2db      	uxtb	r3, r3
    d88e:	18d3      	adds	r3, r2, r3
    d890:	b2da      	uxtb	r2, r3
    d892:	4b2e      	ldr	r3, [pc, #184]	; (d94c <RTCRead+0x178>)
    d894:	701a      	strb	r2, [r3, #0]
  Machinetime.month=xRTCValue.xMonth+xRTCValue.xMonth10*10;
    d896:	003b      	movs	r3, r7
    d898:	795b      	ldrb	r3, [r3, #5]
    d89a:	071b      	lsls	r3, r3, #28
    d89c:	0f1b      	lsrs	r3, r3, #28
    d89e:	b2db      	uxtb	r3, r3
    d8a0:	001a      	movs	r2, r3
    d8a2:	003b      	movs	r3, r7
    d8a4:	795b      	ldrb	r3, [r3, #5]
    d8a6:	06db      	lsls	r3, r3, #27
    d8a8:	0fdb      	lsrs	r3, r3, #31
    d8aa:	b2db      	uxtb	r3, r3
    d8ac:	1c19      	adds	r1, r3, #0
    d8ae:	0089      	lsls	r1, r1, #2
    d8b0:	18cb      	adds	r3, r1, r3
    d8b2:	18db      	adds	r3, r3, r3
    d8b4:	b2db      	uxtb	r3, r3
    d8b6:	18d3      	adds	r3, r2, r3
    d8b8:	b2da      	uxtb	r2, r3
    d8ba:	4b24      	ldr	r3, [pc, #144]	; (d94c <RTCRead+0x178>)
    d8bc:	715a      	strb	r2, [r3, #5]
  Machinetime.day=xRTCValue.xDate+xRTCValue.xDate10*10;
    d8be:	003b      	movs	r3, r7
    d8c0:	791b      	ldrb	r3, [r3, #4]
    d8c2:	071b      	lsls	r3, r3, #28
    d8c4:	0f1b      	lsrs	r3, r3, #28
    d8c6:	b2db      	uxtb	r3, r3
    d8c8:	001a      	movs	r2, r3
    d8ca:	003b      	movs	r3, r7
    d8cc:	791b      	ldrb	r3, [r3, #4]
    d8ce:	069b      	lsls	r3, r3, #26
    d8d0:	0f9b      	lsrs	r3, r3, #30
    d8d2:	b2db      	uxtb	r3, r3
    d8d4:	1c19      	adds	r1, r3, #0
    d8d6:	0089      	lsls	r1, r1, #2
    d8d8:	18cb      	adds	r3, r1, r3
    d8da:	18db      	adds	r3, r3, r3
    d8dc:	b2db      	uxtb	r3, r3
    d8de:	18d3      	adds	r3, r2, r3
    d8e0:	b2da      	uxtb	r2, r3
    d8e2:	4b1a      	ldr	r3, [pc, #104]	; (d94c <RTCRead+0x178>)
    d8e4:	711a      	strb	r2, [r3, #4]
  
  rtc_calendar_set_time(&rtc_instance, &Machinetime);
    d8e6:	4a19      	ldr	r2, [pc, #100]	; (d94c <RTCRead+0x178>)
    d8e8:	4b1a      	ldr	r3, [pc, #104]	; (d954 <RTCRead+0x180>)
    d8ea:	0011      	movs	r1, r2
    d8ec:	0018      	movs	r0, r3
    d8ee:	4b1a      	ldr	r3, [pc, #104]	; (d958 <RTCRead+0x184>)
    d8f0:	4798      	blx	r3
  timeinfo.tm_year = Machinetime.year - 1900;
    d8f2:	4b16      	ldr	r3, [pc, #88]	; (d94c <RTCRead+0x178>)
    d8f4:	88db      	ldrh	r3, [r3, #6]
    d8f6:	4a19      	ldr	r2, [pc, #100]	; (d95c <RTCRead+0x188>)
    d8f8:	189a      	adds	r2, r3, r2
    d8fa:	4b19      	ldr	r3, [pc, #100]	; (d960 <RTCRead+0x18c>)
    d8fc:	615a      	str	r2, [r3, #20]
  timeinfo.tm_mon  = Machinetime.month -1;
    d8fe:	4b13      	ldr	r3, [pc, #76]	; (d94c <RTCRead+0x178>)
    d900:	795b      	ldrb	r3, [r3, #5]
    d902:	1e5a      	subs	r2, r3, #1
    d904:	4b16      	ldr	r3, [pc, #88]	; (d960 <RTCRead+0x18c>)
    d906:	611a      	str	r2, [r3, #16]
  timeinfo.tm_mday = Machinetime.day;
    d908:	4b10      	ldr	r3, [pc, #64]	; (d94c <RTCRead+0x178>)
    d90a:	791b      	ldrb	r3, [r3, #4]
    d90c:	001a      	movs	r2, r3
    d90e:	4b14      	ldr	r3, [pc, #80]	; (d960 <RTCRead+0x18c>)
    d910:	60da      	str	r2, [r3, #12]
  timeinfo.tm_hour = Machinetime.hour;
    d912:	4b0e      	ldr	r3, [pc, #56]	; (d94c <RTCRead+0x178>)
    d914:	789b      	ldrb	r3, [r3, #2]
    d916:	001a      	movs	r2, r3
    d918:	4b11      	ldr	r3, [pc, #68]	; (d960 <RTCRead+0x18c>)
    d91a:	609a      	str	r2, [r3, #8]
  timeinfo.tm_min  = Machinetime.minute;
    d91c:	4b0b      	ldr	r3, [pc, #44]	; (d94c <RTCRead+0x178>)
    d91e:	785b      	ldrb	r3, [r3, #1]
    d920:	001a      	movs	r2, r3
    d922:	4b0f      	ldr	r3, [pc, #60]	; (d960 <RTCRead+0x18c>)
    d924:	605a      	str	r2, [r3, #4]
  timeinfo.tm_sec = Machinetime.second; 
    d926:	4b09      	ldr	r3, [pc, #36]	; (d94c <RTCRead+0x178>)
    d928:	781b      	ldrb	r3, [r3, #0]
    d92a:	001a      	movs	r2, r3
    d92c:	4b0c      	ldr	r3, [pc, #48]	; (d960 <RTCRead+0x18c>)
    d92e:	601a      	str	r2, [r3, #0]
  xMasterTime = mktime(&timeinfo);
    d930:	4b0b      	ldr	r3, [pc, #44]	; (d960 <RTCRead+0x18c>)
    d932:	0018      	movs	r0, r3
    d934:	4b0b      	ldr	r3, [pc, #44]	; (d964 <RTCRead+0x190>)
    d936:	4798      	blx	r3
    d938:	0002      	movs	r2, r0
    d93a:	4b0b      	ldr	r3, [pc, #44]	; (d968 <RTCRead+0x194>)
    d93c:	601a      	str	r2, [r3, #0]
	
}
    d93e:	46c0      	nop			; (mov r8, r8)
    d940:	46bd      	mov	sp, r7
    d942:	b002      	add	sp, #8
    d944:	bd80      	pop	{r7, pc}
    d946:	46c0      	nop			; (mov r8, r8)
    d948:	0000d641 	.word	0x0000d641
    d94c:	20004a68 	.word	0x20004a68
    d950:	0000d545 	.word	0x0000d545
    d954:	20004bc8 	.word	0x20004bc8
    d958:	00013991 	.word	0x00013991
    d95c:	fffff894 	.word	0xfffff894
    d960:	200046c0 	.word	0x200046c0
    d964:	0001f055 	.word	0x0001f055
    d968:	200049e0 	.word	0x200049e0

0000d96c <vSendTCPReply>:


////////////////////////////////////////////////////////////////////////////////////////////////////

static void vSendTCPReply(char *pcRxString, uint16_t usLen)
{
    d96c:	b590      	push	{r4, r7, lr}
    d96e:	b083      	sub	sp, #12
    d970:	af00      	add	r7, sp, #0
    d972:	6078      	str	r0, [r7, #4]
    d974:	000a      	movs	r2, r1
    d976:	1cbb      	adds	r3, r7, #2
    d978:	801a      	strh	r2, [r3, #0]
	 portDISABLE_INTERRUPTS();
    d97a:	b672      	cpsid	i
	 xTCPTxResult=false;
    d97c:	4b0c      	ldr	r3, [pc, #48]	; (d9b0 <vSendTCPReply+0x44>)
    d97e:	2200      	movs	r2, #0
    d980:	701a      	strb	r2, [r3, #0]
	 if (send(tcp_client_socket,pcRxString,usLen,0)==SOCK_ERR_NO_ERROR)
    d982:	4b0c      	ldr	r3, [pc, #48]	; (d9b4 <vSendTCPReply+0x48>)
    d984:	2000      	movs	r0, #0
    d986:	5618      	ldrsb	r0, [r3, r0]
    d988:	1cbb      	adds	r3, r7, #2
    d98a:	881a      	ldrh	r2, [r3, #0]
    d98c:	6879      	ldr	r1, [r7, #4]
    d98e:	2300      	movs	r3, #0
    d990:	4c09      	ldr	r4, [pc, #36]	; (d9b8 <vSendTCPReply+0x4c>)
    d992:	47a0      	blx	r4
    d994:	1e03      	subs	r3, r0, #0
    d996:	d104      	bne.n	d9a2 <vSendTCPReply+0x36>
	 {
	  vTaskDelay(TASK_DELAY_MS(WIFI_TIMEOUT_SEND));
    d998:	4b08      	ldr	r3, [pc, #32]	; (d9bc <vSendTCPReply+0x50>)
    d99a:	0018      	movs	r0, r3
    d99c:	4b08      	ldr	r3, [pc, #32]	; (d9c0 <vSendTCPReply+0x54>)
    d99e:	4798      	blx	r3
    d9a0:	e003      	b.n	d9aa <vSendTCPReply+0x3e>
	  if (!xTCPTxResult) return;
	 }
	 else {portENABLE_INTERRUPTS();vTaskDelay(TASK_DELAY_MS(10));}
    d9a2:	b662      	cpsie	i
    d9a4:	200a      	movs	r0, #10
    d9a6:	4b06      	ldr	r3, [pc, #24]	; (d9c0 <vSendTCPReply+0x54>)
    d9a8:	4798      	blx	r3
}
    d9aa:	46bd      	mov	sp, r7
    d9ac:	b003      	add	sp, #12
    d9ae:	bd90      	pop	{r4, r7, pc}
    d9b0:	20000531 	.word	0x20000531
    d9b4:	20000025 	.word	0x20000025
    d9b8:	0000b77d 	.word	0x0000b77d
    d9bc:	00002710 	.word	0x00002710
    d9c0:	000101fd 	.word	0x000101fd

0000d9c4 <wifi_cb>:
 *  - tstrM2mScanDone
 *  - tstrM2mWifiscanResult
 */

static void wifi_cb(uint8_t u8MsgType, void *pvMsg)
{
    d9c4:	b580      	push	{r7, lr}
    d9c6:	b084      	sub	sp, #16
    d9c8:	af00      	add	r7, sp, #0
    d9ca:	0002      	movs	r2, r0
    d9cc:	6039      	str	r1, [r7, #0]
    d9ce:	1dfb      	adds	r3, r7, #7
    d9d0:	701a      	strb	r2, [r3, #0]

switch (u8MsgType)
    d9d2:	1dfb      	adds	r3, r7, #7
    d9d4:	781b      	ldrb	r3, [r3, #0]
    d9d6:	2b2c      	cmp	r3, #44	; 0x2c
    d9d8:	d002      	beq.n	d9e0 <wifi_cb+0x1c>
    d9da:	2b32      	cmp	r3, #50	; 0x32
    d9dc:	d009      	beq.n	d9f2 <wifi_cb+0x2e>
//pu8IPAddress[0], pu8IPAddress[1], pu8IPAddress[2], pu8IPAddress[3]);
break;
}
default:
{
break;
    d9de:	e00c      	b.n	d9fa <wifi_cb+0x36>

switch (u8MsgType)
{
case M2M_WIFI_RESP_CON_STATE_CHANGED:
{
tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg;
    d9e0:	683b      	ldr	r3, [r7, #0]
    d9e2:	60fb      	str	r3, [r7, #12]
if (pstrWifiState->u8CurrState == M2M_WIFI_CONNECTED) {
    d9e4:	68fb      	ldr	r3, [r7, #12]
    d9e6:	781b      	ldrb	r3, [r3, #0]
    d9e8:	2b01      	cmp	r3, #1
    d9ea:	d105      	bne.n	d9f8 <wifi_cb+0x34>
m2m_wifi_request_dhcp_client();
    d9ec:	4b05      	ldr	r3, [pc, #20]	; (da04 <wifi_cb+0x40>)
    d9ee:	4798      	blx	r3
} else if (pstrWifiState->u8CurrState == M2M_WIFI_DISCONNECTED) {
//printf("Wi-Fi disconnected\r\n");
}
break;
    d9f0:	e002      	b.n	d9f8 <wifi_cb+0x34>
}
case M2M_WIFI_REQ_DHCP_CONF:
{
uint8_t *pu8IPAddress = (uint8_t *)pvMsg;
    d9f2:	683b      	ldr	r3, [r7, #0]
    d9f4:	60bb      	str	r3, [r7, #8]
//printf("Wi-Fi connected\r\n");
//printf("Wi-Fi IP is %u.%u.%u.%u\r\n",
//pu8IPAddress[0], pu8IPAddress[1], pu8IPAddress[2], pu8IPAddress[3]);
break;
    d9f6:	e000      	b.n	d9fa <wifi_cb+0x36>
if (pstrWifiState->u8CurrState == M2M_WIFI_CONNECTED) {
m2m_wifi_request_dhcp_client();
} else if (pstrWifiState->u8CurrState == M2M_WIFI_DISCONNECTED) {
//printf("Wi-Fi disconnected\r\n");
}
break;
    d9f8:	46c0      	nop			; (mov r8, r8)
default:
{
break;
}
}
}
    d9fa:	46c0      	nop			; (mov r8, r8)
    d9fc:	46bd      	mov	sp, r7
    d9fe:	b004      	add	sp, #16
    da00:	bd80      	pop	{r7, pc}
    da02:	46c0      	nop			; (mov r8, r8)
    da04:	00009a8d 	.word	0x00009a8d

0000da08 <vCreateWincTask>:
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void vCreateWincTask(void)
{
    da08:	b590      	push	{r4, r7, lr}
    da0a:	b083      	sub	sp, #12
    da0c:	af02      	add	r7, sp, #8
	
	xTaskCreate(winc_task,(const char *)"Winc",2*configMINIMAL_STACK_SIZE,NULL,WINC_TASK_PRIORITY,&xWincTaskH);
    da0e:	23c8      	movs	r3, #200	; 0xc8
    da10:	005a      	lsls	r2, r3, #1
    da12:	490c      	ldr	r1, [pc, #48]	; (da44 <vCreateWincTask+0x3c>)
    da14:	480c      	ldr	r0, [pc, #48]	; (da48 <vCreateWincTask+0x40>)
    da16:	4b0d      	ldr	r3, [pc, #52]	; (da4c <vCreateWincTask+0x44>)
    da18:	9301      	str	r3, [sp, #4]
    da1a:	2301      	movs	r3, #1
    da1c:	9300      	str	r3, [sp, #0]
    da1e:	2300      	movs	r3, #0
    da20:	4c0b      	ldr	r4, [pc, #44]	; (da50 <vCreateWincTask+0x48>)
    da22:	47a0      	blx	r4
    xTaskCreate(cmd_task,(const char *)"Comm",2*configMINIMAL_STACK_SIZE,NULL,WINC_TASK_PRIORITY,&xCmdTaskH);
    da24:	23c8      	movs	r3, #200	; 0xc8
    da26:	005a      	lsls	r2, r3, #1
    da28:	490a      	ldr	r1, [pc, #40]	; (da54 <vCreateWincTask+0x4c>)
    da2a:	480b      	ldr	r0, [pc, #44]	; (da58 <vCreateWincTask+0x50>)
    da2c:	4b0b      	ldr	r3, [pc, #44]	; (da5c <vCreateWincTask+0x54>)
    da2e:	9301      	str	r3, [sp, #4]
    da30:	2301      	movs	r3, #1
    da32:	9300      	str	r3, [sp, #0]
    da34:	2300      	movs	r3, #0
    da36:	4c06      	ldr	r4, [pc, #24]	; (da50 <vCreateWincTask+0x48>)
    da38:	47a0      	blx	r4
	

}
    da3a:	46c0      	nop			; (mov r8, r8)
    da3c:	46bd      	mov	sp, r7
    da3e:	b001      	add	sp, #4
    da40:	bd90      	pop	{r4, r7, pc}
    da42:	46c0      	nop			; (mov r8, r8)
    da44:	00020e10 	.word	0x00020e10
    da48:	0000da61 	.word	0x0000da61
    da4c:	2000377c 	.word	0x2000377c
    da50:	0000ff91 	.word	0x0000ff91
    da54:	00020e18 	.word	0x00020e18
    da58:	0000dc69 	.word	0x0000dc69
    da5c:	200031c0 	.word	0x200031c0

0000da60 <winc_task>:

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void winc_task(void *params)
{
    da60:	b590      	push	{r4, r7, lr}
    da62:	b08b      	sub	sp, #44	; 0x2c
    da64:	af00      	add	r7, sp, #0
    da66:	6078      	str	r0, [r7, #4]
 tstrWifiInitParam param;
 uint32_t ulNotifiedValue;

 //xIntSemaphore = xSemaphoreCreateCounting( 20, 0 );
 xAcceptQueue = xQueueCreate( 7, sizeof( SOCKET ) );
    da68:	2200      	movs	r2, #0
    da6a:	2101      	movs	r1, #1
    da6c:	2007      	movs	r0, #7
    da6e:	4b62      	ldr	r3, [pc, #392]	; (dbf8 <winc_task+0x198>)
    da70:	4798      	blx	r3
    da72:	0002      	movs	r2, r0
    da74:	4b61      	ldr	r3, [pc, #388]	; (dbfc <winc_task+0x19c>)
    da76:	601a      	str	r2, [r3, #0]
 //xStatus = WAIT_CONNECT;
 
 /* Initialize Wi-Fi parameters structure. */
 memset((uint8_t *)&param, 0, sizeof(tstrWifiInitParam));
    da78:	2308      	movs	r3, #8
    da7a:	18fb      	adds	r3, r7, r3
    da7c:	2218      	movs	r2, #24
    da7e:	2100      	movs	r1, #0
    da80:	0018      	movs	r0, r3
    da82:	4b5f      	ldr	r3, [pc, #380]	; (dc00 <winc_task+0x1a0>)
    da84:	4798      	blx	r3

 /* Initialize Wi-Fi driver with data and status callbacks. */
 param.pfAppWifiCb = wifi_cb;
    da86:	2308      	movs	r3, #8
    da88:	18fb      	adds	r3, r7, r3
    da8a:	4a5e      	ldr	r2, [pc, #376]	; (dc04 <winc_task+0x1a4>)
    da8c:	601a      	str	r2, [r3, #0]
 int8_t ret = m2m_wifi_init(&param);
    da8e:	2323      	movs	r3, #35	; 0x23
    da90:	18fc      	adds	r4, r7, r3
    da92:	2308      	movs	r3, #8
    da94:	18fb      	adds	r3, r7, r3
    da96:	0018      	movs	r0, r3
    da98:	4b5b      	ldr	r3, [pc, #364]	; (dc08 <winc_task+0x1a8>)
    da9a:	4798      	blx	r3
    da9c:	0003      	movs	r3, r0
    da9e:	7023      	strb	r3, [r4, #0]
 if (M2M_SUCCESS != ret) while (1) vTaskDelay(TASK_DELAY_MS(1000));
    daa0:	2323      	movs	r3, #35	; 0x23
    daa2:	18fb      	adds	r3, r7, r3
    daa4:	781b      	ldrb	r3, [r3, #0]
    daa6:	b25b      	sxtb	r3, r3
    daa8:	2b00      	cmp	r3, #0
    daaa:	d005      	beq.n	dab8 <winc_task+0x58>
    daac:	23fa      	movs	r3, #250	; 0xfa
    daae:	009b      	lsls	r3, r3, #2
    dab0:	0018      	movs	r0, r3
    dab2:	4b56      	ldr	r3, [pc, #344]	; (dc0c <winc_task+0x1ac>)
    dab4:	4798      	blx	r3
    dab6:	e7f9      	b.n	daac <winc_task+0x4c>
  //xConfigData.xSecurityType=M2M_WIFI_SEC_WPA_PSK;
  //xConfigData.xDHCP=false;
  //xConfigData.xBaudrate=BR115200;
  //xConfigData.xConnectionMode=TCP;
  
    memset(&xConfigData,0x00,sizeof(xConfigData));
    dab8:	4b55      	ldr	r3, [pc, #340]	; (dc10 <winc_task+0x1b0>)
    daba:	22a0      	movs	r2, #160	; 0xa0
    dabc:	2100      	movs	r1, #0
    dabe:	0018      	movs	r0, r3
    dac0:	4b4f      	ldr	r3, [pc, #316]	; (dc00 <winc_task+0x1a0>)
    dac2:	4798      	blx	r3
    strcpy(xConfigData.cSSID,"OpenSpace");
    dac4:	4b52      	ldr	r3, [pc, #328]	; (dc10 <winc_task+0x1b0>)
    dac6:	4a53      	ldr	r2, [pc, #332]	; (dc14 <winc_task+0x1b4>)
    dac8:	ca03      	ldmia	r2!, {r0, r1}
    daca:	c303      	stmia	r3!, {r0, r1}
    dacc:	8812      	ldrh	r2, [r2, #0]
    dace:	801a      	strh	r2, [r3, #0]
    strcpy(xConfigData.cPassword,"OpenSpaceBtsr$$");
    dad0:	4a51      	ldr	r2, [pc, #324]	; (dc18 <winc_task+0x1b8>)
    dad2:	4b52      	ldr	r3, [pc, #328]	; (dc1c <winc_task+0x1bc>)
    dad4:	0010      	movs	r0, r2
    dad6:	0019      	movs	r1, r3
    dad8:	2310      	movs	r3, #16
    dada:	001a      	movs	r2, r3
    dadc:	4b50      	ldr	r3, [pc, #320]	; (dc20 <winc_task+0x1c0>)
    dade:	4798      	blx	r3
    strcpy(xConfigData.cHostName,"BtsrWiFi");
    dae0:	4b50      	ldr	r3, [pc, #320]	; (dc24 <winc_task+0x1c4>)
    dae2:	4a51      	ldr	r2, [pc, #324]	; (dc28 <winc_task+0x1c8>)
    dae4:	ca03      	ldmia	r2!, {r0, r1}
    dae6:	c303      	stmia	r3!, {r0, r1}
    dae8:	7812      	ldrb	r2, [r2, #0]
    daea:	701a      	strb	r2, [r3, #0]
    xConfigData.u32StaticIP=0xc0a801c0;
    daec:	4b48      	ldr	r3, [pc, #288]	; (dc10 <winc_task+0x1b0>)
    daee:	4a4f      	ldr	r2, [pc, #316]	; (dc2c <winc_task+0x1cc>)
    daf0:	65da      	str	r2, [r3, #92]	; 0x5c
    xConfigData.u32SubnetMask=0xFFFFFE00;
    daf2:	4b47      	ldr	r3, [pc, #284]	; (dc10 <winc_task+0x1b0>)
    daf4:	4a4e      	ldr	r2, [pc, #312]	; (dc30 <winc_task+0x1d0>)
    daf6:	661a      	str	r2, [r3, #96]	; 0x60
    xConfigData.u32Gateway=0xc0a801FE;
    daf8:	4b45      	ldr	r3, [pc, #276]	; (dc10 <winc_task+0x1b0>)
    dafa:	4a4e      	ldr	r2, [pc, #312]	; (dc34 <winc_task+0x1d4>)
    dafc:	665a      	str	r2, [r3, #100]	; 0x64
    xConfigData.xSecurityType=M2M_WIFI_SEC_WPA_PSK;
    dafe:	4b44      	ldr	r3, [pc, #272]	; (dc10 <winc_task+0x1b0>)
    db00:	2268      	movs	r2, #104	; 0x68
    db02:	2102      	movs	r1, #2
    db04:	5499      	strb	r1, [r3, r2]
    xConfigData.xDHCP=false;
    db06:	4b42      	ldr	r3, [pc, #264]	; (dc10 <winc_task+0x1b0>)
    db08:	226b      	movs	r2, #107	; 0x6b
    db0a:	2100      	movs	r1, #0
    db0c:	5499      	strb	r1, [r3, r2]
    xConfigData.xBaudrate=BR115200;
    db0e:	4b40      	ldr	r3, [pc, #256]	; (dc10 <winc_task+0x1b0>)
    db10:	2269      	movs	r2, #105	; 0x69
    db12:	2101      	movs	r1, #1
    db14:	5499      	strb	r1, [r3, r2]
    xConfigData.xConnectionMode=TCP;
    db16:	4b3e      	ldr	r3, [pc, #248]	; (dc10 <winc_task+0x1b0>)
    db18:	226a      	movs	r2, #106	; 0x6a
    db1a:	2101      	movs	r1, #1
    db1c:	5499      	strb	r1, [r3, r2]
 
 //vTaskSuspend(NULL);
 vTaskDelay(TASK_DELAY_MS(4000));
    db1e:	23fa      	movs	r3, #250	; 0xfa
    db20:	011b      	lsls	r3, r3, #4
    db22:	0018      	movs	r0, r3
    db24:	4b39      	ldr	r3, [pc, #228]	; (dc0c <winc_task+0x1ac>)
    db26:	4798      	blx	r3
 
 ret = m2m_wifi_set_device_name((uint8_t *)MAIN_WLAN_DEVICE_NAME,strlen(MAIN_WLAN_DEVICE_NAME));
    db28:	2323      	movs	r3, #35	; 0x23
    db2a:	18fc      	adds	r4, r7, r3
    db2c:	4b42      	ldr	r3, [pc, #264]	; (dc38 <winc_task+0x1d8>)
    db2e:	210f      	movs	r1, #15
    db30:	0018      	movs	r0, r3
    db32:	4b42      	ldr	r3, [pc, #264]	; (dc3c <winc_task+0x1dc>)
    db34:	4798      	blx	r3
    db36:	0003      	movs	r3, r0
    db38:	7023      	strb	r3, [r4, #0]
 if (M2M_SUCCESS != ret) while (1) vTaskDelay(TASK_DELAY_MS(1000));
    db3a:	2323      	movs	r3, #35	; 0x23
    db3c:	18fb      	adds	r3, r7, r3
    db3e:	781b      	ldrb	r3, [r3, #0]
    db40:	b25b      	sxtb	r3, r3
    db42:	2b00      	cmp	r3, #0
    db44:	d005      	beq.n	db52 <winc_task+0xf2>
    db46:	23fa      	movs	r3, #250	; 0xfa
    db48:	009b      	lsls	r3, r3, #2
    db4a:	0018      	movs	r0, r3
    db4c:	4b2f      	ldr	r3, [pc, #188]	; (dc0c <winc_task+0x1ac>)
    db4e:	4798      	blx	r3
    db50:	e7f9      	b.n	db46 <winc_task+0xe6>

 
 
 ret = m2m_wifi_p2p(0);
    db52:	2323      	movs	r3, #35	; 0x23
    db54:	18fc      	adds	r4, r7, r3
    db56:	2000      	movs	r0, #0
    db58:	4b39      	ldr	r3, [pc, #228]	; (dc40 <winc_task+0x1e0>)
    db5a:	4798      	blx	r3
    db5c:	0003      	movs	r3, r0
    db5e:	7023      	strb	r3, [r4, #0]
 if (M2M_SUCCESS != ret) while (1) vTaskDelay(TASK_DELAY_MS(1000));
    db60:	2323      	movs	r3, #35	; 0x23
    db62:	18fb      	adds	r3, r7, r3
    db64:	781b      	ldrb	r3, [r3, #0]
    db66:	b25b      	sxtb	r3, r3
    db68:	2b00      	cmp	r3, #0
    db6a:	d005      	beq.n	db78 <winc_task+0x118>
    db6c:	23fa      	movs	r3, #250	; 0xfa
    db6e:	009b      	lsls	r3, r3, #2
    db70:	0018      	movs	r0, r3
    db72:	4b26      	ldr	r3, [pc, #152]	; (dc0c <winc_task+0x1ac>)
    db74:	4798      	blx	r3
    db76:	e7f9      	b.n	db6c <winc_task+0x10c>
  //#ifdef  DEBUG
  //
  //vSwitchToAPMode();
  xStatus=APOINT_MODE;
    db78:	4b32      	ldr	r3, [pc, #200]	; (dc44 <winc_task+0x1e4>)
    db7a:	2202      	movs	r2, #2
    db7c:	701a      	strb	r2, [r3, #0]

 for (;;)
 {
  
  //xSemaphoreTake(xIntSemaphore,portMAX_DELAY);
  ulNotifiedValue = ulTaskNotifyTake( pdTRUE, portMAX_DELAY );
    db7e:	2301      	movs	r3, #1
    db80:	425b      	negs	r3, r3
    db82:	0019      	movs	r1, r3
    db84:	2001      	movs	r0, #1
    db86:	4b30      	ldr	r3, [pc, #192]	; (dc48 <winc_task+0x1e8>)
    db88:	4798      	blx	r3
    db8a:	0003      	movs	r3, r0
    db8c:	627b      	str	r3, [r7, #36]	; 0x24
  
  while (ulNotifiedValue>0)
    db8e:	e005      	b.n	db9c <winc_task+0x13c>
  {//vTaskDelay(2);
   ulNotifiedValue--;
    db90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    db92:	3b01      	subs	r3, #1
    db94:	627b      	str	r3, [r7, #36]	; 0x24
   m2m_wifi_handle_events(NULL);
    db96:	2000      	movs	r0, #0
    db98:	4b2c      	ldr	r3, [pc, #176]	; (dc4c <winc_task+0x1ec>)
    db9a:	4798      	blx	r3
 {
  
  //xSemaphoreTake(xIntSemaphore,portMAX_DELAY);
  ulNotifiedValue = ulTaskNotifyTake( pdTRUE, portMAX_DELAY );
  
  while (ulNotifiedValue>0)
    db9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    db9e:	2b00      	cmp	r3, #0
    dba0:	d1f6      	bne.n	db90 <winc_task+0x130>
  {//vTaskDelay(2);
   ulNotifiedValue--;
   m2m_wifi_handle_events(NULL);
  }
  
   if (wifi_connected == M2M_WIFI_CONNECTED) 
    dba2:	4b2b      	ldr	r3, [pc, #172]	; (dc50 <winc_task+0x1f0>)
    dba4:	781b      	ldrb	r3, [r3, #0]
    dba6:	2b01      	cmp	r3, #1
    dba8:	d1e9      	bne.n	db7e <winc_task+0x11e>
   {
    if (tcp_server_socket < 0)
    dbaa:	4b2a      	ldr	r3, [pc, #168]	; (dc54 <winc_task+0x1f4>)
    dbac:	781b      	ldrb	r3, [r3, #0]
    dbae:	b25b      	sxtb	r3, r3
    dbb0:	2b00      	cmp	r3, #0
    dbb2:	dae4      	bge.n	db7e <winc_task+0x11e>
    {
     /* Open TCP server socket */
	 //if (xConfigData.xConnectionMode==TCP)
	 //{
      if ((tcp_server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) continue;
    dbb4:	2200      	movs	r2, #0
    dbb6:	2101      	movs	r1, #1
    dbb8:	2002      	movs	r0, #2
    dbba:	4b27      	ldr	r3, [pc, #156]	; (dc58 <winc_task+0x1f8>)
    dbbc:	4798      	blx	r3
    dbbe:	0003      	movs	r3, r0
    dbc0:	001a      	movs	r2, r3
    dbc2:	4b24      	ldr	r3, [pc, #144]	; (dc54 <winc_task+0x1f4>)
    dbc4:	701a      	strb	r2, [r3, #0]
    dbc6:	4b23      	ldr	r3, [pc, #140]	; (dc54 <winc_task+0x1f4>)
    dbc8:	781b      	ldrb	r3, [r3, #0]
    dbca:	b25b      	sxtb	r3, r3
    dbcc:	2b00      	cmp	r3, #0
    dbce:	db11      	blt.n	dbf4 <winc_task+0x194>
    
      /* Bind service*/
	  /* Initialize socket address structure. */
      addr.sin_family = AF_INET;
    dbd0:	4b22      	ldr	r3, [pc, #136]	; (dc5c <winc_task+0x1fc>)
    dbd2:	2202      	movs	r2, #2
    dbd4:	801a      	strh	r2, [r3, #0]
      addr.sin_port = _htons(MAIN_WIFI_M2M_SERVER_PORT);
    dbd6:	4b21      	ldr	r3, [pc, #132]	; (dc5c <winc_task+0x1fc>)
    dbd8:	4a21      	ldr	r2, [pc, #132]	; (dc60 <winc_task+0x200>)
    dbda:	805a      	strh	r2, [r3, #2]
      addr.sin_addr.s_addr = 0;
    dbdc:	4b1f      	ldr	r3, [pc, #124]	; (dc5c <winc_task+0x1fc>)
    dbde:	2200      	movs	r2, #0
    dbe0:	605a      	str	r2, [r3, #4]
	  bind(tcp_server_socket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
    dbe2:	4b1c      	ldr	r3, [pc, #112]	; (dc54 <winc_task+0x1f4>)
    dbe4:	781b      	ldrb	r3, [r3, #0]
    dbe6:	b25b      	sxtb	r3, r3
    dbe8:	491c      	ldr	r1, [pc, #112]	; (dc5c <winc_task+0x1fc>)
    dbea:	2210      	movs	r2, #16
    dbec:	0018      	movs	r0, r3
    dbee:	4b1d      	ldr	r3, [pc, #116]	; (dc64 <winc_task+0x204>)
    dbf0:	4798      	blx	r3
    dbf2:	e7c4      	b.n	db7e <winc_task+0x11e>
    if (tcp_server_socket < 0)
    {
     /* Open TCP server socket */
	 //if (xConfigData.xConnectionMode==TCP)
	 //{
      if ((tcp_server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) continue;
    dbf4:	46c0      	nop			; (mov r8, r8)
     //addr.sin_addr.s_addr = 0;
	 //bind(http_server_socket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
    //}
   }
  //}
 }
    dbf6:	e7c2      	b.n	db7e <winc_task+0x11e>
    dbf8:	0000fed5 	.word	0x0000fed5
    dbfc:	200031c4 	.word	0x200031c4
    dc00:	0001eead 	.word	0x0001eead
    dc04:	0000d9c5 	.word	0x0000d9c5
    dc08:	000099a9 	.word	0x000099a9
    dc0c:	000101fd 	.word	0x000101fd
    dc10:	20003120 	.word	0x20003120
    dc14:	00020e20 	.word	0x00020e20
    dc18:	2000313e 	.word	0x2000313e
    dc1c:	00020e2c 	.word	0x00020e2c
    dc20:	0001ee9b 	.word	0x0001ee9b
    dc24:	2000315c 	.word	0x2000315c
    dc28:	00020e3c 	.word	0x00020e3c
    dc2c:	c0a801c0 	.word	0xc0a801c0
    dc30:	fffffe00 	.word	0xfffffe00
    dc34:	c0a801fe 	.word	0xc0a801fe
    dc38:	00020e48 	.word	0x00020e48
    dc3c:	00009b11 	.word	0x00009b11
    dc40:	00009a99 	.word	0x00009a99
    dc44:	20004ad0 	.word	0x20004ad0
    dc48:	00010bad 	.word	0x00010bad
    dc4c:	00009a71 	.word	0x00009a71
    dc50:	20000530 	.word	0x20000530
    dc54:	20000024 	.word	0x20000024
    dc58:	0000b535 	.word	0x0000b535
    dc5c:	20004ae4 	.word	0x20004ae4
    dc60:	00005a04 	.word	0x00005a04
    dc64:	0000b68d 	.word	0x0000b68d

0000dc68 <cmd_task>:
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void cmd_task(void *params)
{//uint32_t ulNotifiedValue;
    dc68:	b590      	push	{r4, r7, lr}
    dc6a:	b09d      	sub	sp, #116	; 0x74
    dc6c:	af00      	add	r7, sp, #0
    dc6e:	6078      	str	r0, [r7, #4]
	
 for (;;)
 {
  
  //ulNotifiedValue = ulTaskNotifyTake( pdTRUE, portMAX_DELAY );
  ulTaskNotifyTake( pdTRUE, portMAX_DELAY );
    dc70:	2301      	movs	r3, #1
    dc72:	425b      	negs	r3, r3
    dc74:	0019      	movs	r1, r3
    dc76:	2001      	movs	r0, #1
    dc78:	4b1d      	ldr	r3, [pc, #116]	; (dcf0 <cmd_task+0x88>)
    dc7a:	4798      	blx	r3
  
  switch (TCPBuffer[0])
    dc7c:	4b1d      	ldr	r3, [pc, #116]	; (dcf4 <cmd_task+0x8c>)
    dc7e:	781b      	ldrb	r3, [r3, #0]
    dc80:	2b09      	cmp	r3, #9
    dc82:	d900      	bls.n	dc86 <cmd_task+0x1e>
    dc84:	e3d7      	b.n	e436 <cmd_task+0x7ce>
    dc86:	009a      	lsls	r2, r3, #2
    dc88:	4b1b      	ldr	r3, [pc, #108]	; (dcf8 <cmd_task+0x90>)
    dc8a:	18d3      	adds	r3, r2, r3
    dc8c:	681b      	ldr	r3, [r3, #0]
    dc8e:	469f      	mov	pc, r3
  {
	case 0x01: //Recv Program
	{
     UINT uWrt;
	 memcpy(&xProgramList[TCPBuffer[1]-0x01],&TCPBuffer[2],sizeof(xProgram));
    dc90:	4b18      	ldr	r3, [pc, #96]	; (dcf4 <cmd_task+0x8c>)
    dc92:	785b      	ldrb	r3, [r3, #1]
    dc94:	1e5a      	subs	r2, r3, #1
    dc96:	0013      	movs	r3, r2
    dc98:	00db      	lsls	r3, r3, #3
    dc9a:	1a9b      	subs	r3, r3, r2
    dc9c:	00db      	lsls	r3, r3, #3
    dc9e:	189b      	adds	r3, r3, r2
    dca0:	4a16      	ldr	r2, [pc, #88]	; (dcfc <cmd_task+0x94>)
    dca2:	189b      	adds	r3, r3, r2
    dca4:	4916      	ldr	r1, [pc, #88]	; (dd00 <cmd_task+0x98>)
    dca6:	2239      	movs	r2, #57	; 0x39
    dca8:	0018      	movs	r0, r3
    dcaa:	4b16      	ldr	r3, [pc, #88]	; (dd04 <cmd_task+0x9c>)
    dcac:	4798      	blx	r3
	 f_open(&file_object,"0:/PrgList.bin",FA_WRITE);
    dcae:	4916      	ldr	r1, [pc, #88]	; (dd08 <cmd_task+0xa0>)
    dcb0:	4b16      	ldr	r3, [pc, #88]	; (dd0c <cmd_task+0xa4>)
    dcb2:	2202      	movs	r2, #2
    dcb4:	0018      	movs	r0, r3
    dcb6:	4b16      	ldr	r3, [pc, #88]	; (dd10 <cmd_task+0xa8>)
    dcb8:	4798      	blx	r3
	 f_write(&file_object,xProgramList,sizeof(xProgramList),&uWrt);
    dcba:	2364      	movs	r3, #100	; 0x64
    dcbc:	18fb      	adds	r3, r7, r3
    dcbe:	4a15      	ldr	r2, [pc, #84]	; (dd14 <cmd_task+0xac>)
    dcc0:	490e      	ldr	r1, [pc, #56]	; (dcfc <cmd_task+0x94>)
    dcc2:	4812      	ldr	r0, [pc, #72]	; (dd0c <cmd_task+0xa4>)
    dcc4:	4c14      	ldr	r4, [pc, #80]	; (dd18 <cmd_task+0xb0>)
    dcc6:	47a0      	blx	r4
	 f_close(&file_object);
    dcc8:	4b10      	ldr	r3, [pc, #64]	; (dd0c <cmd_task+0xa4>)
    dcca:	0018      	movs	r0, r3
    dccc:	4b13      	ldr	r3, [pc, #76]	; (dd1c <cmd_task+0xb4>)
    dcce:	4798      	blx	r3
	
	 TCPBuffer[0]=0x01;
    dcd0:	4b08      	ldr	r3, [pc, #32]	; (dcf4 <cmd_task+0x8c>)
    dcd2:	2201      	movs	r2, #1
    dcd4:	701a      	strb	r2, [r3, #0]
	 TCPBuffer[1]=0x00;
    dcd6:	4b07      	ldr	r3, [pc, #28]	; (dcf4 <cmd_task+0x8c>)
    dcd8:	2200      	movs	r2, #0
    dcda:	705a      	strb	r2, [r3, #1]
	 TCPBuffer[2]=0x00;
    dcdc:	4b05      	ldr	r3, [pc, #20]	; (dcf4 <cmd_task+0x8c>)
    dcde:	2200      	movs	r2, #0
    dce0:	709a      	strb	r2, [r3, #2]
	 vSendTCPReply(TCPBuffer,0x03);
    dce2:	4b04      	ldr	r3, [pc, #16]	; (dcf4 <cmd_task+0x8c>)
    dce4:	2103      	movs	r1, #3
    dce6:	0018      	movs	r0, r3
    dce8:	4b0d      	ldr	r3, [pc, #52]	; (dd20 <cmd_task+0xb8>)
    dcea:	4798      	blx	r3
	}
	break; 
    dcec:	e3a4      	b.n	e438 <cmd_task+0x7d0>
    dcee:	46c0      	nop			; (mov r8, r8)
    dcf0:	00010bad 	.word	0x00010bad
    dcf4:	20003780 	.word	0x20003780
    dcf8:	00020ebc 	.word	0x00020ebc
    dcfc:	200046ec 	.word	0x200046ec
    dd00:	20003782 	.word	0x20003782
    dd04:	0001ee9b 	.word	0x0001ee9b
    dd08:	00020e58 	.word	0x00020e58
    dd0c:	2000449c 	.word	0x2000449c
    dd10:	00019b09 	.word	0x00019b09
    dd14:	0000023a 	.word	0x0000023a
    dd18:	0001a101 	.word	0x0001a101
    dd1c:	0001a595 	.word	0x0001a595
    dd20:	0000d96d 	.word	0x0000d96d
	{
	 UINT uWrt;
	 xSetup xTempSetup;
	 time_t xSaveTime;
	 	 
	 memcpy (&xTempSetup,&TCPBuffer[1],sizeof(xTempSetup));
    dd24:	2308      	movs	r3, #8
    dd26:	18f9      	adds	r1, r7, r3
    dd28:	4bfb      	ldr	r3, [pc, #1004]	; (e118 <cmd_task+0x4b0>)
    dd2a:	2201      	movs	r2, #1
    dd2c:	0008      	movs	r0, r1
    dd2e:	189b      	adds	r3, r3, r2
    dd30:	222c      	movs	r2, #44	; 0x2c
    dd32:	0019      	movs	r1, r3
    dd34:	4bf9      	ldr	r3, [pc, #996]	; (e11c <cmd_task+0x4b4>)
    dd36:	4798      	blx	r3
	 xSaveTime=xTempSetup.xDateTime;
    dd38:	2308      	movs	r3, #8
    dd3a:	18fb      	adds	r3, r7, r3
    dd3c:	7ada      	ldrb	r2, [r3, #11]
    dd3e:	68db      	ldr	r3, [r3, #12]
    dd40:	021b      	lsls	r3, r3, #8
    dd42:	0a1b      	lsrs	r3, r3, #8
    dd44:	021b      	lsls	r3, r3, #8
    dd46:	4313      	orrs	r3, r2
    dd48:	65fb      	str	r3, [r7, #92]	; 0x5c
	 xTempSetup.xDateTime=0x00;
    dd4a:	2308      	movs	r3, #8
    dd4c:	18fb      	adds	r3, r7, r3
    dd4e:	330b      	adds	r3, #11
    dd50:	781a      	ldrb	r2, [r3, #0]
    dd52:	2100      	movs	r1, #0
    dd54:	400a      	ands	r2, r1
    dd56:	701a      	strb	r2, [r3, #0]
    dd58:	785a      	ldrb	r2, [r3, #1]
    dd5a:	2100      	movs	r1, #0
    dd5c:	400a      	ands	r2, r1
    dd5e:	705a      	strb	r2, [r3, #1]
    dd60:	789a      	ldrb	r2, [r3, #2]
    dd62:	2100      	movs	r1, #0
    dd64:	400a      	ands	r2, r1
    dd66:	709a      	strb	r2, [r3, #2]
    dd68:	78da      	ldrb	r2, [r3, #3]
    dd6a:	2100      	movs	r1, #0
    dd6c:	400a      	ands	r2, r1
    dd6e:	70da      	strb	r2, [r3, #3]
	 
	 if (memcmp(&xMachineSetup,&xTempSetup,sizeof(xMachineSetup)))
    dd70:	2308      	movs	r3, #8
    dd72:	18f9      	adds	r1, r7, r3
    dd74:	4bea      	ldr	r3, [pc, #936]	; (e120 <cmd_task+0x4b8>)
    dd76:	222c      	movs	r2, #44	; 0x2c
    dd78:	0018      	movs	r0, r3
    dd7a:	4bea      	ldr	r3, [pc, #936]	; (e124 <cmd_task+0x4bc>)
    dd7c:	4798      	blx	r3
    dd7e:	1e03      	subs	r3, r0, #0
    dd80:	d019      	beq.n	ddb6 <cmd_task+0x14e>
	 {
	  memcpy(&xMachineSetup,&xTempSetup,sizeof(xMachineSetup));
    dd82:	4ae7      	ldr	r2, [pc, #924]	; (e120 <cmd_task+0x4b8>)
    dd84:	2308      	movs	r3, #8
    dd86:	18fb      	adds	r3, r7, r3
    dd88:	0010      	movs	r0, r2
    dd8a:	0019      	movs	r1, r3
    dd8c:	232c      	movs	r3, #44	; 0x2c
    dd8e:	001a      	movs	r2, r3
    dd90:	4be2      	ldr	r3, [pc, #904]	; (e11c <cmd_task+0x4b4>)
    dd92:	4798      	blx	r3
	  //vSaveSetup();
	  f_open(&file_object,"0:/Setup.bin",FA_WRITE);
    dd94:	49e4      	ldr	r1, [pc, #912]	; (e128 <cmd_task+0x4c0>)
    dd96:	4be5      	ldr	r3, [pc, #916]	; (e12c <cmd_task+0x4c4>)
    dd98:	2202      	movs	r2, #2
    dd9a:	0018      	movs	r0, r3
    dd9c:	4be4      	ldr	r3, [pc, #912]	; (e130 <cmd_task+0x4c8>)
    dd9e:	4798      	blx	r3
	  f_write(&file_object,&xMachineSetup,sizeof(xMachineSetup),&uWrt);
    dda0:	2360      	movs	r3, #96	; 0x60
    dda2:	18fb      	adds	r3, r7, r3
    dda4:	49de      	ldr	r1, [pc, #888]	; (e120 <cmd_task+0x4b8>)
    dda6:	48e1      	ldr	r0, [pc, #900]	; (e12c <cmd_task+0x4c4>)
    dda8:	222c      	movs	r2, #44	; 0x2c
    ddaa:	4ce2      	ldr	r4, [pc, #904]	; (e134 <cmd_task+0x4cc>)
    ddac:	47a0      	blx	r4
	  f_close(&file_object);		 
    ddae:	4bdf      	ldr	r3, [pc, #892]	; (e12c <cmd_task+0x4c4>)
    ddb0:	0018      	movs	r0, r3
    ddb2:	4be1      	ldr	r3, [pc, #900]	; (e138 <cmd_task+0x4d0>)
    ddb4:	4798      	blx	r3
	 }

	struct tm* timeinf=localtime (&xSaveTime);
    ddb6:	235c      	movs	r3, #92	; 0x5c
    ddb8:	18fb      	adds	r3, r7, r3
    ddba:	0018      	movs	r0, r3
    ddbc:	4bdf      	ldr	r3, [pc, #892]	; (e13c <cmd_task+0x4d4>)
    ddbe:	4798      	blx	r3
    ddc0:	0003      	movs	r3, r0
    ddc2:	66fb      	str	r3, [r7, #108]	; 0x6c
	struct rtc_calendar_time time;
	xRTCStruct xRTCValue;
	
	time.year   = timeinf->tm_year+1900;
    ddc4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    ddc6:	695b      	ldr	r3, [r3, #20]
    ddc8:	b29b      	uxth	r3, r3
    ddca:	4add      	ldr	r2, [pc, #884]	; (e140 <cmd_task+0x4d8>)
    ddcc:	4694      	mov	ip, r2
    ddce:	4463      	add	r3, ip
    ddd0:	b29a      	uxth	r2, r3
    ddd2:	2350      	movs	r3, #80	; 0x50
    ddd4:	18fb      	adds	r3, r7, r3
    ddd6:	80da      	strh	r2, [r3, #6]
	time.month  = timeinf->tm_mon+1;
    ddd8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    ddda:	691b      	ldr	r3, [r3, #16]
    dddc:	b2db      	uxtb	r3, r3
    ddde:	3301      	adds	r3, #1
    dde0:	b2da      	uxtb	r2, r3
    dde2:	2350      	movs	r3, #80	; 0x50
    dde4:	18fb      	adds	r3, r7, r3
    dde6:	715a      	strb	r2, [r3, #5]
	time.day    = timeinf->tm_mday;
    dde8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    ddea:	68db      	ldr	r3, [r3, #12]
    ddec:	b2da      	uxtb	r2, r3
    ddee:	2350      	movs	r3, #80	; 0x50
    ddf0:	18fb      	adds	r3, r7, r3
    ddf2:	711a      	strb	r2, [r3, #4]
	time.hour   = timeinf->tm_hour;
    ddf4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    ddf6:	689b      	ldr	r3, [r3, #8]
    ddf8:	b2da      	uxtb	r2, r3
    ddfa:	2350      	movs	r3, #80	; 0x50
    ddfc:	18fb      	adds	r3, r7, r3
    ddfe:	709a      	strb	r2, [r3, #2]
	time.minute = timeinf->tm_min;
    de00:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    de02:	685b      	ldr	r3, [r3, #4]
    de04:	b2da      	uxtb	r2, r3
    de06:	2350      	movs	r3, #80	; 0x50
    de08:	18fb      	adds	r3, r7, r3
    de0a:	705a      	strb	r2, [r3, #1]
	time.second = timeinf->tm_sec;
    de0c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    de0e:	681b      	ldr	r3, [r3, #0]
    de10:	b2da      	uxtb	r2, r3
    de12:	2350      	movs	r3, #80	; 0x50
    de14:	18fb      	adds	r3, r7, r3
    de16:	701a      	strb	r2, [r3, #0]
	rtc_calendar_set_time(&rtc_instance, &time);
    de18:	2350      	movs	r3, #80	; 0x50
    de1a:	18fa      	adds	r2, r7, r3
    de1c:	4bc9      	ldr	r3, [pc, #804]	; (e144 <cmd_task+0x4dc>)
    de1e:	0011      	movs	r1, r2
    de20:	0018      	movs	r0, r3
    de22:	4bc9      	ldr	r3, [pc, #804]	; (e148 <cmd_task+0x4e0>)
    de24:	4798      	blx	r3
	
	xRTCValue.xSec=time.second % 10;
    de26:	2350      	movs	r3, #80	; 0x50
    de28:	18fb      	adds	r3, r7, r3
    de2a:	781a      	ldrb	r2, [r3, #0]
    de2c:	4bc7      	ldr	r3, [pc, #796]	; (e14c <cmd_task+0x4e4>)
    de2e:	210a      	movs	r1, #10
    de30:	0010      	movs	r0, r2
    de32:	4798      	blx	r3
    de34:	000b      	movs	r3, r1
    de36:	b2db      	uxtb	r3, r3
    de38:	1c1a      	adds	r2, r3, #0
    de3a:	230f      	movs	r3, #15
    de3c:	4013      	ands	r3, r2
    de3e:	b2da      	uxtb	r2, r3
    de40:	2348      	movs	r3, #72	; 0x48
    de42:	18fb      	adds	r3, r7, r3
    de44:	210f      	movs	r1, #15
    de46:	400a      	ands	r2, r1
    de48:	0010      	movs	r0, r2
    de4a:	781a      	ldrb	r2, [r3, #0]
    de4c:	210f      	movs	r1, #15
    de4e:	438a      	bics	r2, r1
    de50:	1c11      	adds	r1, r2, #0
    de52:	1c02      	adds	r2, r0, #0
    de54:	430a      	orrs	r2, r1
    de56:	701a      	strb	r2, [r3, #0]
	xRTCValue.xSec10=time.second / 10;
    de58:	2350      	movs	r3, #80	; 0x50
    de5a:	18fb      	adds	r3, r7, r3
    de5c:	781a      	ldrb	r2, [r3, #0]
    de5e:	4bbc      	ldr	r3, [pc, #752]	; (e150 <cmd_task+0x4e8>)
    de60:	210a      	movs	r1, #10
    de62:	0010      	movs	r0, r2
    de64:	4798      	blx	r3
    de66:	0003      	movs	r3, r0
    de68:	b2db      	uxtb	r3, r3
    de6a:	1c1a      	adds	r2, r3, #0
    de6c:	2307      	movs	r3, #7
    de6e:	4013      	ands	r3, r2
    de70:	b2da      	uxtb	r2, r3
    de72:	2348      	movs	r3, #72	; 0x48
    de74:	18fb      	adds	r3, r7, r3
    de76:	2107      	movs	r1, #7
    de78:	400a      	ands	r2, r1
    de7a:	0110      	lsls	r0, r2, #4
    de7c:	781a      	ldrb	r2, [r3, #0]
    de7e:	2170      	movs	r1, #112	; 0x70
    de80:	438a      	bics	r2, r1
    de82:	1c11      	adds	r1, r2, #0
    de84:	1c02      	adds	r2, r0, #0
    de86:	430a      	orrs	r2, r1
    de88:	701a      	strb	r2, [r3, #0]
	xRTCValue.xStart=0;
    de8a:	2348      	movs	r3, #72	; 0x48
    de8c:	18fb      	adds	r3, r7, r3
    de8e:	781a      	ldrb	r2, [r3, #0]
    de90:	217f      	movs	r1, #127	; 0x7f
    de92:	400a      	ands	r2, r1
    de94:	701a      	strb	r2, [r3, #0]
	xRTCValue.xMin=time.minute % 10;
    de96:	2350      	movs	r3, #80	; 0x50
    de98:	18fb      	adds	r3, r7, r3
    de9a:	785a      	ldrb	r2, [r3, #1]
    de9c:	4bab      	ldr	r3, [pc, #684]	; (e14c <cmd_task+0x4e4>)
    de9e:	210a      	movs	r1, #10
    dea0:	0010      	movs	r0, r2
    dea2:	4798      	blx	r3
    dea4:	000b      	movs	r3, r1
    dea6:	b2db      	uxtb	r3, r3
    dea8:	1c1a      	adds	r2, r3, #0
    deaa:	230f      	movs	r3, #15
    deac:	4013      	ands	r3, r2
    deae:	b2da      	uxtb	r2, r3
    deb0:	2348      	movs	r3, #72	; 0x48
    deb2:	18fb      	adds	r3, r7, r3
    deb4:	210f      	movs	r1, #15
    deb6:	400a      	ands	r2, r1
    deb8:	0010      	movs	r0, r2
    deba:	785a      	ldrb	r2, [r3, #1]
    debc:	210f      	movs	r1, #15
    debe:	438a      	bics	r2, r1
    dec0:	1c11      	adds	r1, r2, #0
    dec2:	1c02      	adds	r2, r0, #0
    dec4:	430a      	orrs	r2, r1
    dec6:	705a      	strb	r2, [r3, #1]
	xRTCValue.xMin10=time.minute / 10;
    dec8:	2350      	movs	r3, #80	; 0x50
    deca:	18fb      	adds	r3, r7, r3
    decc:	785a      	ldrb	r2, [r3, #1]
    dece:	4ba0      	ldr	r3, [pc, #640]	; (e150 <cmd_task+0x4e8>)
    ded0:	210a      	movs	r1, #10
    ded2:	0010      	movs	r0, r2
    ded4:	4798      	blx	r3
    ded6:	0003      	movs	r3, r0
    ded8:	b2db      	uxtb	r3, r3
    deda:	1c1a      	adds	r2, r3, #0
    dedc:	2307      	movs	r3, #7
    dede:	4013      	ands	r3, r2
    dee0:	b2da      	uxtb	r2, r3
    dee2:	2348      	movs	r3, #72	; 0x48
    dee4:	18fb      	adds	r3, r7, r3
    dee6:	2107      	movs	r1, #7
    dee8:	400a      	ands	r2, r1
    deea:	0110      	lsls	r0, r2, #4
    deec:	785a      	ldrb	r2, [r3, #1]
    deee:	2170      	movs	r1, #112	; 0x70
    def0:	438a      	bics	r2, r1
    def2:	1c11      	adds	r1, r2, #0
    def4:	1c02      	adds	r2, r0, #0
    def6:	430a      	orrs	r2, r1
    def8:	705a      	strb	r2, [r3, #1]
    xRTCValue.xHour=time.hour % 10;
    defa:	2350      	movs	r3, #80	; 0x50
    defc:	18fb      	adds	r3, r7, r3
    defe:	789a      	ldrb	r2, [r3, #2]
    df00:	4b92      	ldr	r3, [pc, #584]	; (e14c <cmd_task+0x4e4>)
    df02:	210a      	movs	r1, #10
    df04:	0010      	movs	r0, r2
    df06:	4798      	blx	r3
    df08:	000b      	movs	r3, r1
    df0a:	b2db      	uxtb	r3, r3
    df0c:	1c1a      	adds	r2, r3, #0
    df0e:	230f      	movs	r3, #15
    df10:	4013      	ands	r3, r2
    df12:	b2da      	uxtb	r2, r3
    df14:	2348      	movs	r3, #72	; 0x48
    df16:	18fb      	adds	r3, r7, r3
    df18:	210f      	movs	r1, #15
    df1a:	400a      	ands	r2, r1
    df1c:	0010      	movs	r0, r2
    df1e:	789a      	ldrb	r2, [r3, #2]
    df20:	210f      	movs	r1, #15
    df22:	438a      	bics	r2, r1
    df24:	1c11      	adds	r1, r2, #0
    df26:	1c02      	adds	r2, r0, #0
    df28:	430a      	orrs	r2, r1
    df2a:	709a      	strb	r2, [r3, #2]
	xRTCValue.xHour10=time.hour / 10;
    df2c:	2350      	movs	r3, #80	; 0x50
    df2e:	18fb      	adds	r3, r7, r3
    df30:	789a      	ldrb	r2, [r3, #2]
    df32:	4b87      	ldr	r3, [pc, #540]	; (e150 <cmd_task+0x4e8>)
    df34:	210a      	movs	r1, #10
    df36:	0010      	movs	r0, r2
    df38:	4798      	blx	r3
    df3a:	0003      	movs	r3, r0
    df3c:	b2db      	uxtb	r3, r3
    df3e:	1c1a      	adds	r2, r3, #0
    df40:	2303      	movs	r3, #3
    df42:	4013      	ands	r3, r2
    df44:	b2da      	uxtb	r2, r3
    df46:	2348      	movs	r3, #72	; 0x48
    df48:	18fb      	adds	r3, r7, r3
    df4a:	2103      	movs	r1, #3
    df4c:	400a      	ands	r2, r1
    df4e:	0110      	lsls	r0, r2, #4
    df50:	789a      	ldrb	r2, [r3, #2]
    df52:	2130      	movs	r1, #48	; 0x30
    df54:	438a      	bics	r2, r1
    df56:	1c11      	adds	r1, r2, #0
    df58:	1c02      	adds	r2, r0, #0
    df5a:	430a      	orrs	r2, r1
    df5c:	709a      	strb	r2, [r3, #2]
	xRTCValue.x1224=0;
    df5e:	2348      	movs	r3, #72	; 0x48
    df60:	18fb      	adds	r3, r7, r3
    df62:	789a      	ldrb	r2, [r3, #2]
    df64:	2140      	movs	r1, #64	; 0x40
    df66:	438a      	bics	r2, r1
    df68:	709a      	strb	r2, [r3, #2]
	xRTCValue.xCalSign=0;
    df6a:	2348      	movs	r3, #72	; 0x48
    df6c:	18fb      	adds	r3, r7, r3
    df6e:	789a      	ldrb	r2, [r3, #2]
    df70:	217f      	movs	r1, #127	; 0x7f
    df72:	400a      	ands	r2, r1
    df74:	709a      	strb	r2, [r3, #2]
    xRTCValue.xDay=1;
    df76:	2348      	movs	r3, #72	; 0x48
    df78:	18fb      	adds	r3, r7, r3
    df7a:	78da      	ldrb	r2, [r3, #3]
    df7c:	2107      	movs	r1, #7
    df7e:	438a      	bics	r2, r1
    df80:	1c11      	adds	r1, r2, #0
    df82:	2201      	movs	r2, #1
    df84:	430a      	orrs	r2, r1
    df86:	70da      	strb	r2, [r3, #3]
	xRTCValue.xBatEN=1;
    df88:	2348      	movs	r3, #72	; 0x48
    df8a:	18fb      	adds	r3, r7, r3
    df8c:	78da      	ldrb	r2, [r3, #3]
    df8e:	2108      	movs	r1, #8
    df90:	430a      	orrs	r2, r1
    df92:	70da      	strb	r2, [r3, #3]
	xRTCValue.xVBat=0;
    df94:	2348      	movs	r3, #72	; 0x48
    df96:	18fb      	adds	r3, r7, r3
    df98:	78da      	ldrb	r2, [r3, #3]
    df9a:	2110      	movs	r1, #16
    df9c:	438a      	bics	r2, r1
    df9e:	70da      	strb	r2, [r3, #3]
	xRTCValue.xOSCon=0;			
    dfa0:	2348      	movs	r3, #72	; 0x48
    dfa2:	18fb      	adds	r3, r7, r3
    dfa4:	78da      	ldrb	r2, [r3, #3]
    dfa6:	2120      	movs	r1, #32
    dfa8:	438a      	bics	r2, r1
    dfaa:	70da      	strb	r2, [r3, #3]
	xRTCValue.xDate=time.day % 10;
    dfac:	2350      	movs	r3, #80	; 0x50
    dfae:	18fb      	adds	r3, r7, r3
    dfb0:	791a      	ldrb	r2, [r3, #4]
    dfb2:	4b66      	ldr	r3, [pc, #408]	; (e14c <cmd_task+0x4e4>)
    dfb4:	210a      	movs	r1, #10
    dfb6:	0010      	movs	r0, r2
    dfb8:	4798      	blx	r3
    dfba:	000b      	movs	r3, r1
    dfbc:	b2db      	uxtb	r3, r3
    dfbe:	1c1a      	adds	r2, r3, #0
    dfc0:	230f      	movs	r3, #15
    dfc2:	4013      	ands	r3, r2
    dfc4:	b2da      	uxtb	r2, r3
    dfc6:	2348      	movs	r3, #72	; 0x48
    dfc8:	18fb      	adds	r3, r7, r3
    dfca:	210f      	movs	r1, #15
    dfcc:	400a      	ands	r2, r1
    dfce:	0010      	movs	r0, r2
    dfd0:	791a      	ldrb	r2, [r3, #4]
    dfd2:	210f      	movs	r1, #15
    dfd4:	438a      	bics	r2, r1
    dfd6:	1c11      	adds	r1, r2, #0
    dfd8:	1c02      	adds	r2, r0, #0
    dfda:	430a      	orrs	r2, r1
    dfdc:	711a      	strb	r2, [r3, #4]
	xRTCValue.xDate10=time.day / 10;	
    dfde:	2350      	movs	r3, #80	; 0x50
    dfe0:	18fb      	adds	r3, r7, r3
    dfe2:	791a      	ldrb	r2, [r3, #4]
    dfe4:	4b5a      	ldr	r3, [pc, #360]	; (e150 <cmd_task+0x4e8>)
    dfe6:	210a      	movs	r1, #10
    dfe8:	0010      	movs	r0, r2
    dfea:	4798      	blx	r3
    dfec:	0003      	movs	r3, r0
    dfee:	b2db      	uxtb	r3, r3
    dff0:	1c1a      	adds	r2, r3, #0
    dff2:	2303      	movs	r3, #3
    dff4:	4013      	ands	r3, r2
    dff6:	b2da      	uxtb	r2, r3
    dff8:	2348      	movs	r3, #72	; 0x48
    dffa:	18fb      	adds	r3, r7, r3
    dffc:	2103      	movs	r1, #3
    dffe:	400a      	ands	r2, r1
    e000:	0110      	lsls	r0, r2, #4
    e002:	791a      	ldrb	r2, [r3, #4]
    e004:	2130      	movs	r1, #48	; 0x30
    e006:	438a      	bics	r2, r1
    e008:	1c11      	adds	r1, r2, #0
    e00a:	1c02      	adds	r2, r0, #0
    e00c:	430a      	orrs	r2, r1
    e00e:	711a      	strb	r2, [r3, #4]
	xRTCValue.xMonth=time.month % 10;
    e010:	2350      	movs	r3, #80	; 0x50
    e012:	18fb      	adds	r3, r7, r3
    e014:	795a      	ldrb	r2, [r3, #5]
    e016:	4b4d      	ldr	r3, [pc, #308]	; (e14c <cmd_task+0x4e4>)
    e018:	210a      	movs	r1, #10
    e01a:	0010      	movs	r0, r2
    e01c:	4798      	blx	r3
    e01e:	000b      	movs	r3, r1
    e020:	b2db      	uxtb	r3, r3
    e022:	1c1a      	adds	r2, r3, #0
    e024:	230f      	movs	r3, #15
    e026:	4013      	ands	r3, r2
    e028:	b2da      	uxtb	r2, r3
    e02a:	2348      	movs	r3, #72	; 0x48
    e02c:	18fb      	adds	r3, r7, r3
    e02e:	210f      	movs	r1, #15
    e030:	400a      	ands	r2, r1
    e032:	0010      	movs	r0, r2
    e034:	795a      	ldrb	r2, [r3, #5]
    e036:	210f      	movs	r1, #15
    e038:	438a      	bics	r2, r1
    e03a:	1c11      	adds	r1, r2, #0
    e03c:	1c02      	adds	r2, r0, #0
    e03e:	430a      	orrs	r2, r1
    e040:	715a      	strb	r2, [r3, #5]
	xRTCValue.xMonth10=time.month / 10;
    e042:	2350      	movs	r3, #80	; 0x50
    e044:	18fb      	adds	r3, r7, r3
    e046:	795a      	ldrb	r2, [r3, #5]
    e048:	4b41      	ldr	r3, [pc, #260]	; (e150 <cmd_task+0x4e8>)
    e04a:	210a      	movs	r1, #10
    e04c:	0010      	movs	r0, r2
    e04e:	4798      	blx	r3
    e050:	0003      	movs	r3, r0
    e052:	b2db      	uxtb	r3, r3
    e054:	1c1a      	adds	r2, r3, #0
    e056:	2301      	movs	r3, #1
    e058:	4013      	ands	r3, r2
    e05a:	b2da      	uxtb	r2, r3
    e05c:	2348      	movs	r3, #72	; 0x48
    e05e:	18fb      	adds	r3, r7, r3
    e060:	2101      	movs	r1, #1
    e062:	400a      	ands	r2, r1
    e064:	0110      	lsls	r0, r2, #4
    e066:	795a      	ldrb	r2, [r3, #5]
    e068:	2110      	movs	r1, #16
    e06a:	438a      	bics	r2, r1
    e06c:	1c11      	adds	r1, r2, #0
    e06e:	1c02      	adds	r2, r0, #0
    e070:	430a      	orrs	r2, r1
    e072:	715a      	strb	r2, [r3, #5]
    xRTCValue.xLeap=0;
    e074:	2348      	movs	r3, #72	; 0x48
    e076:	18fb      	adds	r3, r7, r3
    e078:	795a      	ldrb	r2, [r3, #5]
    e07a:	2120      	movs	r1, #32
    e07c:	438a      	bics	r2, r1
    e07e:	715a      	strb	r2, [r3, #5]
	xRTCValue.xYear=(time.year-2000) % 10;
    e080:	2350      	movs	r3, #80	; 0x50
    e082:	18fb      	adds	r3, r7, r3
    e084:	88db      	ldrh	r3, [r3, #6]
    e086:	4a33      	ldr	r2, [pc, #204]	; (e154 <cmd_task+0x4ec>)
    e088:	189a      	adds	r2, r3, r2
    e08a:	4b33      	ldr	r3, [pc, #204]	; (e158 <cmd_task+0x4f0>)
    e08c:	210a      	movs	r1, #10
    e08e:	0010      	movs	r0, r2
    e090:	4798      	blx	r3
    e092:	000b      	movs	r3, r1
    e094:	b2db      	uxtb	r3, r3
    e096:	1c1a      	adds	r2, r3, #0
    e098:	230f      	movs	r3, #15
    e09a:	4013      	ands	r3, r2
    e09c:	b2da      	uxtb	r2, r3
    e09e:	2348      	movs	r3, #72	; 0x48
    e0a0:	18fb      	adds	r3, r7, r3
    e0a2:	210f      	movs	r1, #15
    e0a4:	400a      	ands	r2, r1
    e0a6:	0010      	movs	r0, r2
    e0a8:	799a      	ldrb	r2, [r3, #6]
    e0aa:	210f      	movs	r1, #15
    e0ac:	438a      	bics	r2, r1
    e0ae:	1c11      	adds	r1, r2, #0
    e0b0:	1c02      	adds	r2, r0, #0
    e0b2:	430a      	orrs	r2, r1
    e0b4:	719a      	strb	r2, [r3, #6]
	xRTCValue.xYear10=(time.year-2000) / 10;
    e0b6:	2350      	movs	r3, #80	; 0x50
    e0b8:	18fb      	adds	r3, r7, r3
    e0ba:	88db      	ldrh	r3, [r3, #6]
    e0bc:	4a25      	ldr	r2, [pc, #148]	; (e154 <cmd_task+0x4ec>)
    e0be:	189a      	adds	r2, r3, r2
    e0c0:	4b26      	ldr	r3, [pc, #152]	; (e15c <cmd_task+0x4f4>)
    e0c2:	210a      	movs	r1, #10
    e0c4:	0010      	movs	r0, r2
    e0c6:	4798      	blx	r3
    e0c8:	0003      	movs	r3, r0
    e0ca:	b2db      	uxtb	r3, r3
    e0cc:	1c1a      	adds	r2, r3, #0
    e0ce:	230f      	movs	r3, #15
    e0d0:	4013      	ands	r3, r2
    e0d2:	b2da      	uxtb	r2, r3
    e0d4:	2348      	movs	r3, #72	; 0x48
    e0d6:	18fb      	adds	r3, r7, r3
    e0d8:	0110      	lsls	r0, r2, #4
    e0da:	799a      	ldrb	r2, [r3, #6]
    e0dc:	210f      	movs	r1, #15
    e0de:	400a      	ands	r2, r1
    e0e0:	1c11      	adds	r1, r2, #0
    e0e2:	1c02      	adds	r2, r0, #0
    e0e4:	430a      	orrs	r2, r1
    e0e6:	719a      	strb	r2, [r3, #6]
	RTC_WriteRegisters(&xRTCValue);
    e0e8:	2348      	movs	r3, #72	; 0x48
    e0ea:	18fb      	adds	r3, r7, r3
    e0ec:	0018      	movs	r0, r3
    e0ee:	4b1c      	ldr	r3, [pc, #112]	; (e160 <cmd_task+0x4f8>)
    e0f0:	4798      	blx	r3
	RTC_WriteRegister(0x00,0x00);
    e0f2:	2100      	movs	r1, #0
    e0f4:	2000      	movs	r0, #0
    e0f6:	4b1b      	ldr	r3, [pc, #108]	; (e164 <cmd_task+0x4fc>)
    e0f8:	4798      	blx	r3
	RTC_WriteRegister(0x01,(1<<7)+(xRTCValue.xSec10<<4)+xRTCValue.xSec);	
    e0fa:	2348      	movs	r3, #72	; 0x48
    e0fc:	18fb      	adds	r3, r7, r3
    e0fe:	781b      	ldrb	r3, [r3, #0]
    e100:	065b      	lsls	r3, r3, #25
    e102:	0f5b      	lsrs	r3, r3, #29
    e104:	b2db      	uxtb	r3, r3
    e106:	011b      	lsls	r3, r3, #4
    e108:	b2db      	uxtb	r3, r3
    e10a:	2248      	movs	r2, #72	; 0x48
    e10c:	18ba      	adds	r2, r7, r2
    e10e:	7812      	ldrb	r2, [r2, #0]
    e110:	0712      	lsls	r2, r2, #28
    e112:	0f12      	lsrs	r2, r2, #28
    e114:	b2d2      	uxtb	r2, r2
    e116:	e027      	b.n	e168 <cmd_task+0x500>
    e118:	20003780 	.word	0x20003780
    e11c:	0001ee9b 	.word	0x0001ee9b
    e120:	20004a78 	.word	0x20004a78
    e124:	0001ee7d 	.word	0x0001ee7d
    e128:	00020e68 	.word	0x00020e68
    e12c:	2000449c 	.word	0x2000449c
    e130:	00019b09 	.word	0x00019b09
    e134:	0001a101 	.word	0x0001a101
    e138:	0001a595 	.word	0x0001a595
    e13c:	0001ec51 	.word	0x0001ec51
    e140:	0000076c 	.word	0x0000076c
    e144:	20004bc8 	.word	0x20004bc8
    e148:	00013991 	.word	0x00013991
    e14c:	0001d591 	.word	0x0001d591
    e150:	0001d485 	.word	0x0001d485
    e154:	fffff830 	.word	0xfffff830
    e158:	0001d765 	.word	0x0001d765
    e15c:	0001d599 	.word	0x0001d599
    e160:	0000d5e9 	.word	0x0000d5e9
    e164:	0000d581 	.word	0x0000d581
    e168:	189b      	adds	r3, r3, r2
    e16a:	b2db      	uxtb	r3, r3
    e16c:	3b80      	subs	r3, #128	; 0x80
    e16e:	b2db      	uxtb	r3, r3
    e170:	0019      	movs	r1, r3
    e172:	2001      	movs	r0, #1
    e174:	4bb5      	ldr	r3, [pc, #724]	; (e44c <cmd_task+0x7e4>)
    e176:	4798      	blx	r3
	
	f_open(&file_object,"0:/Labels.bin",FA_READ);
    e178:	49b5      	ldr	r1, [pc, #724]	; (e450 <cmd_task+0x7e8>)
    e17a:	4bb6      	ldr	r3, [pc, #728]	; (e454 <cmd_task+0x7ec>)
    e17c:	2201      	movs	r2, #1
    e17e:	0018      	movs	r0, r3
    e180:	4bb5      	ldr	r3, [pc, #724]	; (e458 <cmd_task+0x7f0>)
    e182:	4798      	blx	r3
    f_lseek(&file_object,(uint32_t)xMachineSetup.ucLanguage*sizeof(LCDlabels));
    e184:	4bb5      	ldr	r3, [pc, #724]	; (e45c <cmd_task+0x7f4>)
    e186:	7bdb      	ldrb	r3, [r3, #15]
    e188:	001a      	movs	r2, r3
    e18a:	0013      	movs	r3, r2
    e18c:	011b      	lsls	r3, r3, #4
    e18e:	1a9b      	subs	r3, r3, r2
    e190:	019b      	lsls	r3, r3, #6
    e192:	001a      	movs	r2, r3
    e194:	4baf      	ldr	r3, [pc, #700]	; (e454 <cmd_task+0x7ec>)
    e196:	0011      	movs	r1, r2
    e198:	0018      	movs	r0, r3
    e19a:	4bb1      	ldr	r3, [pc, #708]	; (e460 <cmd_task+0x7f8>)
    e19c:	4798      	blx	r3
    f_read(&file_object,&LCDlabels,sizeof(LCDlabels),&uWrt);
    e19e:	2360      	movs	r3, #96	; 0x60
    e1a0:	18fc      	adds	r4, r7, r3
    e1a2:	23f0      	movs	r3, #240	; 0xf0
    e1a4:	009a      	lsls	r2, r3, #2
    e1a6:	49af      	ldr	r1, [pc, #700]	; (e464 <cmd_task+0x7fc>)
    e1a8:	48aa      	ldr	r0, [pc, #680]	; (e454 <cmd_task+0x7ec>)
    e1aa:	0023      	movs	r3, r4
    e1ac:	4cae      	ldr	r4, [pc, #696]	; (e468 <cmd_task+0x800>)
    e1ae:	47a0      	blx	r4
    f_close(&file_object);	
    e1b0:	4ba8      	ldr	r3, [pc, #672]	; (e454 <cmd_task+0x7ec>)
    e1b2:	0018      	movs	r0, r3
    e1b4:	4bad      	ldr	r3, [pc, #692]	; (e46c <cmd_task+0x804>)
    e1b6:	4798      	blx	r3
	
	TCPBuffer[0]=0x02;
    e1b8:	4bad      	ldr	r3, [pc, #692]	; (e470 <cmd_task+0x808>)
    e1ba:	2202      	movs	r2, #2
    e1bc:	701a      	strb	r2, [r3, #0]
	TCPBuffer[1]=0x00;
    e1be:	4bac      	ldr	r3, [pc, #688]	; (e470 <cmd_task+0x808>)
    e1c0:	2200      	movs	r2, #0
    e1c2:	705a      	strb	r2, [r3, #1]
	TCPBuffer[2]=0x00;
    e1c4:	4baa      	ldr	r3, [pc, #680]	; (e470 <cmd_task+0x808>)
    e1c6:	2200      	movs	r2, #0
    e1c8:	709a      	strb	r2, [r3, #2]
	vSendTCPReply(TCPBuffer,0x03);	  
    e1ca:	4ba9      	ldr	r3, [pc, #676]	; (e470 <cmd_task+0x808>)
    e1cc:	2103      	movs	r1, #3
    e1ce:	0018      	movs	r0, r3
    e1d0:	4ba8      	ldr	r3, [pc, #672]	; (e474 <cmd_task+0x80c>)
    e1d2:	4798      	blx	r3
	}
	
	break;
    e1d4:	e130      	b.n	e438 <cmd_task+0x7d0>
	
	case 0x03:
	{
	TCPBuffer[0]=0x03;
    e1d6:	4ba6      	ldr	r3, [pc, #664]	; (e470 <cmd_task+0x808>)
    e1d8:	2203      	movs	r2, #3
    e1da:	701a      	strb	r2, [r3, #0]
	TCPBuffer[1]=(uint8_t)xMachineState;
    e1dc:	4ba6      	ldr	r3, [pc, #664]	; (e478 <cmd_task+0x810>)
    e1de:	781a      	ldrb	r2, [r3, #0]
    e1e0:	4ba3      	ldr	r3, [pc, #652]	; (e470 <cmd_task+0x808>)
    e1e2:	705a      	strb	r2, [r3, #1]
	TCPBuffer[2]=(uint8_t)xAlarm;
    e1e4:	4ba5      	ldr	r3, [pc, #660]	; (e47c <cmd_task+0x814>)
    e1e6:	781a      	ldrb	r2, [r3, #0]
    e1e8:	4ba1      	ldr	r3, [pc, #644]	; (e470 <cmd_task+0x808>)
    e1ea:	709a      	strb	r2, [r3, #2]
	memcpy(&TCPBuffer[3],&ulProgramRunTime,sizeof(ulProgramRunTime));
    e1ec:	49a4      	ldr	r1, [pc, #656]	; (e480 <cmd_task+0x818>)
    e1ee:	4ba5      	ldr	r3, [pc, #660]	; (e484 <cmd_task+0x81c>)
    e1f0:	2204      	movs	r2, #4
    e1f2:	0018      	movs	r0, r3
    e1f4:	4ba4      	ldr	r3, [pc, #656]	; (e488 <cmd_task+0x820>)
    e1f6:	4798      	blx	r3
	memcpy(&TCPBuffer[7],&ulProgramTimeToEnd,sizeof(ulProgramRunTime));
    e1f8:	49a4      	ldr	r1, [pc, #656]	; (e48c <cmd_task+0x824>)
    e1fa:	4ba5      	ldr	r3, [pc, #660]	; (e490 <cmd_task+0x828>)
    e1fc:	2204      	movs	r2, #4
    e1fe:	0018      	movs	r0, r3
    e200:	4ba1      	ldr	r3, [pc, #644]	; (e488 <cmd_task+0x820>)
    e202:	4798      	blx	r3
	memcpy(&TCPBuffer[11],&ulMachineWorkTime,sizeof(ulProgramRunTime));
    e204:	49a3      	ldr	r1, [pc, #652]	; (e494 <cmd_task+0x82c>)
    e206:	4ba4      	ldr	r3, [pc, #656]	; (e498 <cmd_task+0x830>)
    e208:	2204      	movs	r2, #4
    e20a:	0018      	movs	r0, r3
    e20c:	4b9e      	ldr	r3, [pc, #632]	; (e488 <cmd_task+0x820>)
    e20e:	4798      	blx	r3
	TCPBuffer[15]=1;
    e210:	4b97      	ldr	r3, [pc, #604]	; (e470 <cmd_task+0x808>)
    e212:	2201      	movs	r2, #1
    e214:	73da      	strb	r2, [r3, #15]
	TCPBuffer[16]=0;
    e216:	4b96      	ldr	r3, [pc, #600]	; (e470 <cmd_task+0x808>)
    e218:	2200      	movs	r2, #0
    e21a:	741a      	strb	r2, [r3, #16]
	TCPBuffer[17]=0;
    e21c:	4b94      	ldr	r3, [pc, #592]	; (e470 <cmd_task+0x808>)
    e21e:	2200      	movs	r2, #0
    e220:	745a      	strb	r2, [r3, #17]
	TCPBuffer[18]=0;
    e222:	4b93      	ldr	r3, [pc, #588]	; (e470 <cmd_task+0x808>)
    e224:	2200      	movs	r2, #0
    e226:	749a      	strb	r2, [r3, #18]
	time_t xTmpTime;
	memcpy(&TCPBuffer[19],&xTmpTime,sizeof(time_t));
    e228:	2344      	movs	r3, #68	; 0x44
    e22a:	18f9      	adds	r1, r7, r3
    e22c:	4b9b      	ldr	r3, [pc, #620]	; (e49c <cmd_task+0x834>)
    e22e:	2204      	movs	r2, #4
    e230:	0018      	movs	r0, r3
    e232:	4b95      	ldr	r3, [pc, #596]	; (e488 <cmd_task+0x820>)
    e234:	4798      	blx	r3
	memset(&TCPBuffer[23],0x00,20);
    e236:	4b9a      	ldr	r3, [pc, #616]	; (e4a0 <cmd_task+0x838>)
    e238:	2214      	movs	r2, #20
    e23a:	2100      	movs	r1, #0
    e23c:	0018      	movs	r0, r3
    e23e:	4b99      	ldr	r3, [pc, #612]	; (e4a4 <cmd_task+0x83c>)
    e240:	4798      	blx	r3
    vSendTCPReply(TCPBuffer,0x03);
    e242:	4b8b      	ldr	r3, [pc, #556]	; (e470 <cmd_task+0x808>)
    e244:	2103      	movs	r1, #3
    e246:	0018      	movs	r0, r3
    e248:	4b8a      	ldr	r3, [pc, #552]	; (e474 <cmd_task+0x80c>)
    e24a:	4798      	blx	r3
	}
	
	break;
    e24c:	e0f4      	b.n	e438 <cmd_task+0x7d0>
	
	case 0x04:
	{
	 TCPBuffer[0]=0x04;
    e24e:	4b88      	ldr	r3, [pc, #544]	; (e470 <cmd_task+0x808>)
    e250:	2204      	movs	r2, #4
    e252:	701a      	strb	r2, [r3, #0]
     memcpy(&TCPBuffer[1],&xLogTable,sizeof(xLogTable));
    e254:	4b86      	ldr	r3, [pc, #536]	; (e470 <cmd_task+0x808>)
    e256:	2201      	movs	r2, #1
    e258:	4993      	ldr	r1, [pc, #588]	; (e4a8 <cmd_task+0x840>)
    e25a:	1898      	adds	r0, r3, r2
    e25c:	23fa      	movs	r3, #250	; 0xfa
    e25e:	009b      	lsls	r3, r3, #2
    e260:	001a      	movs	r2, r3
    e262:	4b89      	ldr	r3, [pc, #548]	; (e488 <cmd_task+0x820>)
    e264:	4798      	blx	r3
     vSendTCPReply(TCPBuffer,sizeof(xLogTable)+0x01);
    e266:	4a91      	ldr	r2, [pc, #580]	; (e4ac <cmd_task+0x844>)
    e268:	4b81      	ldr	r3, [pc, #516]	; (e470 <cmd_task+0x808>)
    e26a:	0011      	movs	r1, r2
    e26c:	0018      	movs	r0, r3
    e26e:	4b81      	ldr	r3, [pc, #516]	; (e474 <cmd_task+0x80c>)
    e270:	4798      	blx	r3
	}
		
	break;
    e272:	e0e1      	b.n	e438 <cmd_task+0x7d0>
	
	case 0x05:
	{  
	 UINT uSize;
	 uint8_t ucTempPage=TCPBuffer[2];
    e274:	236b      	movs	r3, #107	; 0x6b
    e276:	18fb      	adds	r3, r7, r3
    e278:	4a7d      	ldr	r2, [pc, #500]	; (e470 <cmd_task+0x808>)
    e27a:	7892      	ldrb	r2, [r2, #2]
    e27c:	701a      	strb	r2, [r3, #0]
	 sprintf(TempString,"0:/Logs/Log%03d.bin",TCPBuffer[1]);
    e27e:	4b7c      	ldr	r3, [pc, #496]	; (e470 <cmd_task+0x808>)
    e280:	785b      	ldrb	r3, [r3, #1]
    e282:	001a      	movs	r2, r3
    e284:	498a      	ldr	r1, [pc, #552]	; (e4b0 <cmd_task+0x848>)
    e286:	4b8b      	ldr	r3, [pc, #556]	; (e4b4 <cmd_task+0x84c>)
    e288:	0018      	movs	r0, r3
    e28a:	4b8b      	ldr	r3, [pc, #556]	; (e4b8 <cmd_task+0x850>)
    e28c:	4798      	blx	r3
	 f_open(&file_object,TempString,FA_READ);
    e28e:	4989      	ldr	r1, [pc, #548]	; (e4b4 <cmd_task+0x84c>)
    e290:	4b70      	ldr	r3, [pc, #448]	; (e454 <cmd_task+0x7ec>)
    e292:	2201      	movs	r2, #1
    e294:	0018      	movs	r0, r3
    e296:	4b70      	ldr	r3, [pc, #448]	; (e458 <cmd_task+0x7f0>)
    e298:	4798      	blx	r3
	 f_lseek(&file_object,(uint32_t)ucTempPage*sizeof(xLogData)*50);
    e29a:	236b      	movs	r3, #107	; 0x6b
    e29c:	18fb      	adds	r3, r7, r3
    e29e:	781b      	ldrb	r3, [r3, #0]
    e2a0:	22c8      	movs	r2, #200	; 0xc8
    e2a2:	0092      	lsls	r2, r2, #2
    e2a4:	435a      	muls	r2, r3
    e2a6:	4b6b      	ldr	r3, [pc, #428]	; (e454 <cmd_task+0x7ec>)
    e2a8:	0011      	movs	r1, r2
    e2aa:	0018      	movs	r0, r3
    e2ac:	4b6c      	ldr	r3, [pc, #432]	; (e460 <cmd_task+0x7f8>)
    e2ae:	4798      	blx	r3
     memset(TCPBuffer,0x00,sizeof(TCPBuffer));
    e2b0:	4a82      	ldr	r2, [pc, #520]	; (e4bc <cmd_task+0x854>)
    e2b2:	4b6f      	ldr	r3, [pc, #444]	; (e470 <cmd_task+0x808>)
    e2b4:	2100      	movs	r1, #0
    e2b6:	0018      	movs	r0, r3
    e2b8:	4b7a      	ldr	r3, [pc, #488]	; (e4a4 <cmd_task+0x83c>)
    e2ba:	4798      	blx	r3
	 f_read(&file_object,&TCPBuffer[2],sizeof(xLogData)*50,&uSize);
    e2bc:	2340      	movs	r3, #64	; 0x40
    e2be:	18fc      	adds	r4, r7, r3
    e2c0:	23c8      	movs	r3, #200	; 0xc8
    e2c2:	009a      	lsls	r2, r3, #2
    e2c4:	497e      	ldr	r1, [pc, #504]	; (e4c0 <cmd_task+0x858>)
    e2c6:	4863      	ldr	r0, [pc, #396]	; (e454 <cmd_task+0x7ec>)
    e2c8:	0023      	movs	r3, r4
    e2ca:	4c67      	ldr	r4, [pc, #412]	; (e468 <cmd_task+0x800>)
    e2cc:	47a0      	blx	r4
	 f_close(&file_object);		
    e2ce:	4b61      	ldr	r3, [pc, #388]	; (e454 <cmd_task+0x7ec>)
    e2d0:	0018      	movs	r0, r3
    e2d2:	4b66      	ldr	r3, [pc, #408]	; (e46c <cmd_task+0x804>)
    e2d4:	4798      	blx	r3
	 TCPBuffer[0]=5;
    e2d6:	4b66      	ldr	r3, [pc, #408]	; (e470 <cmd_task+0x808>)
    e2d8:	2205      	movs	r2, #5
    e2da:	701a      	strb	r2, [r3, #0]
	 TCPBuffer[1]=ucTempPage;
    e2dc:	4b64      	ldr	r3, [pc, #400]	; (e470 <cmd_task+0x808>)
    e2de:	226b      	movs	r2, #107	; 0x6b
    e2e0:	18ba      	adds	r2, r7, r2
    e2e2:	7812      	ldrb	r2, [r2, #0]
    e2e4:	705a      	strb	r2, [r3, #1]
	 vSendTCPReply(TCPBuffer,sizeof(xLogData)*50+0x02);
    e2e6:	4a77      	ldr	r2, [pc, #476]	; (e4c4 <cmd_task+0x85c>)
    e2e8:	4b61      	ldr	r3, [pc, #388]	; (e470 <cmd_task+0x808>)
    e2ea:	0011      	movs	r1, r2
    e2ec:	0018      	movs	r0, r3
    e2ee:	4b61      	ldr	r3, [pc, #388]	; (e474 <cmd_task+0x80c>)
    e2f0:	4798      	blx	r3
	}
	
	break;	
    e2f2:	e0a1      	b.n	e438 <cmd_task+0x7d0>
	
	case 0x06:
	{
     UINT uSize;		
	
	 memcpy(&xTags[TCPBuffer[1]],&TCPBuffer[2],sizeof(xTagData));
    e2f4:	4b5e      	ldr	r3, [pc, #376]	; (e470 <cmd_task+0x808>)
    e2f6:	785b      	ldrb	r3, [r3, #1]
    e2f8:	001a      	movs	r2, r3
    e2fa:	0013      	movs	r3, r2
    e2fc:	00db      	lsls	r3, r3, #3
    e2fe:	189b      	adds	r3, r3, r2
    e300:	4a71      	ldr	r2, [pc, #452]	; (e4c8 <cmd_task+0x860>)
    e302:	189b      	adds	r3, r3, r2
    e304:	496e      	ldr	r1, [pc, #440]	; (e4c0 <cmd_task+0x858>)
    e306:	2209      	movs	r2, #9
    e308:	0018      	movs	r0, r3
    e30a:	4b5f      	ldr	r3, [pc, #380]	; (e488 <cmd_task+0x820>)
    e30c:	4798      	blx	r3
	
	 f_open(&file_object,"0:/TagList.bin",FA_WRITE);
    e30e:	496f      	ldr	r1, [pc, #444]	; (e4cc <cmd_task+0x864>)
    e310:	4b50      	ldr	r3, [pc, #320]	; (e454 <cmd_task+0x7ec>)
    e312:	2202      	movs	r2, #2
    e314:	0018      	movs	r0, r3
    e316:	4b50      	ldr	r3, [pc, #320]	; (e458 <cmd_task+0x7f0>)
    e318:	4798      	blx	r3
	 f_lseek(&file_object,(uint32_t)TCPBuffer[1]*sizeof(xTagData));
    e31a:	4b55      	ldr	r3, [pc, #340]	; (e470 <cmd_task+0x808>)
    e31c:	785b      	ldrb	r3, [r3, #1]
    e31e:	001a      	movs	r2, r3
    e320:	0013      	movs	r3, r2
    e322:	00db      	lsls	r3, r3, #3
    e324:	189a      	adds	r2, r3, r2
    e326:	4b4b      	ldr	r3, [pc, #300]	; (e454 <cmd_task+0x7ec>)
    e328:	0011      	movs	r1, r2
    e32a:	0018      	movs	r0, r3
    e32c:	4b4c      	ldr	r3, [pc, #304]	; (e460 <cmd_task+0x7f8>)
    e32e:	4798      	blx	r3
	 f_write(&file_object,&TCPBuffer[2],sizeof(xTagData),&uSize); 
    e330:	233c      	movs	r3, #60	; 0x3c
    e332:	18fb      	adds	r3, r7, r3
    e334:	4962      	ldr	r1, [pc, #392]	; (e4c0 <cmd_task+0x858>)
    e336:	4847      	ldr	r0, [pc, #284]	; (e454 <cmd_task+0x7ec>)
    e338:	2209      	movs	r2, #9
    e33a:	4c65      	ldr	r4, [pc, #404]	; (e4d0 <cmd_task+0x868>)
    e33c:	47a0      	blx	r4
	 f_close(&file_object);	
    e33e:	4b45      	ldr	r3, [pc, #276]	; (e454 <cmd_task+0x7ec>)
    e340:	0018      	movs	r0, r3
    e342:	4b4a      	ldr	r3, [pc, #296]	; (e46c <cmd_task+0x804>)
    e344:	4798      	blx	r3
	 
	 TCPBuffer[0]=6;
    e346:	4b4a      	ldr	r3, [pc, #296]	; (e470 <cmd_task+0x808>)
    e348:	2206      	movs	r2, #6
    e34a:	701a      	strb	r2, [r3, #0]
	 TCPBuffer[1]=0x00;
    e34c:	4b48      	ldr	r3, [pc, #288]	; (e470 <cmd_task+0x808>)
    e34e:	2200      	movs	r2, #0
    e350:	705a      	strb	r2, [r3, #1]
	 vSendTCPReply(TCPBuffer,0x02);	 	 
    e352:	4b47      	ldr	r3, [pc, #284]	; (e470 <cmd_task+0x808>)
    e354:	2102      	movs	r1, #2
    e356:	0018      	movs	r0, r3
    e358:	4b46      	ldr	r3, [pc, #280]	; (e474 <cmd_task+0x80c>)
    e35a:	4798      	blx	r3
	 	
	}
	break;
    e35c:	e06c      	b.n	e438 <cmd_task+0x7d0>
	
    case 0x08:
	{
     UINT uSize;		
	
	 f_open(&file_object,"0:/Labels.bin",FA_WRITE);
    e35e:	493c      	ldr	r1, [pc, #240]	; (e450 <cmd_task+0x7e8>)
    e360:	4b3c      	ldr	r3, [pc, #240]	; (e454 <cmd_task+0x7ec>)
    e362:	2202      	movs	r2, #2
    e364:	0018      	movs	r0, r3
    e366:	4b3c      	ldr	r3, [pc, #240]	; (e458 <cmd_task+0x7f0>)
    e368:	4798      	blx	r3
	 f_lseek(&file_object,(uint32_t)TCPBuffer[1]*sizeof(LCDlabels)+(uint32_t)TCPBuffer[2]*MAXLSIZE);
    e36a:	4b41      	ldr	r3, [pc, #260]	; (e470 <cmd_task+0x808>)
    e36c:	785b      	ldrb	r3, [r3, #1]
    e36e:	001a      	movs	r2, r3
    e370:	0013      	movs	r3, r2
    e372:	011b      	lsls	r3, r3, #4
    e374:	1a9b      	subs	r3, r3, r2
    e376:	005b      	lsls	r3, r3, #1
    e378:	001a      	movs	r2, r3
    e37a:	4b3d      	ldr	r3, [pc, #244]	; (e470 <cmd_task+0x808>)
    e37c:	789b      	ldrb	r3, [r3, #2]
    e37e:	18d3      	adds	r3, r2, r3
    e380:	015a      	lsls	r2, r3, #5
    e382:	4b34      	ldr	r3, [pc, #208]	; (e454 <cmd_task+0x7ec>)
    e384:	0011      	movs	r1, r2
    e386:	0018      	movs	r0, r3
    e388:	4b35      	ldr	r3, [pc, #212]	; (e460 <cmd_task+0x7f8>)
    e38a:	4798      	blx	r3
	 f_write(&file_object,&TCPBuffer[3],MAXLSIZE,&uSize); 
    e38c:	2338      	movs	r3, #56	; 0x38
    e38e:	18fb      	adds	r3, r7, r3
    e390:	493c      	ldr	r1, [pc, #240]	; (e484 <cmd_task+0x81c>)
    e392:	4830      	ldr	r0, [pc, #192]	; (e454 <cmd_task+0x7ec>)
    e394:	2220      	movs	r2, #32
    e396:	4c4e      	ldr	r4, [pc, #312]	; (e4d0 <cmd_task+0x868>)
    e398:	47a0      	blx	r4
	 f_close(&file_object);
    e39a:	4b2e      	ldr	r3, [pc, #184]	; (e454 <cmd_task+0x7ec>)
    e39c:	0018      	movs	r0, r3
    e39e:	4b33      	ldr	r3, [pc, #204]	; (e46c <cmd_task+0x804>)
    e3a0:	4798      	blx	r3
	 
	 f_open(&file_object,"0:/Labels.bin",FA_READ);
    e3a2:	492b      	ldr	r1, [pc, #172]	; (e450 <cmd_task+0x7e8>)
    e3a4:	4b2b      	ldr	r3, [pc, #172]	; (e454 <cmd_task+0x7ec>)
    e3a6:	2201      	movs	r2, #1
    e3a8:	0018      	movs	r0, r3
    e3aa:	4b2b      	ldr	r3, [pc, #172]	; (e458 <cmd_task+0x7f0>)
    e3ac:	4798      	blx	r3
	 f_read(&file_object,LCDlabels,sizeof(LCDlabels),&uSize);
    e3ae:	2338      	movs	r3, #56	; 0x38
    e3b0:	18fc      	adds	r4, r7, r3
    e3b2:	23f0      	movs	r3, #240	; 0xf0
    e3b4:	009a      	lsls	r2, r3, #2
    e3b6:	492b      	ldr	r1, [pc, #172]	; (e464 <cmd_task+0x7fc>)
    e3b8:	4826      	ldr	r0, [pc, #152]	; (e454 <cmd_task+0x7ec>)
    e3ba:	0023      	movs	r3, r4
    e3bc:	4c2a      	ldr	r4, [pc, #168]	; (e468 <cmd_task+0x800>)
    e3be:	47a0      	blx	r4
	 f_close(&file_object);
    e3c0:	4b24      	ldr	r3, [pc, #144]	; (e454 <cmd_task+0x7ec>)
    e3c2:	0018      	movs	r0, r3
    e3c4:	4b29      	ldr	r3, [pc, #164]	; (e46c <cmd_task+0x804>)
    e3c6:	4798      	blx	r3
	 
	 TCPBuffer[0]=8;
    e3c8:	4b29      	ldr	r3, [pc, #164]	; (e470 <cmd_task+0x808>)
    e3ca:	2208      	movs	r2, #8
    e3cc:	701a      	strb	r2, [r3, #0]
	 TCPBuffer[1]=0x00;
    e3ce:	4b28      	ldr	r3, [pc, #160]	; (e470 <cmd_task+0x808>)
    e3d0:	2200      	movs	r2, #0
    e3d2:	705a      	strb	r2, [r3, #1]
	 vSendTCPReply(TCPBuffer,0x02);	 
    e3d4:	4b26      	ldr	r3, [pc, #152]	; (e470 <cmd_task+0x808>)
    e3d6:	2102      	movs	r1, #2
    e3d8:	0018      	movs	r0, r3
    e3da:	4b26      	ldr	r3, [pc, #152]	; (e474 <cmd_task+0x80c>)
    e3dc:	4798      	blx	r3
	 
	}
	break;
    e3de:	e02b      	b.n	e438 <cmd_task+0x7d0>
	
    case 0x09:
    {
	    UINT uSize;
	    
        ulMachineWorkTime=(uint32_t)xMachineSetup.usRevTime*60;
    e3e0:	4b1e      	ldr	r3, [pc, #120]	; (e45c <cmd_task+0x7f4>)
    e3e2:	7a5a      	ldrb	r2, [r3, #9]
    e3e4:	7a9b      	ldrb	r3, [r3, #10]
    e3e6:	021b      	lsls	r3, r3, #8
    e3e8:	4313      	orrs	r3, r2
    e3ea:	b29b      	uxth	r3, r3
    e3ec:	001a      	movs	r2, r3
    e3ee:	0013      	movs	r3, r2
    e3f0:	011b      	lsls	r3, r3, #4
    e3f2:	1a9b      	subs	r3, r3, r2
    e3f4:	009b      	lsls	r3, r3, #2
    e3f6:	001a      	movs	r2, r3
    e3f8:	4b26      	ldr	r3, [pc, #152]	; (e494 <cmd_task+0x82c>)
    e3fa:	601a      	str	r2, [r3, #0]
        f_open(&file_object,"0:/RunTime.bin",FA_CREATE_ALWAYS | FA_WRITE);
    e3fc:	4935      	ldr	r1, [pc, #212]	; (e4d4 <cmd_task+0x86c>)
    e3fe:	4b15      	ldr	r3, [pc, #84]	; (e454 <cmd_task+0x7ec>)
    e400:	220a      	movs	r2, #10
    e402:	0018      	movs	r0, r3
    e404:	4b14      	ldr	r3, [pc, #80]	; (e458 <cmd_task+0x7f0>)
    e406:	4798      	blx	r3
        f_write(&file_object,&ulMachineWorkTime,sizeof(ulMachineWorkTime),&uSize);
    e408:	2334      	movs	r3, #52	; 0x34
    e40a:	18fb      	adds	r3, r7, r3
    e40c:	4921      	ldr	r1, [pc, #132]	; (e494 <cmd_task+0x82c>)
    e40e:	4811      	ldr	r0, [pc, #68]	; (e454 <cmd_task+0x7ec>)
    e410:	2204      	movs	r2, #4
    e412:	4c2f      	ldr	r4, [pc, #188]	; (e4d0 <cmd_task+0x868>)
    e414:	47a0      	blx	r4
        f_close(&file_object);
    e416:	4b0f      	ldr	r3, [pc, #60]	; (e454 <cmd_task+0x7ec>)
    e418:	0018      	movs	r0, r3
    e41a:	4b14      	ldr	r3, [pc, #80]	; (e46c <cmd_task+0x804>)
    e41c:	4798      	blx	r3
	    
	    TCPBuffer[0]=9;
    e41e:	4b14      	ldr	r3, [pc, #80]	; (e470 <cmd_task+0x808>)
    e420:	2209      	movs	r2, #9
    e422:	701a      	strb	r2, [r3, #0]
	    TCPBuffer[1]=0x00;
    e424:	4b12      	ldr	r3, [pc, #72]	; (e470 <cmd_task+0x808>)
    e426:	2200      	movs	r2, #0
    e428:	705a      	strb	r2, [r3, #1]
	    vSendTCPReply(TCPBuffer,0x02);
    e42a:	4b11      	ldr	r3, [pc, #68]	; (e470 <cmd_task+0x808>)
    e42c:	2102      	movs	r1, #2
    e42e:	0018      	movs	r0, r3
    e430:	4b10      	ldr	r3, [pc, #64]	; (e474 <cmd_task+0x80c>)
    e432:	4798      	blx	r3
	    
    }
    break;	
    e434:	e000      	b.n	e438 <cmd_task+0x7d0>
	
	default:break;   
    e436:	46c0      	nop			; (mov r8, r8)
  }
  
  recv(tcp_client_socket, TCPBuffer, sizeof(TCPBuffer), 10000);
    e438:	4b27      	ldr	r3, [pc, #156]	; (e4d8 <cmd_task+0x870>)
    e43a:	2000      	movs	r0, #0
    e43c:	5618      	ldrsb	r0, [r3, r0]
    e43e:	4b27      	ldr	r3, [pc, #156]	; (e4dc <cmd_task+0x874>)
    e440:	4a1e      	ldr	r2, [pc, #120]	; (e4bc <cmd_task+0x854>)
    e442:	490b      	ldr	r1, [pc, #44]	; (e470 <cmd_task+0x808>)
    e444:	4c26      	ldr	r4, [pc, #152]	; (e4e0 <cmd_task+0x878>)
    e446:	47a0      	blx	r4
  
 }
    e448:	e412      	b.n	dc70 <cmd_task+0x8>
    e44a:	46c0      	nop			; (mov r8, r8)
    e44c:	0000d581 	.word	0x0000d581
    e450:	00020e78 	.word	0x00020e78
    e454:	2000449c 	.word	0x2000449c
    e458:	00019b09 	.word	0x00019b09
    e45c:	20004a78 	.word	0x20004a78
    e460:	0001a5ed 	.word	0x0001a5ed
    e464:	20000054 	.word	0x20000054
    e468:	00019e59 	.word	0x00019e59
    e46c:	0001a595 	.word	0x0001a595
    e470:	20003780 	.word	0x20003780
    e474:	0000d96d 	.word	0x0000d96d
    e478:	20004aa4 	.word	0x20004aa4
    e47c:	20004a73 	.word	0x20004a73
    e480:	200046e8 	.word	0x200046e8
    e484:	20003783 	.word	0x20003783
    e488:	0001ee9b 	.word	0x0001ee9b
    e48c:	200049dc 	.word	0x200049dc
    e490:	20003787 	.word	0x20003787
    e494:	20004aa8 	.word	0x20004aa8
    e498:	2000378b 	.word	0x2000378b
    e49c:	20003793 	.word	0x20003793
    e4a0:	20003797 	.word	0x20003797
    e4a4:	0001eead 	.word	0x0001eead
    e4a8:	20003e48 	.word	0x20003e48
    e4ac:	000003e9 	.word	0x000003e9
    e4b0:	00020e88 	.word	0x00020e88
    e4b4:	20004480 	.word	0x20004480
    e4b8:	0001f4a9 	.word	0x0001f4a9
    e4bc:	000005b4 	.word	0x000005b4
    e4c0:	20003782 	.word	0x20003782
    e4c4:	00000322 	.word	0x00000322
    e4c8:	20004928 	.word	0x20004928
    e4cc:	00020e9c 	.word	0x00020e9c
    e4d0:	0001a101 	.word	0x0001a101
    e4d4:	00020eac 	.word	0x00020eac
    e4d8:	20000025 	.word	0x20000025
    e4dc:	00002710 	.word	0x00002710
    e4e0:	0000b8e1 	.word	0x0000b8e1

0000e4e4 <system_interrupt_enter_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
    e4e4:	b580      	push	{r7, lr}
    e4e6:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
    e4e8:	4b02      	ldr	r3, [pc, #8]	; (e4f4 <system_interrupt_enter_critical_section+0x10>)
    e4ea:	4798      	blx	r3
}
    e4ec:	46c0      	nop			; (mov r8, r8)
    e4ee:	46bd      	mov	sp, r7
    e4f0:	bd80      	pop	{r7, pc}
    e4f2:	46c0      	nop			; (mov r8, r8)
    e4f4:	00013345 	.word	0x00013345

0000e4f8 <system_interrupt_leave_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
    e4f8:	b580      	push	{r7, lr}
    e4fa:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
    e4fc:	4b02      	ldr	r3, [pc, #8]	; (e508 <system_interrupt_leave_critical_section+0x10>)
    e4fe:	4798      	blx	r3
}
    e500:	46c0      	nop			; (mov r8, r8)
    e502:	46bd      	mov	sp, r7
    e504:	bd80      	pop	{r7, pc}
    e506:	46c0      	nop			; (mov r8, r8)
    e508:	00013399 	.word	0x00013399

0000e50c <DMAC_Handler>:
/**
 * \brief DMA interrupt service routine.
 *
 */
void DMAC_Handler( void )
{
    e50c:	b580      	push	{r7, lr}
    e50e:	b086      	sub	sp, #24
    e510:	af00      	add	r7, sp, #0
	struct dma_resource *resource;
	uint8_t isr;
	uint32_t write_size;
	uint32_t total_size;

	system_interrupt_enter_critical_section();
    e512:	4b49      	ldr	r3, [pc, #292]	; (e638 <DMAC_Handler+0x12c>)
    e514:	4798      	blx	r3

	/* Get Pending channel */
	active_channel =  DMAC->INTPEND.reg & DMAC_INTPEND_ID_Msk;
    e516:	4b49      	ldr	r3, [pc, #292]	; (e63c <DMAC_Handler+0x130>)
    e518:	8c1b      	ldrh	r3, [r3, #32]
    e51a:	b29b      	uxth	r3, r3
    e51c:	b2da      	uxtb	r2, r3
    e51e:	2317      	movs	r3, #23
    e520:	18fb      	adds	r3, r7, r3
    e522:	210f      	movs	r1, #15
    e524:	400a      	ands	r2, r1
    e526:	701a      	strb	r2, [r3, #0]

	Assert(_dma_active_resource[active_channel]);

	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];
    e528:	2317      	movs	r3, #23
    e52a:	18fb      	adds	r3, r7, r3
    e52c:	781a      	ldrb	r2, [r3, #0]
    e52e:	4b44      	ldr	r3, [pc, #272]	; (e640 <DMAC_Handler+0x134>)
    e530:	0092      	lsls	r2, r2, #2
    e532:	58d3      	ldr	r3, [r2, r3]
    e534:	613b      	str	r3, [r7, #16]

	/* Select the active channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    e536:	4a41      	ldr	r2, [pc, #260]	; (e63c <DMAC_Handler+0x130>)
    e538:	693b      	ldr	r3, [r7, #16]
    e53a:	781b      	ldrb	r3, [r3, #0]
    e53c:	210f      	movs	r1, #15
    e53e:	400b      	ands	r3, r1
    e540:	b2d9      	uxtb	r1, r3
    e542:	233f      	movs	r3, #63	; 0x3f
    e544:	54d1      	strb	r1, [r2, r3]
	isr = DMAC->CHINTFLAG.reg;
    e546:	493d      	ldr	r1, [pc, #244]	; (e63c <DMAC_Handler+0x130>)
    e548:	230f      	movs	r3, #15
    e54a:	18fb      	adds	r3, r7, r3
    e54c:	224e      	movs	r2, #78	; 0x4e
    e54e:	5c8a      	ldrb	r2, [r1, r2]
    e550:	701a      	strb	r2, [r3, #0]

	/* Calculate block transfer size of the DMA transfer */
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
    e552:	693b      	ldr	r3, [r7, #16]
    e554:	781b      	ldrb	r3, [r3, #0]
    e556:	4a3b      	ldr	r2, [pc, #236]	; (e644 <DMAC_Handler+0x138>)
    e558:	011b      	lsls	r3, r3, #4
    e55a:	18d3      	adds	r3, r2, r3
    e55c:	3302      	adds	r3, #2
    e55e:	881b      	ldrh	r3, [r3, #0]
    e560:	b29b      	uxth	r3, r3
    e562:	60bb      	str	r3, [r7, #8]
	write_size = _write_back_section[resource->channel_id].BTCNT.reg;
    e564:	693b      	ldr	r3, [r7, #16]
    e566:	781b      	ldrb	r3, [r3, #0]
    e568:	4a37      	ldr	r2, [pc, #220]	; (e648 <DMAC_Handler+0x13c>)
    e56a:	011b      	lsls	r3, r3, #4
    e56c:	18d3      	adds	r3, r2, r3
    e56e:	3302      	adds	r3, #2
    e570:	881b      	ldrh	r3, [r3, #0]
    e572:	b29b      	uxth	r3, r3
    e574:	607b      	str	r3, [r7, #4]
	resource->transfered_size = total_size - write_size;
    e576:	68ba      	ldr	r2, [r7, #8]
    e578:	687b      	ldr	r3, [r7, #4]
    e57a:	1ad2      	subs	r2, r2, r3
    e57c:	693b      	ldr	r3, [r7, #16]
    e57e:	615a      	str	r2, [r3, #20]

	/* DMA channel interrupt handler */
	if (isr & DMAC_CHINTENCLR_TERR) {
    e580:	230f      	movs	r3, #15
    e582:	18fb      	adds	r3, r7, r3
    e584:	781b      	ldrb	r3, [r3, #0]
    e586:	2201      	movs	r2, #1
    e588:	4013      	ands	r3, r2
    e58a:	d016      	beq.n	e5ba <DMAC_Handler+0xae>
		/* Clear transfer error flag */
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TERR;
    e58c:	4a2b      	ldr	r2, [pc, #172]	; (e63c <DMAC_Handler+0x130>)
    e58e:	234e      	movs	r3, #78	; 0x4e
    e590:	2101      	movs	r1, #1
    e592:	54d1      	strb	r1, [r2, r3]

		/* Set I/O ERROR status */
		resource->job_status = STATUS_ERR_IO;
    e594:	693b      	ldr	r3, [r7, #16]
    e596:	2210      	movs	r2, #16
    e598:	745a      	strb	r2, [r3, #17]

		/* Execute the callback function */
		if ((resource->callback_enable & (1<<DMA_CALLBACK_TRANSFER_ERROR)) &&
    e59a:	693b      	ldr	r3, [r7, #16]
    e59c:	7c1b      	ldrb	r3, [r3, #16]
    e59e:	001a      	movs	r2, r3
    e5a0:	2301      	movs	r3, #1
    e5a2:	4013      	ands	r3, r2
    e5a4:	d042      	beq.n	e62c <DMAC_Handler+0x120>
				(resource->callback[DMA_CALLBACK_TRANSFER_ERROR])) {
    e5a6:	693b      	ldr	r3, [r7, #16]
    e5a8:	685b      	ldr	r3, [r3, #4]

		/* Set I/O ERROR status */
		resource->job_status = STATUS_ERR_IO;

		/* Execute the callback function */
		if ((resource->callback_enable & (1<<DMA_CALLBACK_TRANSFER_ERROR)) &&
    e5aa:	2b00      	cmp	r3, #0
    e5ac:	d03e      	beq.n	e62c <DMAC_Handler+0x120>
				(resource->callback[DMA_CALLBACK_TRANSFER_ERROR])) {
			resource->callback[DMA_CALLBACK_TRANSFER_ERROR](resource);
    e5ae:	693b      	ldr	r3, [r7, #16]
    e5b0:	685b      	ldr	r3, [r3, #4]
    e5b2:	693a      	ldr	r2, [r7, #16]
    e5b4:	0010      	movs	r0, r2
    e5b6:	4798      	blx	r3
    e5b8:	e038      	b.n	e62c <DMAC_Handler+0x120>
		}
	} else if (isr & DMAC_CHINTENCLR_TCMPL) {
    e5ba:	230f      	movs	r3, #15
    e5bc:	18fb      	adds	r3, r7, r3
    e5be:	781b      	ldrb	r3, [r3, #0]
    e5c0:	2202      	movs	r2, #2
    e5c2:	4013      	ands	r3, r2
    e5c4:	d016      	beq.n	e5f4 <DMAC_Handler+0xe8>
		/* Clear the transfer complete flag */
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TCMPL;
    e5c6:	4a1d      	ldr	r2, [pc, #116]	; (e63c <DMAC_Handler+0x130>)
    e5c8:	234e      	movs	r3, #78	; 0x4e
    e5ca:	2102      	movs	r1, #2
    e5cc:	54d1      	strb	r1, [r2, r3]

		/* Set job status */
		resource->job_status = STATUS_OK;
    e5ce:	693b      	ldr	r3, [r7, #16]
    e5d0:	2200      	movs	r2, #0
    e5d2:	745a      	strb	r2, [r3, #17]

		/* Execute the callback function */
		if ((resource->callback_enable & (1 << DMA_CALLBACK_TRANSFER_DONE)) &&
    e5d4:	693b      	ldr	r3, [r7, #16]
    e5d6:	7c1b      	ldrb	r3, [r3, #16]
    e5d8:	001a      	movs	r2, r3
    e5da:	2302      	movs	r3, #2
    e5dc:	4013      	ands	r3, r2
    e5de:	d025      	beq.n	e62c <DMAC_Handler+0x120>
				(resource->callback[DMA_CALLBACK_TRANSFER_DONE])) {
    e5e0:	693b      	ldr	r3, [r7, #16]
    e5e2:	689b      	ldr	r3, [r3, #8]

		/* Set job status */
		resource->job_status = STATUS_OK;

		/* Execute the callback function */
		if ((resource->callback_enable & (1 << DMA_CALLBACK_TRANSFER_DONE)) &&
    e5e4:	2b00      	cmp	r3, #0
    e5e6:	d021      	beq.n	e62c <DMAC_Handler+0x120>
				(resource->callback[DMA_CALLBACK_TRANSFER_DONE])) {
			resource->callback[DMA_CALLBACK_TRANSFER_DONE](resource);
    e5e8:	693b      	ldr	r3, [r7, #16]
    e5ea:	689b      	ldr	r3, [r3, #8]
    e5ec:	693a      	ldr	r2, [r7, #16]
    e5ee:	0010      	movs	r0, r2
    e5f0:	4798      	blx	r3
    e5f2:	e01b      	b.n	e62c <DMAC_Handler+0x120>
		}
	} else if (isr & DMAC_CHINTENCLR_SUSP) {
    e5f4:	230f      	movs	r3, #15
    e5f6:	18fb      	adds	r3, r7, r3
    e5f8:	781b      	ldrb	r3, [r3, #0]
    e5fa:	2204      	movs	r2, #4
    e5fc:	4013      	ands	r3, r2
    e5fe:	d015      	beq.n	e62c <DMAC_Handler+0x120>
		/* Clear channel suspend flag */
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_SUSP;
    e600:	4a0e      	ldr	r2, [pc, #56]	; (e63c <DMAC_Handler+0x130>)
    e602:	234e      	movs	r3, #78	; 0x4e
    e604:	2104      	movs	r1, #4
    e606:	54d1      	strb	r1, [r2, r3]

		/* Set job status */
		resource->job_status = STATUS_SUSPEND;
    e608:	693b      	ldr	r3, [r7, #16]
    e60a:	2206      	movs	r2, #6
    e60c:	745a      	strb	r2, [r3, #17]

		/* Execute the callback function */
		if ((resource->callback_enable & (1 << DMA_CALLBACK_CHANNEL_SUSPEND)) &&
    e60e:	693b      	ldr	r3, [r7, #16]
    e610:	7c1b      	ldrb	r3, [r3, #16]
    e612:	001a      	movs	r2, r3
    e614:	2304      	movs	r3, #4
    e616:	4013      	ands	r3, r2
    e618:	d008      	beq.n	e62c <DMAC_Handler+0x120>
			(resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND])){
    e61a:	693b      	ldr	r3, [r7, #16]
    e61c:	68db      	ldr	r3, [r3, #12]

		/* Set job status */
		resource->job_status = STATUS_SUSPEND;

		/* Execute the callback function */
		if ((resource->callback_enable & (1 << DMA_CALLBACK_CHANNEL_SUSPEND)) &&
    e61e:	2b00      	cmp	r3, #0
    e620:	d004      	beq.n	e62c <DMAC_Handler+0x120>
			(resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND])){
			resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND](resource);
    e622:	693b      	ldr	r3, [r7, #16]
    e624:	68db      	ldr	r3, [r3, #12]
    e626:	693a      	ldr	r2, [r7, #16]
    e628:	0010      	movs	r0, r2
    e62a:	4798      	blx	r3
		}
	}

	system_interrupt_leave_critical_section();
    e62c:	4b07      	ldr	r3, [pc, #28]	; (e64c <DMAC_Handler+0x140>)
    e62e:	4798      	blx	r3
}
    e630:	46c0      	nop			; (mov r8, r8)
    e632:	46bd      	mov	sp, r7
    e634:	b006      	add	sp, #24
    e636:	bd80      	pop	{r7, pc}
    e638:	0000e4e5 	.word	0x0000e4e5
    e63c:	41004800 	.word	0x41004800
    e640:	20000590 	.word	0x20000590
    e644:	20004b00 	.word	0x20004b00
    e648:	20000540 	.word	0x20000540
    e64c:	0000e4f9 	.word	0x0000e4f9

0000e650 <_extint_get_eic_from_channel>:
 *
 * \return Base address of the associated EIC module.
 */
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
    e650:	b580      	push	{r7, lr}
    e652:	b084      	sub	sp, #16
    e654:	af00      	add	r7, sp, #0
    e656:	0002      	movs	r2, r0
    e658:	1dfb      	adds	r3, r7, #7
    e65a:	701a      	strb	r2, [r3, #0]
	uint8_t eic_index = (channel / 32);
    e65c:	230f      	movs	r3, #15
    e65e:	18fb      	adds	r3, r7, r3
    e660:	1dfa      	adds	r2, r7, #7
    e662:	7812      	ldrb	r2, [r2, #0]
    e664:	0952      	lsrs	r2, r2, #5
    e666:	701a      	strb	r2, [r3, #0]

	if (eic_index < EIC_INST_NUM) {
    e668:	230f      	movs	r3, #15
    e66a:	18fb      	adds	r3, r7, r3
    e66c:	781b      	ldrb	r3, [r3, #0]
    e66e:	2b00      	cmp	r3, #0
    e670:	d10c      	bne.n	e68c <_extint_get_eic_from_channel+0x3c>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    e672:	4b09      	ldr	r3, [pc, #36]	; (e698 <_extint_get_eic_from_channel+0x48>)
    e674:	60bb      	str	r3, [r7, #8]

		return eics[eic_index];
    e676:	230f      	movs	r3, #15
    e678:	18fb      	adds	r3, r7, r3
    e67a:	781b      	ldrb	r3, [r3, #0]
    e67c:	009b      	lsls	r3, r3, #2
    e67e:	2210      	movs	r2, #16
    e680:	4694      	mov	ip, r2
    e682:	44bc      	add	ip, r7
    e684:	4463      	add	r3, ip
    e686:	3b08      	subs	r3, #8
    e688:	681b      	ldr	r3, [r3, #0]
    e68a:	e000      	b.n	e68e <_extint_get_eic_from_channel+0x3e>
	} else {
		Assert(false);
		return NULL;
    e68c:	2300      	movs	r3, #0
	}
}
    e68e:	0018      	movs	r0, r3
    e690:	46bd      	mov	sp, r7
    e692:	b004      	add	sp, #16
    e694:	bd80      	pop	{r7, pc}
    e696:	46c0      	nop			; (mov r8, r8)
    e698:	40001800 	.word	0x40001800

0000e69c <extint_chan_is_detected>:
 *  \retval true   If the channel's edge/level detection criteria was met
 *  \retval false  If the channel has not detected its configured criteria
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
    e69c:	b580      	push	{r7, lr}
    e69e:	b084      	sub	sp, #16
    e6a0:	af00      	add	r7, sp, #0
    e6a2:	0002      	movs	r2, r0
    e6a4:	1dfb      	adds	r3, r7, #7
    e6a6:	701a      	strb	r2, [r3, #0]
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
    e6a8:	1dfb      	adds	r3, r7, #7
    e6aa:	781b      	ldrb	r3, [r3, #0]
    e6ac:	0018      	movs	r0, r3
    e6ae:	4b0b      	ldr	r3, [pc, #44]	; (e6dc <extint_chan_is_detected+0x40>)
    e6b0:	4798      	blx	r3
    e6b2:	0003      	movs	r3, r0
    e6b4:	60fb      	str	r3, [r7, #12]
	uint32_t eic_mask   = (1UL << (channel % 32));
    e6b6:	1dfb      	adds	r3, r7, #7
    e6b8:	781b      	ldrb	r3, [r3, #0]
    e6ba:	221f      	movs	r2, #31
    e6bc:	4013      	ands	r3, r2
    e6be:	2201      	movs	r2, #1
    e6c0:	409a      	lsls	r2, r3
    e6c2:	0013      	movs	r3, r2
    e6c4:	60bb      	str	r3, [r7, #8]

	return (eic_module->INTFLAG.reg & eic_mask);
    e6c6:	68fb      	ldr	r3, [r7, #12]
    e6c8:	691b      	ldr	r3, [r3, #16]
    e6ca:	68ba      	ldr	r2, [r7, #8]
    e6cc:	4013      	ands	r3, r2
    e6ce:	1e5a      	subs	r2, r3, #1
    e6d0:	4193      	sbcs	r3, r2
    e6d2:	b2db      	uxtb	r3, r3
}
    e6d4:	0018      	movs	r0, r3
    e6d6:	46bd      	mov	sp, r7
    e6d8:	b004      	add	sp, #16
    e6da:	bd80      	pop	{r7, pc}
    e6dc:	0000e651 	.word	0x0000e651

0000e6e0 <extint_chan_clear_detected>:
 *
 *  \param[in] channel  External Interrupt channel index to check
 */
static inline void extint_chan_clear_detected(
		const uint8_t channel)
{
    e6e0:	b580      	push	{r7, lr}
    e6e2:	b084      	sub	sp, #16
    e6e4:	af00      	add	r7, sp, #0
    e6e6:	0002      	movs	r2, r0
    e6e8:	1dfb      	adds	r3, r7, #7
    e6ea:	701a      	strb	r2, [r3, #0]
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
    e6ec:	1dfb      	adds	r3, r7, #7
    e6ee:	781b      	ldrb	r3, [r3, #0]
    e6f0:	0018      	movs	r0, r3
    e6f2:	4b09      	ldr	r3, [pc, #36]	; (e718 <extint_chan_clear_detected+0x38>)
    e6f4:	4798      	blx	r3
    e6f6:	0003      	movs	r3, r0
    e6f8:	60fb      	str	r3, [r7, #12]
	uint32_t eic_mask   = (1UL << (channel % 32));
    e6fa:	1dfb      	adds	r3, r7, #7
    e6fc:	781b      	ldrb	r3, [r3, #0]
    e6fe:	221f      	movs	r2, #31
    e700:	4013      	ands	r3, r2
    e702:	2201      	movs	r2, #1
    e704:	409a      	lsls	r2, r3
    e706:	0013      	movs	r3, r2
    e708:	60bb      	str	r3, [r7, #8]

	eic_module->INTFLAG.reg = eic_mask;
    e70a:	68fb      	ldr	r3, [r7, #12]
    e70c:	68ba      	ldr	r2, [r7, #8]
    e70e:	611a      	str	r2, [r3, #16]
}
    e710:	46c0      	nop			; (mov r8, r8)
    e712:	46bd      	mov	sp, r7
    e714:	b004      	add	sp, #16
    e716:	bd80      	pop	{r7, pc}
    e718:	0000e651 	.word	0x0000e651

0000e71c <extint_register_callback>:
 */
enum status_code extint_register_callback(
	const extint_callback_t callback,
	const uint8_t channel,
	const enum extint_callback_type type)
{
    e71c:	b580      	push	{r7, lr}
    e71e:	b082      	sub	sp, #8
    e720:	af00      	add	r7, sp, #0
    e722:	6078      	str	r0, [r7, #4]
    e724:	0008      	movs	r0, r1
    e726:	0011      	movs	r1, r2
    e728:	1cfb      	adds	r3, r7, #3
    e72a:	1c02      	adds	r2, r0, #0
    e72c:	701a      	strb	r2, [r3, #0]
    e72e:	1cbb      	adds	r3, r7, #2
    e730:	1c0a      	adds	r2, r1, #0
    e732:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
    e734:	1cbb      	adds	r3, r7, #2
    e736:	781b      	ldrb	r3, [r3, #0]
    e738:	2b00      	cmp	r3, #0
    e73a:	d001      	beq.n	e740 <extint_register_callback+0x24>
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    e73c:	2317      	movs	r3, #23
    e73e:	e019      	b.n	e774 <extint_register_callback+0x58>
	}

	if (_extint_dev.callbacks[channel] == NULL) {
    e740:	1cfb      	adds	r3, r7, #3
    e742:	781a      	ldrb	r2, [r3, #0]
    e744:	4b0d      	ldr	r3, [pc, #52]	; (e77c <extint_register_callback+0x60>)
    e746:	0092      	lsls	r2, r2, #2
    e748:	58d3      	ldr	r3, [r2, r3]
    e74a:	2b00      	cmp	r3, #0
    e74c:	d107      	bne.n	e75e <extint_register_callback+0x42>
		_extint_dev.callbacks[channel] = callback;
    e74e:	1cfb      	adds	r3, r7, #3
    e750:	781a      	ldrb	r2, [r3, #0]
    e752:	4b0a      	ldr	r3, [pc, #40]	; (e77c <extint_register_callback+0x60>)
    e754:	0092      	lsls	r2, r2, #2
    e756:	6879      	ldr	r1, [r7, #4]
    e758:	50d1      	str	r1, [r2, r3]
		return STATUS_OK;
    e75a:	2300      	movs	r3, #0
    e75c:	e00a      	b.n	e774 <extint_register_callback+0x58>
	} else if (_extint_dev.callbacks[channel] == callback) {
    e75e:	1cfb      	adds	r3, r7, #3
    e760:	781a      	ldrb	r2, [r3, #0]
    e762:	4b06      	ldr	r3, [pc, #24]	; (e77c <extint_register_callback+0x60>)
    e764:	0092      	lsls	r2, r2, #2
    e766:	58d2      	ldr	r2, [r2, r3]
    e768:	687b      	ldr	r3, [r7, #4]
    e76a:	429a      	cmp	r2, r3
    e76c:	d101      	bne.n	e772 <extint_register_callback+0x56>
		return STATUS_OK;
    e76e:	2300      	movs	r3, #0
    e770:	e000      	b.n	e774 <extint_register_callback+0x58>
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
    e772:	231d      	movs	r3, #29
}
    e774:	0018      	movs	r0, r3
    e776:	46bd      	mov	sp, r7
    e778:	b002      	add	sp, #8
    e77a:	bd80      	pop	{r7, pc}
    e77c:	20004b54 	.word	0x20004b54

0000e780 <extint_chan_enable_callback>:
 * \retval STATUS_ERR_INVALID_ARG  If an invalid callback type was supplied
 */
enum status_code extint_chan_enable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
    e780:	b580      	push	{r7, lr}
    e782:	b084      	sub	sp, #16
    e784:	af00      	add	r7, sp, #0
    e786:	0002      	movs	r2, r0
    e788:	1dfb      	adds	r3, r7, #7
    e78a:	701a      	strb	r2, [r3, #0]
    e78c:	1dbb      	adds	r3, r7, #6
    e78e:	1c0a      	adds	r2, r1, #0
    e790:	701a      	strb	r2, [r3, #0]
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    e792:	1dbb      	adds	r3, r7, #6
    e794:	781b      	ldrb	r3, [r3, #0]
    e796:	2b00      	cmp	r3, #0
    e798:	d10e      	bne.n	e7b8 <extint_chan_enable_callback+0x38>
		Eic *const eic = _extint_get_eic_from_channel(channel);
    e79a:	1dfb      	adds	r3, r7, #7
    e79c:	781b      	ldrb	r3, [r3, #0]
    e79e:	0018      	movs	r0, r3
    e7a0:	4b08      	ldr	r3, [pc, #32]	; (e7c4 <extint_chan_enable_callback+0x44>)
    e7a2:	4798      	blx	r3
    e7a4:	0003      	movs	r3, r0
    e7a6:	60fb      	str	r3, [r7, #12]

		eic->INTENSET.reg = (1UL << channel);
    e7a8:	1dfb      	adds	r3, r7, #7
    e7aa:	781b      	ldrb	r3, [r3, #0]
    e7ac:	2201      	movs	r2, #1
    e7ae:	409a      	lsls	r2, r3
    e7b0:	68fb      	ldr	r3, [r7, #12]
    e7b2:	60da      	str	r2, [r3, #12]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    e7b4:	2300      	movs	r3, #0
    e7b6:	e000      	b.n	e7ba <extint_chan_enable_callback+0x3a>

		eic->INTENSET.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    e7b8:	2317      	movs	r3, #23
	}

	return STATUS_OK;
}
    e7ba:	0018      	movs	r0, r3
    e7bc:	46bd      	mov	sp, r7
    e7be:	b004      	add	sp, #16
    e7c0:	bd80      	pop	{r7, pc}
    e7c2:	46c0      	nop			; (mov r8, r8)
    e7c4:	0000e651 	.word	0x0000e651

0000e7c8 <extint_chan_disable_callback>:
 * \retval STATUS_ERR_INVALID_ARG  If an invalid callback type was supplied
 */
enum status_code extint_chan_disable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
    e7c8:	b580      	push	{r7, lr}
    e7ca:	b084      	sub	sp, #16
    e7cc:	af00      	add	r7, sp, #0
    e7ce:	0002      	movs	r2, r0
    e7d0:	1dfb      	adds	r3, r7, #7
    e7d2:	701a      	strb	r2, [r3, #0]
    e7d4:	1dbb      	adds	r3, r7, #6
    e7d6:	1c0a      	adds	r2, r1, #0
    e7d8:	701a      	strb	r2, [r3, #0]
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    e7da:	1dbb      	adds	r3, r7, #6
    e7dc:	781b      	ldrb	r3, [r3, #0]
    e7de:	2b00      	cmp	r3, #0
    e7e0:	d10e      	bne.n	e800 <extint_chan_disable_callback+0x38>
		Eic *const eic = _extint_get_eic_from_channel(channel);
    e7e2:	1dfb      	adds	r3, r7, #7
    e7e4:	781b      	ldrb	r3, [r3, #0]
    e7e6:	0018      	movs	r0, r3
    e7e8:	4b08      	ldr	r3, [pc, #32]	; (e80c <extint_chan_disable_callback+0x44>)
    e7ea:	4798      	blx	r3
    e7ec:	0003      	movs	r3, r0
    e7ee:	60fb      	str	r3, [r7, #12]

		eic->INTENCLR.reg = (1UL << channel);
    e7f0:	1dfb      	adds	r3, r7, #7
    e7f2:	781b      	ldrb	r3, [r3, #0]
    e7f4:	2201      	movs	r2, #1
    e7f6:	409a      	lsls	r2, r3
    e7f8:	68fb      	ldr	r3, [r7, #12]
    e7fa:	609a      	str	r2, [r3, #8]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    e7fc:	2300      	movs	r3, #0
    e7fe:	e000      	b.n	e802 <extint_chan_disable_callback+0x3a>

		eic->INTENCLR.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    e800:	2317      	movs	r3, #23
	}

	return STATUS_OK;
}
    e802:	0018      	movs	r0, r3
    e804:	46bd      	mov	sp, r7
    e806:	b004      	add	sp, #16
    e808:	bd80      	pop	{r7, pc}
    e80a:	46c0      	nop			; (mov r8, r8)
    e80c:	0000e651 	.word	0x0000e651

0000e810 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
    e810:	b580      	push	{r7, lr}
    e812:	af00      	add	r7, sp, #0
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    e814:	4b15      	ldr	r3, [pc, #84]	; (e86c <EIC_Handler+0x5c>)
    e816:	2200      	movs	r2, #0
    e818:	701a      	strb	r2, [r3, #0]
    e81a:	e020      	b.n	e85e <EIC_Handler+0x4e>
		if (extint_chan_is_detected(_current_channel)) {
    e81c:	4b13      	ldr	r3, [pc, #76]	; (e86c <EIC_Handler+0x5c>)
    e81e:	781b      	ldrb	r3, [r3, #0]
    e820:	0018      	movs	r0, r3
    e822:	4b13      	ldr	r3, [pc, #76]	; (e870 <EIC_Handler+0x60>)
    e824:	4798      	blx	r3
    e826:	1e03      	subs	r3, r0, #0
    e828:	d013      	beq.n	e852 <EIC_Handler+0x42>
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
    e82a:	4b10      	ldr	r3, [pc, #64]	; (e86c <EIC_Handler+0x5c>)
    e82c:	781b      	ldrb	r3, [r3, #0]
    e82e:	0018      	movs	r0, r3
    e830:	4b10      	ldr	r3, [pc, #64]	; (e874 <EIC_Handler+0x64>)
    e832:	4798      	blx	r3
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    e834:	4b0d      	ldr	r3, [pc, #52]	; (e86c <EIC_Handler+0x5c>)
    e836:	781b      	ldrb	r3, [r3, #0]
    e838:	001a      	movs	r2, r3
    e83a:	4b0f      	ldr	r3, [pc, #60]	; (e878 <EIC_Handler+0x68>)
    e83c:	0092      	lsls	r2, r2, #2
    e83e:	58d3      	ldr	r3, [r2, r3]
    e840:	2b00      	cmp	r3, #0
    e842:	d006      	beq.n	e852 <EIC_Handler+0x42>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
    e844:	4b09      	ldr	r3, [pc, #36]	; (e86c <EIC_Handler+0x5c>)
    e846:	781b      	ldrb	r3, [r3, #0]
    e848:	001a      	movs	r2, r3
    e84a:	4b0b      	ldr	r3, [pc, #44]	; (e878 <EIC_Handler+0x68>)
    e84c:	0092      	lsls	r2, r2, #2
    e84e:	58d3      	ldr	r3, [r2, r3]
    e850:	4798      	blx	r3

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    e852:	4b06      	ldr	r3, [pc, #24]	; (e86c <EIC_Handler+0x5c>)
    e854:	781b      	ldrb	r3, [r3, #0]
    e856:	3301      	adds	r3, #1
    e858:	b2da      	uxtb	r2, r3
    e85a:	4b04      	ldr	r3, [pc, #16]	; (e86c <EIC_Handler+0x5c>)
    e85c:	701a      	strb	r2, [r3, #0]
    e85e:	4b03      	ldr	r3, [pc, #12]	; (e86c <EIC_Handler+0x5c>)
    e860:	781b      	ldrb	r3, [r3, #0]
    e862:	2b0f      	cmp	r3, #15
    e864:	d9da      	bls.n	e81c <EIC_Handler+0xc>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
			}
		}
	}
}
    e866:	46c0      	nop			; (mov r8, r8)
    e868:	46bd      	mov	sp, r7
    e86a:	bd80      	pop	{r7, pc}
    e86c:	20004b50 	.word	0x20004b50
    e870:	0000e69d 	.word	0x0000e69d
    e874:	0000e6e1 	.word	0x0000e6e1
    e878:	20004b54 	.word	0x20004b54

0000e87c <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    e87c:	b580      	push	{r7, lr}
    e87e:	b082      	sub	sp, #8
    e880:	af00      	add	r7, sp, #0
    e882:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    e884:	687b      	ldr	r3, [r7, #4]
    e886:	2200      	movs	r2, #0
    e888:	701a      	strb	r2, [r3, #0]
}
    e88a:	46c0      	nop			; (mov r8, r8)
    e88c:	46bd      	mov	sp, r7
    e88e:	b002      	add	sp, #8
    e890:	bd80      	pop	{r7, pc}
    e892:	46c0      	nop			; (mov r8, r8)

0000e894 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    e894:	b580      	push	{r7, lr}
    e896:	b082      	sub	sp, #8
    e898:	af00      	add	r7, sp, #0
    e89a:	0002      	movs	r2, r0
    e89c:	6039      	str	r1, [r7, #0]
    e89e:	1dfb      	adds	r3, r7, #7
    e8a0:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    e8a2:	1dfb      	adds	r3, r7, #7
    e8a4:	781b      	ldrb	r3, [r3, #0]
    e8a6:	2b01      	cmp	r3, #1
    e8a8:	d00a      	beq.n	e8c0 <system_apb_clock_set_mask+0x2c>
    e8aa:	2b02      	cmp	r3, #2
    e8ac:	d00f      	beq.n	e8ce <system_apb_clock_set_mask+0x3a>
    e8ae:	2b00      	cmp	r3, #0
    e8b0:	d114      	bne.n	e8dc <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    e8b2:	4b0e      	ldr	r3, [pc, #56]	; (e8ec <system_apb_clock_set_mask+0x58>)
    e8b4:	4a0d      	ldr	r2, [pc, #52]	; (e8ec <system_apb_clock_set_mask+0x58>)
    e8b6:	6991      	ldr	r1, [r2, #24]
    e8b8:	683a      	ldr	r2, [r7, #0]
    e8ba:	430a      	orrs	r2, r1
    e8bc:	619a      	str	r2, [r3, #24]
			break;
    e8be:	e00f      	b.n	e8e0 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    e8c0:	4b0a      	ldr	r3, [pc, #40]	; (e8ec <system_apb_clock_set_mask+0x58>)
    e8c2:	4a0a      	ldr	r2, [pc, #40]	; (e8ec <system_apb_clock_set_mask+0x58>)
    e8c4:	69d1      	ldr	r1, [r2, #28]
    e8c6:	683a      	ldr	r2, [r7, #0]
    e8c8:	430a      	orrs	r2, r1
    e8ca:	61da      	str	r2, [r3, #28]
			break;
    e8cc:	e008      	b.n	e8e0 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    e8ce:	4b07      	ldr	r3, [pc, #28]	; (e8ec <system_apb_clock_set_mask+0x58>)
    e8d0:	4a06      	ldr	r2, [pc, #24]	; (e8ec <system_apb_clock_set_mask+0x58>)
    e8d2:	6a11      	ldr	r1, [r2, #32]
    e8d4:	683a      	ldr	r2, [r7, #0]
    e8d6:	430a      	orrs	r2, r1
    e8d8:	621a      	str	r2, [r3, #32]
			break;
    e8da:	e001      	b.n	e8e0 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    e8dc:	2317      	movs	r3, #23
    e8de:	e000      	b.n	e8e2 <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    e8e0:	2300      	movs	r3, #0
}
    e8e2:	0018      	movs	r0, r3
    e8e4:	46bd      	mov	sp, r7
    e8e6:	b002      	add	sp, #8
    e8e8:	bd80      	pop	{r7, pc}
    e8ea:	46c0      	nop			; (mov r8, r8)
    e8ec:	40000400 	.word	0x40000400

0000e8f0 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    e8f0:	b580      	push	{r7, lr}
    e8f2:	b082      	sub	sp, #8
    e8f4:	af00      	add	r7, sp, #0
    e8f6:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    e8f8:	687b      	ldr	r3, [r7, #4]
    e8fa:	2280      	movs	r2, #128	; 0x80
    e8fc:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    e8fe:	687b      	ldr	r3, [r7, #4]
    e900:	2200      	movs	r2, #0
    e902:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    e904:	687b      	ldr	r3, [r7, #4]
    e906:	2201      	movs	r2, #1
    e908:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    e90a:	687b      	ldr	r3, [r7, #4]
    e90c:	2200      	movs	r2, #0
    e90e:	70da      	strb	r2, [r3, #3]
}
    e910:	46c0      	nop			; (mov r8, r8)
    e912:	46bd      	mov	sp, r7
    e914:	b002      	add	sp, #8
    e916:	bd80      	pop	{r7, pc}

0000e918 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
    e918:	b580      	push	{r7, lr}
    e91a:	b082      	sub	sp, #8
    e91c:	af00      	add	r7, sp, #0
    e91e:	0002      	movs	r2, r0
    e920:	1dfb      	adds	r3, r7, #7
    e922:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    e924:	4b06      	ldr	r3, [pc, #24]	; (e940 <system_interrupt_enable+0x28>)
    e926:	1dfa      	adds	r2, r7, #7
    e928:	7812      	ldrb	r2, [r2, #0]
    e92a:	0011      	movs	r1, r2
    e92c:	221f      	movs	r2, #31
    e92e:	400a      	ands	r2, r1
    e930:	2101      	movs	r1, #1
    e932:	4091      	lsls	r1, r2
    e934:	000a      	movs	r2, r1
    e936:	601a      	str	r2, [r3, #0]
}
    e938:	46c0      	nop			; (mov r8, r8)
    e93a:	46bd      	mov	sp, r7
    e93c:	b002      	add	sp, #8
    e93e:	bd80      	pop	{r7, pc}
    e940:	e000e100 	.word	0xe000e100

0000e944 <_extint_get_eic_from_channel>:
 *
 * \return Base address of the associated EIC module.
 */
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
    e944:	b580      	push	{r7, lr}
    e946:	b084      	sub	sp, #16
    e948:	af00      	add	r7, sp, #0
    e94a:	0002      	movs	r2, r0
    e94c:	1dfb      	adds	r3, r7, #7
    e94e:	701a      	strb	r2, [r3, #0]
	uint8_t eic_index = (channel / 32);
    e950:	230f      	movs	r3, #15
    e952:	18fb      	adds	r3, r7, r3
    e954:	1dfa      	adds	r2, r7, #7
    e956:	7812      	ldrb	r2, [r2, #0]
    e958:	0952      	lsrs	r2, r2, #5
    e95a:	701a      	strb	r2, [r3, #0]

	if (eic_index < EIC_INST_NUM) {
    e95c:	230f      	movs	r3, #15
    e95e:	18fb      	adds	r3, r7, r3
    e960:	781b      	ldrb	r3, [r3, #0]
    e962:	2b00      	cmp	r3, #0
    e964:	d10c      	bne.n	e980 <_extint_get_eic_from_channel+0x3c>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    e966:	4b09      	ldr	r3, [pc, #36]	; (e98c <_extint_get_eic_from_channel+0x48>)
    e968:	60bb      	str	r3, [r7, #8]

		return eics[eic_index];
    e96a:	230f      	movs	r3, #15
    e96c:	18fb      	adds	r3, r7, r3
    e96e:	781b      	ldrb	r3, [r3, #0]
    e970:	009b      	lsls	r3, r3, #2
    e972:	2210      	movs	r2, #16
    e974:	4694      	mov	ip, r2
    e976:	44bc      	add	ip, r7
    e978:	4463      	add	r3, ip
    e97a:	3b08      	subs	r3, #8
    e97c:	681b      	ldr	r3, [r3, #0]
    e97e:	e000      	b.n	e982 <_extint_get_eic_from_channel+0x3e>
	} else {
		Assert(false);
		return NULL;
    e980:	2300      	movs	r3, #0
	}
}
    e982:	0018      	movs	r0, r3
    e984:	46bd      	mov	sp, r7
    e986:	b004      	add	sp, #16
    e988:	bd80      	pop	{r7, pc}
    e98a:	46c0      	nop			; (mov r8, r8)
    e98c:	40001800 	.word	0x40001800

0000e990 <extint_is_syncing>:
 *
 * \retval true  If the module synchronization is ongoing
 * \retval false If the module has completed synchronization
 */
static inline bool extint_is_syncing(void)
{
    e990:	b580      	push	{r7, lr}
    e992:	b082      	sub	sp, #8
    e994:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    e996:	4b0f      	ldr	r3, [pc, #60]	; (e9d4 <extint_is_syncing+0x44>)
    e998:	603b      	str	r3, [r7, #0]

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    e99a:	2300      	movs	r3, #0
    e99c:	607b      	str	r3, [r7, #4]
    e99e:	e011      	b.n	e9c4 <extint_is_syncing+0x34>
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    e9a0:	687b      	ldr	r3, [r7, #4]
    e9a2:	009b      	lsls	r3, r3, #2
    e9a4:	2208      	movs	r2, #8
    e9a6:	4694      	mov	ip, r2
    e9a8:	44bc      	add	ip, r7
    e9aa:	4463      	add	r3, ip
    e9ac:	3b08      	subs	r3, #8
    e9ae:	681b      	ldr	r3, [r3, #0]
    e9b0:	785b      	ldrb	r3, [r3, #1]
    e9b2:	b2db      	uxtb	r3, r3
    e9b4:	b25b      	sxtb	r3, r3
    e9b6:	2b00      	cmp	r3, #0
    e9b8:	da01      	bge.n	e9be <extint_is_syncing+0x2e>
			return true;
    e9ba:	2301      	movs	r3, #1
    e9bc:	e006      	b.n	e9cc <extint_is_syncing+0x3c>
 */
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    e9be:	687b      	ldr	r3, [r7, #4]
    e9c0:	3301      	adds	r3, #1
    e9c2:	607b      	str	r3, [r7, #4]
    e9c4:	687b      	ldr	r3, [r7, #4]
    e9c6:	2b00      	cmp	r3, #0
    e9c8:	d0ea      	beq.n	e9a0 <extint_is_syncing+0x10>
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
			return true;
		}
	}
	return false;
    e9ca:	2300      	movs	r3, #0
}
    e9cc:	0018      	movs	r0, r3
    e9ce:	46bd      	mov	sp, r7
    e9d0:	b002      	add	sp, #8
    e9d2:	bd80      	pop	{r7, pc}
    e9d4:	40001800 	.word	0x40001800

0000e9d8 <_system_extint_init>:
 * \note When SYSTEM module is used, this function will be invoked by
 * \ref system_init() automatically if the module is included.
 */
void _system_extint_init(void);
void _system_extint_init(void)
{
    e9d8:	b580      	push	{r7, lr}
    e9da:	b084      	sub	sp, #16
    e9dc:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    e9de:	4b2d      	ldr	r3, [pc, #180]	; (ea94 <_system_extint_init+0xbc>)
    e9e0:	607b      	str	r3, [r7, #4]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_EIC);
    e9e2:	2140      	movs	r1, #64	; 0x40
    e9e4:	2000      	movs	r0, #0
    e9e6:	4b2c      	ldr	r3, [pc, #176]	; (ea98 <_system_extint_init+0xc0>)
    e9e8:	4798      	blx	r3

	/* Configure the generic clock for the module and enable it */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
    e9ea:	003b      	movs	r3, r7
    e9ec:	0018      	movs	r0, r3
    e9ee:	4b2b      	ldr	r3, [pc, #172]	; (ea9c <_system_extint_init+0xc4>)
    e9f0:	4798      	blx	r3
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
    e9f2:	003b      	movs	r3, r7
    e9f4:	2202      	movs	r2, #2
    e9f6:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    e9f8:	003b      	movs	r3, r7
    e9fa:	0019      	movs	r1, r3
    e9fc:	2005      	movs	r0, #5
    e9fe:	4b28      	ldr	r3, [pc, #160]	; (eaa0 <_system_extint_init+0xc8>)
    ea00:	4798      	blx	r3

	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);
    ea02:	2005      	movs	r0, #5
    ea04:	4b27      	ldr	r3, [pc, #156]	; (eaa4 <_system_extint_init+0xcc>)
    ea06:	4798      	blx	r3

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    ea08:	2300      	movs	r3, #0
    ea0a:	60fb      	str	r3, [r7, #12]
    ea0c:	e018      	b.n	ea40 <_system_extint_init+0x68>
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
    ea0e:	68fb      	ldr	r3, [r7, #12]
    ea10:	009b      	lsls	r3, r3, #2
    ea12:	2210      	movs	r2, #16
    ea14:	4694      	mov	ip, r2
    ea16:	44bc      	add	ip, r7
    ea18:	4463      	add	r3, ip
    ea1a:	3b0c      	subs	r3, #12
    ea1c:	681a      	ldr	r2, [r3, #0]
    ea1e:	68fb      	ldr	r3, [r7, #12]
    ea20:	009b      	lsls	r3, r3, #2
    ea22:	2110      	movs	r1, #16
    ea24:	468c      	mov	ip, r1
    ea26:	44bc      	add	ip, r7
    ea28:	4463      	add	r3, ip
    ea2a:	3b0c      	subs	r3, #12
    ea2c:	681b      	ldr	r3, [r3, #0]
    ea2e:	781b      	ldrb	r3, [r3, #0]
    ea30:	b2db      	uxtb	r3, r3
    ea32:	2101      	movs	r1, #1
    ea34:	430b      	orrs	r3, r1
    ea36:	b2db      	uxtb	r3, r3
    ea38:	7013      	strb	r3, [r2, #0]
	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    ea3a:	68fb      	ldr	r3, [r7, #12]
    ea3c:	3301      	adds	r3, #1
    ea3e:	60fb      	str	r3, [r7, #12]
    ea40:	68fb      	ldr	r3, [r7, #12]
    ea42:	2b00      	cmp	r3, #0
    ea44:	d0e3      	beq.n	ea0e <_system_extint_init+0x36>
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
	}

	while (extint_is_syncing()) {
    ea46:	46c0      	nop			; (mov r8, r8)
    ea48:	4b17      	ldr	r3, [pc, #92]	; (eaa8 <_system_extint_init+0xd0>)
    ea4a:	4798      	blx	r3
    ea4c:	1e03      	subs	r3, r0, #0
    ea4e:	d1fb      	bne.n	ea48 <_system_extint_init+0x70>
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    ea50:	230b      	movs	r3, #11
    ea52:	18fb      	adds	r3, r7, r3
    ea54:	2200      	movs	r2, #0
    ea56:	701a      	strb	r2, [r3, #0]
    ea58:	e00d      	b.n	ea76 <_system_extint_init+0x9e>
		_extint_dev.callbacks[j] = NULL;
    ea5a:	230b      	movs	r3, #11
    ea5c:	18fb      	adds	r3, r7, r3
    ea5e:	781a      	ldrb	r2, [r3, #0]
    ea60:	4b12      	ldr	r3, [pc, #72]	; (eaac <_system_extint_init+0xd4>)
    ea62:	0092      	lsls	r2, r2, #2
    ea64:	2100      	movs	r1, #0
    ea66:	50d1      	str	r1, [r2, r3]
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    ea68:	230b      	movs	r3, #11
    ea6a:	18fb      	adds	r3, r7, r3
    ea6c:	781a      	ldrb	r2, [r3, #0]
    ea6e:	230b      	movs	r3, #11
    ea70:	18fb      	adds	r3, r7, r3
    ea72:	3201      	adds	r2, #1
    ea74:	701a      	strb	r2, [r3, #0]
    ea76:	230b      	movs	r3, #11
    ea78:	18fb      	adds	r3, r7, r3
    ea7a:	781b      	ldrb	r3, [r3, #0]
    ea7c:	2b0f      	cmp	r3, #15
    ea7e:	d9ec      	bls.n	ea5a <_system_extint_init+0x82>
		_extint_dev.callbacks[j] = NULL;
	}
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
    ea80:	2004      	movs	r0, #4
    ea82:	4b0b      	ldr	r3, [pc, #44]	; (eab0 <_system_extint_init+0xd8>)
    ea84:	4798      	blx	r3
#endif

	/* Enables the driver for further use */
	_extint_enable();
    ea86:	4b0b      	ldr	r3, [pc, #44]	; (eab4 <_system_extint_init+0xdc>)
    ea88:	4798      	blx	r3
}
    ea8a:	46c0      	nop			; (mov r8, r8)
    ea8c:	46bd      	mov	sp, r7
    ea8e:	b004      	add	sp, #16
    ea90:	bd80      	pop	{r7, pc}
    ea92:	46c0      	nop			; (mov r8, r8)
    ea94:	40001800 	.word	0x40001800
    ea98:	0000e895 	.word	0x0000e895
    ea9c:	0000e87d 	.word	0x0000e87d
    eaa0:	000169e1 	.word	0x000169e1
    eaa4:	00016a25 	.word	0x00016a25
    eaa8:	0000e991 	.word	0x0000e991
    eaac:	20004b54 	.word	0x20004b54
    eab0:	0000e919 	.word	0x0000e919
    eab4:	0000eab9 	.word	0x0000eab9

0000eab8 <_extint_enable>:
 *
 * Enables EIC modules.
 * Registered callback list will not be affected if callback mode is used.
 */
void _extint_enable(void)
{
    eab8:	b580      	push	{r7, lr}
    eaba:	b082      	sub	sp, #8
    eabc:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    eabe:	4b15      	ldr	r3, [pc, #84]	; (eb14 <_extint_enable+0x5c>)
    eac0:	603b      	str	r3, [r7, #0]

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    eac2:	2300      	movs	r3, #0
    eac4:	607b      	str	r3, [r7, #4]
    eac6:	e018      	b.n	eafa <_extint_enable+0x42>
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    eac8:	687b      	ldr	r3, [r7, #4]
    eaca:	009b      	lsls	r3, r3, #2
    eacc:	2208      	movs	r2, #8
    eace:	4694      	mov	ip, r2
    ead0:	44bc      	add	ip, r7
    ead2:	4463      	add	r3, ip
    ead4:	3b08      	subs	r3, #8
    ead6:	681a      	ldr	r2, [r3, #0]
    ead8:	687b      	ldr	r3, [r7, #4]
    eada:	009b      	lsls	r3, r3, #2
    eadc:	2108      	movs	r1, #8
    eade:	468c      	mov	ip, r1
    eae0:	44bc      	add	ip, r7
    eae2:	4463      	add	r3, ip
    eae4:	3b08      	subs	r3, #8
    eae6:	681b      	ldr	r3, [r3, #0]
    eae8:	781b      	ldrb	r3, [r3, #0]
    eaea:	b2db      	uxtb	r3, r3
    eaec:	2102      	movs	r1, #2
    eaee:	430b      	orrs	r3, r1
    eaf0:	b2db      	uxtb	r3, r3
    eaf2:	7013      	strb	r3, [r2, #0]
void _extint_enable(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    eaf4:	687b      	ldr	r3, [r7, #4]
    eaf6:	3301      	adds	r3, #1
    eaf8:	607b      	str	r3, [r7, #4]
    eafa:	687b      	ldr	r3, [r7, #4]
    eafc:	2b00      	cmp	r3, #0
    eafe:	d0e3      	beq.n	eac8 <_extint_enable+0x10>
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
	}

	while (extint_is_syncing()) {
    eb00:	46c0      	nop			; (mov r8, r8)
    eb02:	4b05      	ldr	r3, [pc, #20]	; (eb18 <_extint_enable+0x60>)
    eb04:	4798      	blx	r3
    eb06:	1e03      	subs	r3, r0, #0
    eb08:	d1fb      	bne.n	eb02 <_extint_enable+0x4a>
		/* Wait for all hardware modules to complete synchronization */
	}
}
    eb0a:	46c0      	nop			; (mov r8, r8)
    eb0c:	46bd      	mov	sp, r7
    eb0e:	b002      	add	sp, #8
    eb10:	bd80      	pop	{r7, pc}
    eb12:	46c0      	nop			; (mov r8, r8)
    eb14:	40001800 	.word	0x40001800
    eb18:	0000e991 	.word	0x0000e991

0000eb1c <extint_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
void extint_chan_get_config_defaults(
		struct extint_chan_conf *const config)
{
    eb1c:	b580      	push	{r7, lr}
    eb1e:	b082      	sub	sp, #8
    eb20:	af00      	add	r7, sp, #0
    eb22:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->gpio_pin            = 0;
    eb24:	687b      	ldr	r3, [r7, #4]
    eb26:	2200      	movs	r2, #0
    eb28:	601a      	str	r2, [r3, #0]
	config->gpio_pin_mux        = 0;
    eb2a:	687b      	ldr	r3, [r7, #4]
    eb2c:	2200      	movs	r2, #0
    eb2e:	605a      	str	r2, [r3, #4]
	config->gpio_pin_pull       = EXTINT_PULL_UP;
    eb30:	687b      	ldr	r3, [r7, #4]
    eb32:	2201      	movs	r2, #1
    eb34:	721a      	strb	r2, [r3, #8]
	config->wake_if_sleeping    = true;
    eb36:	687b      	ldr	r3, [r7, #4]
    eb38:	2201      	movs	r2, #1
    eb3a:	725a      	strb	r2, [r3, #9]
	config->filter_input_signal = false;
    eb3c:	687b      	ldr	r3, [r7, #4]
    eb3e:	2200      	movs	r2, #0
    eb40:	729a      	strb	r2, [r3, #10]
	config->detection_criteria  = EXTINT_DETECT_FALLING;
    eb42:	687b      	ldr	r3, [r7, #4]
    eb44:	2202      	movs	r2, #2
    eb46:	72da      	strb	r2, [r3, #11]
}
    eb48:	46c0      	nop			; (mov r8, r8)
    eb4a:	46bd      	mov	sp, r7
    eb4c:	b002      	add	sp, #8
    eb4e:	bd80      	pop	{r7, pc}

0000eb50 <extint_chan_set_config>:

 */
void extint_chan_set_config(
		const uint8_t channel,
		const struct extint_chan_conf *const config)
{
    eb50:	b580      	push	{r7, lr}
    eb52:	b086      	sub	sp, #24
    eb54:	af00      	add	r7, sp, #0
    eb56:	0002      	movs	r2, r0
    eb58:	6039      	str	r1, [r7, #0]
    eb5a:	1dfb      	adds	r3, r7, #7
    eb5c:	701a      	strb	r2, [r3, #0]
	Assert(!(!system_gclk_gen_is_enabled(EXTINT_CLOCK_SOURCE) &&
		_extint_is_gclk_required(config->filter_input_signal,
			config->detection_criteria)));

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);
    eb5e:	2308      	movs	r3, #8
    eb60:	18fb      	adds	r3, r7, r3
    eb62:	0018      	movs	r0, r3
    eb64:	4b36      	ldr	r3, [pc, #216]	; (ec40 <extint_chan_set_config+0xf0>)
    eb66:	4798      	blx	r3

	pinmux_config.mux_position = config->gpio_pin_mux;
    eb68:	683b      	ldr	r3, [r7, #0]
    eb6a:	685b      	ldr	r3, [r3, #4]
    eb6c:	b2da      	uxtb	r2, r3
    eb6e:	2308      	movs	r3, #8
    eb70:	18fb      	adds	r3, r7, r3
    eb72:	701a      	strb	r2, [r3, #0]
	pinmux_config.direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    eb74:	2308      	movs	r3, #8
    eb76:	18fb      	adds	r3, r7, r3
    eb78:	2200      	movs	r2, #0
    eb7a:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->gpio_pin_pull;
    eb7c:	683b      	ldr	r3, [r7, #0]
    eb7e:	7a1a      	ldrb	r2, [r3, #8]
    eb80:	2308      	movs	r3, #8
    eb82:	18fb      	adds	r3, r7, r3
    eb84:	709a      	strb	r2, [r3, #2]
	system_pinmux_pin_set_config(config->gpio_pin, &pinmux_config);
    eb86:	683b      	ldr	r3, [r7, #0]
    eb88:	681b      	ldr	r3, [r3, #0]
    eb8a:	b2db      	uxtb	r3, r3
    eb8c:	2208      	movs	r2, #8
    eb8e:	18ba      	adds	r2, r7, r2
    eb90:	0011      	movs	r1, r2
    eb92:	0018      	movs	r0, r3
    eb94:	4b2b      	ldr	r3, [pc, #172]	; (ec44 <extint_chan_set_config+0xf4>)
    eb96:	4798      	blx	r3

	/* Get a pointer to the module hardware instance */
	Eic *const EIC_module = _extint_get_eic_from_channel(channel);
    eb98:	1dfb      	adds	r3, r7, #7
    eb9a:	781b      	ldrb	r3, [r3, #0]
    eb9c:	0018      	movs	r0, r3
    eb9e:	4b2a      	ldr	r3, [pc, #168]	; (ec48 <extint_chan_set_config+0xf8>)
    eba0:	4798      	blx	r3
    eba2:	0003      	movs	r3, r0
    eba4:	613b      	str	r3, [r7, #16]

	uint32_t config_pos = (4 * (channel % 8));
    eba6:	1dfb      	adds	r3, r7, #7
    eba8:	781b      	ldrb	r3, [r3, #0]
    ebaa:	2207      	movs	r2, #7
    ebac:	4013      	ands	r3, r2
    ebae:	009b      	lsls	r3, r3, #2
    ebb0:	60fb      	str	r3, [r7, #12]
	uint32_t new_config;

	/* Determine the channel's new edge detection configuration */
	new_config = (config->detection_criteria << EIC_CONFIG_SENSE0_Pos);
    ebb2:	683b      	ldr	r3, [r7, #0]
    ebb4:	7adb      	ldrb	r3, [r3, #11]
    ebb6:	617b      	str	r3, [r7, #20]

	/* Enable the hardware signal filter if requested in the config */
	if (config->filter_input_signal) {
    ebb8:	683b      	ldr	r3, [r7, #0]
    ebba:	7a9b      	ldrb	r3, [r3, #10]
    ebbc:	2b00      	cmp	r3, #0
    ebbe:	d003      	beq.n	ebc8 <extint_chan_set_config+0x78>
		new_config |= EIC_CONFIG_FILTEN0;
    ebc0:	697b      	ldr	r3, [r7, #20]
    ebc2:	2208      	movs	r2, #8
    ebc4:	4313      	orrs	r3, r2
    ebc6:	617b      	str	r3, [r7, #20]
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
    ebc8:	1dfb      	adds	r3, r7, #7
    ebca:	781b      	ldrb	r3, [r3, #0]
    ebcc:	08db      	lsrs	r3, r3, #3
    ebce:	b2db      	uxtb	r3, r3
    ebd0:	0018      	movs	r0, r3
		= (EIC_module->CONFIG[channel / 8].reg &
    ebd2:	1dfb      	adds	r3, r7, #7
    ebd4:	781b      	ldrb	r3, [r3, #0]
    ebd6:	08db      	lsrs	r3, r3, #3
    ebd8:	b2db      	uxtb	r3, r3
    ebda:	001a      	movs	r2, r3
    ebdc:	693b      	ldr	r3, [r7, #16]
    ebde:	3206      	adds	r2, #6
    ebe0:	0092      	lsls	r2, r2, #2
    ebe2:	58d3      	ldr	r3, [r2, r3]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    ebe4:	210f      	movs	r1, #15
    ebe6:	68fa      	ldr	r2, [r7, #12]
    ebe8:	4091      	lsls	r1, r2
    ebea:	000a      	movs	r2, r1
    ebec:	43d2      	mvns	r2, r2
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    ebee:	401a      	ands	r2, r3
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);
    ebf0:	6979      	ldr	r1, [r7, #20]
    ebf2:	68fb      	ldr	r3, [r7, #12]
    ebf4:	4099      	lsls	r1, r3
    ebf6:	000b      	movs	r3, r1
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    ebf8:	431a      	orrs	r2, r3
    ebfa:	0011      	movs	r1, r2
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    ebfc:	693b      	ldr	r3, [r7, #16]
    ebfe:	1d82      	adds	r2, r0, #6
    ec00:	0092      	lsls	r2, r2, #2
    ec02:	50d1      	str	r1, [r2, r3]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);

	/* Set the channel's new wake up mode setting */
	if (config->wake_if_sleeping) {
    ec04:	683b      	ldr	r3, [r7, #0]
    ec06:	7a5b      	ldrb	r3, [r3, #9]
    ec08:	2b00      	cmp	r3, #0
    ec0a:	d00a      	beq.n	ec22 <extint_chan_set_config+0xd2>
		EIC_module->WAKEUP.reg |=  (1UL << channel);
    ec0c:	693b      	ldr	r3, [r7, #16]
    ec0e:	695a      	ldr	r2, [r3, #20]
    ec10:	1dfb      	adds	r3, r7, #7
    ec12:	781b      	ldrb	r3, [r3, #0]
    ec14:	2101      	movs	r1, #1
    ec16:	4099      	lsls	r1, r3
    ec18:	000b      	movs	r3, r1
    ec1a:	431a      	orrs	r2, r3
    ec1c:	693b      	ldr	r3, [r7, #16]
    ec1e:	615a      	str	r2, [r3, #20]
	} else {
		EIC_module->WAKEUP.reg &= ~(1UL << channel);
	}
}
    ec20:	e00a      	b.n	ec38 <extint_chan_set_config+0xe8>

	/* Set the channel's new wake up mode setting */
	if (config->wake_if_sleeping) {
		EIC_module->WAKEUP.reg |=  (1UL << channel);
	} else {
		EIC_module->WAKEUP.reg &= ~(1UL << channel);
    ec22:	693b      	ldr	r3, [r7, #16]
    ec24:	695b      	ldr	r3, [r3, #20]
    ec26:	1dfa      	adds	r2, r7, #7
    ec28:	7812      	ldrb	r2, [r2, #0]
    ec2a:	2101      	movs	r1, #1
    ec2c:	4091      	lsls	r1, r2
    ec2e:	000a      	movs	r2, r1
    ec30:	43d2      	mvns	r2, r2
    ec32:	401a      	ands	r2, r3
    ec34:	693b      	ldr	r3, [r7, #16]
    ec36:	615a      	str	r2, [r3, #20]
	}
}
    ec38:	46c0      	nop			; (mov r8, r8)
    ec3a:	46bd      	mov	sp, r7
    ec3c:	b006      	add	sp, #24
    ec3e:	bd80      	pop	{r7, pc}
    ec40:	0000e8f1 	.word	0x0000e8f1
    ec44:	00016d15 	.word	0x00016d15
    ec48:	0000e945 	.word	0x0000e945

0000ec4c <nvm_is_ready>:
 * \retval true   If the hardware module is ready for a new command
 * \retval false  If the hardware module is busy executing a command
 *
 */
static inline bool nvm_is_ready(void)
{
    ec4c:	b580      	push	{r7, lr}
    ec4e:	b082      	sub	sp, #8
    ec50:	af00      	add	r7, sp, #0
	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    ec52:	4b07      	ldr	r3, [pc, #28]	; (ec70 <nvm_is_ready+0x24>)
    ec54:	607b      	str	r3, [r7, #4]

	return nvm_module->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
    ec56:	687b      	ldr	r3, [r7, #4]
    ec58:	7d1b      	ldrb	r3, [r3, #20]
    ec5a:	b2db      	uxtb	r3, r3
    ec5c:	001a      	movs	r2, r3
    ec5e:	2301      	movs	r3, #1
    ec60:	4013      	ands	r3, r2
    ec62:	1e5a      	subs	r2, r3, #1
    ec64:	4193      	sbcs	r3, r2
    ec66:	b2db      	uxtb	r3, r3
}
    ec68:	0018      	movs	r0, r3
    ec6a:	46bd      	mov	sp, r7
    ec6c:	b002      	add	sp, #8
    ec6e:	bd80      	pop	{r7, pc}
    ec70:	41004000 	.word	0x41004000

0000ec74 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    ec74:	b580      	push	{r7, lr}
    ec76:	b082      	sub	sp, #8
    ec78:	af00      	add	r7, sp, #0
    ec7a:	0002      	movs	r2, r0
    ec7c:	6039      	str	r1, [r7, #0]
    ec7e:	1dfb      	adds	r3, r7, #7
    ec80:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    ec82:	1dfb      	adds	r3, r7, #7
    ec84:	781b      	ldrb	r3, [r3, #0]
    ec86:	2b01      	cmp	r3, #1
    ec88:	d00a      	beq.n	eca0 <system_apb_clock_set_mask+0x2c>
    ec8a:	2b02      	cmp	r3, #2
    ec8c:	d00f      	beq.n	ecae <system_apb_clock_set_mask+0x3a>
    ec8e:	2b00      	cmp	r3, #0
    ec90:	d114      	bne.n	ecbc <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    ec92:	4b0e      	ldr	r3, [pc, #56]	; (eccc <system_apb_clock_set_mask+0x58>)
    ec94:	4a0d      	ldr	r2, [pc, #52]	; (eccc <system_apb_clock_set_mask+0x58>)
    ec96:	6991      	ldr	r1, [r2, #24]
    ec98:	683a      	ldr	r2, [r7, #0]
    ec9a:	430a      	orrs	r2, r1
    ec9c:	619a      	str	r2, [r3, #24]
			break;
    ec9e:	e00f      	b.n	ecc0 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    eca0:	4b0a      	ldr	r3, [pc, #40]	; (eccc <system_apb_clock_set_mask+0x58>)
    eca2:	4a0a      	ldr	r2, [pc, #40]	; (eccc <system_apb_clock_set_mask+0x58>)
    eca4:	69d1      	ldr	r1, [r2, #28]
    eca6:	683a      	ldr	r2, [r7, #0]
    eca8:	430a      	orrs	r2, r1
    ecaa:	61da      	str	r2, [r3, #28]
			break;
    ecac:	e008      	b.n	ecc0 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    ecae:	4b07      	ldr	r3, [pc, #28]	; (eccc <system_apb_clock_set_mask+0x58>)
    ecb0:	4a06      	ldr	r2, [pc, #24]	; (eccc <system_apb_clock_set_mask+0x58>)
    ecb2:	6a11      	ldr	r1, [r2, #32]
    ecb4:	683a      	ldr	r2, [r7, #0]
    ecb6:	430a      	orrs	r2, r1
    ecb8:	621a      	str	r2, [r3, #32]
			break;
    ecba:	e001      	b.n	ecc0 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    ecbc:	2317      	movs	r3, #23
    ecbe:	e000      	b.n	ecc2 <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    ecc0:	2300      	movs	r3, #0
}
    ecc2:	0018      	movs	r0, r3
    ecc4:	46bd      	mov	sp, r7
    ecc6:	b002      	add	sp, #8
    ecc8:	bd80      	pop	{r7, pc}
    ecca:	46c0      	nop			; (mov r8, r8)
    eccc:	40000400 	.word	0x40000400

0000ecd0 <nvm_set_config>:
 *                        EEPROM and/or auxiliary space configuration from being
 *                        altered
 */
enum status_code nvm_set_config(
		const struct nvm_config *const config)
{
    ecd0:	b580      	push	{r7, lr}
    ecd2:	b084      	sub	sp, #16
    ecd4:	af00      	add	r7, sp, #0
    ecd6:	6078      	str	r0, [r7, #4]
	/* Sanity check argument */
	Assert(config);

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    ecd8:	4b31      	ldr	r3, [pc, #196]	; (eda0 <nvm_set_config+0xd0>)
    ecda:	60fb      	str	r3, [r7, #12]
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBB, MCLK_APBBMASK_NVMCTRL);
#else
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBB, PM_APBBMASK_NVMCTRL);
    ecdc:	2104      	movs	r1, #4
    ecde:	2001      	movs	r0, #1
    ece0:	4b30      	ldr	r3, [pc, #192]	; (eda4 <nvm_set_config+0xd4>)
    ece2:	4798      	blx	r3
#endif

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    ece4:	68fb      	ldr	r3, [r7, #12]
    ece6:	8b1b      	ldrh	r3, [r3, #24]
    ece8:	b29b      	uxth	r3, r3
    ecea:	2220      	movs	r2, #32
    ecec:	32ff      	adds	r2, #255	; 0xff
    ecee:	4313      	orrs	r3, r2
    ecf0:	b29a      	uxth	r2, r3
    ecf2:	68fb      	ldr	r3, [r7, #12]
    ecf4:	831a      	strh	r2, [r3, #24]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    ecf6:	4b2c      	ldr	r3, [pc, #176]	; (eda8 <nvm_set_config+0xd8>)
    ecf8:	4798      	blx	r3
    ecfa:	0003      	movs	r3, r0
    ecfc:	001a      	movs	r2, r3
    ecfe:	2301      	movs	r3, #1
    ed00:	4053      	eors	r3, r2
    ed02:	b2db      	uxtb	r3, r3
    ed04:	2b00      	cmp	r3, #0
    ed06:	d001      	beq.n	ed0c <nvm_set_config+0x3c>
		return STATUS_BUSY;
    ed08:	2305      	movs	r3, #5
    ed0a:	e045      	b.n	ed98 <nvm_set_config+0xc8>
	}

#if (!SAMC20) && (!SAMC21)
	/* Writing configuration to the CTRLB register */
	nvm_module->CTRLB.reg =
			NVMCTRL_CTRLB_SLEEPPRM(config->sleep_power_mode) |
    ed0c:	687b      	ldr	r3, [r7, #4]
    ed0e:	781b      	ldrb	r3, [r3, #0]
    ed10:	021b      	lsls	r3, r3, #8
    ed12:	001a      	movs	r2, r3
    ed14:	23c0      	movs	r3, #192	; 0xc0
    ed16:	009b      	lsls	r3, r3, #2
    ed18:	401a      	ands	r2, r3
			((config->manual_page_write & 0x01) << NVMCTRL_CTRLB_MANW_Pos) |
    ed1a:	687b      	ldr	r3, [r7, #4]
    ed1c:	785b      	ldrb	r3, [r3, #1]
    ed1e:	01db      	lsls	r3, r3, #7
	}

#if (!SAMC20) && (!SAMC21)
	/* Writing configuration to the CTRLB register */
	nvm_module->CTRLB.reg =
			NVMCTRL_CTRLB_SLEEPPRM(config->sleep_power_mode) |
    ed20:	0019      	movs	r1, r3
    ed22:	23ff      	movs	r3, #255	; 0xff
    ed24:	400b      	ands	r3, r1
    ed26:	431a      	orrs	r2, r3
			((config->manual_page_write & 0x01) << NVMCTRL_CTRLB_MANW_Pos) |
			NVMCTRL_CTRLB_RWS(config->wait_states) |
    ed28:	687b      	ldr	r3, [r7, #4]
    ed2a:	789b      	ldrb	r3, [r3, #2]
    ed2c:	005b      	lsls	r3, r3, #1
    ed2e:	0019      	movs	r1, r3
    ed30:	231e      	movs	r3, #30
    ed32:	400b      	ands	r3, r1

#if (!SAMC20) && (!SAMC21)
	/* Writing configuration to the CTRLB register */
	nvm_module->CTRLB.reg =
			NVMCTRL_CTRLB_SLEEPPRM(config->sleep_power_mode) |
			((config->manual_page_write & 0x01) << NVMCTRL_CTRLB_MANW_Pos) |
    ed34:	431a      	orrs	r2, r3
			NVMCTRL_CTRLB_RWS(config->wait_states) |
			((config->disable_cache & 0x01) << NVMCTRL_CTRLB_CACHEDIS_Pos) |
    ed36:	687b      	ldr	r3, [r7, #4]
    ed38:	78db      	ldrb	r3, [r3, #3]
    ed3a:	049b      	lsls	r3, r3, #18
#if (!SAMC20) && (!SAMC21)
	/* Writing configuration to the CTRLB register */
	nvm_module->CTRLB.reg =
			NVMCTRL_CTRLB_SLEEPPRM(config->sleep_power_mode) |
			((config->manual_page_write & 0x01) << NVMCTRL_CTRLB_MANW_Pos) |
			NVMCTRL_CTRLB_RWS(config->wait_states) |
    ed3c:	0019      	movs	r1, r3
    ed3e:	2380      	movs	r3, #128	; 0x80
    ed40:	02db      	lsls	r3, r3, #11
    ed42:	400b      	ands	r3, r1
    ed44:	431a      	orrs	r2, r3
			((config->disable_cache & 0x01) << NVMCTRL_CTRLB_CACHEDIS_Pos) |
			NVMCTRL_CTRLB_READMODE(config->cache_readmode);
    ed46:	687b      	ldr	r3, [r7, #4]
    ed48:	791b      	ldrb	r3, [r3, #4]
    ed4a:	041b      	lsls	r3, r3, #16
    ed4c:	0019      	movs	r1, r3
    ed4e:	23c0      	movs	r3, #192	; 0xc0
    ed50:	029b      	lsls	r3, r3, #10
    ed52:	400b      	ands	r3, r1
	/* Writing configuration to the CTRLB register */
	nvm_module->CTRLB.reg =
			NVMCTRL_CTRLB_SLEEPPRM(config->sleep_power_mode) |
			((config->manual_page_write & 0x01) << NVMCTRL_CTRLB_MANW_Pos) |
			NVMCTRL_CTRLB_RWS(config->wait_states) |
			((config->disable_cache & 0x01) << NVMCTRL_CTRLB_CACHEDIS_Pos) |
    ed54:	431a      	orrs	r2, r3
		return STATUS_BUSY;
	}

#if (!SAMC20) && (!SAMC21)
	/* Writing configuration to the CTRLB register */
	nvm_module->CTRLB.reg =
    ed56:	68fb      	ldr	r3, [r7, #12]
    ed58:	605a      	str	r2, [r3, #4]
			(cache_disable_value << NVMCTRL_CTRLB_CACHEDIS_Pos) |
			NVMCTRL_CTRLB_READMODE(config->cache_readmode);
#endif

	/* Initialize the internal device struct */
	_nvm_dev.page_size         = (8 << nvm_module->PARAM.bit.PSZ);
    ed5a:	68fb      	ldr	r3, [r7, #12]
    ed5c:	689b      	ldr	r3, [r3, #8]
    ed5e:	035b      	lsls	r3, r3, #13
    ed60:	0f5b      	lsrs	r3, r3, #29
    ed62:	b2db      	uxtb	r3, r3
    ed64:	001a      	movs	r2, r3
    ed66:	2308      	movs	r3, #8
    ed68:	4093      	lsls	r3, r2
    ed6a:	b29a      	uxth	r2, r3
    ed6c:	4b0f      	ldr	r3, [pc, #60]	; (edac <nvm_set_config+0xdc>)
    ed6e:	801a      	strh	r2, [r3, #0]
	_nvm_dev.number_of_pages   = nvm_module->PARAM.bit.NVMP;
    ed70:	68fb      	ldr	r3, [r7, #12]
    ed72:	689b      	ldr	r3, [r3, #8]
    ed74:	b29a      	uxth	r2, r3
    ed76:	4b0d      	ldr	r3, [pc, #52]	; (edac <nvm_set_config+0xdc>)
    ed78:	805a      	strh	r2, [r3, #2]
	_nvm_dev.manual_page_write = config->manual_page_write;
    ed7a:	687b      	ldr	r3, [r7, #4]
    ed7c:	785a      	ldrb	r2, [r3, #1]
    ed7e:	4b0b      	ldr	r3, [pc, #44]	; (edac <nvm_set_config+0xdc>)
    ed80:	711a      	strb	r2, [r3, #4]

	/* If the security bit is set, the auxiliary space cannot be written */
	if (nvm_module->STATUS.reg & NVMCTRL_STATUS_SB) {
    ed82:	68fb      	ldr	r3, [r7, #12]
    ed84:	8b1b      	ldrh	r3, [r3, #24]
    ed86:	b29b      	uxth	r3, r3
    ed88:	001a      	movs	r2, r3
    ed8a:	2380      	movs	r3, #128	; 0x80
    ed8c:	005b      	lsls	r3, r3, #1
    ed8e:	4013      	ands	r3, r2
    ed90:	d001      	beq.n	ed96 <nvm_set_config+0xc6>
		return STATUS_ERR_IO;
    ed92:	2310      	movs	r3, #16
    ed94:	e000      	b.n	ed98 <nvm_set_config+0xc8>
	}

	return STATUS_OK;
    ed96:	2300      	movs	r3, #0
}
    ed98:	0018      	movs	r0, r3
    ed9a:	46bd      	mov	sp, r7
    ed9c:	b004      	add	sp, #16
    ed9e:	bd80      	pop	{r7, pc}
    eda0:	41004000 	.word	0x41004000
    eda4:	0000ec75 	.word	0x0000ec75
    eda8:	0000ec4d 	.word	0x0000ec4d
    edac:	200005a4 	.word	0x200005a4

0000edb0 <nvm_execute_command>:
 */
enum status_code nvm_execute_command(
		const enum nvm_command command,
		const uint32_t address,
		const uint32_t parameter)
{
    edb0:	b580      	push	{r7, lr}
    edb2:	b086      	sub	sp, #24
    edb4:	af00      	add	r7, sp, #0
    edb6:	60b9      	str	r1, [r7, #8]
    edb8:	607a      	str	r2, [r7, #4]
    edba:	230f      	movs	r3, #15
    edbc:	18fb      	adds	r3, r7, r3
    edbe:	1c02      	adds	r2, r0, #0
    edc0:	701a      	strb	r2, [r3, #0]
	uint32_t ctrlb_bak;

	/* Check that the address given is valid  */
	if (address > ((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)
    edc2:	4b3c      	ldr	r3, [pc, #240]	; (eeb4 <nvm_execute_command+0x104>)
    edc4:	881b      	ldrh	r3, [r3, #0]
    edc6:	001a      	movs	r2, r3
    edc8:	4b3a      	ldr	r3, [pc, #232]	; (eeb4 <nvm_execute_command+0x104>)
    edca:	885b      	ldrh	r3, [r3, #2]
    edcc:	435a      	muls	r2, r3
    edce:	68bb      	ldr	r3, [r7, #8]
    edd0:	429a      	cmp	r2, r3
    edd2:	d209      	bcs.n	ede8 <nvm_execute_command+0x38>
		&& !(address >= NVMCTRL_AUX0_ADDRESS && address <= NVMCTRL_AUX1_ADDRESS )){
    edd4:	68bb      	ldr	r3, [r7, #8]
    edd6:	4a38      	ldr	r2, [pc, #224]	; (eeb8 <nvm_execute_command+0x108>)
    edd8:	4293      	cmp	r3, r2
    edda:	d903      	bls.n	ede4 <nvm_execute_command+0x34>
    eddc:	68bb      	ldr	r3, [r7, #8]
    edde:	4a37      	ldr	r2, [pc, #220]	; (eebc <nvm_execute_command+0x10c>)
    ede0:	4293      	cmp	r3, r2
    ede2:	d901      	bls.n	ede8 <nvm_execute_command+0x38>
		if (address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
			|| address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
#else
		return STATUS_ERR_BAD_ADDRESS;
    ede4:	2318      	movs	r3, #24
    ede6:	e061      	b.n	eeac <nvm_execute_command+0xfc>
#endif
	}

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    ede8:	4b35      	ldr	r3, [pc, #212]	; (eec0 <nvm_execute_command+0x110>)
    edea:	617b      	str	r3, [r7, #20]

	/* Turn off cache before issuing flash commands */
	ctrlb_bak = nvm_module->CTRLB.reg;
    edec:	697b      	ldr	r3, [r7, #20]
    edee:	685b      	ldr	r3, [r3, #4]
    edf0:	613b      	str	r3, [r7, #16]
#if (SAMC20) || (SAMC21)
	nvm_module->CTRLB.reg = ((ctrlb_bak &(~(NVMCTRL_CTRLB_CACHEDIS(0x2)))) 
							| NVMCTRL_CTRLB_CACHEDIS(0x1));
#else
	nvm_module->CTRLB.reg = ctrlb_bak | NVMCTRL_CTRLB_CACHEDIS;
    edf2:	693b      	ldr	r3, [r7, #16]
    edf4:	2280      	movs	r2, #128	; 0x80
    edf6:	02d2      	lsls	r2, r2, #11
    edf8:	431a      	orrs	r2, r3
    edfa:	697b      	ldr	r3, [r7, #20]
    edfc:	605a      	str	r2, [r3, #4]
#endif

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    edfe:	697b      	ldr	r3, [r7, #20]
    ee00:	8b1b      	ldrh	r3, [r3, #24]
    ee02:	b29b      	uxth	r3, r3
    ee04:	2220      	movs	r2, #32
    ee06:	32ff      	adds	r2, #255	; 0xff
    ee08:	4313      	orrs	r3, r2
    ee0a:	b29a      	uxth	r2, r3
    ee0c:	697b      	ldr	r3, [r7, #20]
    ee0e:	831a      	strh	r2, [r3, #24]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    ee10:	4b2c      	ldr	r3, [pc, #176]	; (eec4 <nvm_execute_command+0x114>)
    ee12:	4798      	blx	r3
    ee14:	0003      	movs	r3, r0
    ee16:	001a      	movs	r2, r3
    ee18:	2301      	movs	r3, #1
    ee1a:	4053      	eors	r3, r2
    ee1c:	b2db      	uxtb	r3, r3
    ee1e:	2b00      	cmp	r3, #0
    ee20:	d004      	beq.n	ee2c <nvm_execute_command+0x7c>
		/* Restore the setting */
		nvm_module->CTRLB.reg = ctrlb_bak;
    ee22:	697b      	ldr	r3, [r7, #20]
    ee24:	693a      	ldr	r2, [r7, #16]
    ee26:	605a      	str	r2, [r3, #4]
		return STATUS_BUSY;
    ee28:	2305      	movs	r3, #5
    ee2a:	e03f      	b.n	eeac <nvm_execute_command+0xfc>
	}

	switch (command) {
    ee2c:	230f      	movs	r3, #15
    ee2e:	18fb      	adds	r3, r7, r3
    ee30:	781b      	ldrb	r3, [r3, #0]
    ee32:	2b45      	cmp	r3, #69	; 0x45
    ee34:	d81d      	bhi.n	ee72 <nvm_execute_command+0xc2>
    ee36:	009a      	lsls	r2, r3, #2
    ee38:	4b23      	ldr	r3, [pc, #140]	; (eec8 <nvm_execute_command+0x118>)
    ee3a:	18d3      	adds	r3, r2, r3
    ee3c:	681b      	ldr	r3, [r3, #0]
    ee3e:	469f      	mov	pc, r3
		/* Commands requiring address (protected) */
		case NVM_COMMAND_ERASE_AUX_ROW:
		case NVM_COMMAND_WRITE_AUX_ROW:

			/* Auxiliary space cannot be accessed if the security bit is set */
			if (nvm_module->STATUS.reg & NVMCTRL_STATUS_SB) {
    ee40:	697b      	ldr	r3, [r7, #20]
    ee42:	8b1b      	ldrh	r3, [r3, #24]
    ee44:	b29b      	uxth	r3, r3
    ee46:	001a      	movs	r2, r3
    ee48:	2380      	movs	r3, #128	; 0x80
    ee4a:	005b      	lsls	r3, r3, #1
    ee4c:	4013      	ands	r3, r2
    ee4e:	d004      	beq.n	ee5a <nvm_execute_command+0xaa>
				/* Restore the setting */
				nvm_module->CTRLB.reg = ctrlb_bak;
    ee50:	697b      	ldr	r3, [r7, #20]
    ee52:	693a      	ldr	r2, [r7, #16]
    ee54:	605a      	str	r2, [r3, #4]
				return STATUS_ERR_IO;
    ee56:	2310      	movs	r3, #16
    ee58:	e028      	b.n	eeac <nvm_execute_command+0xfc>
			}

			/* Set address, command will be issued elsewhere */
			nvm_module->ADDR.reg = (uintptr_t)&NVM_MEMORY[address / 4];
    ee5a:	68bb      	ldr	r3, [r7, #8]
    ee5c:	089b      	lsrs	r3, r3, #2
    ee5e:	005a      	lsls	r2, r3, #1
    ee60:	697b      	ldr	r3, [r7, #20]
    ee62:	61da      	str	r2, [r3, #28]
			break;
    ee64:	e00b      	b.n	ee7e <nvm_execute_command+0xce>
		case NVM_COMMAND_RWWEE_ERASE_ROW:
		case NVM_COMMAND_RWWEE_WRITE_PAGE:
#endif

			/* Set address, command will be issued elsewhere */
			nvm_module->ADDR.reg = (uintptr_t)&NVM_MEMORY[address / 4];
    ee66:	68bb      	ldr	r3, [r7, #8]
    ee68:	089b      	lsrs	r3, r3, #2
    ee6a:	005a      	lsls	r2, r3, #1
    ee6c:	697b      	ldr	r3, [r7, #20]
    ee6e:	61da      	str	r2, [r3, #28]
			break;
    ee70:	e005      	b.n	ee7e <nvm_execute_command+0xce>
		case NVM_COMMAND_EXIT_LOW_POWER_MODE:
			break;

		default:
			/* Restore the setting */
			nvm_module->CTRLB.reg = ctrlb_bak;
    ee72:	697b      	ldr	r3, [r7, #20]
    ee74:	693a      	ldr	r2, [r7, #16]
    ee76:	605a      	str	r2, [r3, #4]
			return STATUS_ERR_INVALID_ARG;
    ee78:	2317      	movs	r3, #23
    ee7a:	e017      	b.n	eeac <nvm_execute_command+0xfc>
		/* Commands not requiring address */
		case NVM_COMMAND_PAGE_BUFFER_CLEAR:
		case NVM_COMMAND_SET_SECURITY_BIT:
		case NVM_COMMAND_ENTER_LOW_POWER_MODE:
		case NVM_COMMAND_EXIT_LOW_POWER_MODE:
			break;
    ee7c:	46c0      	nop			; (mov r8, r8)
			nvm_module->CTRLB.reg = ctrlb_bak;
			return STATUS_ERR_INVALID_ARG;
	}

	/* Set command */
	nvm_module->CTRLA.reg = command | NVMCTRL_CTRLA_CMDEX_KEY;
    ee7e:	230f      	movs	r3, #15
    ee80:	18fb      	adds	r3, r7, r3
    ee82:	781b      	ldrb	r3, [r3, #0]
    ee84:	b29b      	uxth	r3, r3
    ee86:	4a11      	ldr	r2, [pc, #68]	; (eecc <nvm_execute_command+0x11c>)
    ee88:	4313      	orrs	r3, r2
    ee8a:	b29a      	uxth	r2, r3
    ee8c:	697b      	ldr	r3, [r7, #20]
    ee8e:	801a      	strh	r2, [r3, #0]

	/* Wait for the NVM controller to become ready */
	while (!nvm_is_ready()) {
    ee90:	46c0      	nop			; (mov r8, r8)
    ee92:	4b0c      	ldr	r3, [pc, #48]	; (eec4 <nvm_execute_command+0x114>)
    ee94:	4798      	blx	r3
    ee96:	0003      	movs	r3, r0
    ee98:	001a      	movs	r2, r3
    ee9a:	2301      	movs	r3, #1
    ee9c:	4053      	eors	r3, r2
    ee9e:	b2db      	uxtb	r3, r3
    eea0:	2b00      	cmp	r3, #0
    eea2:	d1f6      	bne.n	ee92 <nvm_execute_command+0xe2>
	}

	/* Restore the setting */
	nvm_module->CTRLB.reg = ctrlb_bak;
    eea4:	697b      	ldr	r3, [r7, #20]
    eea6:	693a      	ldr	r2, [r7, #16]
    eea8:	605a      	str	r2, [r3, #4]

	return STATUS_OK;
    eeaa:	2300      	movs	r3, #0
}
    eeac:	0018      	movs	r0, r3
    eeae:	46bd      	mov	sp, r7
    eeb0:	b006      	add	sp, #24
    eeb2:	bd80      	pop	{r7, pc}
    eeb4:	200005a4 	.word	0x200005a4
    eeb8:	00803fff 	.word	0x00803fff
    eebc:	00806000 	.word	0x00806000
    eec0:	41004000 	.word	0x41004000
    eec4:	0000ec4d 	.word	0x0000ec4d
    eec8:	00020ee4 	.word	0x00020ee4
    eecc:	ffffa500 	.word	0xffffa500

0000eed0 <nvm_write_buffer>:
 */
enum status_code nvm_write_buffer(
		const uint32_t destination_address,
		const uint8_t *buffer,
		uint16_t length)
{
    eed0:	b580      	push	{r7, lr}
    eed2:	b088      	sub	sp, #32
    eed4:	af00      	add	r7, sp, #0
    eed6:	60f8      	str	r0, [r7, #12]
    eed8:	60b9      	str	r1, [r7, #8]
    eeda:	1dbb      	adds	r3, r7, #6
    eedc:	801a      	strh	r2, [r3, #0]
	bool is_rww_eeprom = false;
#endif

	/* Check if the destination address is valid */
	if (destination_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    eede:	4b4c      	ldr	r3, [pc, #304]	; (f010 <nvm_write_buffer+0x140>)
    eee0:	881b      	ldrh	r3, [r3, #0]
    eee2:	001a      	movs	r2, r3
    eee4:	4b4a      	ldr	r3, [pc, #296]	; (f010 <nvm_write_buffer+0x140>)
    eee6:	885b      	ldrh	r3, [r3, #2]
    eee8:	435a      	muls	r2, r3
#ifdef FEATURE_NVM_RWWEE
	bool is_rww_eeprom = false;
#endif

	/* Check if the destination address is valid */
	if (destination_address >
    eeea:	68fb      	ldr	r3, [r7, #12]
    eeec:	429a      	cmp	r2, r3
    eeee:	d201      	bcs.n	eef4 <nvm_write_buffer+0x24>
			|| destination_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
		is_rww_eeprom = true;
#else
		return STATUS_ERR_BAD_ADDRESS;
    eef0:	2318      	movs	r3, #24
    eef2:	e089      	b.n	f008 <nvm_write_buffer+0x138>
#endif
	}

	/* Check if the write address not aligned to the start of a page */
	if (destination_address & (_nvm_dev.page_size - 1)) {
    eef4:	4b46      	ldr	r3, [pc, #280]	; (f010 <nvm_write_buffer+0x140>)
    eef6:	881b      	ldrh	r3, [r3, #0]
    eef8:	3b01      	subs	r3, #1
    eefa:	001a      	movs	r2, r3
    eefc:	68fb      	ldr	r3, [r7, #12]
    eefe:	4013      	ands	r3, r2
    ef00:	d001      	beq.n	ef06 <nvm_write_buffer+0x36>
		return STATUS_ERR_BAD_ADDRESS;
    ef02:	2318      	movs	r3, #24
    ef04:	e080      	b.n	f008 <nvm_write_buffer+0x138>
	}

	/* Check if the write length is longer than a NVM page */
	if (length > _nvm_dev.page_size) {
    ef06:	4b42      	ldr	r3, [pc, #264]	; (f010 <nvm_write_buffer+0x140>)
    ef08:	881b      	ldrh	r3, [r3, #0]
    ef0a:	1dba      	adds	r2, r7, #6
    ef0c:	8812      	ldrh	r2, [r2, #0]
    ef0e:	429a      	cmp	r2, r3
    ef10:	d901      	bls.n	ef16 <nvm_write_buffer+0x46>
		return STATUS_ERR_INVALID_ARG;
    ef12:	2317      	movs	r3, #23
    ef14:	e078      	b.n	f008 <nvm_write_buffer+0x138>
	}

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    ef16:	4b3f      	ldr	r3, [pc, #252]	; (f014 <nvm_write_buffer+0x144>)
    ef18:	617b      	str	r3, [r7, #20]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    ef1a:	4b3f      	ldr	r3, [pc, #252]	; (f018 <nvm_write_buffer+0x148>)
    ef1c:	4798      	blx	r3
    ef1e:	0003      	movs	r3, r0
    ef20:	001a      	movs	r2, r3
    ef22:	2301      	movs	r3, #1
    ef24:	4053      	eors	r3, r2
    ef26:	b2db      	uxtb	r3, r3
    ef28:	2b00      	cmp	r3, #0
    ef2a:	d001      	beq.n	ef30 <nvm_write_buffer+0x60>
		return STATUS_BUSY;
    ef2c:	2305      	movs	r3, #5
    ef2e:	e06b      	b.n	f008 <nvm_write_buffer+0x138>
	}

	/* Erase the page buffer before buffering new data */
	nvm_module->CTRLA.reg = NVM_COMMAND_PAGE_BUFFER_CLEAR | NVMCTRL_CTRLA_CMDEX_KEY;
    ef30:	697b      	ldr	r3, [r7, #20]
    ef32:	4a3a      	ldr	r2, [pc, #232]	; (f01c <nvm_write_buffer+0x14c>)
    ef34:	801a      	strh	r2, [r3, #0]

	/* Check if the module is busy */
	while (!nvm_is_ready()) {
    ef36:	46c0      	nop			; (mov r8, r8)
    ef38:	4b37      	ldr	r3, [pc, #220]	; (f018 <nvm_write_buffer+0x148>)
    ef3a:	4798      	blx	r3
    ef3c:	0003      	movs	r3, r0
    ef3e:	001a      	movs	r2, r3
    ef40:	2301      	movs	r3, #1
    ef42:	4053      	eors	r3, r2
    ef44:	b2db      	uxtb	r3, r3
    ef46:	2b00      	cmp	r3, #0
    ef48:	d1f6      	bne.n	ef38 <nvm_write_buffer+0x68>
		/* Force-wait for the buffer clear to complete */
	}

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    ef4a:	697b      	ldr	r3, [r7, #20]
    ef4c:	8b1b      	ldrh	r3, [r3, #24]
    ef4e:	b29b      	uxth	r3, r3
    ef50:	2220      	movs	r2, #32
    ef52:	32ff      	adds	r2, #255	; 0xff
    ef54:	4313      	orrs	r3, r2
    ef56:	b29a      	uxth	r2, r3
    ef58:	697b      	ldr	r3, [r7, #20]
    ef5a:	831a      	strh	r2, [r3, #24]

	uint32_t nvm_address = destination_address / 2;
    ef5c:	68fb      	ldr	r3, [r7, #12]
    ef5e:	085b      	lsrs	r3, r3, #1
    ef60:	61fb      	str	r3, [r7, #28]

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
    ef62:	231a      	movs	r3, #26
    ef64:	18fb      	adds	r3, r7, r3
    ef66:	2200      	movs	r2, #0
    ef68:	801a      	strh	r2, [r3, #0]
    ef6a:	e032      	b.n	efd2 <nvm_write_buffer+0x102>
		uint16_t data;

		/* Copy first byte of the 16-bit chunk to the temporary buffer */
		data = buffer[i];
    ef6c:	231a      	movs	r3, #26
    ef6e:	18fb      	adds	r3, r7, r3
    ef70:	881b      	ldrh	r3, [r3, #0]
    ef72:	68ba      	ldr	r2, [r7, #8]
    ef74:	18d3      	adds	r3, r2, r3
    ef76:	781a      	ldrb	r2, [r3, #0]
    ef78:	2318      	movs	r3, #24
    ef7a:	18fb      	adds	r3, r7, r3
    ef7c:	801a      	strh	r2, [r3, #0]

		/* If we are not at the end of a write request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
    ef7e:	231a      	movs	r3, #26
    ef80:	18fb      	adds	r3, r7, r3
    ef82:	881a      	ldrh	r2, [r3, #0]
    ef84:	1dbb      	adds	r3, r7, #6
    ef86:	881b      	ldrh	r3, [r3, #0]
    ef88:	3b01      	subs	r3, #1
    ef8a:	429a      	cmp	r2, r3
    ef8c:	da11      	bge.n	efb2 <nvm_write_buffer+0xe2>
			data |= (buffer[i + 1] << 8);
    ef8e:	231a      	movs	r3, #26
    ef90:	18fb      	adds	r3, r7, r3
    ef92:	881b      	ldrh	r3, [r3, #0]
    ef94:	3301      	adds	r3, #1
    ef96:	68ba      	ldr	r2, [r7, #8]
    ef98:	18d3      	adds	r3, r2, r3
    ef9a:	781b      	ldrb	r3, [r3, #0]
    ef9c:	021b      	lsls	r3, r3, #8
    ef9e:	b21a      	sxth	r2, r3
    efa0:	2318      	movs	r3, #24
    efa2:	18fb      	adds	r3, r7, r3
    efa4:	2100      	movs	r1, #0
    efa6:	5e5b      	ldrsh	r3, [r3, r1]
    efa8:	4313      	orrs	r3, r2
    efaa:	b21a      	sxth	r2, r3
    efac:	2318      	movs	r3, #24
    efae:	18fb      	adds	r3, r7, r3
    efb0:	801a      	strh	r2, [r3, #0]
		}

		/* Store next 16-bit chunk to the NVM memory space */
		NVM_MEMORY[nvm_address++] = data;
    efb2:	69fb      	ldr	r3, [r7, #28]
    efb4:	1c5a      	adds	r2, r3, #1
    efb6:	61fa      	str	r2, [r7, #28]
    efb8:	005b      	lsls	r3, r3, #1
    efba:	001a      	movs	r2, r3
    efbc:	2318      	movs	r3, #24
    efbe:	18fb      	adds	r3, r7, r3
    efc0:	881b      	ldrh	r3, [r3, #0]
    efc2:	8013      	strh	r3, [r2, #0]

	uint32_t nvm_address = destination_address / 2;

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
    efc4:	231a      	movs	r3, #26
    efc6:	18fb      	adds	r3, r7, r3
    efc8:	221a      	movs	r2, #26
    efca:	18ba      	adds	r2, r7, r2
    efcc:	8812      	ldrh	r2, [r2, #0]
    efce:	3202      	adds	r2, #2
    efd0:	801a      	strh	r2, [r3, #0]
    efd2:	231a      	movs	r3, #26
    efd4:	18fa      	adds	r2, r7, r3
    efd6:	1dbb      	adds	r3, r7, #6
    efd8:	8812      	ldrh	r2, [r2, #0]
    efda:	881b      	ldrh	r3, [r3, #0]
    efdc:	429a      	cmp	r2, r3
    efde:	d3c5      	bcc.n	ef6c <nvm_write_buffer+0x9c>
	}

	/* If automatic page write mode is enable, then perform a manual NVM
	 * write when the length of data to be programmed is less than page size
	 */
	if ((_nvm_dev.manual_page_write == false) && (length < NVMCTRL_PAGE_SIZE)) {
    efe0:	4b0b      	ldr	r3, [pc, #44]	; (f010 <nvm_write_buffer+0x140>)
    efe2:	791b      	ldrb	r3, [r3, #4]
    efe4:	2201      	movs	r2, #1
    efe6:	4053      	eors	r3, r2
    efe8:	b2db      	uxtb	r3, r3
    efea:	2b00      	cmp	r3, #0
    efec:	d00b      	beq.n	f006 <nvm_write_buffer+0x136>
    efee:	1dbb      	adds	r3, r7, #6
    eff0:	881b      	ldrh	r3, [r3, #0]
    eff2:	2b3f      	cmp	r3, #63	; 0x3f
    eff4:	d807      	bhi.n	f006 <nvm_write_buffer+0x136>
#ifdef FEATURE_NVM_RWWEE
	 return ((is_rww_eeprom) ?
				(nvm_execute_command(NVM_COMMAND_RWWEE_WRITE_PAGE,destination_address, 0)):
	 			(nvm_execute_command(NVM_COMMAND_WRITE_PAGE,destination_address, 0)));
#else
		return nvm_execute_command(NVM_COMMAND_WRITE_PAGE,
    eff6:	68fb      	ldr	r3, [r7, #12]
    eff8:	2200      	movs	r2, #0
    effa:	0019      	movs	r1, r3
    effc:	2004      	movs	r0, #4
    effe:	4b08      	ldr	r3, [pc, #32]	; (f020 <nvm_write_buffer+0x150>)
    f000:	4798      	blx	r3
    f002:	0003      	movs	r3, r0
    f004:	e000      	b.n	f008 <nvm_write_buffer+0x138>
				destination_address, 0);
#endif
	}

	return STATUS_OK;
    f006:	2300      	movs	r3, #0
}
    f008:	0018      	movs	r0, r3
    f00a:	46bd      	mov	sp, r7
    f00c:	b008      	add	sp, #32
    f00e:	bd80      	pop	{r7, pc}
    f010:	200005a4 	.word	0x200005a4
    f014:	41004000 	.word	0x41004000
    f018:	0000ec4d 	.word	0x0000ec4d
    f01c:	ffffa544 	.word	0xffffa544
    f020:	0000edb1 	.word	0x0000edb1

0000f024 <nvm_read_buffer>:
 */
enum status_code nvm_read_buffer(
		const uint32_t source_address,
		uint8_t *const buffer,
		uint16_t length)
{
    f024:	b580      	push	{r7, lr}
    f026:	b088      	sub	sp, #32
    f028:	af00      	add	r7, sp, #0
    f02a:	60f8      	str	r0, [r7, #12]
    f02c:	60b9      	str	r1, [r7, #8]
    f02e:	1dbb      	adds	r3, r7, #6
    f030:	801a      	strh	r2, [r3, #0]
	/* Check if the source address is valid */
	if (source_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    f032:	4b3a      	ldr	r3, [pc, #232]	; (f11c <nvm_read_buffer+0xf8>)
    f034:	881b      	ldrh	r3, [r3, #0]
    f036:	001a      	movs	r2, r3
    f038:	4b38      	ldr	r3, [pc, #224]	; (f11c <nvm_read_buffer+0xf8>)
    f03a:	885b      	ldrh	r3, [r3, #2]
    f03c:	435a      	muls	r2, r3
		const uint32_t source_address,
		uint8_t *const buffer,
		uint16_t length)
{
	/* Check if the source address is valid */
	if (source_address >
    f03e:	68fb      	ldr	r3, [r7, #12]
    f040:	429a      	cmp	r2, r3
    f042:	d201      	bcs.n	f048 <nvm_read_buffer+0x24>
		if (source_address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
			|| source_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
#else
		return STATUS_ERR_BAD_ADDRESS;
    f044:	2318      	movs	r3, #24
    f046:	e065      	b.n	f114 <nvm_read_buffer+0xf0>
#endif
	}

	/* Check if the read address is not aligned to the start of a page */
	if (source_address & (_nvm_dev.page_size - 1)) {
    f048:	4b34      	ldr	r3, [pc, #208]	; (f11c <nvm_read_buffer+0xf8>)
    f04a:	881b      	ldrh	r3, [r3, #0]
    f04c:	3b01      	subs	r3, #1
    f04e:	001a      	movs	r2, r3
    f050:	68fb      	ldr	r3, [r7, #12]
    f052:	4013      	ands	r3, r2
    f054:	d001      	beq.n	f05a <nvm_read_buffer+0x36>
		return STATUS_ERR_BAD_ADDRESS;
    f056:	2318      	movs	r3, #24
    f058:	e05c      	b.n	f114 <nvm_read_buffer+0xf0>
	}

	/* Check if the write length is longer than a NVM page */
	if (length > _nvm_dev.page_size) {
    f05a:	4b30      	ldr	r3, [pc, #192]	; (f11c <nvm_read_buffer+0xf8>)
    f05c:	881b      	ldrh	r3, [r3, #0]
    f05e:	1dba      	adds	r2, r7, #6
    f060:	8812      	ldrh	r2, [r2, #0]
    f062:	429a      	cmp	r2, r3
    f064:	d901      	bls.n	f06a <nvm_read_buffer+0x46>
		return STATUS_ERR_INVALID_ARG;
    f066:	2317      	movs	r3, #23
    f068:	e054      	b.n	f114 <nvm_read_buffer+0xf0>
	}

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    f06a:	4b2d      	ldr	r3, [pc, #180]	; (f120 <nvm_read_buffer+0xfc>)
    f06c:	617b      	str	r3, [r7, #20]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    f06e:	4b2d      	ldr	r3, [pc, #180]	; (f124 <nvm_read_buffer+0x100>)
    f070:	4798      	blx	r3
    f072:	0003      	movs	r3, r0
    f074:	001a      	movs	r2, r3
    f076:	2301      	movs	r3, #1
    f078:	4053      	eors	r3, r2
    f07a:	b2db      	uxtb	r3, r3
    f07c:	2b00      	cmp	r3, #0
    f07e:	d001      	beq.n	f084 <nvm_read_buffer+0x60>
		return STATUS_BUSY;
    f080:	2305      	movs	r3, #5
    f082:	e047      	b.n	f114 <nvm_read_buffer+0xf0>
	}

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    f084:	697b      	ldr	r3, [r7, #20]
    f086:	8b1b      	ldrh	r3, [r3, #24]
    f088:	b29b      	uxth	r3, r3
    f08a:	2220      	movs	r2, #32
    f08c:	32ff      	adds	r2, #255	; 0xff
    f08e:	4313      	orrs	r3, r2
    f090:	b29a      	uxth	r2, r3
    f092:	697b      	ldr	r3, [r7, #20]
    f094:	831a      	strh	r2, [r3, #24]

	uint32_t page_address = source_address / 2;
    f096:	68fb      	ldr	r3, [r7, #12]
    f098:	085b      	lsrs	r3, r3, #1
    f09a:	61fb      	str	r3, [r7, #28]

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
    f09c:	231a      	movs	r3, #26
    f09e:	18fb      	adds	r3, r7, r3
    f0a0:	2200      	movs	r2, #0
    f0a2:	801a      	strh	r2, [r3, #0]
    f0a4:	e02e      	b.n	f104 <nvm_read_buffer+0xe0>
		/* Fetch next 16-bit chunk from the NVM memory space */
		uint16_t data = NVM_MEMORY[page_address++];
    f0a6:	69fb      	ldr	r3, [r7, #28]
    f0a8:	1c5a      	adds	r2, r3, #1
    f0aa:	61fa      	str	r2, [r7, #28]
    f0ac:	005b      	lsls	r3, r3, #1
    f0ae:	001a      	movs	r2, r3
    f0b0:	2312      	movs	r3, #18
    f0b2:	18fb      	adds	r3, r7, r3
    f0b4:	8812      	ldrh	r2, [r2, #0]
    f0b6:	801a      	strh	r2, [r3, #0]

		/* Copy first byte of the 16-bit chunk to the destination buffer */
		buffer[i] = (data & 0xFF);
    f0b8:	231a      	movs	r3, #26
    f0ba:	18fb      	adds	r3, r7, r3
    f0bc:	881b      	ldrh	r3, [r3, #0]
    f0be:	68ba      	ldr	r2, [r7, #8]
    f0c0:	18d3      	adds	r3, r2, r3
    f0c2:	2212      	movs	r2, #18
    f0c4:	18ba      	adds	r2, r7, r2
    f0c6:	8812      	ldrh	r2, [r2, #0]
    f0c8:	b2d2      	uxtb	r2, r2
    f0ca:	701a      	strb	r2, [r3, #0]

		/* If we are not at the end of a read request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
    f0cc:	231a      	movs	r3, #26
    f0ce:	18fb      	adds	r3, r7, r3
    f0d0:	881a      	ldrh	r2, [r3, #0]
    f0d2:	1dbb      	adds	r3, r7, #6
    f0d4:	881b      	ldrh	r3, [r3, #0]
    f0d6:	3b01      	subs	r3, #1
    f0d8:	429a      	cmp	r2, r3
    f0da:	da0c      	bge.n	f0f6 <nvm_read_buffer+0xd2>
			buffer[i + 1] = (data >> 8);
    f0dc:	231a      	movs	r3, #26
    f0de:	18fb      	adds	r3, r7, r3
    f0e0:	881b      	ldrh	r3, [r3, #0]
    f0e2:	3301      	adds	r3, #1
    f0e4:	68ba      	ldr	r2, [r7, #8]
    f0e6:	18d3      	adds	r3, r2, r3
    f0e8:	2212      	movs	r2, #18
    f0ea:	18ba      	adds	r2, r7, r2
    f0ec:	8812      	ldrh	r2, [r2, #0]
    f0ee:	0a12      	lsrs	r2, r2, #8
    f0f0:	b292      	uxth	r2, r2
    f0f2:	b2d2      	uxtb	r2, r2
    f0f4:	701a      	strb	r2, [r3, #0]

	uint32_t page_address = source_address / 2;

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
    f0f6:	231a      	movs	r3, #26
    f0f8:	18fb      	adds	r3, r7, r3
    f0fa:	221a      	movs	r2, #26
    f0fc:	18ba      	adds	r2, r7, r2
    f0fe:	8812      	ldrh	r2, [r2, #0]
    f100:	3202      	adds	r2, #2
    f102:	801a      	strh	r2, [r3, #0]
    f104:	231a      	movs	r3, #26
    f106:	18fa      	adds	r2, r7, r3
    f108:	1dbb      	adds	r3, r7, #6
    f10a:	8812      	ldrh	r2, [r2, #0]
    f10c:	881b      	ldrh	r3, [r3, #0]
    f10e:	429a      	cmp	r2, r3
    f110:	d3c9      	bcc.n	f0a6 <nvm_read_buffer+0x82>
		if (i < (length - 1)) {
			buffer[i + 1] = (data >> 8);
		}
	}

	return STATUS_OK;
    f112:	2300      	movs	r3, #0
}
    f114:	0018      	movs	r0, r3
    f116:	46bd      	mov	sp, r7
    f118:	b008      	add	sp, #32
    f11a:	bd80      	pop	{r7, pc}
    f11c:	200005a4 	.word	0x200005a4
    f120:	41004000 	.word	0x41004000
    f124:	0000ec4d 	.word	0x0000ec4d

0000f128 <nvm_erase_row>:
 *                                 acceptable range of the NVM memory region or
 *                                 not aligned to the start of a row
 */
enum status_code nvm_erase_row(
		const uint32_t row_address)
{
    f128:	b580      	push	{r7, lr}
    f12a:	b084      	sub	sp, #16
    f12c:	af00      	add	r7, sp, #0
    f12e:	6078      	str	r0, [r7, #4]
		bool is_rww_eeprom = false;
#endif

	/* Check if the row address is valid */
	if (row_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    f130:	4b20      	ldr	r3, [pc, #128]	; (f1b4 <nvm_erase_row+0x8c>)
    f132:	881b      	ldrh	r3, [r3, #0]
    f134:	001a      	movs	r2, r3
    f136:	4b1f      	ldr	r3, [pc, #124]	; (f1b4 <nvm_erase_row+0x8c>)
    f138:	885b      	ldrh	r3, [r3, #2]
    f13a:	435a      	muls	r2, r3
#ifdef FEATURE_NVM_RWWEE
		bool is_rww_eeprom = false;
#endif

	/* Check if the row address is valid */
	if (row_address >
    f13c:	687b      	ldr	r3, [r7, #4]
    f13e:	429a      	cmp	r2, r3
    f140:	d201      	bcs.n	f146 <nvm_erase_row+0x1e>
			|| row_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
		is_rww_eeprom = true;
#else
		return STATUS_ERR_BAD_ADDRESS;
    f142:	2318      	movs	r3, #24
    f144:	e032      	b.n	f1ac <nvm_erase_row+0x84>
#endif
	}

	/* Check if the address to erase is not aligned to the start of a row */
	if (row_address & ((_nvm_dev.page_size * NVMCTRL_ROW_PAGES) - 1)) {
    f146:	4b1b      	ldr	r3, [pc, #108]	; (f1b4 <nvm_erase_row+0x8c>)
    f148:	881b      	ldrh	r3, [r3, #0]
    f14a:	009b      	lsls	r3, r3, #2
    f14c:	3b01      	subs	r3, #1
    f14e:	001a      	movs	r2, r3
    f150:	687b      	ldr	r3, [r7, #4]
    f152:	4013      	ands	r3, r2
    f154:	d001      	beq.n	f15a <nvm_erase_row+0x32>
		return STATUS_ERR_BAD_ADDRESS;
    f156:	2318      	movs	r3, #24
    f158:	e028      	b.n	f1ac <nvm_erase_row+0x84>
	}

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    f15a:	4b17      	ldr	r3, [pc, #92]	; (f1b8 <nvm_erase_row+0x90>)
    f15c:	60fb      	str	r3, [r7, #12]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    f15e:	4b17      	ldr	r3, [pc, #92]	; (f1bc <nvm_erase_row+0x94>)
    f160:	4798      	blx	r3
    f162:	0003      	movs	r3, r0
    f164:	001a      	movs	r2, r3
    f166:	2301      	movs	r3, #1
    f168:	4053      	eors	r3, r2
    f16a:	b2db      	uxtb	r3, r3
    f16c:	2b00      	cmp	r3, #0
    f16e:	d001      	beq.n	f174 <nvm_erase_row+0x4c>
		return STATUS_BUSY;
    f170:	2305      	movs	r3, #5
    f172:	e01b      	b.n	f1ac <nvm_erase_row+0x84>
	}

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    f174:	68fb      	ldr	r3, [r7, #12]
    f176:	8b1b      	ldrh	r3, [r3, #24]
    f178:	b29b      	uxth	r3, r3
    f17a:	2220      	movs	r2, #32
    f17c:	32ff      	adds	r2, #255	; 0xff
    f17e:	4313      	orrs	r3, r2
    f180:	b29a      	uxth	r2, r3
    f182:	68fb      	ldr	r3, [r7, #12]
    f184:	831a      	strh	r2, [r3, #24]

	/* Set address and command */
	nvm_module->ADDR.reg  = (uintptr_t)&NVM_MEMORY[row_address / 4];
    f186:	687b      	ldr	r3, [r7, #4]
    f188:	089b      	lsrs	r3, r3, #2
    f18a:	005a      	lsls	r2, r3, #1
    f18c:	68fb      	ldr	r3, [r7, #12]
    f18e:	61da      	str	r2, [r3, #28]
#ifdef FEATURE_NVM_RWWEE
	nvm_module->CTRLA.reg = ((is_rww_eeprom) ?
								(NVM_COMMAND_RWWEE_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY):
								(NVM_COMMAND_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY));
#else
	nvm_module->CTRLA.reg = NVM_COMMAND_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY;
    f190:	68fb      	ldr	r3, [r7, #12]
    f192:	4a0b      	ldr	r2, [pc, #44]	; (f1c0 <nvm_erase_row+0x98>)
    f194:	801a      	strh	r2, [r3, #0]
#endif

	while (!nvm_is_ready()) {
    f196:	46c0      	nop			; (mov r8, r8)
    f198:	4b08      	ldr	r3, [pc, #32]	; (f1bc <nvm_erase_row+0x94>)
    f19a:	4798      	blx	r3
    f19c:	0003      	movs	r3, r0
    f19e:	001a      	movs	r2, r3
    f1a0:	2301      	movs	r3, #1
    f1a2:	4053      	eors	r3, r2
    f1a4:	b2db      	uxtb	r3, r3
    f1a6:	2b00      	cmp	r3, #0
    f1a8:	d1f6      	bne.n	f198 <nvm_erase_row+0x70>
	}

	return STATUS_OK;
    f1aa:	2300      	movs	r3, #0
}
    f1ac:	0018      	movs	r0, r3
    f1ae:	46bd      	mov	sp, r7
    f1b0:	b004      	add	sp, #16
    f1b2:	bd80      	pop	{r7, pc}
    f1b4:	200005a4 	.word	0x200005a4
    f1b8:	41004000 	.word	0x41004000
    f1bc:	0000ec4d 	.word	0x0000ec4d
    f1c0:	ffffa502 	.word	0xffffa502

0000f1c4 <_nvm_translate_raw_fusebits_to_struct>:
 *
 */
static void _nvm_translate_raw_fusebits_to_struct (
		uint32_t *raw_user_row,
		struct nvm_fusebits *fusebits)
{
    f1c4:	b580      	push	{r7, lr}
    f1c6:	b082      	sub	sp, #8
    f1c8:	af00      	add	r7, sp, #0
    f1ca:	6078      	str	r0, [r7, #4]
    f1cc:	6039      	str	r1, [r7, #0]

	fusebits->bootloader_size = (enum nvm_bootloader_size)
			((raw_user_row[0] & NVMCTRL_FUSES_BOOTPROT_Msk)
    f1ce:	687b      	ldr	r3, [r7, #4]
    f1d0:	681b      	ldr	r3, [r3, #0]
static void _nvm_translate_raw_fusebits_to_struct (
		uint32_t *raw_user_row,
		struct nvm_fusebits *fusebits)
{

	fusebits->bootloader_size = (enum nvm_bootloader_size)
    f1d2:	b2db      	uxtb	r3, r3
    f1d4:	2207      	movs	r2, #7
    f1d6:	4013      	ands	r3, r2
    f1d8:	b2da      	uxtb	r2, r3
    f1da:	683b      	ldr	r3, [r7, #0]
    f1dc:	701a      	strb	r2, [r3, #0]
			((raw_user_row[0] & NVMCTRL_FUSES_BOOTPROT_Msk)
			>> NVMCTRL_FUSES_BOOTPROT_Pos);

	fusebits->eeprom_size = (enum nvm_eeprom_emulator_size)
			((raw_user_row[0] & NVMCTRL_FUSES_EEPROM_SIZE_Msk)
    f1de:	687b      	ldr	r3, [r7, #4]
    f1e0:	681b      	ldr	r3, [r3, #0]
			>> NVMCTRL_FUSES_EEPROM_SIZE_Pos);
    f1e2:	091b      	lsrs	r3, r3, #4
    f1e4:	2207      	movs	r2, #7
    f1e6:	4013      	ands	r3, r2

	fusebits->bootloader_size = (enum nvm_bootloader_size)
			((raw_user_row[0] & NVMCTRL_FUSES_BOOTPROT_Msk)
			>> NVMCTRL_FUSES_BOOTPROT_Pos);

	fusebits->eeprom_size = (enum nvm_eeprom_emulator_size)
    f1e8:	b2da      	uxtb	r2, r3
    f1ea:	683b      	ldr	r3, [r7, #0]
    f1ec:	705a      	strb	r2, [r3, #1]
			((raw_user_row[1] & FUSES_BOD33_HYST_Msk)
			>> FUSES_BOD33_HYST_Pos);

#elif (SAMD20) || (SAMD21) || (SAMR21)|| (SAMDA1) || (SAMD09) || (SAMD10)
	fusebits->bod33_level = (uint8_t)
			((raw_user_row[0] & FUSES_BOD33USERLEVEL_Msk)
    f1ee:	687b      	ldr	r3, [r7, #4]
    f1f0:	681b      	ldr	r3, [r3, #0]
			>> FUSES_BOD33USERLEVEL_Pos);
    f1f2:	0a1b      	lsrs	r3, r3, #8
	fusebits->bod33_hysteresis = (bool)
			((raw_user_row[1] & FUSES_BOD33_HYST_Msk)
			>> FUSES_BOD33_HYST_Pos);

#elif (SAMD20) || (SAMD21) || (SAMR21)|| (SAMDA1) || (SAMD09) || (SAMD10)
	fusebits->bod33_level = (uint8_t)
    f1f4:	b2db      	uxtb	r3, r3
    f1f6:	223f      	movs	r2, #63	; 0x3f
    f1f8:	4013      	ands	r3, r2
    f1fa:	b2da      	uxtb	r2, r3
    f1fc:	683b      	ldr	r3, [r7, #0]
    f1fe:	709a      	strb	r2, [r3, #2]
			((raw_user_row[0] & FUSES_BOD33USERLEVEL_Msk)
			>> FUSES_BOD33USERLEVEL_Pos);

	fusebits->bod33_enable = (bool)
			((raw_user_row[0] & FUSES_BOD33_EN_Msk)
    f200:	687b      	ldr	r3, [r7, #4]
    f202:	681a      	ldr	r2, [r3, #0]
#elif (SAMD20) || (SAMD21) || (SAMR21)|| (SAMDA1) || (SAMD09) || (SAMD10)
	fusebits->bod33_level = (uint8_t)
			((raw_user_row[0] & FUSES_BOD33USERLEVEL_Msk)
			>> FUSES_BOD33USERLEVEL_Pos);

	fusebits->bod33_enable = (bool)
    f204:	2380      	movs	r3, #128	; 0x80
    f206:	01db      	lsls	r3, r3, #7
    f208:	4013      	ands	r3, r2
    f20a:	1e5a      	subs	r2, r3, #1
    f20c:	4193      	sbcs	r3, r2
    f20e:	b2da      	uxtb	r2, r3
    f210:	683b      	ldr	r3, [r7, #0]
    f212:	70da      	strb	r2, [r3, #3]
			((raw_user_row[0] & FUSES_BOD33_EN_Msk)
			>> FUSES_BOD33_EN_Pos);

	fusebits->bod33_action = (enum nvm_bod33_action)
			((raw_user_row[0] & FUSES_BOD33_ACTION_Msk)
    f214:	687b      	ldr	r3, [r7, #4]
    f216:	681b      	ldr	r3, [r3, #0]
			>> FUSES_BOD33_ACTION_Pos);
    f218:	0bdb      	lsrs	r3, r3, #15
    f21a:	2203      	movs	r2, #3
    f21c:	4013      	ands	r3, r2

	fusebits->bod33_enable = (bool)
			((raw_user_row[0] & FUSES_BOD33_EN_Msk)
			>> FUSES_BOD33_EN_Pos);

	fusebits->bod33_action = (enum nvm_bod33_action)
    f21e:	b2da      	uxtb	r2, r3
    f220:	683b      	ldr	r3, [r7, #0]
    f222:	711a      	strb	r2, [r3, #4]
			((raw_user_row[0] & FUSES_BOD33_ACTION_Msk)
			>> FUSES_BOD33_ACTION_Pos);
	fusebits->bod33_hysteresis = (bool)
			((raw_user_row[1] & FUSES_BOD33_HYST_Msk)
    f224:	687b      	ldr	r3, [r7, #4]
    f226:	3304      	adds	r3, #4
    f228:	681a      	ldr	r2, [r3, #0]
			>> FUSES_BOD33_EN_Pos);

	fusebits->bod33_action = (enum nvm_bod33_action)
			((raw_user_row[0] & FUSES_BOD33_ACTION_Msk)
			>> FUSES_BOD33_ACTION_Pos);
	fusebits->bod33_hysteresis = (bool)
    f22a:	2380      	movs	r3, #128	; 0x80
    f22c:	005b      	lsls	r3, r3, #1
    f22e:	4013      	ands	r3, r2
    f230:	1e5a      	subs	r2, r3, #1
    f232:	4193      	sbcs	r3, r2
    f234:	b2da      	uxtb	r2, r3
    f236:	683b      	ldr	r3, [r7, #0]
    f238:	715a      	strb	r2, [r3, #5]
			((raw_user_row[1] & FUSES_BOD12_HYST_Msk)
			>> FUSES_BOD12_HYST_Pos);
#endif

	fusebits->wdt_enable = (bool)
			((raw_user_row[0] & WDT_FUSES_ENABLE_Msk) >> WDT_FUSES_ENABLE_Pos);
    f23a:	687b      	ldr	r3, [r7, #4]
    f23c:	681a      	ldr	r2, [r3, #0]
	fusebits->bod12_hysteresis = (bool)
			((raw_user_row[1] & FUSES_BOD12_HYST_Msk)
			>> FUSES_BOD12_HYST_Pos);
#endif

	fusebits->wdt_enable = (bool)
    f23e:	2380      	movs	r3, #128	; 0x80
    f240:	049b      	lsls	r3, r3, #18
    f242:	4013      	ands	r3, r2
    f244:	1e5a      	subs	r2, r3, #1
    f246:	4193      	sbcs	r3, r2
    f248:	b2da      	uxtb	r2, r3
    f24a:	683b      	ldr	r3, [r7, #0]
    f24c:	719a      	strb	r2, [r3, #6]
			((raw_user_row[0] & WDT_FUSES_ENABLE_Msk) >> WDT_FUSES_ENABLE_Pos);

	fusebits->wdt_always_on = (bool)
			((raw_user_row[0] & WDT_FUSES_ALWAYSON_Msk) >> WDT_FUSES_ALWAYSON_Pos);
    f24e:	687b      	ldr	r3, [r7, #4]
    f250:	681a      	ldr	r2, [r3, #0]
#endif

	fusebits->wdt_enable = (bool)
			((raw_user_row[0] & WDT_FUSES_ENABLE_Msk) >> WDT_FUSES_ENABLE_Pos);

	fusebits->wdt_always_on = (bool)
    f252:	2380      	movs	r3, #128	; 0x80
    f254:	04db      	lsls	r3, r3, #19
    f256:	4013      	ands	r3, r2
    f258:	1e5a      	subs	r2, r3, #1
    f25a:	4193      	sbcs	r3, r2
    f25c:	b2da      	uxtb	r2, r3
    f25e:	683b      	ldr	r3, [r7, #0]
    f260:	71da      	strb	r2, [r3, #7]
			((raw_user_row[0] & WDT_FUSES_ALWAYSON_Msk) >> WDT_FUSES_ALWAYSON_Pos);

	fusebits->wdt_timeout_period = (uint8_t)
			((raw_user_row[0] & WDT_FUSES_PER_Msk) >> WDT_FUSES_PER_Pos);
    f262:	687b      	ldr	r3, [r7, #4]
    f264:	681b      	ldr	r3, [r3, #0]
    f266:	0edb      	lsrs	r3, r3, #27
			((raw_user_row[0] & WDT_FUSES_ENABLE_Msk) >> WDT_FUSES_ENABLE_Pos);

	fusebits->wdt_always_on = (bool)
			((raw_user_row[0] & WDT_FUSES_ALWAYSON_Msk) >> WDT_FUSES_ALWAYSON_Pos);

	fusebits->wdt_timeout_period = (uint8_t)
    f268:	b2db      	uxtb	r3, r3
    f26a:	220f      	movs	r2, #15
    f26c:	4013      	ands	r3, r2
    f26e:	b2da      	uxtb	r2, r3
    f270:	683b      	ldr	r3, [r7, #0]
    f272:	721a      	strb	r2, [r3, #8]
			((raw_user_row[1] & WDT_FUSES_WINDOW_Msk) >> WDT_FUSES_WINDOW_Pos);
#else
	/* WDT Windows timout lay between two 32-bit words in the user row. Because only one bit lays in word[0],
	   bits in word[1] must be left sifted by one to make the correct number */
	fusebits->wdt_window_timeout = (enum nvm_wdt_window_timeout)
			(((raw_user_row[0] & WDT_FUSES_WINDOW_0_Msk) >> WDT_FUSES_WINDOW_0_Pos) |
    f274:	687b      	ldr	r3, [r7, #4]
    f276:	681b      	ldr	r3, [r3, #0]
    f278:	0fdb      	lsrs	r3, r3, #31
	fusebits->wdt_window_timeout = (enum nvm_wdt_window_timeout)
			((raw_user_row[1] & WDT_FUSES_WINDOW_Msk) >> WDT_FUSES_WINDOW_Pos);
#else
	/* WDT Windows timout lay between two 32-bit words in the user row. Because only one bit lays in word[0],
	   bits in word[1] must be left sifted by one to make the correct number */
	fusebits->wdt_window_timeout = (enum nvm_wdt_window_timeout)
    f27a:	b2da      	uxtb	r2, r3
			(((raw_user_row[0] & WDT_FUSES_WINDOW_0_Msk) >> WDT_FUSES_WINDOW_0_Pos) |
			((raw_user_row[1] & WDT_FUSES_WINDOW_1_Msk) << 1));
    f27c:	687b      	ldr	r3, [r7, #4]
    f27e:	3304      	adds	r3, #4
    f280:	681b      	ldr	r3, [r3, #0]
	fusebits->wdt_window_timeout = (enum nvm_wdt_window_timeout)
			((raw_user_row[1] & WDT_FUSES_WINDOW_Msk) >> WDT_FUSES_WINDOW_Pos);
#else
	/* WDT Windows timout lay between two 32-bit words in the user row. Because only one bit lays in word[0],
	   bits in word[1] must be left sifted by one to make the correct number */
	fusebits->wdt_window_timeout = (enum nvm_wdt_window_timeout)
    f282:	b2db      	uxtb	r3, r3
    f284:	18db      	adds	r3, r3, r3
    f286:	b2db      	uxtb	r3, r3
    f288:	210e      	movs	r1, #14
    f28a:	400b      	ands	r3, r1
    f28c:	b2db      	uxtb	r3, r3
    f28e:	4313      	orrs	r3, r2
    f290:	b2da      	uxtb	r2, r3
    f292:	683b      	ldr	r3, [r7, #0]
    f294:	725a      	strb	r2, [r3, #9]
			(((raw_user_row[0] & WDT_FUSES_WINDOW_0_Msk) >> WDT_FUSES_WINDOW_0_Pos) |
			((raw_user_row[1] & WDT_FUSES_WINDOW_1_Msk) << 1));
#endif
	fusebits->wdt_early_warning_offset = (enum nvm_wdt_early_warning_offset)
			((raw_user_row[1] & WDT_FUSES_EWOFFSET_Msk) >> WDT_FUSES_EWOFFSET_Pos);
    f296:	687b      	ldr	r3, [r7, #4]
    f298:	3304      	adds	r3, #4
    f29a:	681b      	ldr	r3, [r3, #0]
    f29c:	08db      	lsrs	r3, r3, #3
    f29e:	220f      	movs	r2, #15
    f2a0:	4013      	ands	r3, r2
	   bits in word[1] must be left sifted by one to make the correct number */
	fusebits->wdt_window_timeout = (enum nvm_wdt_window_timeout)
			(((raw_user_row[0] & WDT_FUSES_WINDOW_0_Msk) >> WDT_FUSES_WINDOW_0_Pos) |
			((raw_user_row[1] & WDT_FUSES_WINDOW_1_Msk) << 1));
#endif
	fusebits->wdt_early_warning_offset = (enum nvm_wdt_early_warning_offset)
    f2a2:	b2da      	uxtb	r2, r3
    f2a4:	683b      	ldr	r3, [r7, #0]
    f2a6:	729a      	strb	r2, [r3, #10]
			((raw_user_row[1] & WDT_FUSES_EWOFFSET_Msk) >> WDT_FUSES_EWOFFSET_Pos);

	fusebits->wdt_window_mode_enable_at_poweron = (bool)
			((raw_user_row[1] & WDT_FUSES_WEN_Msk) >> WDT_FUSES_WEN_Pos);
    f2a8:	687b      	ldr	r3, [r7, #4]
    f2aa:	3304      	adds	r3, #4
    f2ac:	681b      	ldr	r3, [r3, #0]
			((raw_user_row[1] & WDT_FUSES_WINDOW_1_Msk) << 1));
#endif
	fusebits->wdt_early_warning_offset = (enum nvm_wdt_early_warning_offset)
			((raw_user_row[1] & WDT_FUSES_EWOFFSET_Msk) >> WDT_FUSES_EWOFFSET_Pos);

	fusebits->wdt_window_mode_enable_at_poweron = (bool)
    f2ae:	2280      	movs	r2, #128	; 0x80
    f2b0:	4013      	ands	r3, r2
    f2b2:	1e5a      	subs	r2, r3, #1
    f2b4:	4193      	sbcs	r3, r2
    f2b6:	b2da      	uxtb	r2, r3
    f2b8:	683b      	ldr	r3, [r7, #0]
    f2ba:	72da      	strb	r2, [r3, #11]
			((raw_user_row[1] & WDT_FUSES_WEN_Msk) >> WDT_FUSES_WEN_Pos);

	fusebits->lockbits = (uint16_t)
			((raw_user_row[1] & NVMCTRL_FUSES_REGION_LOCKS_Msk)
    f2bc:	687b      	ldr	r3, [r7, #4]
    f2be:	3304      	adds	r3, #4
    f2c0:	681b      	ldr	r3, [r3, #0]
			>> NVMCTRL_FUSES_REGION_LOCKS_Pos);
    f2c2:	0c1b      	lsrs	r3, r3, #16
			((raw_user_row[1] & WDT_FUSES_EWOFFSET_Msk) >> WDT_FUSES_EWOFFSET_Pos);

	fusebits->wdt_window_mode_enable_at_poweron = (bool)
			((raw_user_row[1] & WDT_FUSES_WEN_Msk) >> WDT_FUSES_WEN_Pos);

	fusebits->lockbits = (uint16_t)
    f2c4:	b29a      	uxth	r2, r3
    f2c6:	683b      	ldr	r3, [r7, #0]
    f2c8:	819a      	strh	r2, [r3, #12]
			((raw_user_row[1] & NVMCTRL_FUSES_REGION_LOCKS_Msk)
			>> NVMCTRL_FUSES_REGION_LOCKS_Pos);

}
    f2ca:	46c0      	nop			; (mov r8, r8)
    f2cc:	46bd      	mov	sp, r7
    f2ce:	b002      	add	sp, #8
    f2d0:	bd80      	pop	{r7, pc}
    f2d2:	46c0      	nop			; (mov r8, r8)

0000f2d4 <nvm_get_fuses>:
 *
 * \retval STATUS_OK   This function will always return STATUS_OK
 */
enum status_code nvm_get_fuses (
		struct nvm_fusebits *fusebits)
{
    f2d4:	b580      	push	{r7, lr}
    f2d6:	b086      	sub	sp, #24
    f2d8:	af00      	add	r7, sp, #0
    f2da:	6078      	str	r0, [r7, #4]
	enum status_code error_code = STATUS_OK;
    f2dc:	2317      	movs	r3, #23
    f2de:	18fb      	adds	r3, r7, r3
    f2e0:	2200      	movs	r2, #0
    f2e2:	701a      	strb	r2, [r3, #0]
	uint32_t raw_fusebits[2];

	/* Make sure the module is ready */
	while (!nvm_is_ready()) {
    f2e4:	46c0      	nop			; (mov r8, r8)
    f2e6:	4b19      	ldr	r3, [pc, #100]	; (f34c <nvm_get_fuses+0x78>)
    f2e8:	4798      	blx	r3
    f2ea:	0003      	movs	r3, r0
    f2ec:	001a      	movs	r2, r3
    f2ee:	2301      	movs	r3, #1
    f2f0:	4053      	eors	r3, r2
    f2f2:	b2db      	uxtb	r3, r3
    f2f4:	2b00      	cmp	r3, #0
    f2f6:	d1f6      	bne.n	f2e6 <nvm_get_fuses+0x12>
	}

	/* Read the fuse settings in the user row, 64 bit */
	((uint16_t*)&raw_fusebits)[0] = (uint16_t)NVM_MEMORY[NVMCTRL_USER / 2];
    f2f8:	230c      	movs	r3, #12
    f2fa:	18fb      	adds	r3, r7, r3
    f2fc:	4a14      	ldr	r2, [pc, #80]	; (f350 <nvm_get_fuses+0x7c>)
    f2fe:	8812      	ldrh	r2, [r2, #0]
    f300:	b292      	uxth	r2, r2
    f302:	801a      	strh	r2, [r3, #0]
	((uint16_t*)&raw_fusebits)[1] = (uint16_t)NVM_MEMORY[(NVMCTRL_USER / 2) + 1];
    f304:	230c      	movs	r3, #12
    f306:	18fb      	adds	r3, r7, r3
    f308:	3302      	adds	r3, #2
    f30a:	4a12      	ldr	r2, [pc, #72]	; (f354 <nvm_get_fuses+0x80>)
    f30c:	8812      	ldrh	r2, [r2, #0]
    f30e:	b292      	uxth	r2, r2
    f310:	801a      	strh	r2, [r3, #0]
	((uint16_t*)&raw_fusebits)[2] = (uint16_t)NVM_MEMORY[(NVMCTRL_USER / 2) + 2];
    f312:	230c      	movs	r3, #12
    f314:	18fb      	adds	r3, r7, r3
    f316:	3304      	adds	r3, #4
    f318:	4a0f      	ldr	r2, [pc, #60]	; (f358 <nvm_get_fuses+0x84>)
    f31a:	8812      	ldrh	r2, [r2, #0]
    f31c:	b292      	uxth	r2, r2
    f31e:	801a      	strh	r2, [r3, #0]
	((uint16_t*)&raw_fusebits)[3] = (uint16_t)NVM_MEMORY[(NVMCTRL_USER / 2) + 3];
    f320:	230c      	movs	r3, #12
    f322:	18fb      	adds	r3, r7, r3
    f324:	3306      	adds	r3, #6
    f326:	4a0d      	ldr	r2, [pc, #52]	; (f35c <nvm_get_fuses+0x88>)
    f328:	8812      	ldrh	r2, [r2, #0]
    f32a:	b292      	uxth	r2, r2
    f32c:	801a      	strh	r2, [r3, #0]

	_nvm_translate_raw_fusebits_to_struct(raw_fusebits, fusebits);
    f32e:	687a      	ldr	r2, [r7, #4]
    f330:	230c      	movs	r3, #12
    f332:	18fb      	adds	r3, r7, r3
    f334:	0011      	movs	r1, r2
    f336:	0018      	movs	r0, r3
    f338:	4b09      	ldr	r3, [pc, #36]	; (f360 <nvm_get_fuses+0x8c>)
    f33a:	4798      	blx	r3

	return error_code;
    f33c:	2317      	movs	r3, #23
    f33e:	18fb      	adds	r3, r7, r3
    f340:	781b      	ldrb	r3, [r3, #0]
}
    f342:	0018      	movs	r0, r3
    f344:	46bd      	mov	sp, r7
    f346:	b006      	add	sp, #24
    f348:	bd80      	pop	{r7, pc}
    f34a:	46c0      	nop			; (mov r8, r8)
    f34c:	0000ec4d 	.word	0x0000ec4d
    f350:	00804000 	.word	0x00804000
    f354:	00804002 	.word	0x00804002
    f358:	00804004 	.word	0x00804004
    f35c:	00804006 	.word	0x00804006
    f360:	0000f1c5 	.word	0x0000f1c5

0000f364 <nvm_set_fuses>:
 *                                 unsupported
 * \retval STATUS_ERR_BAD_ADDRESS  If the given address was invalid
 */

enum status_code nvm_set_fuses(struct nvm_fusebits *fb)
{
    f364:	b590      	push	{r4, r7, lr}
    f366:	b087      	sub	sp, #28
    f368:	af00      	add	r7, sp, #0
    f36a:	6078      	str	r0, [r7, #4]
    uint32_t fusebits[2];
	enum status_code error_code = STATUS_OK;
    f36c:	2317      	movs	r3, #23
    f36e:	18fb      	adds	r3, r7, r3
    f370:	2200      	movs	r2, #0
    f372:	701a      	strb	r2, [r3, #0]

	if (fb == NULL) {
    f374:	687b      	ldr	r3, [r7, #4]
    f376:	2b00      	cmp	r3, #0
    f378:	d101      	bne.n	f37e <nvm_set_fuses+0x1a>
		return STATUS_ERR_INVALID_ARG;
    f37a:	2317      	movs	r3, #23
    f37c:	e15a      	b.n	f634 <nvm_set_fuses+0x2d0>
	}
    /* Read the fuse settings in the user row, 64 bit */
    fusebits[0] = *((uint32_t *)NVMCTRL_AUX0_ADDRESS);
    f37e:	4baf      	ldr	r3, [pc, #700]	; (f63c <nvm_set_fuses+0x2d8>)
    f380:	681a      	ldr	r2, [r3, #0]
    f382:	230c      	movs	r3, #12
    f384:	18fb      	adds	r3, r7, r3
    f386:	601a      	str	r2, [r3, #0]
    fusebits[1] = *(((uint32_t *)NVMCTRL_AUX0_ADDRESS) + 1);
    f388:	4bad      	ldr	r3, [pc, #692]	; (f640 <nvm_set_fuses+0x2dc>)
    f38a:	681a      	ldr	r2, [r3, #0]
    f38c:	230c      	movs	r3, #12
    f38e:	18fb      	adds	r3, r7, r3
    f390:	605a      	str	r2, [r3, #4]

	/* Set user fuses bit */
	fusebits[0] &= (~NVMCTRL_FUSES_BOOTPROT_Msk);
    f392:	230c      	movs	r3, #12
    f394:	18fb      	adds	r3, r7, r3
    f396:	681b      	ldr	r3, [r3, #0]
    f398:	2207      	movs	r2, #7
    f39a:	4393      	bics	r3, r2
    f39c:	001a      	movs	r2, r3
    f39e:	230c      	movs	r3, #12
    f3a0:	18fb      	adds	r3, r7, r3
    f3a2:	601a      	str	r2, [r3, #0]
	fusebits[0] |= NVMCTRL_FUSES_BOOTPROT(fb->bootloader_size);
    f3a4:	230c      	movs	r3, #12
    f3a6:	18fb      	adds	r3, r7, r3
    f3a8:	681a      	ldr	r2, [r3, #0]
    f3aa:	687b      	ldr	r3, [r7, #4]
    f3ac:	781b      	ldrb	r3, [r3, #0]
    f3ae:	0019      	movs	r1, r3
    f3b0:	2307      	movs	r3, #7
    f3b2:	400b      	ands	r3, r1
    f3b4:	431a      	orrs	r2, r3
    f3b6:	230c      	movs	r3, #12
    f3b8:	18fb      	adds	r3, r7, r3
    f3ba:	601a      	str	r2, [r3, #0]

	fusebits[0] &= (~NVMCTRL_FUSES_EEPROM_SIZE_Msk);
    f3bc:	230c      	movs	r3, #12
    f3be:	18fb      	adds	r3, r7, r3
    f3c0:	681b      	ldr	r3, [r3, #0]
    f3c2:	2270      	movs	r2, #112	; 0x70
    f3c4:	4393      	bics	r3, r2
    f3c6:	001a      	movs	r2, r3
    f3c8:	230c      	movs	r3, #12
    f3ca:	18fb      	adds	r3, r7, r3
    f3cc:	601a      	str	r2, [r3, #0]
	fusebits[0] |= NVMCTRL_FUSES_EEPROM_SIZE(fb->eeprom_size);
    f3ce:	230c      	movs	r3, #12
    f3d0:	18fb      	adds	r3, r7, r3
    f3d2:	681a      	ldr	r2, [r3, #0]
    f3d4:	687b      	ldr	r3, [r7, #4]
    f3d6:	785b      	ldrb	r3, [r3, #1]
    f3d8:	011b      	lsls	r3, r3, #4
    f3da:	0019      	movs	r1, r3
    f3dc:	2370      	movs	r3, #112	; 0x70
    f3de:	400b      	ands	r3, r1
    f3e0:	431a      	orrs	r2, r3
    f3e2:	230c      	movs	r3, #12
    f3e4:	18fb      	adds	r3, r7, r3
    f3e6:	601a      	str	r2, [r3, #0]

	fusebits[1] &= (~FUSES_BOD33_HYST_Msk);
	fusebits[1] |= fb->bod33_hysteresis << FUSES_BOD33_HYST_Pos;

#elif (SAMD20) || (SAMD21) || (SAMR21) || (SAMDA1) || (SAMD09) || (SAMD10)
	fusebits[0] &= (~FUSES_BOD33USERLEVEL_Msk);
    f3e8:	230c      	movs	r3, #12
    f3ea:	18fb      	adds	r3, r7, r3
    f3ec:	681b      	ldr	r3, [r3, #0]
    f3ee:	4a95      	ldr	r2, [pc, #596]	; (f644 <nvm_set_fuses+0x2e0>)
    f3f0:	401a      	ands	r2, r3
    f3f2:	230c      	movs	r3, #12
    f3f4:	18fb      	adds	r3, r7, r3
    f3f6:	601a      	str	r2, [r3, #0]
	fusebits[0] |= FUSES_BOD33USERLEVEL(fb->bod33_level);
    f3f8:	230c      	movs	r3, #12
    f3fa:	18fb      	adds	r3, r7, r3
    f3fc:	681a      	ldr	r2, [r3, #0]
    f3fe:	687b      	ldr	r3, [r7, #4]
    f400:	789b      	ldrb	r3, [r3, #2]
    f402:	021b      	lsls	r3, r3, #8
    f404:	0019      	movs	r1, r3
    f406:	23fc      	movs	r3, #252	; 0xfc
    f408:	019b      	lsls	r3, r3, #6
    f40a:	400b      	ands	r3, r1
    f40c:	431a      	orrs	r2, r3
    f40e:	230c      	movs	r3, #12
    f410:	18fb      	adds	r3, r7, r3
    f412:	601a      	str	r2, [r3, #0]

	fusebits[0] &= (~FUSES_BOD33_EN_Msk);
    f414:	230c      	movs	r3, #12
    f416:	18fb      	adds	r3, r7, r3
    f418:	681b      	ldr	r3, [r3, #0]
    f41a:	4a8b      	ldr	r2, [pc, #556]	; (f648 <nvm_set_fuses+0x2e4>)
    f41c:	401a      	ands	r2, r3
    f41e:	230c      	movs	r3, #12
    f420:	18fb      	adds	r3, r7, r3
    f422:	601a      	str	r2, [r3, #0]
	fusebits[0] |= (fb->bod33_enable) << FUSES_BOD33_EN_Pos;
    f424:	230c      	movs	r3, #12
    f426:	18fb      	adds	r3, r7, r3
    f428:	681b      	ldr	r3, [r3, #0]
    f42a:	687a      	ldr	r2, [r7, #4]
    f42c:	78d2      	ldrb	r2, [r2, #3]
    f42e:	0392      	lsls	r2, r2, #14
    f430:	431a      	orrs	r2, r3
    f432:	230c      	movs	r3, #12
    f434:	18fb      	adds	r3, r7, r3
    f436:	601a      	str	r2, [r3, #0]

	fusebits[0] &= (~FUSES_BOD33_ACTION_Msk);
    f438:	230c      	movs	r3, #12
    f43a:	18fb      	adds	r3, r7, r3
    f43c:	681b      	ldr	r3, [r3, #0]
    f43e:	4a83      	ldr	r2, [pc, #524]	; (f64c <nvm_set_fuses+0x2e8>)
    f440:	401a      	ands	r2, r3
    f442:	230c      	movs	r3, #12
    f444:	18fb      	adds	r3, r7, r3
    f446:	601a      	str	r2, [r3, #0]
	fusebits[0] |= fb->bod33_action << FUSES_BOD33_ACTION_Pos;
    f448:	230c      	movs	r3, #12
    f44a:	18fb      	adds	r3, r7, r3
    f44c:	681b      	ldr	r3, [r3, #0]
    f44e:	687a      	ldr	r2, [r7, #4]
    f450:	7912      	ldrb	r2, [r2, #4]
    f452:	03d2      	lsls	r2, r2, #15
    f454:	431a      	orrs	r2, r3
    f456:	230c      	movs	r3, #12
    f458:	18fb      	adds	r3, r7, r3
    f45a:	601a      	str	r2, [r3, #0]

	fusebits[1] &= (~FUSES_BOD33_HYST_Msk);
    f45c:	230c      	movs	r3, #12
    f45e:	18fb      	adds	r3, r7, r3
    f460:	685b      	ldr	r3, [r3, #4]
    f462:	4a7b      	ldr	r2, [pc, #492]	; (f650 <nvm_set_fuses+0x2ec>)
    f464:	401a      	ands	r2, r3
    f466:	230c      	movs	r3, #12
    f468:	18fb      	adds	r3, r7, r3
    f46a:	605a      	str	r2, [r3, #4]
	fusebits[1] |= fb->bod33_hysteresis << FUSES_BOD33_HYST_Pos;
    f46c:	230c      	movs	r3, #12
    f46e:	18fb      	adds	r3, r7, r3
    f470:	685b      	ldr	r3, [r3, #4]
    f472:	687a      	ldr	r2, [r7, #4]
    f474:	7952      	ldrb	r2, [r2, #5]
    f476:	0212      	lsls	r2, r2, #8
    f478:	431a      	orrs	r2, r3
    f47a:	230c      	movs	r3, #12
    f47c:	18fb      	adds	r3, r7, r3
    f47e:	605a      	str	r2, [r3, #4]
	fusebits[1] &= (~SYSCTRL_FUSES_BOD33_HYST_Msk);
	fusebits[1] |= fb->bod33_hysteresis << SYSCTRL_FUSES_BOD33_HYST_Pos;

#endif

	fusebits[0] &= (~WDT_FUSES_ENABLE_Msk);
    f480:	230c      	movs	r3, #12
    f482:	18fb      	adds	r3, r7, r3
    f484:	681b      	ldr	r3, [r3, #0]
    f486:	4a73      	ldr	r2, [pc, #460]	; (f654 <nvm_set_fuses+0x2f0>)
    f488:	401a      	ands	r2, r3
    f48a:	230c      	movs	r3, #12
    f48c:	18fb      	adds	r3, r7, r3
    f48e:	601a      	str	r2, [r3, #0]
	fusebits[0] |= fb->wdt_enable << WDT_FUSES_ENABLE_Pos;
    f490:	230c      	movs	r3, #12
    f492:	18fb      	adds	r3, r7, r3
    f494:	681b      	ldr	r3, [r3, #0]
    f496:	687a      	ldr	r2, [r7, #4]
    f498:	7992      	ldrb	r2, [r2, #6]
    f49a:	0652      	lsls	r2, r2, #25
    f49c:	431a      	orrs	r2, r3
    f49e:	230c      	movs	r3, #12
    f4a0:	18fb      	adds	r3, r7, r3
    f4a2:	601a      	str	r2, [r3, #0]

	fusebits[0] &= (~WDT_FUSES_ALWAYSON_Msk);
    f4a4:	230c      	movs	r3, #12
    f4a6:	18fb      	adds	r3, r7, r3
    f4a8:	681b      	ldr	r3, [r3, #0]
    f4aa:	4a6b      	ldr	r2, [pc, #428]	; (f658 <nvm_set_fuses+0x2f4>)
    f4ac:	401a      	ands	r2, r3
    f4ae:	230c      	movs	r3, #12
    f4b0:	18fb      	adds	r3, r7, r3
    f4b2:	601a      	str	r2, [r3, #0]
	fusebits[0] |= (fb->wdt_always_on) << WDT_FUSES_ALWAYSON_Pos;
    f4b4:	230c      	movs	r3, #12
    f4b6:	18fb      	adds	r3, r7, r3
    f4b8:	681b      	ldr	r3, [r3, #0]
    f4ba:	687a      	ldr	r2, [r7, #4]
    f4bc:	79d2      	ldrb	r2, [r2, #7]
    f4be:	0692      	lsls	r2, r2, #26
    f4c0:	431a      	orrs	r2, r3
    f4c2:	230c      	movs	r3, #12
    f4c4:	18fb      	adds	r3, r7, r3
    f4c6:	601a      	str	r2, [r3, #0]

	fusebits[0] &= (~WDT_FUSES_PER_Msk);
    f4c8:	230c      	movs	r3, #12
    f4ca:	18fb      	adds	r3, r7, r3
    f4cc:	681b      	ldr	r3, [r3, #0]
    f4ce:	4a63      	ldr	r2, [pc, #396]	; (f65c <nvm_set_fuses+0x2f8>)
    f4d0:	401a      	ands	r2, r3
    f4d2:	230c      	movs	r3, #12
    f4d4:	18fb      	adds	r3, r7, r3
    f4d6:	601a      	str	r2, [r3, #0]
	fusebits[0] |= fb->wdt_timeout_period << WDT_FUSES_PER_Pos;
    f4d8:	230c      	movs	r3, #12
    f4da:	18fb      	adds	r3, r7, r3
    f4dc:	681b      	ldr	r3, [r3, #0]
    f4de:	687a      	ldr	r2, [r7, #4]
    f4e0:	7a12      	ldrb	r2, [r2, #8]
    f4e2:	06d2      	lsls	r2, r2, #27
    f4e4:	431a      	orrs	r2, r3
    f4e6:	230c      	movs	r3, #12
    f4e8:	18fb      	adds	r3, r7, r3
    f4ea:	601a      	str	r2, [r3, #0]
	fusebits[1] &= (~WDT_FUSES_WINDOW_Msk);
	fusebits[1] |= fb->wdt_window_timeout << WDT_FUSES_WINDOW_Pos;
#else
   /* WDT Windows timout lay between two 32-bit words in the user row. the last one bit lays in word[0],
	   and the other bits in word[1] */
	fusebits[0] &= (~WDT_FUSES_WINDOW_0_Msk);
    f4ec:	230c      	movs	r3, #12
    f4ee:	18fb      	adds	r3, r7, r3
    f4f0:	681b      	ldr	r3, [r3, #0]
    f4f2:	005b      	lsls	r3, r3, #1
    f4f4:	085a      	lsrs	r2, r3, #1
    f4f6:	230c      	movs	r3, #12
    f4f8:	18fb      	adds	r3, r7, r3
    f4fa:	601a      	str	r2, [r3, #0]
	fusebits[0] |= (fb->wdt_window_timeout & 0x1) << WDT_FUSES_WINDOW_0_Pos;
    f4fc:	230c      	movs	r3, #12
    f4fe:	18fb      	adds	r3, r7, r3
    f500:	681b      	ldr	r3, [r3, #0]
    f502:	687a      	ldr	r2, [r7, #4]
    f504:	7a52      	ldrb	r2, [r2, #9]
    f506:	07d2      	lsls	r2, r2, #31
    f508:	431a      	orrs	r2, r3
    f50a:	230c      	movs	r3, #12
    f50c:	18fb      	adds	r3, r7, r3
    f50e:	601a      	str	r2, [r3, #0]

	fusebits[1] &= (~WDT_FUSES_WINDOW_1_Msk);
    f510:	230c      	movs	r3, #12
    f512:	18fb      	adds	r3, r7, r3
    f514:	685b      	ldr	r3, [r3, #4]
    f516:	2207      	movs	r2, #7
    f518:	4393      	bics	r3, r2
    f51a:	001a      	movs	r2, r3
    f51c:	230c      	movs	r3, #12
    f51e:	18fb      	adds	r3, r7, r3
    f520:	605a      	str	r2, [r3, #4]
	fusebits[1] |= (fb->wdt_window_timeout >> 1) << WDT_FUSES_WINDOW_1_Pos;
    f522:	230c      	movs	r3, #12
    f524:	18fb      	adds	r3, r7, r3
    f526:	685b      	ldr	r3, [r3, #4]
    f528:	687a      	ldr	r2, [r7, #4]
    f52a:	7a52      	ldrb	r2, [r2, #9]
    f52c:	0852      	lsrs	r2, r2, #1
    f52e:	b2d2      	uxtb	r2, r2
    f530:	431a      	orrs	r2, r3
    f532:	230c      	movs	r3, #12
    f534:	18fb      	adds	r3, r7, r3
    f536:	605a      	str	r2, [r3, #4]

#endif
	fusebits[1] &= (~WDT_FUSES_EWOFFSET_Msk);
    f538:	230c      	movs	r3, #12
    f53a:	18fb      	adds	r3, r7, r3
    f53c:	685b      	ldr	r3, [r3, #4]
    f53e:	2278      	movs	r2, #120	; 0x78
    f540:	4393      	bics	r3, r2
    f542:	001a      	movs	r2, r3
    f544:	230c      	movs	r3, #12
    f546:	18fb      	adds	r3, r7, r3
    f548:	605a      	str	r2, [r3, #4]
	fusebits[1] |= fb->wdt_early_warning_offset << WDT_FUSES_EWOFFSET_Pos;
    f54a:	230c      	movs	r3, #12
    f54c:	18fb      	adds	r3, r7, r3
    f54e:	685b      	ldr	r3, [r3, #4]
    f550:	687a      	ldr	r2, [r7, #4]
    f552:	7a92      	ldrb	r2, [r2, #10]
    f554:	00d2      	lsls	r2, r2, #3
    f556:	431a      	orrs	r2, r3
    f558:	230c      	movs	r3, #12
    f55a:	18fb      	adds	r3, r7, r3
    f55c:	605a      	str	r2, [r3, #4]

	fusebits[1] &= (~WDT_FUSES_WEN_Msk);
    f55e:	230c      	movs	r3, #12
    f560:	18fb      	adds	r3, r7, r3
    f562:	685b      	ldr	r3, [r3, #4]
    f564:	2280      	movs	r2, #128	; 0x80
    f566:	4393      	bics	r3, r2
    f568:	001a      	movs	r2, r3
    f56a:	230c      	movs	r3, #12
    f56c:	18fb      	adds	r3, r7, r3
    f56e:	605a      	str	r2, [r3, #4]
	fusebits[1] |= fb->wdt_window_mode_enable_at_poweron << WDT_FUSES_WEN_Pos;
    f570:	230c      	movs	r3, #12
    f572:	18fb      	adds	r3, r7, r3
    f574:	685b      	ldr	r3, [r3, #4]
    f576:	687a      	ldr	r2, [r7, #4]
    f578:	7ad2      	ldrb	r2, [r2, #11]
    f57a:	01d2      	lsls	r2, r2, #7
    f57c:	431a      	orrs	r2, r3
    f57e:	230c      	movs	r3, #12
    f580:	18fb      	adds	r3, r7, r3
    f582:	605a      	str	r2, [r3, #4]

	fusebits[1] &= (~NVMCTRL_FUSES_REGION_LOCKS_Msk);
    f584:	230c      	movs	r3, #12
    f586:	18fb      	adds	r3, r7, r3
    f588:	685b      	ldr	r3, [r3, #4]
    f58a:	041b      	lsls	r3, r3, #16
    f58c:	0c1a      	lsrs	r2, r3, #16
    f58e:	230c      	movs	r3, #12
    f590:	18fb      	adds	r3, r7, r3
    f592:	605a      	str	r2, [r3, #4]
	fusebits[1] |= fb->lockbits << NVMCTRL_FUSES_REGION_LOCKS_Pos;
    f594:	230c      	movs	r3, #12
    f596:	18fb      	adds	r3, r7, r3
    f598:	685b      	ldr	r3, [r3, #4]
    f59a:	687a      	ldr	r2, [r7, #4]
    f59c:	8992      	ldrh	r2, [r2, #12]
    f59e:	0412      	lsls	r2, r2, #16
    f5a0:	431a      	orrs	r2, r3
    f5a2:	230c      	movs	r3, #12
    f5a4:	18fb      	adds	r3, r7, r3
    f5a6:	605a      	str	r2, [r3, #4]

	fusebits[1] &= (~FUSES_BOD12_HYST_Msk);
	fusebits[1] |= fb->bod12_hysteresis << FUSES_BOD12_HYST_Pos;
#endif

	error_code = nvm_execute_command(NVM_COMMAND_ERASE_AUX_ROW,NVMCTRL_AUX0_ADDRESS,0);
    f5a8:	2317      	movs	r3, #23
    f5aa:	18fc      	adds	r4, r7, r3
    f5ac:	4b23      	ldr	r3, [pc, #140]	; (f63c <nvm_set_fuses+0x2d8>)
    f5ae:	2200      	movs	r2, #0
    f5b0:	0019      	movs	r1, r3
    f5b2:	2005      	movs	r0, #5
    f5b4:	4b2a      	ldr	r3, [pc, #168]	; (f660 <nvm_set_fuses+0x2fc>)
    f5b6:	4798      	blx	r3
    f5b8:	0003      	movs	r3, r0
    f5ba:	7023      	strb	r3, [r4, #0]
	if (error_code != STATUS_OK) {
    f5bc:	2317      	movs	r3, #23
    f5be:	18fb      	adds	r3, r7, r3
    f5c0:	781b      	ldrb	r3, [r3, #0]
    f5c2:	2b00      	cmp	r3, #0
    f5c4:	d003      	beq.n	f5ce <nvm_set_fuses+0x26a>
		return error_code;
    f5c6:	2317      	movs	r3, #23
    f5c8:	18fb      	adds	r3, r7, r3
    f5ca:	781b      	ldrb	r3, [r3, #0]
    f5cc:	e032      	b.n	f634 <nvm_set_fuses+0x2d0>
	}

	error_code = nvm_execute_command(NVM_COMMAND_PAGE_BUFFER_CLEAR,NVMCTRL_AUX0_ADDRESS,0);
    f5ce:	2317      	movs	r3, #23
    f5d0:	18fc      	adds	r4, r7, r3
    f5d2:	4b1a      	ldr	r3, [pc, #104]	; (f63c <nvm_set_fuses+0x2d8>)
    f5d4:	2200      	movs	r2, #0
    f5d6:	0019      	movs	r1, r3
    f5d8:	2044      	movs	r0, #68	; 0x44
    f5da:	4b21      	ldr	r3, [pc, #132]	; (f660 <nvm_set_fuses+0x2fc>)
    f5dc:	4798      	blx	r3
    f5de:	0003      	movs	r3, r0
    f5e0:	7023      	strb	r3, [r4, #0]
	if (error_code != STATUS_OK) {
    f5e2:	2317      	movs	r3, #23
    f5e4:	18fb      	adds	r3, r7, r3
    f5e6:	781b      	ldrb	r3, [r3, #0]
    f5e8:	2b00      	cmp	r3, #0
    f5ea:	d003      	beq.n	f5f4 <nvm_set_fuses+0x290>
		return error_code;
    f5ec:	2317      	movs	r3, #23
    f5ee:	18fb      	adds	r3, r7, r3
    f5f0:	781b      	ldrb	r3, [r3, #0]
    f5f2:	e01f      	b.n	f634 <nvm_set_fuses+0x2d0>
	}

	*((uint32_t *)NVMCTRL_AUX0_ADDRESS) = fusebits[0];
    f5f4:	4a11      	ldr	r2, [pc, #68]	; (f63c <nvm_set_fuses+0x2d8>)
    f5f6:	230c      	movs	r3, #12
    f5f8:	18fb      	adds	r3, r7, r3
    f5fa:	681b      	ldr	r3, [r3, #0]
    f5fc:	6013      	str	r3, [r2, #0]
    *(((uint32_t *)NVMCTRL_AUX0_ADDRESS) + 1) = fusebits[1];
    f5fe:	4a10      	ldr	r2, [pc, #64]	; (f640 <nvm_set_fuses+0x2dc>)
    f600:	230c      	movs	r3, #12
    f602:	18fb      	adds	r3, r7, r3
    f604:	685b      	ldr	r3, [r3, #4]
    f606:	6013      	str	r3, [r2, #0]

	error_code = nvm_execute_command(NVM_COMMAND_WRITE_AUX_ROW,NVMCTRL_AUX0_ADDRESS,0);
    f608:	2317      	movs	r3, #23
    f60a:	18fc      	adds	r4, r7, r3
    f60c:	4b0b      	ldr	r3, [pc, #44]	; (f63c <nvm_set_fuses+0x2d8>)
    f60e:	2200      	movs	r2, #0
    f610:	0019      	movs	r1, r3
    f612:	2006      	movs	r0, #6
    f614:	4b12      	ldr	r3, [pc, #72]	; (f660 <nvm_set_fuses+0x2fc>)
    f616:	4798      	blx	r3
    f618:	0003      	movs	r3, r0
    f61a:	7023      	strb	r3, [r4, #0]
	if (error_code != STATUS_OK) {
    f61c:	2317      	movs	r3, #23
    f61e:	18fb      	adds	r3, r7, r3
    f620:	781b      	ldrb	r3, [r3, #0]
    f622:	2b00      	cmp	r3, #0
    f624:	d003      	beq.n	f62e <nvm_set_fuses+0x2ca>
		return error_code;
    f626:	2317      	movs	r3, #23
    f628:	18fb      	adds	r3, r7, r3
    f62a:	781b      	ldrb	r3, [r3, #0]
    f62c:	e002      	b.n	f634 <nvm_set_fuses+0x2d0>
	}

	return error_code;
    f62e:	2317      	movs	r3, #23
    f630:	18fb      	adds	r3, r7, r3
    f632:	781b      	ldrb	r3, [r3, #0]
}
    f634:	0018      	movs	r0, r3
    f636:	46bd      	mov	sp, r7
    f638:	b007      	add	sp, #28
    f63a:	bd90      	pop	{r4, r7, pc}
    f63c:	00804000 	.word	0x00804000
    f640:	00804004 	.word	0x00804004
    f644:	ffffc0ff 	.word	0xffffc0ff
    f648:	ffffbfff 	.word	0xffffbfff
    f64c:	fffe7fff 	.word	0xfffe7fff
    f650:	fffffeff 	.word	0xfffffeff
    f654:	fdffffff 	.word	0xfdffffff
    f658:	fbffffff 	.word	0xfbffffff
    f65c:	87ffffff 	.word	0x87ffffff
    f660:	0000edb1 	.word	0x0000edb1

0000f664 <TC3_Handler>:
#if (SAML21E) || (SAML21G)
	_TC_INTERRUPT_HANDLER(0,0)
	_TC_INTERRUPT_HANDLER(1,1)
	_TC_INTERRUPT_HANDLER(4,2)
#else
	MRECURSION(TC_INST_NUM, _TC_INTERRUPT_HANDLER, TC_INST_MAX_ID)
    f664:	b580      	push	{r7, lr}
    f666:	af00      	add	r7, sp, #0
    f668:	2000      	movs	r0, #0
    f66a:	4b02      	ldr	r3, [pc, #8]	; (f674 <TC3_Handler+0x10>)
    f66c:	4798      	blx	r3
    f66e:	46c0      	nop			; (mov r8, r8)
    f670:	46bd      	mov	sp, r7
    f672:	bd80      	pop	{r7, pc}
    f674:	0000f6c9 	.word	0x0000f6c9

0000f678 <TC4_Handler>:
    f678:	b580      	push	{r7, lr}
    f67a:	af00      	add	r7, sp, #0
    f67c:	2001      	movs	r0, #1
    f67e:	4b02      	ldr	r3, [pc, #8]	; (f688 <TC4_Handler+0x10>)
    f680:	4798      	blx	r3
    f682:	46c0      	nop			; (mov r8, r8)
    f684:	46bd      	mov	sp, r7
    f686:	bd80      	pop	{r7, pc}
    f688:	0000f6c9 	.word	0x0000f6c9

0000f68c <TC5_Handler>:
    f68c:	b580      	push	{r7, lr}
    f68e:	af00      	add	r7, sp, #0
    f690:	2002      	movs	r0, #2
    f692:	4b02      	ldr	r3, [pc, #8]	; (f69c <TC5_Handler+0x10>)
    f694:	4798      	blx	r3
    f696:	46c0      	nop			; (mov r8, r8)
    f698:	46bd      	mov	sp, r7
    f69a:	bd80      	pop	{r7, pc}
    f69c:	0000f6c9 	.word	0x0000f6c9

0000f6a0 <TC6_Handler>:
    f6a0:	b580      	push	{r7, lr}
    f6a2:	af00      	add	r7, sp, #0
    f6a4:	2003      	movs	r0, #3
    f6a6:	4b02      	ldr	r3, [pc, #8]	; (f6b0 <TC6_Handler+0x10>)
    f6a8:	4798      	blx	r3
    f6aa:	46c0      	nop			; (mov r8, r8)
    f6ac:	46bd      	mov	sp, r7
    f6ae:	bd80      	pop	{r7, pc}
    f6b0:	0000f6c9 	.word	0x0000f6c9

0000f6b4 <TC7_Handler>:
    f6b4:	b580      	push	{r7, lr}
    f6b6:	af00      	add	r7, sp, #0
    f6b8:	2004      	movs	r0, #4
    f6ba:	4b02      	ldr	r3, [pc, #8]	; (f6c4 <TC7_Handler+0x10>)
    f6bc:	4798      	blx	r3
    f6be:	46c0      	nop			; (mov r8, r8)
    f6c0:	46bd      	mov	sp, r7
    f6c2:	bd80      	pop	{r7, pc}
    f6c4:	0000f6c9 	.word	0x0000f6c9

0000f6c8 <_tc_interrupt_handler>:
 * \param[in]  instance  ID of the TC instance calling the interrupt
 *                       handler
 */
void _tc_interrupt_handler(
		uint8_t instance)
{
    f6c8:	b580      	push	{r7, lr}
    f6ca:	b084      	sub	sp, #16
    f6cc:	af00      	add	r7, sp, #0
    f6ce:	0002      	movs	r2, r0
    f6d0:	1dfb      	adds	r3, r7, #7
    f6d2:	701a      	strb	r2, [r3, #0]
	/* Temporary variable */
	uint8_t interrupt_and_callback_status_mask;

	/* Get device instance from the look-up table */
	struct tc_module *module
			= (struct tc_module *)_tc_instances[instance];
    f6d4:	1dfb      	adds	r3, r7, #7
    f6d6:	781a      	ldrb	r2, [r3, #0]
{
	/* Temporary variable */
	uint8_t interrupt_and_callback_status_mask;

	/* Get device instance from the look-up table */
	struct tc_module *module
    f6d8:	4b28      	ldr	r3, [pc, #160]	; (f77c <_tc_interrupt_handler+0xb4>)
    f6da:	0092      	lsls	r2, r2, #2
    f6dc:	58d3      	ldr	r3, [r2, r3]
    f6de:	60fb      	str	r3, [r7, #12]
			= (struct tc_module *)_tc_instances[instance];

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
    f6e0:	68fb      	ldr	r3, [r7, #12]
    f6e2:	681b      	ldr	r3, [r3, #0]
    f6e4:	7b9b      	ldrb	r3, [r3, #14]
    f6e6:	b2db      	uxtb	r3, r3
			module->register_callback_mask &
    f6e8:	68fa      	ldr	r2, [r7, #12]
    f6ea:	7e12      	ldrb	r2, [r2, #24]
	/* Get device instance from the look-up table */
	struct tc_module *module
			= (struct tc_module *)_tc_instances[instance];

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
    f6ec:	4013      	ands	r3, r2
    f6ee:	b2da      	uxtb	r2, r3
			module->register_callback_mask &
			module->enable_callback_mask;
    f6f0:	68fb      	ldr	r3, [r7, #12]
    f6f2:	7e59      	ldrb	r1, [r3, #25]
	/* Get device instance from the look-up table */
	struct tc_module *module
			= (struct tc_module *)_tc_instances[instance];

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
    f6f4:	230b      	movs	r3, #11
    f6f6:	18fb      	adds	r3, r7, r3
    f6f8:	400a      	ands	r2, r1
    f6fa:	701a      	strb	r2, [r3, #0]
			module->register_callback_mask &
			module->enable_callback_mask;

	/* Check if an Overflow interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_OVF) {
    f6fc:	230b      	movs	r3, #11
    f6fe:	18fb      	adds	r3, r7, r3
    f700:	781b      	ldrb	r3, [r3, #0]
    f702:	2201      	movs	r2, #1
    f704:	4013      	ands	r3, r2
    f706:	d008      	beq.n	f71a <_tc_interrupt_handler+0x52>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_OVERFLOW])(module);
    f708:	68fb      	ldr	r3, [r7, #12]
    f70a:	689b      	ldr	r3, [r3, #8]
    f70c:	68fa      	ldr	r2, [r7, #12]
    f70e:	0010      	movs	r0, r2
    f710:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_OVF;
    f712:	68fb      	ldr	r3, [r7, #12]
    f714:	681b      	ldr	r3, [r3, #0]
    f716:	2201      	movs	r2, #1
    f718:	739a      	strb	r2, [r3, #14]
	}

	/* Check if an Error interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_ERR) {
    f71a:	230b      	movs	r3, #11
    f71c:	18fb      	adds	r3, r7, r3
    f71e:	781b      	ldrb	r3, [r3, #0]
    f720:	2202      	movs	r2, #2
    f722:	4013      	ands	r3, r2
    f724:	d008      	beq.n	f738 <_tc_interrupt_handler+0x70>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_ERROR])(module);
    f726:	68fb      	ldr	r3, [r7, #12]
    f728:	68db      	ldr	r3, [r3, #12]
    f72a:	68fa      	ldr	r2, [r7, #12]
    f72c:	0010      	movs	r0, r2
    f72e:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_ERR;
    f730:	68fb      	ldr	r3, [r7, #12]
    f732:	681b      	ldr	r3, [r3, #0]
    f734:	2202      	movs	r2, #2
    f736:	739a      	strb	r2, [r3, #14]
	}

	/* Check if an Match/Capture Channel 0 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(1)) {
    f738:	230b      	movs	r3, #11
    f73a:	18fb      	adds	r3, r7, r3
    f73c:	781b      	ldrb	r3, [r3, #0]
    f73e:	2210      	movs	r2, #16
    f740:	4013      	ands	r3, r2
    f742:	d008      	beq.n	f756 <_tc_interrupt_handler+0x8e>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL0])(module);
    f744:	68fb      	ldr	r3, [r7, #12]
    f746:	691b      	ldr	r3, [r3, #16]
    f748:	68fa      	ldr	r2, [r7, #12]
    f74a:	0010      	movs	r0, r2
    f74c:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(1);
    f74e:	68fb      	ldr	r3, [r7, #12]
    f750:	681b      	ldr	r3, [r3, #0]
    f752:	2210      	movs	r2, #16
    f754:	739a      	strb	r2, [r3, #14]
	}

	/* Check if an Match/Capture Channel 1 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(2)) {
    f756:	230b      	movs	r3, #11
    f758:	18fb      	adds	r3, r7, r3
    f75a:	781b      	ldrb	r3, [r3, #0]
    f75c:	2220      	movs	r2, #32
    f75e:	4013      	ands	r3, r2
    f760:	d008      	beq.n	f774 <_tc_interrupt_handler+0xac>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL1])(module);
    f762:	68fb      	ldr	r3, [r7, #12]
    f764:	695b      	ldr	r3, [r3, #20]
    f766:	68fa      	ldr	r2, [r7, #12]
    f768:	0010      	movs	r0, r2
    f76a:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(2);
    f76c:	68fb      	ldr	r3, [r7, #12]
    f76e:	681b      	ldr	r3, [r3, #0]
    f770:	2220      	movs	r2, #32
    f772:	739a      	strb	r2, [r3, #14]
	}
}
    f774:	46c0      	nop			; (mov r8, r8)
    f776:	46bd      	mov	sp, r7
    f778:	b004      	add	sp, #16
    f77a:	bd80      	pop	{r7, pc}
    f77c:	20004b94 	.word	0x20004b94

0000f780 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    f780:	b580      	push	{r7, lr}
    f782:	b082      	sub	sp, #8
    f784:	af00      	add	r7, sp, #0
    f786:	0002      	movs	r2, r0
    f788:	6039      	str	r1, [r7, #0]
    f78a:	1dfb      	adds	r3, r7, #7
    f78c:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    f78e:	1dfb      	adds	r3, r7, #7
    f790:	781b      	ldrb	r3, [r3, #0]
    f792:	2b01      	cmp	r3, #1
    f794:	d00a      	beq.n	f7ac <system_apb_clock_set_mask+0x2c>
    f796:	2b02      	cmp	r3, #2
    f798:	d00f      	beq.n	f7ba <system_apb_clock_set_mask+0x3a>
    f79a:	2b00      	cmp	r3, #0
    f79c:	d114      	bne.n	f7c8 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    f79e:	4b0e      	ldr	r3, [pc, #56]	; (f7d8 <system_apb_clock_set_mask+0x58>)
    f7a0:	4a0d      	ldr	r2, [pc, #52]	; (f7d8 <system_apb_clock_set_mask+0x58>)
    f7a2:	6991      	ldr	r1, [r2, #24]
    f7a4:	683a      	ldr	r2, [r7, #0]
    f7a6:	430a      	orrs	r2, r1
    f7a8:	619a      	str	r2, [r3, #24]
			break;
    f7aa:	e00f      	b.n	f7cc <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    f7ac:	4b0a      	ldr	r3, [pc, #40]	; (f7d8 <system_apb_clock_set_mask+0x58>)
    f7ae:	4a0a      	ldr	r2, [pc, #40]	; (f7d8 <system_apb_clock_set_mask+0x58>)
    f7b0:	69d1      	ldr	r1, [r2, #28]
    f7b2:	683a      	ldr	r2, [r7, #0]
    f7b4:	430a      	orrs	r2, r1
    f7b6:	61da      	str	r2, [r3, #28]
			break;
    f7b8:	e008      	b.n	f7cc <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    f7ba:	4b07      	ldr	r3, [pc, #28]	; (f7d8 <system_apb_clock_set_mask+0x58>)
    f7bc:	4a06      	ldr	r2, [pc, #24]	; (f7d8 <system_apb_clock_set_mask+0x58>)
    f7be:	6a11      	ldr	r1, [r2, #32]
    f7c0:	683a      	ldr	r2, [r7, #0]
    f7c2:	430a      	orrs	r2, r1
    f7c4:	621a      	str	r2, [r3, #32]
			break;
    f7c6:	e001      	b.n	f7cc <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    f7c8:	2317      	movs	r3, #23
    f7ca:	e000      	b.n	f7ce <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    f7cc:	2300      	movs	r3, #0
}
    f7ce:	0018      	movs	r0, r3
    f7d0:	46bd      	mov	sp, r7
    f7d2:	b002      	add	sp, #8
    f7d4:	bd80      	pop	{r7, pc}
    f7d6:	46c0      	nop			; (mov r8, r8)
    f7d8:	40000400 	.word	0x40000400

0000f7dc <wdt_is_syncing>:
 *
 * \retval false If the module has completed synchronization
 * \retval true If the module synchronization is ongoing
 */
static inline bool wdt_is_syncing(void)
{
    f7dc:	b580      	push	{r7, lr}
    f7de:	b082      	sub	sp, #8
    f7e0:	af00      	add	r7, sp, #0
	Wdt *const WDT_module = WDT;
    f7e2:	4b07      	ldr	r3, [pc, #28]	; (f800 <wdt_is_syncing+0x24>)
    f7e4:	607b      	str	r3, [r7, #4]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	if (WDT_module->SYNCBUSY.reg) {
#else
	if (WDT_module->STATUS.reg & WDT_STATUS_SYNCBUSY) {
    f7e6:	687b      	ldr	r3, [r7, #4]
    f7e8:	79db      	ldrb	r3, [r3, #7]
    f7ea:	b2db      	uxtb	r3, r3
    f7ec:	b25b      	sxtb	r3, r3
    f7ee:	2b00      	cmp	r3, #0
    f7f0:	da01      	bge.n	f7f6 <wdt_is_syncing+0x1a>
#endif
		return true;
    f7f2:	2301      	movs	r3, #1
    f7f4:	e000      	b.n	f7f8 <wdt_is_syncing+0x1c>
	}

	return false;
    f7f6:	2300      	movs	r3, #0
}
    f7f8:	0018      	movs	r0, r3
    f7fa:	46bd      	mov	sp, r7
    f7fc:	b002      	add	sp, #8
    f7fe:	bd80      	pop	{r7, pc}
    f800:	40001000 	.word	0x40001000

0000f804 <wdt_is_locked>:
 *  it cannot be disabled or otherwise reconfigured.
 *
 *  \return Current Watchdog lock state.
 */
static inline bool wdt_is_locked(void)
{
    f804:	b580      	push	{r7, lr}
    f806:	b082      	sub	sp, #8
    f808:	af00      	add	r7, sp, #0
	Wdt *const WDT_module = WDT;
    f80a:	4b07      	ldr	r3, [pc, #28]	; (f828 <wdt_is_locked+0x24>)
    f80c:	607b      	str	r3, [r7, #4]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (WDT_module->CTRLA.reg & WDT_CTRLA_ALWAYSON);
#else
	return (WDT_module->CTRL.reg & WDT_CTRL_ALWAYSON);
    f80e:	687b      	ldr	r3, [r7, #4]
    f810:	781b      	ldrb	r3, [r3, #0]
    f812:	b2db      	uxtb	r3, r3
    f814:	001a      	movs	r2, r3
    f816:	2380      	movs	r3, #128	; 0x80
    f818:	4013      	ands	r3, r2
    f81a:	1e5a      	subs	r2, r3, #1
    f81c:	4193      	sbcs	r3, r2
    f81e:	b2db      	uxtb	r3, r3
#endif
}
    f820:	0018      	movs	r0, r3
    f822:	46bd      	mov	sp, r7
    f824:	b002      	add	sp, #8
    f826:	bd80      	pop	{r7, pc}
    f828:	40001000 	.word	0x40001000

0000f82c <wdt_set_config>:
	return STATUS_OK;
}
#else
enum status_code wdt_set_config(
		const struct wdt_conf *const config)
{
    f82c:	b580      	push	{r7, lr}
    f82e:	b086      	sub	sp, #24
    f830:	af00      	add	r7, sp, #0
    f832:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	Wdt *const WDT_module = WDT;
    f834:	4b54      	ldr	r3, [pc, #336]	; (f988 <wdt_set_config+0x15c>)
    f836:	613b      	str	r3, [r7, #16]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_WDT);
    f838:	2110      	movs	r1, #16
    f83a:	2000      	movs	r0, #0
    f83c:	4b53      	ldr	r3, [pc, #332]	; (f98c <wdt_set_config+0x160>)
    f83e:	4798      	blx	r3

	/* Check of the Watchdog has been locked to be always on, if so, abort */
	if (wdt_is_locked()) {
    f840:	4b53      	ldr	r3, [pc, #332]	; (f990 <wdt_set_config+0x164>)
    f842:	4798      	blx	r3
    f844:	1e03      	subs	r3, r0, #0
    f846:	d001      	beq.n	f84c <wdt_set_config+0x20>
		return STATUS_ERR_IO;
    f848:	2310      	movs	r3, #16
    f84a:	e098      	b.n	f97e <wdt_set_config+0x152>
	}

	/* Check for an invalid timeout period, abort if found */
	if (config->timeout_period == WDT_PERIOD_NONE) {
    f84c:	687b      	ldr	r3, [r7, #4]
    f84e:	78db      	ldrb	r3, [r3, #3]
    f850:	2b00      	cmp	r3, #0
    f852:	d101      	bne.n	f858 <wdt_set_config+0x2c>
		return STATUS_ERR_INVALID_ARG;
    f854:	2317      	movs	r3, #23
    f856:	e092      	b.n	f97e <wdt_set_config+0x152>
	}

	/* Make sure the Window and Early Warning periods are not more than the
	 * reset period, abort if either is invalid */
	if ((config->timeout_period < config->window_period) ||
    f858:	687b      	ldr	r3, [r7, #4]
    f85a:	78da      	ldrb	r2, [r3, #3]
    f85c:	687b      	ldr	r3, [r7, #4]
    f85e:	791b      	ldrb	r3, [r3, #4]
    f860:	429a      	cmp	r2, r3
    f862:	d305      	bcc.n	f870 <wdt_set_config+0x44>
			(config->timeout_period < config->early_warning_period)) {
    f864:	687b      	ldr	r3, [r7, #4]
    f866:	78da      	ldrb	r2, [r3, #3]
    f868:	687b      	ldr	r3, [r7, #4]
    f86a:	795b      	ldrb	r3, [r3, #5]
		return STATUS_ERR_INVALID_ARG;
	}

	/* Make sure the Window and Early Warning periods are not more than the
	 * reset period, abort if either is invalid */
	if ((config->timeout_period < config->window_period) ||
    f86c:	429a      	cmp	r2, r3
    f86e:	d201      	bcs.n	f874 <wdt_set_config+0x48>
			(config->timeout_period < config->early_warning_period)) {
		return STATUS_ERR_INVALID_ARG;
    f870:	2317      	movs	r3, #23
    f872:	e084      	b.n	f97e <wdt_set_config+0x152>
	}

	/* Disable the Watchdog module */
	WDT_module->CTRL.reg &= ~WDT_CTRL_ENABLE;
    f874:	693b      	ldr	r3, [r7, #16]
    f876:	781b      	ldrb	r3, [r3, #0]
    f878:	b2db      	uxtb	r3, r3
    f87a:	2202      	movs	r2, #2
    f87c:	4393      	bics	r3, r2
    f87e:	b2da      	uxtb	r2, r3
    f880:	693b      	ldr	r3, [r7, #16]
    f882:	701a      	strb	r2, [r3, #0]

	while (wdt_is_syncing()) {
    f884:	46c0      	nop			; (mov r8, r8)
    f886:	4b43      	ldr	r3, [pc, #268]	; (f994 <wdt_set_config+0x168>)
    f888:	4798      	blx	r3
    f88a:	1e03      	subs	r3, r0, #0
    f88c:	d1fb      	bne.n	f886 <wdt_set_config+0x5a>
		/* Wait for all hardware modules to complete synchronization */
	}

	if(config->enable == false) {
    f88e:	687b      	ldr	r3, [r7, #4]
    f890:	785b      	ldrb	r3, [r3, #1]
    f892:	2201      	movs	r2, #1
    f894:	4053      	eors	r3, r2
    f896:	b2db      	uxtb	r3, r3
    f898:	2b00      	cmp	r3, #0
    f89a:	d001      	beq.n	f8a0 <wdt_set_config+0x74>
		return STATUS_OK;
    f89c:	2300      	movs	r3, #0
    f89e:	e06e      	b.n	f97e <wdt_set_config+0x152>
	}

	/* Configure GCLK channel and enable clock */
	struct system_gclk_chan_config gclk_chan_conf;
	gclk_chan_conf.source_generator = config->clock_source;
    f8a0:	687b      	ldr	r3, [r7, #4]
    f8a2:	789a      	ldrb	r2, [r3, #2]
    f8a4:	230c      	movs	r3, #12
    f8a6:	18fb      	adds	r3, r7, r3
    f8a8:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(WDT_GCLK_ID, &gclk_chan_conf);
    f8aa:	230c      	movs	r3, #12
    f8ac:	18fb      	adds	r3, r7, r3
    f8ae:	0019      	movs	r1, r3
    f8b0:	2003      	movs	r0, #3
    f8b2:	4b39      	ldr	r3, [pc, #228]	; (f998 <wdt_set_config+0x16c>)
    f8b4:	4798      	blx	r3
	system_gclk_chan_enable(WDT_GCLK_ID);
    f8b6:	2003      	movs	r0, #3
    f8b8:	4b38      	ldr	r3, [pc, #224]	; (f99c <wdt_set_config+0x170>)
    f8ba:	4798      	blx	r3
	if (config->always_on) {
    f8bc:	687b      	ldr	r3, [r7, #4]
    f8be:	781b      	ldrb	r3, [r3, #0]
    f8c0:	2b00      	cmp	r3, #0
    f8c2:	d002      	beq.n	f8ca <wdt_set_config+0x9e>
		system_gclk_chan_lock(WDT_GCLK_ID);
    f8c4:	2003      	movs	r0, #3
    f8c6:	4b36      	ldr	r3, [pc, #216]	; (f9a0 <wdt_set_config+0x174>)
    f8c8:	4798      	blx	r3
	}

	uint32_t new_config = 0;
    f8ca:	2300      	movs	r3, #0
    f8cc:	617b      	str	r3, [r7, #20]

	/* Update the timeout period value with the requested period */
	new_config |= (config->timeout_period - 1) << WDT_CONFIG_PER_Pos;
    f8ce:	687b      	ldr	r3, [r7, #4]
    f8d0:	78db      	ldrb	r3, [r3, #3]
    f8d2:	3b01      	subs	r3, #1
    f8d4:	001a      	movs	r2, r3
    f8d6:	697b      	ldr	r3, [r7, #20]
    f8d8:	4313      	orrs	r3, r2
    f8da:	617b      	str	r3, [r7, #20]

	/* Check if the user has requested a reset window period */
	if (config->window_period != WDT_PERIOD_NONE) {
    f8dc:	687b      	ldr	r3, [r7, #4]
    f8de:	791b      	ldrb	r3, [r3, #4]
    f8e0:	2b00      	cmp	r3, #0
    f8e2:	d010      	beq.n	f906 <wdt_set_config+0xda>
		WDT_module->CTRL.reg |= WDT_CTRL_WEN;
    f8e4:	693b      	ldr	r3, [r7, #16]
    f8e6:	781b      	ldrb	r3, [r3, #0]
    f8e8:	b2db      	uxtb	r3, r3
    f8ea:	2204      	movs	r2, #4
    f8ec:	4313      	orrs	r3, r2
    f8ee:	b2da      	uxtb	r2, r3
    f8f0:	693b      	ldr	r3, [r7, #16]
    f8f2:	701a      	strb	r2, [r3, #0]

		/* Update and enable the timeout period value */
		new_config |= (config->window_period - 1) << WDT_CONFIG_WINDOW_Pos;
    f8f4:	687b      	ldr	r3, [r7, #4]
    f8f6:	791b      	ldrb	r3, [r3, #4]
    f8f8:	3b01      	subs	r3, #1
    f8fa:	011b      	lsls	r3, r3, #4
    f8fc:	001a      	movs	r2, r3
    f8fe:	697b      	ldr	r3, [r7, #20]
    f900:	4313      	orrs	r3, r2
    f902:	617b      	str	r3, [r7, #20]
    f904:	e007      	b.n	f916 <wdt_set_config+0xea>
	} else {
		/* Ensure the window enable control flag is cleared */
		WDT_module->CTRL.reg &= ~WDT_CTRL_WEN;
    f906:	693b      	ldr	r3, [r7, #16]
    f908:	781b      	ldrb	r3, [r3, #0]
    f90a:	b2db      	uxtb	r3, r3
    f90c:	2204      	movs	r2, #4
    f90e:	4393      	bics	r3, r2
    f910:	b2da      	uxtb	r2, r3
    f912:	693b      	ldr	r3, [r7, #16]
    f914:	701a      	strb	r2, [r3, #0]
	}

	while (wdt_is_syncing()) {
    f916:	46c0      	nop			; (mov r8, r8)
    f918:	4b1e      	ldr	r3, [pc, #120]	; (f994 <wdt_set_config+0x168>)
    f91a:	4798      	blx	r3
    f91c:	1e03      	subs	r3, r0, #0
    f91e:	d1fb      	bne.n	f918 <wdt_set_config+0xec>
		/* Wait for all hardware modules to complete synchronization */
	}

	/* Write the new Watchdog configuration */
	WDT_module->CONFIG.reg = new_config;
    f920:	697b      	ldr	r3, [r7, #20]
    f922:	b2da      	uxtb	r2, r3
    f924:	693b      	ldr	r3, [r7, #16]
    f926:	705a      	strb	r2, [r3, #1]

	/* Check if the user has requested an early warning period */
	if (config->early_warning_period != WDT_PERIOD_NONE) {
    f928:	687b      	ldr	r3, [r7, #4]
    f92a:	795b      	ldrb	r3, [r3, #5]
    f92c:	2b00      	cmp	r3, #0
    f92e:	d00a      	beq.n	f946 <wdt_set_config+0x11a>
		while (wdt_is_syncing()) {
    f930:	46c0      	nop			; (mov r8, r8)
    f932:	4b18      	ldr	r3, [pc, #96]	; (f994 <wdt_set_config+0x168>)
    f934:	4798      	blx	r3
    f936:	1e03      	subs	r3, r0, #0
    f938:	d1fb      	bne.n	f932 <wdt_set_config+0x106>
			/* Wait for all hardware modules to complete synchronization */
		}

		/* Set the Early Warning period */
		WDT_module->EWCTRL.reg
			= (config->early_warning_period - 1) << WDT_EWCTRL_EWOFFSET_Pos;
    f93a:	687b      	ldr	r3, [r7, #4]
    f93c:	795b      	ldrb	r3, [r3, #5]
    f93e:	3b01      	subs	r3, #1
    f940:	b2da      	uxtb	r2, r3
    f942:	693b      	ldr	r3, [r7, #16]
    f944:	709a      	strb	r2, [r3, #2]
	}

	/* Either enable or lock-enable the Watchdog timer depending on the user
	 * settings */
	if (config->always_on) {
    f946:	687b      	ldr	r3, [r7, #4]
    f948:	781b      	ldrb	r3, [r3, #0]
    f94a:	2b00      	cmp	r3, #0
    f94c:	d009      	beq.n	f962 <wdt_set_config+0x136>
		WDT_module->CTRL.reg |= WDT_CTRL_ALWAYSON;
    f94e:	693b      	ldr	r3, [r7, #16]
    f950:	781b      	ldrb	r3, [r3, #0]
    f952:	b2db      	uxtb	r3, r3
    f954:	2280      	movs	r2, #128	; 0x80
    f956:	4252      	negs	r2, r2
    f958:	4313      	orrs	r3, r2
    f95a:	b2da      	uxtb	r2, r3
    f95c:	693b      	ldr	r3, [r7, #16]
    f95e:	701a      	strb	r2, [r3, #0]
    f960:	e007      	b.n	f972 <wdt_set_config+0x146>
	} else {
		WDT_module->CTRL.reg |= WDT_CTRL_ENABLE;
    f962:	693b      	ldr	r3, [r7, #16]
    f964:	781b      	ldrb	r3, [r3, #0]
    f966:	b2db      	uxtb	r3, r3
    f968:	2202      	movs	r2, #2
    f96a:	4313      	orrs	r3, r2
    f96c:	b2da      	uxtb	r2, r3
    f96e:	693b      	ldr	r3, [r7, #16]
    f970:	701a      	strb	r2, [r3, #0]
	}

	while (wdt_is_syncing()) {
    f972:	46c0      	nop			; (mov r8, r8)
    f974:	4b07      	ldr	r3, [pc, #28]	; (f994 <wdt_set_config+0x168>)
    f976:	4798      	blx	r3
    f978:	1e03      	subs	r3, r0, #0
    f97a:	d1fb      	bne.n	f974 <wdt_set_config+0x148>
		/* Wait for all hardware modules to complete synchronization */
	}

	return STATUS_OK;
    f97c:	2300      	movs	r3, #0
}
    f97e:	0018      	movs	r0, r3
    f980:	46bd      	mov	sp, r7
    f982:	b006      	add	sp, #24
    f984:	bd80      	pop	{r7, pc}
    f986:	46c0      	nop			; (mov r8, r8)
    f988:	40001000 	.word	0x40001000
    f98c:	0000f781 	.word	0x0000f781
    f990:	0000f805 	.word	0x0000f805
    f994:	0000f7dd 	.word	0x0000f7dd
    f998:	000169e1 	.word	0x000169e1
    f99c:	00016a25 	.word	0x00016a25
    f9a0:	00016b05 	.word	0x00016b05

0000f9a4 <wdt_reset_count>:
 * period count elapsed. This function should be called after the window
 * period (if one was set in the module configuration) but before the timeout
 * period to prevent a reset of the system.
 */
void wdt_reset_count(void)
{
    f9a4:	b580      	push	{r7, lr}
    f9a6:	b082      	sub	sp, #8
    f9a8:	af00      	add	r7, sp, #0
	Wdt *const WDT_module = WDT;
    f9aa:	4b07      	ldr	r3, [pc, #28]	; (f9c8 <wdt_reset_count+0x24>)
    f9ac:	607b      	str	r3, [r7, #4]

	/* Disable the Watchdog module */
	WDT_module->CLEAR.reg = WDT_CLEAR_CLEAR_KEY;
    f9ae:	687b      	ldr	r3, [r7, #4]
    f9b0:	22a5      	movs	r2, #165	; 0xa5
    f9b2:	721a      	strb	r2, [r3, #8]

	while (wdt_is_syncing()) {
    f9b4:	46c0      	nop			; (mov r8, r8)
    f9b6:	4b05      	ldr	r3, [pc, #20]	; (f9cc <wdt_reset_count+0x28>)
    f9b8:	4798      	blx	r3
    f9ba:	1e03      	subs	r3, r0, #0
    f9bc:	d1fb      	bne.n	f9b6 <wdt_reset_count+0x12>
		/* Wait for all hardware modules to complete synchronization */
	}
}
    f9be:	46c0      	nop			; (mov r8, r8)
    f9c0:	46bd      	mov	sp, r7
    f9c2:	b002      	add	sp, #8
    f9c4:	bd80      	pop	{r7, pc}
    f9c6:	46c0      	nop			; (mov r8, r8)
    f9c8:	40001000 	.word	0x40001000
    f9cc:	0000f7dd 	.word	0x0000f7dd

0000f9d0 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    f9d0:	b580      	push	{r7, lr}
    f9d2:	b084      	sub	sp, #16
    f9d4:	af00      	add	r7, sp, #0
    f9d6:	60f8      	str	r0, [r7, #12]
    f9d8:	60b9      	str	r1, [r7, #8]
    f9da:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    f9dc:	68fb      	ldr	r3, [r7, #12]
    f9de:	3b04      	subs	r3, #4
    f9e0:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    f9e2:	68fb      	ldr	r3, [r7, #12]
    f9e4:	2280      	movs	r2, #128	; 0x80
    f9e6:	0452      	lsls	r2, r2, #17
    f9e8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
    f9ea:	68fb      	ldr	r3, [r7, #12]
    f9ec:	3b04      	subs	r3, #4
    f9ee:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
    f9f0:	68ba      	ldr	r2, [r7, #8]
    f9f2:	68fb      	ldr	r3, [r7, #12]
    f9f4:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
    f9f6:	68fb      	ldr	r3, [r7, #12]
    f9f8:	3b04      	subs	r3, #4
    f9fa:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    f9fc:	4a08      	ldr	r2, [pc, #32]	; (fa20 <pxPortInitialiseStack+0x50>)
    f9fe:	68fb      	ldr	r3, [r7, #12]
    fa00:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
    fa02:	68fb      	ldr	r3, [r7, #12]
    fa04:	3b14      	subs	r3, #20
    fa06:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
    fa08:	687a      	ldr	r2, [r7, #4]
    fa0a:	68fb      	ldr	r3, [r7, #12]
    fa0c:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
    fa0e:	68fb      	ldr	r3, [r7, #12]
    fa10:	3b20      	subs	r3, #32
    fa12:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
    fa14:	68fb      	ldr	r3, [r7, #12]
}
    fa16:	0018      	movs	r0, r3
    fa18:	46bd      	mov	sp, r7
    fa1a:	b004      	add	sp, #16
    fa1c:	bd80      	pop	{r7, pc}
    fa1e:	46c0      	nop			; (mov r8, r8)
    fa20:	0000fa25 	.word	0x0000fa25

0000fa24 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    fa24:	b580      	push	{r7, lr}
    fa26:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
    fa28:	4b03      	ldr	r3, [pc, #12]	; (fa38 <prvTaskExitError+0x14>)
    fa2a:	681b      	ldr	r3, [r3, #0]
    fa2c:	3301      	adds	r3, #1
    fa2e:	d001      	beq.n	fa34 <prvTaskExitError+0x10>
    fa30:	b672      	cpsid	i
    fa32:	e7fe      	b.n	fa32 <prvTaskExitError+0xe>
	portDISABLE_INTERRUPTS();
    fa34:	b672      	cpsid	i
	for( ;; );
    fa36:	e7fe      	b.n	fa36 <prvTaskExitError+0x12>
    fa38:	20000028 	.word	0x20000028

0000fa3c <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
    fa3c:	b580      	push	{r7, lr}
    fa3e:	af00      	add	r7, sp, #0
	/* This function is no longer used, but retained for backward
	compatibility. */
}
    fa40:	46c0      	nop			; (mov r8, r8)
    fa42:	46bd      	mov	sp, r7
    fa44:	bd80      	pop	{r7, pc}
    fa46:	46c0      	nop			; (mov r8, r8)
	...

0000fa50 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
    fa50:	4a0b      	ldr	r2, [pc, #44]	; (fa80 <pxCurrentTCBConst2>)
    fa52:	6813      	ldr	r3, [r2, #0]
    fa54:	6818      	ldr	r0, [r3, #0]
    fa56:	3020      	adds	r0, #32
    fa58:	f380 8809 	msr	PSP, r0
    fa5c:	2002      	movs	r0, #2
    fa5e:	f380 8814 	msr	CONTROL, r0
    fa62:	f3bf 8f6f 	isb	sy
    fa66:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
    fa68:	46ae      	mov	lr, r5
    fa6a:	bc08      	pop	{r3}
    fa6c:	bc04      	pop	{r2}
    fa6e:	b662      	cpsie	i
    fa70:	4718      	bx	r3
    fa72:	46c0      	nop			; (mov r8, r8)
    fa74:	46c0      	nop			; (mov r8, r8)
    fa76:	46c0      	nop			; (mov r8, r8)
    fa78:	46c0      	nop			; (mov r8, r8)
    fa7a:	46c0      	nop			; (mov r8, r8)
    fa7c:	46c0      	nop			; (mov r8, r8)
    fa7e:	46c0      	nop			; (mov r8, r8)

0000fa80 <pxCurrentTCBConst2>:
    fa80:	20002cc4 	.word	0x20002cc4
	"	bx r3						\n" /* Finally, jump to the user defined task code. */
	"								\n"
	"	.align 4					\n"
	"pxCurrentTCBConst2: .word pxCurrentTCB	  "
				  );
}
    fa84:	46c0      	nop			; (mov r8, r8)
    fa86:	46c0      	nop			; (mov r8, r8)

0000fa88 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
    fa88:	b580      	push	{r7, lr}
    fa8a:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    fa8c:	4b0d      	ldr	r3, [pc, #52]	; (fac4 <xPortStartScheduler+0x3c>)
    fa8e:	4a0d      	ldr	r2, [pc, #52]	; (fac4 <xPortStartScheduler+0x3c>)
    fa90:	6812      	ldr	r2, [r2, #0]
    fa92:	21ff      	movs	r1, #255	; 0xff
    fa94:	0409      	lsls	r1, r1, #16
    fa96:	430a      	orrs	r2, r1
    fa98:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    fa9a:	4b0a      	ldr	r3, [pc, #40]	; (fac4 <xPortStartScheduler+0x3c>)
    fa9c:	4a09      	ldr	r2, [pc, #36]	; (fac4 <xPortStartScheduler+0x3c>)
    fa9e:	6812      	ldr	r2, [r2, #0]
    faa0:	21ff      	movs	r1, #255	; 0xff
    faa2:	0609      	lsls	r1, r1, #24
    faa4:	430a      	orrs	r2, r1
    faa6:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
    faa8:	4b07      	ldr	r3, [pc, #28]	; (fac8 <xPortStartScheduler+0x40>)
    faaa:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
    faac:	4b07      	ldr	r3, [pc, #28]	; (facc <xPortStartScheduler+0x44>)
    faae:	2200      	movs	r2, #0
    fab0:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
    fab2:	4b07      	ldr	r3, [pc, #28]	; (fad0 <xPortStartScheduler+0x48>)
    fab4:	4798      	blx	r3

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
    fab6:	4b07      	ldr	r3, [pc, #28]	; (fad4 <xPortStartScheduler+0x4c>)
    fab8:	4798      	blx	r3

	/* Should not get here! */
	return 0;
    faba:	2300      	movs	r3, #0
}
    fabc:	0018      	movs	r0, r3
    fabe:	46bd      	mov	sp, r7
    fac0:	bd80      	pop	{r7, pc}
    fac2:	46c0      	nop			; (mov r8, r8)
    fac4:	e000ed20 	.word	0xe000ed20
    fac8:	0000fbe9 	.word	0x0000fbe9
    facc:	20000028 	.word	0x20000028
    fad0:	0000fa51 	.word	0x0000fa51
    fad4:	0000fa25 	.word	0x0000fa25

0000fad8 <vPortYield>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
    fad8:	b580      	push	{r7, lr}
    fada:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
    fadc:	4b05      	ldr	r3, [pc, #20]	; (faf4 <vPortYield+0x1c>)
    fade:	2280      	movs	r2, #128	; 0x80
    fae0:	0552      	lsls	r2, r2, #21
    fae2:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
    fae4:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    fae8:	f3bf 8f6f 	isb	sy
}
    faec:	46c0      	nop			; (mov r8, r8)
    faee:	46bd      	mov	sp, r7
    faf0:	bd80      	pop	{r7, pc}
    faf2:	46c0      	nop			; (mov r8, r8)
    faf4:	e000ed04 	.word	0xe000ed04

0000faf8 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    faf8:	b580      	push	{r7, lr}
    fafa:	af00      	add	r7, sp, #0
    portDISABLE_INTERRUPTS();
    fafc:	b672      	cpsid	i
    uxCriticalNesting++;
    fafe:	4b06      	ldr	r3, [pc, #24]	; (fb18 <vPortEnterCritical+0x20>)
    fb00:	681b      	ldr	r3, [r3, #0]
    fb02:	1c5a      	adds	r2, r3, #1
    fb04:	4b04      	ldr	r3, [pc, #16]	; (fb18 <vPortEnterCritical+0x20>)
    fb06:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" );
    fb08:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    fb0c:	f3bf 8f6f 	isb	sy
}
    fb10:	46c0      	nop			; (mov r8, r8)
    fb12:	46bd      	mov	sp, r7
    fb14:	bd80      	pop	{r7, pc}
    fb16:	46c0      	nop			; (mov r8, r8)
    fb18:	20000028 	.word	0x20000028

0000fb1c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    fb1c:	b580      	push	{r7, lr}
    fb1e:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
    fb20:	4b09      	ldr	r3, [pc, #36]	; (fb48 <vPortExitCritical+0x2c>)
    fb22:	681b      	ldr	r3, [r3, #0]
    fb24:	2b00      	cmp	r3, #0
    fb26:	d101      	bne.n	fb2c <vPortExitCritical+0x10>
    fb28:	b672      	cpsid	i
    fb2a:	e7fe      	b.n	fb2a <vPortExitCritical+0xe>
    uxCriticalNesting--;
    fb2c:	4b06      	ldr	r3, [pc, #24]	; (fb48 <vPortExitCritical+0x2c>)
    fb2e:	681b      	ldr	r3, [r3, #0]
    fb30:	1e5a      	subs	r2, r3, #1
    fb32:	4b05      	ldr	r3, [pc, #20]	; (fb48 <vPortExitCritical+0x2c>)
    fb34:	601a      	str	r2, [r3, #0]
    if( uxCriticalNesting == 0 )
    fb36:	4b04      	ldr	r3, [pc, #16]	; (fb48 <vPortExitCritical+0x2c>)
    fb38:	681b      	ldr	r3, [r3, #0]
    fb3a:	2b00      	cmp	r3, #0
    fb3c:	d100      	bne.n	fb40 <vPortExitCritical+0x24>
    {
        portENABLE_INTERRUPTS();
    fb3e:	b662      	cpsie	i
    }
}
    fb40:	46c0      	nop			; (mov r8, r8)
    fb42:	46bd      	mov	sp, r7
    fb44:	bd80      	pop	{r7, pc}
    fb46:	46c0      	nop			; (mov r8, r8)
    fb48:	20000028 	.word	0x20000028

0000fb4c <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
    fb4c:	f3ef 8010 	mrs	r0, PRIMASK
    fb50:	b672      	cpsid	i
    fb52:	4770      	bx	lr
					" cpsid i			\n"
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
    fb54:	2300      	movs	r3, #0
}
    fb56:	0018      	movs	r0, r3

0000fb58 <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
    fb58:	f380 8810 	msr	PRIMASK, r0
    fb5c:	4770      	bx	lr
					" bx lr				  "
				  );

	/* Just to avoid compiler warning. */
	( void ) ulMask;
}
    fb5e:	46c0      	nop			; (mov r8, r8)

0000fb60 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
    fb60:	f3ef 8009 	mrs	r0, PSP
    fb64:	4b0e      	ldr	r3, [pc, #56]	; (fba0 <pxCurrentTCBConst>)
    fb66:	681a      	ldr	r2, [r3, #0]
    fb68:	3820      	subs	r0, #32
    fb6a:	6010      	str	r0, [r2, #0]
    fb6c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    fb6e:	4644      	mov	r4, r8
    fb70:	464d      	mov	r5, r9
    fb72:	4656      	mov	r6, sl
    fb74:	465f      	mov	r7, fp
    fb76:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    fb78:	b508      	push	{r3, lr}
    fb7a:	b672      	cpsid	i
    fb7c:	f000 fe92 	bl	108a4 <vTaskSwitchContext>
    fb80:	b662      	cpsie	i
    fb82:	bc0c      	pop	{r2, r3}
    fb84:	6811      	ldr	r1, [r2, #0]
    fb86:	6808      	ldr	r0, [r1, #0]
    fb88:	3010      	adds	r0, #16
    fb8a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    fb8c:	46a0      	mov	r8, r4
    fb8e:	46a9      	mov	r9, r5
    fb90:	46b2      	mov	sl, r6
    fb92:	46bb      	mov	fp, r7
    fb94:	f380 8809 	msr	PSP, r0
    fb98:	3820      	subs	r0, #32
    fb9a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    fb9c:	4718      	bx	r3
    fb9e:	46c0      	nop			; (mov r8, r8)

0000fba0 <pxCurrentTCBConst>:
    fba0:	20002cc4 	.word	0x20002cc4
	"	bx r3								\n"
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	  "
	);
}
    fba4:	46c0      	nop			; (mov r8, r8)
    fba6:	46c0      	nop			; (mov r8, r8)

0000fba8 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
    fba8:	b580      	push	{r7, lr}
    fbaa:	b082      	sub	sp, #8
    fbac:	af00      	add	r7, sp, #0
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    fbae:	4b0a      	ldr	r3, [pc, #40]	; (fbd8 <SysTick_Handler+0x30>)
    fbb0:	4798      	blx	r3
    fbb2:	0003      	movs	r3, r0
    fbb4:	607b      	str	r3, [r7, #4]
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
    fbb6:	4b09      	ldr	r3, [pc, #36]	; (fbdc <SysTick_Handler+0x34>)
    fbb8:	4798      	blx	r3
    fbba:	1e03      	subs	r3, r0, #0
    fbbc:	d003      	beq.n	fbc6 <SysTick_Handler+0x1e>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    fbbe:	4b08      	ldr	r3, [pc, #32]	; (fbe0 <SysTick_Handler+0x38>)
    fbc0:	2280      	movs	r2, #128	; 0x80
    fbc2:	0552      	lsls	r2, r2, #21
    fbc4:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
    fbc6:	687b      	ldr	r3, [r7, #4]
    fbc8:	0018      	movs	r0, r3
    fbca:	4b06      	ldr	r3, [pc, #24]	; (fbe4 <SysTick_Handler+0x3c>)
    fbcc:	4798      	blx	r3
}
    fbce:	46c0      	nop			; (mov r8, r8)
    fbd0:	46bd      	mov	sp, r7
    fbd2:	b002      	add	sp, #8
    fbd4:	bd80      	pop	{r7, pc}
    fbd6:	46c0      	nop			; (mov r8, r8)
    fbd8:	0000fb4d 	.word	0x0000fb4d
    fbdc:	0001075d 	.word	0x0001075d
    fbe0:	e000ed04 	.word	0xe000ed04
    fbe4:	0000fb59 	.word	0x0000fb59

0000fbe8 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
    fbe8:	b5b0      	push	{r4, r5, r7, lr}
    fbea:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    fbec:	4c08      	ldr	r4, [pc, #32]	; (fc10 <prvSetupTimerInterrupt+0x28>)
    fbee:	2000      	movs	r0, #0
    fbf0:	4b08      	ldr	r3, [pc, #32]	; (fc14 <prvSetupTimerInterrupt+0x2c>)
    fbf2:	4798      	blx	r3
    fbf4:	4b08      	ldr	r3, [pc, #32]	; (fc18 <prvSetupTimerInterrupt+0x30>)
    fbf6:	22fa      	movs	r2, #250	; 0xfa
    fbf8:	0091      	lsls	r1, r2, #2
    fbfa:	4798      	blx	r3
    fbfc:	0003      	movs	r3, r0
    fbfe:	3b01      	subs	r3, #1
    fc00:	6023      	str	r3, [r4, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
    fc02:	4b06      	ldr	r3, [pc, #24]	; (fc1c <prvSetupTimerInterrupt+0x34>)
    fc04:	2207      	movs	r2, #7
    fc06:	601a      	str	r2, [r3, #0]
}
    fc08:	46c0      	nop			; (mov r8, r8)
    fc0a:	46bd      	mov	sp, r7
    fc0c:	bdb0      	pop	{r4, r5, r7, pc}
    fc0e:	46c0      	nop			; (mov r8, r8)
    fc10:	e000e014 	.word	0xe000e014
    fc14:	00016909 	.word	0x00016909
    fc18:	0001d485 	.word	0x0001d485
    fc1c:	e000e010 	.word	0xe000e010

0000fc20 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    fc20:	b580      	push	{r7, lr}
    fc22:	b084      	sub	sp, #16
    fc24:	af00      	add	r7, sp, #0
    fc26:	6078      	str	r0, [r7, #4]
void *pvReturn = NULL;
    fc28:	2300      	movs	r3, #0
    fc2a:	60fb      	str	r3, [r7, #12]
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
    fc2c:	687b      	ldr	r3, [r7, #4]
    fc2e:	2207      	movs	r2, #7
    fc30:	4013      	ands	r3, r2
    fc32:	d004      	beq.n	fc3e <pvPortMalloc+0x1e>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    fc34:	687b      	ldr	r3, [r7, #4]
    fc36:	2207      	movs	r2, #7
    fc38:	4393      	bics	r3, r2
    fc3a:	3308      	adds	r3, #8
    fc3c:	607b      	str	r3, [r7, #4]
		}
	}
	#endif

	vTaskSuspendAll();
    fc3e:	4b17      	ldr	r3, [pc, #92]	; (fc9c <pvPortMalloc+0x7c>)
    fc40:	4798      	blx	r3
	{
		if( pucAlignedHeap == NULL )
    fc42:	4b17      	ldr	r3, [pc, #92]	; (fca0 <pvPortMalloc+0x80>)
    fc44:	681b      	ldr	r3, [r3, #0]
    fc46:	2b00      	cmp	r3, #0
    fc48:	d105      	bne.n	fc56 <pvPortMalloc+0x36>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    fc4a:	4b16      	ldr	r3, [pc, #88]	; (fca4 <pvPortMalloc+0x84>)
    fc4c:	2207      	movs	r2, #7
    fc4e:	4393      	bics	r3, r2
    fc50:	001a      	movs	r2, r3
    fc52:	4b13      	ldr	r3, [pc, #76]	; (fca0 <pvPortMalloc+0x80>)
    fc54:	601a      	str	r2, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    fc56:	4b14      	ldr	r3, [pc, #80]	; (fca8 <pvPortMalloc+0x88>)
    fc58:	681a      	ldr	r2, [r3, #0]
    fc5a:	687b      	ldr	r3, [r7, #4]
    fc5c:	18d3      	adds	r3, r2, r3
    fc5e:	4a13      	ldr	r2, [pc, #76]	; (fcac <pvPortMalloc+0x8c>)
    fc60:	4293      	cmp	r3, r2
    fc62:	d813      	bhi.n	fc8c <pvPortMalloc+0x6c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    fc64:	4b10      	ldr	r3, [pc, #64]	; (fca8 <pvPortMalloc+0x88>)
    fc66:	681a      	ldr	r2, [r3, #0]
    fc68:	687b      	ldr	r3, [r7, #4]
    fc6a:	18d2      	adds	r2, r2, r3
    fc6c:	4b0e      	ldr	r3, [pc, #56]	; (fca8 <pvPortMalloc+0x88>)
    fc6e:	681b      	ldr	r3, [r3, #0]
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    fc70:	429a      	cmp	r2, r3
    fc72:	d90b      	bls.n	fc8c <pvPortMalloc+0x6c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    fc74:	4b0a      	ldr	r3, [pc, #40]	; (fca0 <pvPortMalloc+0x80>)
    fc76:	681a      	ldr	r2, [r3, #0]
    fc78:	4b0b      	ldr	r3, [pc, #44]	; (fca8 <pvPortMalloc+0x88>)
    fc7a:	681b      	ldr	r3, [r3, #0]
    fc7c:	18d3      	adds	r3, r2, r3
    fc7e:	60fb      	str	r3, [r7, #12]
			xNextFreeByte += xWantedSize;
    fc80:	4b09      	ldr	r3, [pc, #36]	; (fca8 <pvPortMalloc+0x88>)
    fc82:	681a      	ldr	r2, [r3, #0]
    fc84:	687b      	ldr	r3, [r7, #4]
    fc86:	18d2      	adds	r2, r2, r3
    fc88:	4b07      	ldr	r3, [pc, #28]	; (fca8 <pvPortMalloc+0x88>)
    fc8a:	601a      	str	r2, [r3, #0]
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    fc8c:	4b08      	ldr	r3, [pc, #32]	; (fcb0 <pvPortMalloc+0x90>)
    fc8e:	4798      	blx	r3
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    fc90:	68fb      	ldr	r3, [r7, #12]
}
    fc92:	0018      	movs	r0, r3
    fc94:	46bd      	mov	sp, r7
    fc96:	b004      	add	sp, #16
    fc98:	bd80      	pop	{r7, pc}
    fc9a:	46c0      	nop			; (mov r8, r8)
    fc9c:	00010565 	.word	0x00010565
    fca0:	20002cc0 	.word	0x20002cc0
    fca4:	200005b4 	.word	0x200005b4
    fca8:	20002cbc 	.word	0x20002cbc
    fcac:	00002707 	.word	0x00002707
    fcb0:	0001057d 	.word	0x0001057d

0000fcb4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    fcb4:	b580      	push	{r7, lr}
    fcb6:	b082      	sub	sp, #8
    fcb8:	af00      	add	r7, sp, #0
    fcba:	6078      	str	r0, [r7, #4]
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
    fcbc:	687b      	ldr	r3, [r7, #4]
    fcbe:	2b00      	cmp	r3, #0
    fcc0:	d001      	beq.n	fcc6 <vPortFree+0x12>
    fcc2:	b672      	cpsid	i
    fcc4:	e7fe      	b.n	fcc4 <vPortFree+0x10>
}
    fcc6:	46c0      	nop			; (mov r8, r8)
    fcc8:	46bd      	mov	sp, r7
    fcca:	b002      	add	sp, #8
    fccc:	bd80      	pop	{r7, pc}
    fcce:	46c0      	nop			; (mov r8, r8)

0000fcd0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    fcd0:	b580      	push	{r7, lr}
    fcd2:	b082      	sub	sp, #8
    fcd4:	af00      	add	r7, sp, #0
    fcd6:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    fcd8:	687b      	ldr	r3, [r7, #4]
    fcda:	3308      	adds	r3, #8
    fcdc:	001a      	movs	r2, r3
    fcde:	687b      	ldr	r3, [r7, #4]
    fce0:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    fce2:	687b      	ldr	r3, [r7, #4]
    fce4:	2201      	movs	r2, #1
    fce6:	4252      	negs	r2, r2
    fce8:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    fcea:	687b      	ldr	r3, [r7, #4]
    fcec:	3308      	adds	r3, #8
    fcee:	001a      	movs	r2, r3
    fcf0:	687b      	ldr	r3, [r7, #4]
    fcf2:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    fcf4:	687b      	ldr	r3, [r7, #4]
    fcf6:	3308      	adds	r3, #8
    fcf8:	001a      	movs	r2, r3
    fcfa:	687b      	ldr	r3, [r7, #4]
    fcfc:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    fcfe:	687b      	ldr	r3, [r7, #4]
    fd00:	2200      	movs	r2, #0
    fd02:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    fd04:	46c0      	nop			; (mov r8, r8)
    fd06:	46bd      	mov	sp, r7
    fd08:	b002      	add	sp, #8
    fd0a:	bd80      	pop	{r7, pc}

0000fd0c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    fd0c:	b580      	push	{r7, lr}
    fd0e:	b082      	sub	sp, #8
    fd10:	af00      	add	r7, sp, #0
    fd12:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    fd14:	687b      	ldr	r3, [r7, #4]
    fd16:	2200      	movs	r2, #0
    fd18:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    fd1a:	46c0      	nop			; (mov r8, r8)
    fd1c:	46bd      	mov	sp, r7
    fd1e:	b002      	add	sp, #8
    fd20:	bd80      	pop	{r7, pc}
    fd22:	46c0      	nop			; (mov r8, r8)

0000fd24 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    fd24:	b580      	push	{r7, lr}
    fd26:	b084      	sub	sp, #16
    fd28:	af00      	add	r7, sp, #0
    fd2a:	6078      	str	r0, [r7, #4]
    fd2c:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
    fd2e:	687b      	ldr	r3, [r7, #4]
    fd30:	685b      	ldr	r3, [r3, #4]
    fd32:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    fd34:	683b      	ldr	r3, [r7, #0]
    fd36:	68fa      	ldr	r2, [r7, #12]
    fd38:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    fd3a:	68fb      	ldr	r3, [r7, #12]
    fd3c:	689a      	ldr	r2, [r3, #8]
    fd3e:	683b      	ldr	r3, [r7, #0]
    fd40:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    fd42:	68fb      	ldr	r3, [r7, #12]
    fd44:	689b      	ldr	r3, [r3, #8]
    fd46:	683a      	ldr	r2, [r7, #0]
    fd48:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
    fd4a:	68fb      	ldr	r3, [r7, #12]
    fd4c:	683a      	ldr	r2, [r7, #0]
    fd4e:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    fd50:	683b      	ldr	r3, [r7, #0]
    fd52:	687a      	ldr	r2, [r7, #4]
    fd54:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    fd56:	687b      	ldr	r3, [r7, #4]
    fd58:	681b      	ldr	r3, [r3, #0]
    fd5a:	1c5a      	adds	r2, r3, #1
    fd5c:	687b      	ldr	r3, [r7, #4]
    fd5e:	601a      	str	r2, [r3, #0]
}
    fd60:	46c0      	nop			; (mov r8, r8)
    fd62:	46bd      	mov	sp, r7
    fd64:	b004      	add	sp, #16
    fd66:	bd80      	pop	{r7, pc}

0000fd68 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    fd68:	b580      	push	{r7, lr}
    fd6a:	b084      	sub	sp, #16
    fd6c:	af00      	add	r7, sp, #0
    fd6e:	6078      	str	r0, [r7, #4]
    fd70:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    fd72:	683b      	ldr	r3, [r7, #0]
    fd74:	681b      	ldr	r3, [r3, #0]
    fd76:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    fd78:	68bb      	ldr	r3, [r7, #8]
    fd7a:	3301      	adds	r3, #1
    fd7c:	d103      	bne.n	fd86 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    fd7e:	687b      	ldr	r3, [r7, #4]
    fd80:	691b      	ldr	r3, [r3, #16]
    fd82:	60fb      	str	r3, [r7, #12]
    fd84:	e00c      	b.n	fda0 <vListInsert+0x38>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    fd86:	687b      	ldr	r3, [r7, #4]
    fd88:	3308      	adds	r3, #8
    fd8a:	60fb      	str	r3, [r7, #12]
    fd8c:	e002      	b.n	fd94 <vListInsert+0x2c>
    fd8e:	68fb      	ldr	r3, [r7, #12]
    fd90:	685b      	ldr	r3, [r3, #4]
    fd92:	60fb      	str	r3, [r7, #12]
    fd94:	68fb      	ldr	r3, [r7, #12]
    fd96:	685b      	ldr	r3, [r3, #4]
    fd98:	681a      	ldr	r2, [r3, #0]
    fd9a:	68bb      	ldr	r3, [r7, #8]
    fd9c:	429a      	cmp	r2, r3
    fd9e:	d9f6      	bls.n	fd8e <vListInsert+0x26>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    fda0:	68fb      	ldr	r3, [r7, #12]
    fda2:	685a      	ldr	r2, [r3, #4]
    fda4:	683b      	ldr	r3, [r7, #0]
    fda6:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    fda8:	683b      	ldr	r3, [r7, #0]
    fdaa:	685b      	ldr	r3, [r3, #4]
    fdac:	683a      	ldr	r2, [r7, #0]
    fdae:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    fdb0:	683b      	ldr	r3, [r7, #0]
    fdb2:	68fa      	ldr	r2, [r7, #12]
    fdb4:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
    fdb6:	68fb      	ldr	r3, [r7, #12]
    fdb8:	683a      	ldr	r2, [r7, #0]
    fdba:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    fdbc:	683b      	ldr	r3, [r7, #0]
    fdbe:	687a      	ldr	r2, [r7, #4]
    fdc0:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    fdc2:	687b      	ldr	r3, [r7, #4]
    fdc4:	681b      	ldr	r3, [r3, #0]
    fdc6:	1c5a      	adds	r2, r3, #1
    fdc8:	687b      	ldr	r3, [r7, #4]
    fdca:	601a      	str	r2, [r3, #0]
}
    fdcc:	46c0      	nop			; (mov r8, r8)
    fdce:	46bd      	mov	sp, r7
    fdd0:	b004      	add	sp, #16
    fdd2:	bd80      	pop	{r7, pc}

0000fdd4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    fdd4:	b580      	push	{r7, lr}
    fdd6:	b084      	sub	sp, #16
    fdd8:	af00      	add	r7, sp, #0
    fdda:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    fddc:	687b      	ldr	r3, [r7, #4]
    fdde:	691b      	ldr	r3, [r3, #16]
    fde0:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    fde2:	687b      	ldr	r3, [r7, #4]
    fde4:	685b      	ldr	r3, [r3, #4]
    fde6:	687a      	ldr	r2, [r7, #4]
    fde8:	6892      	ldr	r2, [r2, #8]
    fdea:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    fdec:	687b      	ldr	r3, [r7, #4]
    fdee:	689b      	ldr	r3, [r3, #8]
    fdf0:	687a      	ldr	r2, [r7, #4]
    fdf2:	6852      	ldr	r2, [r2, #4]
    fdf4:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    fdf6:	68fb      	ldr	r3, [r7, #12]
    fdf8:	685a      	ldr	r2, [r3, #4]
    fdfa:	687b      	ldr	r3, [r7, #4]
    fdfc:	429a      	cmp	r2, r3
    fdfe:	d103      	bne.n	fe08 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    fe00:	687b      	ldr	r3, [r7, #4]
    fe02:	689a      	ldr	r2, [r3, #8]
    fe04:	68fb      	ldr	r3, [r7, #12]
    fe06:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    fe08:	687b      	ldr	r3, [r7, #4]
    fe0a:	2200      	movs	r2, #0
    fe0c:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
    fe0e:	68fb      	ldr	r3, [r7, #12]
    fe10:	681b      	ldr	r3, [r3, #0]
    fe12:	1e5a      	subs	r2, r3, #1
    fe14:	68fb      	ldr	r3, [r7, #12]
    fe16:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    fe18:	68fb      	ldr	r3, [r7, #12]
    fe1a:	681b      	ldr	r3, [r3, #0]
}
    fe1c:	0018      	movs	r0, r3
    fe1e:	46bd      	mov	sp, r7
    fe20:	b004      	add	sp, #16
    fe22:	bd80      	pop	{r7, pc}

0000fe24 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    fe24:	b580      	push	{r7, lr}
    fe26:	b084      	sub	sp, #16
    fe28:	af00      	add	r7, sp, #0
    fe2a:	6078      	str	r0, [r7, #4]
    fe2c:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    fe2e:	687b      	ldr	r3, [r7, #4]
    fe30:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
    fe32:	68fb      	ldr	r3, [r7, #12]
    fe34:	2b00      	cmp	r3, #0
    fe36:	d101      	bne.n	fe3c <xQueueGenericReset+0x18>
    fe38:	b672      	cpsid	i
    fe3a:	e7fe      	b.n	fe3a <xQueueGenericReset+0x16>

	taskENTER_CRITICAL();
    fe3c:	4b21      	ldr	r3, [pc, #132]	; (fec4 <xQueueGenericReset+0xa0>)
    fe3e:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    fe40:	68fb      	ldr	r3, [r7, #12]
    fe42:	681a      	ldr	r2, [r3, #0]
    fe44:	68fb      	ldr	r3, [r7, #12]
    fe46:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
    fe48:	68fb      	ldr	r3, [r7, #12]
    fe4a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    fe4c:	434b      	muls	r3, r1
    fe4e:	18d2      	adds	r2, r2, r3
    fe50:	68fb      	ldr	r3, [r7, #12]
    fe52:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    fe54:	68fb      	ldr	r3, [r7, #12]
    fe56:	2200      	movs	r2, #0
    fe58:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
    fe5a:	68fb      	ldr	r3, [r7, #12]
    fe5c:	681a      	ldr	r2, [r3, #0]
    fe5e:	68fb      	ldr	r3, [r7, #12]
    fe60:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    fe62:	68fb      	ldr	r3, [r7, #12]
    fe64:	681a      	ldr	r2, [r3, #0]
    fe66:	68fb      	ldr	r3, [r7, #12]
    fe68:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    fe6a:	1e59      	subs	r1, r3, #1
    fe6c:	68fb      	ldr	r3, [r7, #12]
    fe6e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    fe70:	434b      	muls	r3, r1
    fe72:	18d2      	adds	r2, r2, r3
    fe74:	68fb      	ldr	r3, [r7, #12]
    fe76:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
    fe78:	68fb      	ldr	r3, [r7, #12]
    fe7a:	2244      	movs	r2, #68	; 0x44
    fe7c:	21ff      	movs	r1, #255	; 0xff
    fe7e:	5499      	strb	r1, [r3, r2]
		pxQueue->cTxLock = queueUNLOCKED;
    fe80:	68fb      	ldr	r3, [r7, #12]
    fe82:	2245      	movs	r2, #69	; 0x45
    fe84:	21ff      	movs	r1, #255	; 0xff
    fe86:	5499      	strb	r1, [r3, r2]

		if( xNewQueue == pdFALSE )
    fe88:	683b      	ldr	r3, [r7, #0]
    fe8a:	2b00      	cmp	r3, #0
    fe8c:	d109      	bne.n	fea2 <xQueueGenericReset+0x7e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    fe8e:	68fb      	ldr	r3, [r7, #12]
    fe90:	691b      	ldr	r3, [r3, #16]
    fe92:	2b00      	cmp	r3, #0
    fe94:	d00f      	beq.n	feb6 <xQueueGenericReset+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    fe96:	68fb      	ldr	r3, [r7, #12]
    fe98:	3310      	adds	r3, #16
    fe9a:	0018      	movs	r0, r3
    fe9c:	4b0a      	ldr	r3, [pc, #40]	; (fec8 <xQueueGenericReset+0xa4>)
    fe9e:	4798      	blx	r3
    fea0:	e009      	b.n	feb6 <xQueueGenericReset+0x92>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    fea2:	68fb      	ldr	r3, [r7, #12]
    fea4:	3310      	adds	r3, #16
    fea6:	0018      	movs	r0, r3
    fea8:	4b08      	ldr	r3, [pc, #32]	; (fecc <xQueueGenericReset+0xa8>)
    feaa:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    feac:	68fb      	ldr	r3, [r7, #12]
    feae:	3324      	adds	r3, #36	; 0x24
    feb0:	0018      	movs	r0, r3
    feb2:	4b06      	ldr	r3, [pc, #24]	; (fecc <xQueueGenericReset+0xa8>)
    feb4:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
    feb6:	4b06      	ldr	r3, [pc, #24]	; (fed0 <xQueueGenericReset+0xac>)
    feb8:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    feba:	2301      	movs	r3, #1
}
    febc:	0018      	movs	r0, r3
    febe:	46bd      	mov	sp, r7
    fec0:	b004      	add	sp, #16
    fec2:	bd80      	pop	{r7, pc}
    fec4:	0000faf9 	.word	0x0000faf9
    fec8:	00010949 	.word	0x00010949
    fecc:	0000fcd1 	.word	0x0000fcd1
    fed0:	0000fb1d 	.word	0x0000fb1d

0000fed4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    fed4:	b590      	push	{r4, r7, lr}
    fed6:	b08b      	sub	sp, #44	; 0x2c
    fed8:	af02      	add	r7, sp, #8
    feda:	60f8      	str	r0, [r7, #12]
    fedc:	60b9      	str	r1, [r7, #8]
    fede:	1dfb      	adds	r3, r7, #7
    fee0:	701a      	strb	r2, [r3, #0]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    fee2:	68fb      	ldr	r3, [r7, #12]
    fee4:	2b00      	cmp	r3, #0
    fee6:	d101      	bne.n	feec <xQueueGenericCreate+0x18>
    fee8:	b672      	cpsid	i
    feea:	e7fe      	b.n	feea <xQueueGenericCreate+0x16>

		if( uxItemSize == ( UBaseType_t ) 0 )
    feec:	68bb      	ldr	r3, [r7, #8]
    feee:	2b00      	cmp	r3, #0
    fef0:	d102      	bne.n	fef8 <xQueueGenericCreate+0x24>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    fef2:	2300      	movs	r3, #0
    fef4:	61fb      	str	r3, [r7, #28]
    fef6:	e003      	b.n	ff00 <xQueueGenericCreate+0x2c>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    fef8:	68fb      	ldr	r3, [r7, #12]
    fefa:	68ba      	ldr	r2, [r7, #8]
    fefc:	4353      	muls	r3, r2
    fefe:	61fb      	str	r3, [r7, #28]
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    ff00:	69fb      	ldr	r3, [r7, #28]
    ff02:	334c      	adds	r3, #76	; 0x4c
    ff04:	0018      	movs	r0, r3
    ff06:	4b0c      	ldr	r3, [pc, #48]	; (ff38 <xQueueGenericCreate+0x64>)
    ff08:	4798      	blx	r3
    ff0a:	0003      	movs	r3, r0
    ff0c:	61bb      	str	r3, [r7, #24]

		if( pxNewQueue != NULL )
    ff0e:	69bb      	ldr	r3, [r7, #24]
    ff10:	2b00      	cmp	r3, #0
    ff12:	d00c      	beq.n	ff2e <xQueueGenericCreate+0x5a>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    ff14:	69bb      	ldr	r3, [r7, #24]
    ff16:	334c      	adds	r3, #76	; 0x4c
    ff18:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    ff1a:	1dfb      	adds	r3, r7, #7
    ff1c:	781c      	ldrb	r4, [r3, #0]
    ff1e:	697a      	ldr	r2, [r7, #20]
    ff20:	68b9      	ldr	r1, [r7, #8]
    ff22:	68f8      	ldr	r0, [r7, #12]
    ff24:	69bb      	ldr	r3, [r7, #24]
    ff26:	9300      	str	r3, [sp, #0]
    ff28:	0023      	movs	r3, r4
    ff2a:	4c04      	ldr	r4, [pc, #16]	; (ff3c <xQueueGenericCreate+0x68>)
    ff2c:	47a0      	blx	r4
		}

		return pxNewQueue;
    ff2e:	69bb      	ldr	r3, [r7, #24]
	}
    ff30:	0018      	movs	r0, r3
    ff32:	46bd      	mov	sp, r7
    ff34:	b009      	add	sp, #36	; 0x24
    ff36:	bd90      	pop	{r4, r7, pc}
    ff38:	0000fc21 	.word	0x0000fc21
    ff3c:	0000ff41 	.word	0x0000ff41

0000ff40 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    ff40:	b580      	push	{r7, lr}
    ff42:	b084      	sub	sp, #16
    ff44:	af00      	add	r7, sp, #0
    ff46:	60f8      	str	r0, [r7, #12]
    ff48:	60b9      	str	r1, [r7, #8]
    ff4a:	607a      	str	r2, [r7, #4]
    ff4c:	001a      	movs	r2, r3
    ff4e:	1cfb      	adds	r3, r7, #3
    ff50:	701a      	strb	r2, [r3, #0]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    ff52:	68bb      	ldr	r3, [r7, #8]
    ff54:	2b00      	cmp	r3, #0
    ff56:	d103      	bne.n	ff60 <prvInitialiseNewQueue+0x20>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    ff58:	69bb      	ldr	r3, [r7, #24]
    ff5a:	69ba      	ldr	r2, [r7, #24]
    ff5c:	601a      	str	r2, [r3, #0]
    ff5e:	e002      	b.n	ff66 <prvInitialiseNewQueue+0x26>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    ff60:	69bb      	ldr	r3, [r7, #24]
    ff62:	687a      	ldr	r2, [r7, #4]
    ff64:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    ff66:	69bb      	ldr	r3, [r7, #24]
    ff68:	68fa      	ldr	r2, [r7, #12]
    ff6a:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    ff6c:	69bb      	ldr	r3, [r7, #24]
    ff6e:	68ba      	ldr	r2, [r7, #8]
    ff70:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    ff72:	69bb      	ldr	r3, [r7, #24]
    ff74:	2101      	movs	r1, #1
    ff76:	0018      	movs	r0, r3
    ff78:	4b04      	ldr	r3, [pc, #16]	; (ff8c <prvInitialiseNewQueue+0x4c>)
    ff7a:	4798      	blx	r3
	}
	#endif /* configUSE_TRACE_FACILITY */

	#if( configUSE_QUEUE_SETS == 1 )
	{
		pxNewQueue->pxQueueSetContainer = NULL;
    ff7c:	69bb      	ldr	r3, [r7, #24]
    ff7e:	2200      	movs	r2, #0
    ff80:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    ff82:	46c0      	nop			; (mov r8, r8)
    ff84:	46bd      	mov	sp, r7
    ff86:	b004      	add	sp, #16
    ff88:	bd80      	pop	{r7, pc}
    ff8a:	46c0      	nop			; (mov r8, r8)
    ff8c:	0000fe25 	.word	0x0000fe25

0000ff90 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    ff90:	b590      	push	{r4, r7, lr}
    ff92:	b08d      	sub	sp, #52	; 0x34
    ff94:	af04      	add	r7, sp, #16
    ff96:	60f8      	str	r0, [r7, #12]
    ff98:	60b9      	str	r1, [r7, #8]
    ff9a:	603b      	str	r3, [r7, #0]
    ff9c:	1dbb      	adds	r3, r7, #6
    ff9e:	801a      	strh	r2, [r3, #0]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    ffa0:	1dbb      	adds	r3, r7, #6
    ffa2:	881b      	ldrh	r3, [r3, #0]
    ffa4:	009b      	lsls	r3, r3, #2
    ffa6:	0018      	movs	r0, r3
    ffa8:	4b1d      	ldr	r3, [pc, #116]	; (10020 <xTaskCreate+0x90>)
    ffaa:	4798      	blx	r3
    ffac:	0003      	movs	r3, r0
    ffae:	617b      	str	r3, [r7, #20]

			if( pxStack != NULL )
    ffb0:	697b      	ldr	r3, [r7, #20]
    ffb2:	2b00      	cmp	r3, #0
    ffb4:	d010      	beq.n	ffd8 <xTaskCreate+0x48>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    ffb6:	204c      	movs	r0, #76	; 0x4c
    ffb8:	4b19      	ldr	r3, [pc, #100]	; (10020 <xTaskCreate+0x90>)
    ffba:	4798      	blx	r3
    ffbc:	0003      	movs	r3, r0
    ffbe:	61fb      	str	r3, [r7, #28]

				if( pxNewTCB != NULL )
    ffc0:	69fb      	ldr	r3, [r7, #28]
    ffc2:	2b00      	cmp	r3, #0
    ffc4:	d003      	beq.n	ffce <xTaskCreate+0x3e>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    ffc6:	69fb      	ldr	r3, [r7, #28]
    ffc8:	697a      	ldr	r2, [r7, #20]
    ffca:	631a      	str	r2, [r3, #48]	; 0x30
    ffcc:	e006      	b.n	ffdc <xTaskCreate+0x4c>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    ffce:	697b      	ldr	r3, [r7, #20]
    ffd0:	0018      	movs	r0, r3
    ffd2:	4b14      	ldr	r3, [pc, #80]	; (10024 <xTaskCreate+0x94>)
    ffd4:	4798      	blx	r3
    ffd6:	e001      	b.n	ffdc <xTaskCreate+0x4c>
				}
			}
			else
			{
				pxNewTCB = NULL;
    ffd8:	2300      	movs	r3, #0
    ffda:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    ffdc:	69fb      	ldr	r3, [r7, #28]
    ffde:	2b00      	cmp	r3, #0
    ffe0:	d016      	beq.n	10010 <xTaskCreate+0x80>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    ffe2:	1dbb      	adds	r3, r7, #6
    ffe4:	881a      	ldrh	r2, [r3, #0]
    ffe6:	683c      	ldr	r4, [r7, #0]
    ffe8:	68b9      	ldr	r1, [r7, #8]
    ffea:	68f8      	ldr	r0, [r7, #12]
    ffec:	2300      	movs	r3, #0
    ffee:	9303      	str	r3, [sp, #12]
    fff0:	69fb      	ldr	r3, [r7, #28]
    fff2:	9302      	str	r3, [sp, #8]
    fff4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    fff6:	9301      	str	r3, [sp, #4]
    fff8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    fffa:	9300      	str	r3, [sp, #0]
    fffc:	0023      	movs	r3, r4
    fffe:	4c0a      	ldr	r4, [pc, #40]	; (10028 <xTaskCreate+0x98>)
   10000:	47a0      	blx	r4
			prvAddNewTaskToReadyList( pxNewTCB );
   10002:	69fb      	ldr	r3, [r7, #28]
   10004:	0018      	movs	r0, r3
   10006:	4b09      	ldr	r3, [pc, #36]	; (1002c <xTaskCreate+0x9c>)
   10008:	4798      	blx	r3
			xReturn = pdPASS;
   1000a:	2301      	movs	r3, #1
   1000c:	61bb      	str	r3, [r7, #24]
   1000e:	e002      	b.n	10016 <xTaskCreate+0x86>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   10010:	2301      	movs	r3, #1
   10012:	425b      	negs	r3, r3
   10014:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
   10016:	69bb      	ldr	r3, [r7, #24]
	}
   10018:	0018      	movs	r0, r3
   1001a:	46bd      	mov	sp, r7
   1001c:	b009      	add	sp, #36	; 0x24
   1001e:	bd90      	pop	{r4, r7, pc}
   10020:	0000fc21 	.word	0x0000fc21
   10024:	0000fcb5 	.word	0x0000fcb5
   10028:	00010031 	.word	0x00010031
   1002c:	00010135 	.word	0x00010135

00010030 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   10030:	b580      	push	{r7, lr}
   10032:	b086      	sub	sp, #24
   10034:	af00      	add	r7, sp, #0
   10036:	60f8      	str	r0, [r7, #12]
   10038:	60b9      	str	r1, [r7, #8]
   1003a:	607a      	str	r2, [r7, #4]
   1003c:	603b      	str	r3, [r7, #0]
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   1003e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10040:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   10042:	687b      	ldr	r3, [r7, #4]
   10044:	4938      	ldr	r1, [pc, #224]	; (10128 <prvInitialiseNewTask+0xf8>)
   10046:	468c      	mov	ip, r1
   10048:	4463      	add	r3, ip
   1004a:	009b      	lsls	r3, r3, #2
   1004c:	18d3      	adds	r3, r2, r3
   1004e:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   10050:	693b      	ldr	r3, [r7, #16]
   10052:	2207      	movs	r2, #7
   10054:	4393      	bics	r3, r2
   10056:	613b      	str	r3, [r7, #16]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   10058:	693b      	ldr	r3, [r7, #16]
   1005a:	2207      	movs	r2, #7
   1005c:	4013      	ands	r3, r2
   1005e:	d001      	beq.n	10064 <prvInitialiseNewTask+0x34>
   10060:	b672      	cpsid	i
   10062:	e7fe      	b.n	10062 <prvInitialiseNewTask+0x32>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   10064:	2300      	movs	r3, #0
   10066:	617b      	str	r3, [r7, #20]
   10068:	e013      	b.n	10092 <prvInitialiseNewTask+0x62>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   1006a:	68ba      	ldr	r2, [r7, #8]
   1006c:	697b      	ldr	r3, [r7, #20]
   1006e:	18d3      	adds	r3, r2, r3
   10070:	7818      	ldrb	r0, [r3, #0]
   10072:	6aba      	ldr	r2, [r7, #40]	; 0x28
   10074:	2134      	movs	r1, #52	; 0x34
   10076:	697b      	ldr	r3, [r7, #20]
   10078:	18d3      	adds	r3, r2, r3
   1007a:	185b      	adds	r3, r3, r1
   1007c:	1c02      	adds	r2, r0, #0
   1007e:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   10080:	68ba      	ldr	r2, [r7, #8]
   10082:	697b      	ldr	r3, [r7, #20]
   10084:	18d3      	adds	r3, r2, r3
   10086:	781b      	ldrb	r3, [r3, #0]
   10088:	2b00      	cmp	r3, #0
   1008a:	d006      	beq.n	1009a <prvInitialiseNewTask+0x6a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   1008c:	697b      	ldr	r3, [r7, #20]
   1008e:	3301      	adds	r3, #1
   10090:	617b      	str	r3, [r7, #20]
   10092:	697b      	ldr	r3, [r7, #20]
   10094:	2b07      	cmp	r3, #7
   10096:	d9e8      	bls.n	1006a <prvInitialiseNewTask+0x3a>
   10098:	e000      	b.n	1009c <prvInitialiseNewTask+0x6c>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
   1009a:	46c0      	nop			; (mov r8, r8)
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   1009c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1009e:	223b      	movs	r2, #59	; 0x3b
   100a0:	2100      	movs	r1, #0
   100a2:	5499      	strb	r1, [r3, r2]

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   100a4:	6a3b      	ldr	r3, [r7, #32]
   100a6:	2b04      	cmp	r3, #4
   100a8:	d901      	bls.n	100ae <prvInitialiseNewTask+0x7e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   100aa:	2304      	movs	r3, #4
   100ac:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   100ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100b0:	6a3a      	ldr	r2, [r7, #32]
   100b2:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
   100b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100b6:	6a3a      	ldr	r2, [r7, #32]
   100b8:	63da      	str	r2, [r3, #60]	; 0x3c
		pxNewTCB->uxMutexesHeld = 0;
   100ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100bc:	2200      	movs	r2, #0
   100be:	641a      	str	r2, [r3, #64]	; 0x40
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   100c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100c2:	3304      	adds	r3, #4
   100c4:	0018      	movs	r0, r3
   100c6:	4b19      	ldr	r3, [pc, #100]	; (1012c <prvInitialiseNewTask+0xfc>)
   100c8:	4798      	blx	r3
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   100ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100cc:	3318      	adds	r3, #24
   100ce:	0018      	movs	r0, r3
   100d0:	4b16      	ldr	r3, [pc, #88]	; (1012c <prvInitialiseNewTask+0xfc>)
   100d2:	4798      	blx	r3

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   100d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100d6:	6aba      	ldr	r2, [r7, #40]	; 0x28
   100d8:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   100da:	6a3b      	ldr	r3, [r7, #32]
   100dc:	2205      	movs	r2, #5
   100de:	1ad2      	subs	r2, r2, r3
   100e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100e2:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   100e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100e6:	6aba      	ldr	r2, [r7, #40]	; 0x28
   100e8:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   100ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100ec:	2200      	movs	r2, #0
   100ee:	645a      	str	r2, [r3, #68]	; 0x44
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   100f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100f2:	2248      	movs	r2, #72	; 0x48
   100f4:	2100      	movs	r1, #0
   100f6:	5499      	strb	r1, [r3, r2]
	}
	#endif

	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		pxNewTCB->ucDelayAborted = pdFALSE;
   100f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   100fa:	2249      	movs	r2, #73	; 0x49
   100fc:	2100      	movs	r1, #0
   100fe:	5499      	strb	r1, [r3, r2]
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   10100:	683a      	ldr	r2, [r7, #0]
   10102:	68f9      	ldr	r1, [r7, #12]
   10104:	693b      	ldr	r3, [r7, #16]
   10106:	0018      	movs	r0, r3
   10108:	4b09      	ldr	r3, [pc, #36]	; (10130 <prvInitialiseNewTask+0x100>)
   1010a:	4798      	blx	r3
   1010c:	0002      	movs	r2, r0
   1010e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10110:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
   10112:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10114:	2b00      	cmp	r3, #0
   10116:	d002      	beq.n	1011e <prvInitialiseNewTask+0xee>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   10118:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1011a:	6aba      	ldr	r2, [r7, #40]	; 0x28
   1011c:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   1011e:	46c0      	nop			; (mov r8, r8)
   10120:	46bd      	mov	sp, r7
   10122:	b006      	add	sp, #24
   10124:	bd80      	pop	{r7, pc}
   10126:	46c0      	nop			; (mov r8, r8)
   10128:	3fffffff 	.word	0x3fffffff
   1012c:	0000fd0d 	.word	0x0000fd0d
   10130:	0000f9d1 	.word	0x0000f9d1

00010134 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   10134:	b580      	push	{r7, lr}
   10136:	b082      	sub	sp, #8
   10138:	af00      	add	r7, sp, #0
   1013a:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   1013c:	4b25      	ldr	r3, [pc, #148]	; (101d4 <prvAddNewTaskToReadyList+0xa0>)
   1013e:	4798      	blx	r3
	{
		uxCurrentNumberOfTasks++;
   10140:	4b25      	ldr	r3, [pc, #148]	; (101d8 <prvAddNewTaskToReadyList+0xa4>)
   10142:	681b      	ldr	r3, [r3, #0]
   10144:	1c5a      	adds	r2, r3, #1
   10146:	4b24      	ldr	r3, [pc, #144]	; (101d8 <prvAddNewTaskToReadyList+0xa4>)
   10148:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
   1014a:	4b24      	ldr	r3, [pc, #144]	; (101dc <prvAddNewTaskToReadyList+0xa8>)
   1014c:	681b      	ldr	r3, [r3, #0]
   1014e:	2b00      	cmp	r3, #0
   10150:	d109      	bne.n	10166 <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   10152:	4b22      	ldr	r3, [pc, #136]	; (101dc <prvAddNewTaskToReadyList+0xa8>)
   10154:	687a      	ldr	r2, [r7, #4]
   10156:	601a      	str	r2, [r3, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   10158:	4b1f      	ldr	r3, [pc, #124]	; (101d8 <prvAddNewTaskToReadyList+0xa4>)
   1015a:	681b      	ldr	r3, [r3, #0]
   1015c:	2b01      	cmp	r3, #1
   1015e:	d110      	bne.n	10182 <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   10160:	4b1f      	ldr	r3, [pc, #124]	; (101e0 <prvAddNewTaskToReadyList+0xac>)
   10162:	4798      	blx	r3
   10164:	e00d      	b.n	10182 <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   10166:	4b1f      	ldr	r3, [pc, #124]	; (101e4 <prvAddNewTaskToReadyList+0xb0>)
   10168:	681b      	ldr	r3, [r3, #0]
   1016a:	2b00      	cmp	r3, #0
   1016c:	d109      	bne.n	10182 <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   1016e:	4b1b      	ldr	r3, [pc, #108]	; (101dc <prvAddNewTaskToReadyList+0xa8>)
   10170:	681b      	ldr	r3, [r3, #0]
   10172:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10174:	687b      	ldr	r3, [r7, #4]
   10176:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10178:	429a      	cmp	r2, r3
   1017a:	d802      	bhi.n	10182 <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
   1017c:	4b17      	ldr	r3, [pc, #92]	; (101dc <prvAddNewTaskToReadyList+0xa8>)
   1017e:	687a      	ldr	r2, [r7, #4]
   10180:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   10182:	4b19      	ldr	r3, [pc, #100]	; (101e8 <prvAddNewTaskToReadyList+0xb4>)
   10184:	681b      	ldr	r3, [r3, #0]
   10186:	1c5a      	adds	r2, r3, #1
   10188:	4b17      	ldr	r3, [pc, #92]	; (101e8 <prvAddNewTaskToReadyList+0xb4>)
   1018a:	601a      	str	r2, [r3, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   1018c:	687b      	ldr	r3, [r7, #4]
   1018e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10190:	4b16      	ldr	r3, [pc, #88]	; (101ec <prvAddNewTaskToReadyList+0xb8>)
   10192:	681b      	ldr	r3, [r3, #0]
   10194:	429a      	cmp	r2, r3
   10196:	d903      	bls.n	101a0 <prvAddNewTaskToReadyList+0x6c>
   10198:	687b      	ldr	r3, [r7, #4]
   1019a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1019c:	4b13      	ldr	r3, [pc, #76]	; (101ec <prvAddNewTaskToReadyList+0xb8>)
   1019e:	601a      	str	r2, [r3, #0]
   101a0:	687b      	ldr	r3, [r7, #4]
   101a2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   101a4:	0013      	movs	r3, r2
   101a6:	009b      	lsls	r3, r3, #2
   101a8:	189b      	adds	r3, r3, r2
   101aa:	009b      	lsls	r3, r3, #2
   101ac:	4a10      	ldr	r2, [pc, #64]	; (101f0 <prvAddNewTaskToReadyList+0xbc>)
   101ae:	189a      	adds	r2, r3, r2
   101b0:	687b      	ldr	r3, [r7, #4]
   101b2:	3304      	adds	r3, #4
   101b4:	0019      	movs	r1, r3
   101b6:	0010      	movs	r0, r2
   101b8:	4b0e      	ldr	r3, [pc, #56]	; (101f4 <prvAddNewTaskToReadyList+0xc0>)
   101ba:	4798      	blx	r3

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   101bc:	4b0e      	ldr	r3, [pc, #56]	; (101f8 <prvAddNewTaskToReadyList+0xc4>)
   101be:	4798      	blx	r3

	if( xSchedulerRunning != pdFALSE )
   101c0:	4b08      	ldr	r3, [pc, #32]	; (101e4 <prvAddNewTaskToReadyList+0xb0>)
   101c2:	681b      	ldr	r3, [r3, #0]
   101c4:	2b00      	cmp	r3, #0
   101c6:	d001      	beq.n	101cc <prvAddNewTaskToReadyList+0x98>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   101c8:	4b04      	ldr	r3, [pc, #16]	; (101dc <prvAddNewTaskToReadyList+0xa8>)
   101ca:	681b      	ldr	r3, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   101cc:	46c0      	nop			; (mov r8, r8)
   101ce:	46bd      	mov	sp, r7
   101d0:	b002      	add	sp, #8
   101d2:	bd80      	pop	{r7, pc}
   101d4:	0000faf9 	.word	0x0000faf9
   101d8:	20002d9c 	.word	0x20002d9c
   101dc:	20002cc4 	.word	0x20002cc4
   101e0:	00010a25 	.word	0x00010a25
   101e4:	20002da8 	.word	0x20002da8
   101e8:	20002db8 	.word	0x20002db8
   101ec:	20002da4 	.word	0x20002da4
   101f0:	20002cc8 	.word	0x20002cc8
   101f4:	0000fd25 	.word	0x0000fd25
   101f8:	0000fb1d 	.word	0x0000fb1d

000101fc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
   101fc:	b580      	push	{r7, lr}
   101fe:	b084      	sub	sp, #16
   10200:	af00      	add	r7, sp, #0
   10202:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
   10204:	2300      	movs	r3, #0
   10206:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
   10208:	687b      	ldr	r3, [r7, #4]
   1020a:	2b00      	cmp	r3, #0
   1020c:	d010      	beq.n	10230 <vTaskDelay+0x34>
		{
			configASSERT( uxSchedulerSuspended == 0 );
   1020e:	4b0d      	ldr	r3, [pc, #52]	; (10244 <vTaskDelay+0x48>)
   10210:	681b      	ldr	r3, [r3, #0]
   10212:	2b00      	cmp	r3, #0
   10214:	d001      	beq.n	1021a <vTaskDelay+0x1e>
   10216:	b672      	cpsid	i
   10218:	e7fe      	b.n	10218 <vTaskDelay+0x1c>
			vTaskSuspendAll();
   1021a:	4b0b      	ldr	r3, [pc, #44]	; (10248 <vTaskDelay+0x4c>)
   1021c:	4798      	blx	r3
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   1021e:	687b      	ldr	r3, [r7, #4]
   10220:	2100      	movs	r1, #0
   10222:	0018      	movs	r0, r3
   10224:	4b09      	ldr	r3, [pc, #36]	; (1024c <vTaskDelay+0x50>)
   10226:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
   10228:	4b09      	ldr	r3, [pc, #36]	; (10250 <vTaskDelay+0x54>)
   1022a:	4798      	blx	r3
   1022c:	0003      	movs	r3, r0
   1022e:	60fb      	str	r3, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   10230:	68fb      	ldr	r3, [r7, #12]
   10232:	2b00      	cmp	r3, #0
   10234:	d101      	bne.n	1023a <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
   10236:	4b07      	ldr	r3, [pc, #28]	; (10254 <vTaskDelay+0x58>)
   10238:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   1023a:	46c0      	nop			; (mov r8, r8)
   1023c:	46bd      	mov	sp, r7
   1023e:	b004      	add	sp, #16
   10240:	bd80      	pop	{r7, pc}
   10242:	46c0      	nop			; (mov r8, r8)
   10244:	20002dc4 	.word	0x20002dc4
   10248:	00010565 	.word	0x00010565
   1024c:	00010d45 	.word	0x00010d45
   10250:	0001057d 	.word	0x0001057d
   10254:	0000fad9 	.word	0x0000fad9

00010258 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
   10258:	b580      	push	{r7, lr}
   1025a:	b086      	sub	sp, #24
   1025c:	af00      	add	r7, sp, #0
   1025e:	6078      	str	r0, [r7, #4]
	eTaskState eReturn;
	List_t *pxStateList;
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   10260:	687b      	ldr	r3, [r7, #4]
   10262:	613b      	str	r3, [r7, #16]

		configASSERT( pxTCB );
   10264:	693b      	ldr	r3, [r7, #16]
   10266:	2b00      	cmp	r3, #0
   10268:	d101      	bne.n	1026e <eTaskGetState+0x16>
   1026a:	b672      	cpsid	i
   1026c:	e7fe      	b.n	1026c <eTaskGetState+0x14>

		if( pxTCB == pxCurrentTCB )
   1026e:	4b24      	ldr	r3, [pc, #144]	; (10300 <eTaskGetState+0xa8>)
   10270:	681b      	ldr	r3, [r3, #0]
   10272:	693a      	ldr	r2, [r7, #16]
   10274:	429a      	cmp	r2, r3
   10276:	d104      	bne.n	10282 <eTaskGetState+0x2a>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
   10278:	2317      	movs	r3, #23
   1027a:	18fb      	adds	r3, r7, r3
   1027c:	2200      	movs	r2, #0
   1027e:	701a      	strb	r2, [r3, #0]
   10280:	e037      	b.n	102f2 <eTaskGetState+0x9a>
		}
		else
		{
			taskENTER_CRITICAL();
   10282:	4b20      	ldr	r3, [pc, #128]	; (10304 <eTaskGetState+0xac>)
   10284:	4798      	blx	r3
			{
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
   10286:	693b      	ldr	r3, [r7, #16]
   10288:	695b      	ldr	r3, [r3, #20]
   1028a:	60fb      	str	r3, [r7, #12]
			}
			taskEXIT_CRITICAL();
   1028c:	4b1e      	ldr	r3, [pc, #120]	; (10308 <eTaskGetState+0xb0>)
   1028e:	4798      	blx	r3

			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
   10290:	4b1e      	ldr	r3, [pc, #120]	; (1030c <eTaskGetState+0xb4>)
   10292:	681b      	ldr	r3, [r3, #0]
   10294:	68fa      	ldr	r2, [r7, #12]
   10296:	429a      	cmp	r2, r3
   10298:	d004      	beq.n	102a4 <eTaskGetState+0x4c>
   1029a:	4b1d      	ldr	r3, [pc, #116]	; (10310 <eTaskGetState+0xb8>)
   1029c:	681b      	ldr	r3, [r3, #0]
   1029e:	68fa      	ldr	r2, [r7, #12]
   102a0:	429a      	cmp	r2, r3
   102a2:	d104      	bne.n	102ae <eTaskGetState+0x56>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
   102a4:	2317      	movs	r3, #23
   102a6:	18fb      	adds	r3, r7, r3
   102a8:	2202      	movs	r2, #2
   102aa:	701a      	strb	r2, [r3, #0]
   102ac:	e021      	b.n	102f2 <eTaskGetState+0x9a>
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
   102ae:	68fa      	ldr	r2, [r7, #12]
   102b0:	4b18      	ldr	r3, [pc, #96]	; (10314 <eTaskGetState+0xbc>)
   102b2:	429a      	cmp	r2, r3
   102b4:	d10d      	bne.n	102d2 <eTaskGetState+0x7a>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it block
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   102b6:	693b      	ldr	r3, [r7, #16]
   102b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   102ba:	2b00      	cmp	r3, #0
   102bc:	d104      	bne.n	102c8 <eTaskGetState+0x70>
					{
						eReturn = eSuspended;
   102be:	2317      	movs	r3, #23
   102c0:	18fb      	adds	r3, r7, r3
   102c2:	2203      	movs	r2, #3
   102c4:	701a      	strb	r2, [r3, #0]
   102c6:	e014      	b.n	102f2 <eTaskGetState+0x9a>
					}
					else
					{
						eReturn = eBlocked;
   102c8:	2317      	movs	r3, #23
   102ca:	18fb      	adds	r3, r7, r3
   102cc:	2202      	movs	r2, #2
   102ce:	701a      	strb	r2, [r3, #0]
   102d0:	e00f      	b.n	102f2 <eTaskGetState+0x9a>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   102d2:	68fa      	ldr	r2, [r7, #12]
   102d4:	4b10      	ldr	r3, [pc, #64]	; (10318 <eTaskGetState+0xc0>)
   102d6:	429a      	cmp	r2, r3
   102d8:	d002      	beq.n	102e0 <eTaskGetState+0x88>
   102da:	68fb      	ldr	r3, [r7, #12]
   102dc:	2b00      	cmp	r3, #0
   102de:	d104      	bne.n	102ea <eTaskGetState+0x92>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
   102e0:	2317      	movs	r3, #23
   102e2:	18fb      	adds	r3, r7, r3
   102e4:	2204      	movs	r2, #4
   102e6:	701a      	strb	r2, [r3, #0]
   102e8:	e003      	b.n	102f2 <eTaskGetState+0x9a>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
   102ea:	2317      	movs	r3, #23
   102ec:	18fb      	adds	r3, r7, r3
   102ee:	2201      	movs	r2, #1
   102f0:	701a      	strb	r2, [r3, #0]
			}
		}

		return eReturn;
   102f2:	2317      	movs	r3, #23
   102f4:	18fb      	adds	r3, r7, r3
   102f6:	781b      	ldrb	r3, [r3, #0]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   102f8:	0018      	movs	r0, r3
   102fa:	46bd      	mov	sp, r7
   102fc:	b006      	add	sp, #24
   102fe:	bd80      	pop	{r7, pc}
   10300:	20002cc4 	.word	0x20002cc4
   10304:	0000faf9 	.word	0x0000faf9
   10308:	0000fb1d 	.word	0x0000fb1d
   1030c:	20002d54 	.word	0x20002d54
   10310:	20002d58 	.word	0x20002d58
   10314:	20002d88 	.word	0x20002d88
   10318:	20002d70 	.word	0x20002d70

0001031c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
   1031c:	b580      	push	{r7, lr}
   1031e:	b084      	sub	sp, #16
   10320:	af00      	add	r7, sp, #0
   10322:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
   10324:	4b26      	ldr	r3, [pc, #152]	; (103c0 <vTaskSuspend+0xa4>)
   10326:	4798      	blx	r3
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   10328:	687b      	ldr	r3, [r7, #4]
   1032a:	2b00      	cmp	r3, #0
   1032c:	d102      	bne.n	10334 <vTaskSuspend+0x18>
   1032e:	4b25      	ldr	r3, [pc, #148]	; (103c4 <vTaskSuspend+0xa8>)
   10330:	681b      	ldr	r3, [r3, #0]
   10332:	e000      	b.n	10336 <vTaskSuspend+0x1a>
   10334:	687b      	ldr	r3, [r7, #4]
   10336:	60fb      	str	r3, [r7, #12]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   10338:	68fb      	ldr	r3, [r7, #12]
   1033a:	3304      	adds	r3, #4
   1033c:	0018      	movs	r0, r3
   1033e:	4b22      	ldr	r3, [pc, #136]	; (103c8 <vTaskSuspend+0xac>)
   10340:	4798      	blx	r3
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   10342:	68fb      	ldr	r3, [r7, #12]
   10344:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10346:	2b00      	cmp	r3, #0
   10348:	d004      	beq.n	10354 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1034a:	68fb      	ldr	r3, [r7, #12]
   1034c:	3318      	adds	r3, #24
   1034e:	0018      	movs	r0, r3
   10350:	4b1d      	ldr	r3, [pc, #116]	; (103c8 <vTaskSuspend+0xac>)
   10352:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
   10354:	68fb      	ldr	r3, [r7, #12]
   10356:	1d1a      	adds	r2, r3, #4
   10358:	4b1c      	ldr	r3, [pc, #112]	; (103cc <vTaskSuspend+0xb0>)
   1035a:	0011      	movs	r1, r2
   1035c:	0018      	movs	r0, r3
   1035e:	4b1c      	ldr	r3, [pc, #112]	; (103d0 <vTaskSuspend+0xb4>)
   10360:	4798      	blx	r3
		}
		taskEXIT_CRITICAL();
   10362:	4b1c      	ldr	r3, [pc, #112]	; (103d4 <vTaskSuspend+0xb8>)
   10364:	4798      	blx	r3

		if( xSchedulerRunning != pdFALSE )
   10366:	4b1c      	ldr	r3, [pc, #112]	; (103d8 <vTaskSuspend+0xbc>)
   10368:	681b      	ldr	r3, [r3, #0]
   1036a:	2b00      	cmp	r3, #0
   1036c:	d005      	beq.n	1037a <vTaskSuspend+0x5e>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
   1036e:	4b14      	ldr	r3, [pc, #80]	; (103c0 <vTaskSuspend+0xa4>)
   10370:	4798      	blx	r3
			{
				prvResetNextTaskUnblockTime();
   10372:	4b1a      	ldr	r3, [pc, #104]	; (103dc <vTaskSuspend+0xc0>)
   10374:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
   10376:	4b17      	ldr	r3, [pc, #92]	; (103d4 <vTaskSuspend+0xb8>)
   10378:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
   1037a:	4b12      	ldr	r3, [pc, #72]	; (103c4 <vTaskSuspend+0xa8>)
   1037c:	681b      	ldr	r3, [r3, #0]
   1037e:	68fa      	ldr	r2, [r7, #12]
   10380:	429a      	cmp	r2, r3
   10382:	d118      	bne.n	103b6 <vTaskSuspend+0x9a>
		{
			if( xSchedulerRunning != pdFALSE )
   10384:	4b14      	ldr	r3, [pc, #80]	; (103d8 <vTaskSuspend+0xbc>)
   10386:	681b      	ldr	r3, [r3, #0]
   10388:	2b00      	cmp	r3, #0
   1038a:	d008      	beq.n	1039e <vTaskSuspend+0x82>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
   1038c:	4b14      	ldr	r3, [pc, #80]	; (103e0 <vTaskSuspend+0xc4>)
   1038e:	681b      	ldr	r3, [r3, #0]
   10390:	2b00      	cmp	r3, #0
   10392:	d001      	beq.n	10398 <vTaskSuspend+0x7c>
   10394:	b672      	cpsid	i
   10396:	e7fe      	b.n	10396 <vTaskSuspend+0x7a>
				portYIELD_WITHIN_API();
   10398:	4b12      	ldr	r3, [pc, #72]	; (103e4 <vTaskSuspend+0xc8>)
   1039a:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   1039c:	e00b      	b.n	103b6 <vTaskSuspend+0x9a>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   1039e:	4b0b      	ldr	r3, [pc, #44]	; (103cc <vTaskSuspend+0xb0>)
   103a0:	681a      	ldr	r2, [r3, #0]
   103a2:	4b11      	ldr	r3, [pc, #68]	; (103e8 <vTaskSuspend+0xcc>)
   103a4:	681b      	ldr	r3, [r3, #0]
   103a6:	429a      	cmp	r2, r3
   103a8:	d103      	bne.n	103b2 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
   103aa:	4b06      	ldr	r3, [pc, #24]	; (103c4 <vTaskSuspend+0xa8>)
   103ac:	2200      	movs	r2, #0
   103ae:	601a      	str	r2, [r3, #0]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   103b0:	e001      	b.n	103b6 <vTaskSuspend+0x9a>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
   103b2:	4b0e      	ldr	r3, [pc, #56]	; (103ec <vTaskSuspend+0xd0>)
   103b4:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   103b6:	46c0      	nop			; (mov r8, r8)
   103b8:	46bd      	mov	sp, r7
   103ba:	b004      	add	sp, #16
   103bc:	bd80      	pop	{r7, pc}
   103be:	46c0      	nop			; (mov r8, r8)
   103c0:	0000faf9 	.word	0x0000faf9
   103c4:	20002cc4 	.word	0x20002cc4
   103c8:	0000fdd5 	.word	0x0000fdd5
   103cc:	20002d88 	.word	0x20002d88
   103d0:	0000fd25 	.word	0x0000fd25
   103d4:	0000fb1d 	.word	0x0000fb1d
   103d8:	20002da8 	.word	0x20002da8
   103dc:	00010b65 	.word	0x00010b65
   103e0:	20002dc4 	.word	0x20002dc4
   103e4:	0000fad9 	.word	0x0000fad9
   103e8:	20002d9c 	.word	0x20002d9c
   103ec:	000108a5 	.word	0x000108a5

000103f0 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
   103f0:	b580      	push	{r7, lr}
   103f2:	b084      	sub	sp, #16
   103f4:	af00      	add	r7, sp, #0
   103f6:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn = pdFALSE;
   103f8:	2300      	movs	r3, #0
   103fa:	60fb      	str	r3, [r7, #12]
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   103fc:	687b      	ldr	r3, [r7, #4]
   103fe:	60bb      	str	r3, [r7, #8]

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
   10400:	687b      	ldr	r3, [r7, #4]
   10402:	2b00      	cmp	r3, #0
   10404:	d101      	bne.n	1040a <prvTaskIsTaskSuspended+0x1a>
   10406:	b672      	cpsid	i
   10408:	e7fe      	b.n	10408 <prvTaskIsTaskSuspended+0x18>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
   1040a:	68bb      	ldr	r3, [r7, #8]
   1040c:	695a      	ldr	r2, [r3, #20]
   1040e:	4b0e      	ldr	r3, [pc, #56]	; (10448 <prvTaskIsTaskSuspended+0x58>)
   10410:	429a      	cmp	r2, r3
   10412:	d101      	bne.n	10418 <prvTaskIsTaskSuspended+0x28>
   10414:	2301      	movs	r3, #1
   10416:	e000      	b.n	1041a <prvTaskIsTaskSuspended+0x2a>
   10418:	2300      	movs	r3, #0
   1041a:	2b00      	cmp	r3, #0
   1041c:	d00f      	beq.n	1043e <prvTaskIsTaskSuspended+0x4e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   1041e:	68bb      	ldr	r3, [r7, #8]
   10420:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   10422:	4b0a      	ldr	r3, [pc, #40]	; (1044c <prvTaskIsTaskSuspended+0x5c>)
   10424:	429a      	cmp	r2, r3
   10426:	d00a      	beq.n	1043e <prvTaskIsTaskSuspended+0x4e>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
   10428:	68bb      	ldr	r3, [r7, #8]
   1042a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1042c:	2b00      	cmp	r3, #0
   1042e:	d101      	bne.n	10434 <prvTaskIsTaskSuspended+0x44>
   10430:	2301      	movs	r3, #1
   10432:	e000      	b.n	10436 <prvTaskIsTaskSuspended+0x46>
   10434:	2300      	movs	r3, #0
   10436:	2b00      	cmp	r3, #0
   10438:	d001      	beq.n	1043e <prvTaskIsTaskSuspended+0x4e>
				{
					xReturn = pdTRUE;
   1043a:	2301      	movs	r3, #1
   1043c:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   1043e:	68fb      	ldr	r3, [r7, #12]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   10440:	0018      	movs	r0, r3
   10442:	46bd      	mov	sp, r7
   10444:	b004      	add	sp, #16
   10446:	bd80      	pop	{r7, pc}
   10448:	20002d88 	.word	0x20002d88
   1044c:	20002d5c 	.word	0x20002d5c

00010450 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
   10450:	b580      	push	{r7, lr}
   10452:	b084      	sub	sp, #16
   10454:	af00      	add	r7, sp, #0
   10456:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   10458:	687b      	ldr	r3, [r7, #4]
   1045a:	60fb      	str	r3, [r7, #12]

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
   1045c:	687b      	ldr	r3, [r7, #4]
   1045e:	2b00      	cmp	r3, #0
   10460:	d101      	bne.n	10466 <vTaskResume+0x16>
   10462:	b672      	cpsid	i
   10464:	e7fe      	b.n	10464 <vTaskResume+0x14>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   10466:	68fb      	ldr	r3, [r7, #12]
   10468:	2b00      	cmp	r3, #0
   1046a:	d02d      	beq.n	104c8 <vTaskResume+0x78>
   1046c:	4b18      	ldr	r3, [pc, #96]	; (104d0 <vTaskResume+0x80>)
   1046e:	681b      	ldr	r3, [r3, #0]
   10470:	68fa      	ldr	r2, [r7, #12]
   10472:	429a      	cmp	r2, r3
   10474:	d028      	beq.n	104c8 <vTaskResume+0x78>
		{
			taskENTER_CRITICAL();
   10476:	4b17      	ldr	r3, [pc, #92]	; (104d4 <vTaskResume+0x84>)
   10478:	4798      	blx	r3
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   1047a:	68fb      	ldr	r3, [r7, #12]
   1047c:	0018      	movs	r0, r3
   1047e:	4b16      	ldr	r3, [pc, #88]	; (104d8 <vTaskResume+0x88>)
   10480:	4798      	blx	r3
   10482:	1e03      	subs	r3, r0, #0
   10484:	d01e      	beq.n	104c4 <vTaskResume+0x74>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
   10486:	68fb      	ldr	r3, [r7, #12]
   10488:	3304      	adds	r3, #4
   1048a:	0018      	movs	r0, r3
   1048c:	4b13      	ldr	r3, [pc, #76]	; (104dc <vTaskResume+0x8c>)
   1048e:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
   10490:	68fb      	ldr	r3, [r7, #12]
   10492:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10494:	4b12      	ldr	r3, [pc, #72]	; (104e0 <vTaskResume+0x90>)
   10496:	681b      	ldr	r3, [r3, #0]
   10498:	429a      	cmp	r2, r3
   1049a:	d903      	bls.n	104a4 <vTaskResume+0x54>
   1049c:	68fb      	ldr	r3, [r7, #12]
   1049e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   104a0:	4b0f      	ldr	r3, [pc, #60]	; (104e0 <vTaskResume+0x90>)
   104a2:	601a      	str	r2, [r3, #0]
   104a4:	68fb      	ldr	r3, [r7, #12]
   104a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   104a8:	0013      	movs	r3, r2
   104aa:	009b      	lsls	r3, r3, #2
   104ac:	189b      	adds	r3, r3, r2
   104ae:	009b      	lsls	r3, r3, #2
   104b0:	4a0c      	ldr	r2, [pc, #48]	; (104e4 <vTaskResume+0x94>)
   104b2:	189a      	adds	r2, r3, r2
   104b4:	68fb      	ldr	r3, [r7, #12]
   104b6:	3304      	adds	r3, #4
   104b8:	0019      	movs	r1, r3
   104ba:	0010      	movs	r0, r2
   104bc:	4b0a      	ldr	r3, [pc, #40]	; (104e8 <vTaskResume+0x98>)
   104be:	4798      	blx	r3

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   104c0:	4b03      	ldr	r3, [pc, #12]	; (104d0 <vTaskResume+0x80>)
   104c2:	681b      	ldr	r3, [r3, #0]
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
   104c4:	4b09      	ldr	r3, [pc, #36]	; (104ec <vTaskResume+0x9c>)
   104c6:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   104c8:	46c0      	nop			; (mov r8, r8)
   104ca:	46bd      	mov	sp, r7
   104cc:	b004      	add	sp, #16
   104ce:	bd80      	pop	{r7, pc}
   104d0:	20002cc4 	.word	0x20002cc4
   104d4:	0000faf9 	.word	0x0000faf9
   104d8:	000103f1 	.word	0x000103f1
   104dc:	0000fdd5 	.word	0x0000fdd5
   104e0:	20002da4 	.word	0x20002da4
   104e4:	20002cc8 	.word	0x20002cc8
   104e8:	0000fd25 	.word	0x0000fd25
   104ec:	0000fb1d 	.word	0x0000fb1d

000104f0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   104f0:	b590      	push	{r4, r7, lr}
   104f2:	b085      	sub	sp, #20
   104f4:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
   104f6:	4913      	ldr	r1, [pc, #76]	; (10544 <vTaskStartScheduler+0x54>)
   104f8:	4813      	ldr	r0, [pc, #76]	; (10548 <vTaskStartScheduler+0x58>)
   104fa:	4b14      	ldr	r3, [pc, #80]	; (1054c <vTaskStartScheduler+0x5c>)
   104fc:	9301      	str	r3, [sp, #4]
   104fe:	2300      	movs	r3, #0
   10500:	9300      	str	r3, [sp, #0]
   10502:	2300      	movs	r3, #0
   10504:	22c8      	movs	r2, #200	; 0xc8
   10506:	4c12      	ldr	r4, [pc, #72]	; (10550 <vTaskStartScheduler+0x60>)
   10508:	47a0      	blx	r4
   1050a:	0003      	movs	r3, r0
   1050c:	607b      	str	r3, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   1050e:	687b      	ldr	r3, [r7, #4]
   10510:	2b01      	cmp	r3, #1
   10512:	d10d      	bne.n	10530 <vTaskStartScheduler+0x40>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
   10514:	b672      	cpsid	i
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   10516:	4b0f      	ldr	r3, [pc, #60]	; (10554 <vTaskStartScheduler+0x64>)
   10518:	2201      	movs	r2, #1
   1051a:	4252      	negs	r2, r2
   1051c:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   1051e:	4b0e      	ldr	r3, [pc, #56]	; (10558 <vTaskStartScheduler+0x68>)
   10520:	2201      	movs	r2, #1
   10522:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   10524:	4b0d      	ldr	r3, [pc, #52]	; (1055c <vTaskStartScheduler+0x6c>)
   10526:	2200      	movs	r2, #0
   10528:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   1052a:	4b0d      	ldr	r3, [pc, #52]	; (10560 <vTaskStartScheduler+0x70>)
   1052c:	4798      	blx	r3
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   1052e:	e004      	b.n	1053a <vTaskStartScheduler+0x4a>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   10530:	687b      	ldr	r3, [r7, #4]
   10532:	3301      	adds	r3, #1
   10534:	d101      	bne.n	1053a <vTaskStartScheduler+0x4a>
   10536:	b672      	cpsid	i
   10538:	e7fe      	b.n	10538 <vTaskStartScheduler+0x48>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   1053a:	46c0      	nop			; (mov r8, r8)
   1053c:	46bd      	mov	sp, r7
   1053e:	b003      	add	sp, #12
   10540:	bd90      	pop	{r4, r7, pc}
   10542:	46c0      	nop			; (mov r8, r8)
   10544:	00020ffc 	.word	0x00020ffc
   10548:	00010a09 	.word	0x00010a09
   1054c:	20002dc0 	.word	0x20002dc0
   10550:	0000ff91 	.word	0x0000ff91
   10554:	20002dbc 	.word	0x20002dbc
   10558:	20002da8 	.word	0x20002da8
   1055c:	20002da0 	.word	0x20002da0
   10560:	0000fa89 	.word	0x0000fa89

00010564 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
   10564:	b580      	push	{r7, lr}
   10566:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   10568:	4b03      	ldr	r3, [pc, #12]	; (10578 <vTaskSuspendAll+0x14>)
   1056a:	681b      	ldr	r3, [r3, #0]
   1056c:	1c5a      	adds	r2, r3, #1
   1056e:	4b02      	ldr	r3, [pc, #8]	; (10578 <vTaskSuspendAll+0x14>)
   10570:	601a      	str	r2, [r3, #0]
}
   10572:	46c0      	nop			; (mov r8, r8)
   10574:	46bd      	mov	sp, r7
   10576:	bd80      	pop	{r7, pc}
   10578:	20002dc4 	.word	0x20002dc4

0001057c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   1057c:	b580      	push	{r7, lr}
   1057e:	b084      	sub	sp, #16
   10580:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
   10582:	2300      	movs	r3, #0
   10584:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
   10586:	2300      	movs	r3, #0
   10588:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
   1058a:	4b37      	ldr	r3, [pc, #220]	; (10668 <xTaskResumeAll+0xec>)
   1058c:	681b      	ldr	r3, [r3, #0]
   1058e:	2b00      	cmp	r3, #0
   10590:	d101      	bne.n	10596 <xTaskResumeAll+0x1a>
   10592:	b672      	cpsid	i
   10594:	e7fe      	b.n	10594 <xTaskResumeAll+0x18>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   10596:	4b35      	ldr	r3, [pc, #212]	; (1066c <xTaskResumeAll+0xf0>)
   10598:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
   1059a:	4b33      	ldr	r3, [pc, #204]	; (10668 <xTaskResumeAll+0xec>)
   1059c:	681b      	ldr	r3, [r3, #0]
   1059e:	1e5a      	subs	r2, r3, #1
   105a0:	4b31      	ldr	r3, [pc, #196]	; (10668 <xTaskResumeAll+0xec>)
   105a2:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   105a4:	4b30      	ldr	r3, [pc, #192]	; (10668 <xTaskResumeAll+0xec>)
   105a6:	681b      	ldr	r3, [r3, #0]
   105a8:	2b00      	cmp	r3, #0
   105aa:	d155      	bne.n	10658 <xTaskResumeAll+0xdc>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   105ac:	4b30      	ldr	r3, [pc, #192]	; (10670 <xTaskResumeAll+0xf4>)
   105ae:	681b      	ldr	r3, [r3, #0]
   105b0:	2b00      	cmp	r3, #0
   105b2:	d051      	beq.n	10658 <xTaskResumeAll+0xdc>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   105b4:	e02f      	b.n	10616 <xTaskResumeAll+0x9a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   105b6:	4b2f      	ldr	r3, [pc, #188]	; (10674 <xTaskResumeAll+0xf8>)
   105b8:	68db      	ldr	r3, [r3, #12]
   105ba:	68db      	ldr	r3, [r3, #12]
   105bc:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   105be:	68fb      	ldr	r3, [r7, #12]
   105c0:	3318      	adds	r3, #24
   105c2:	0018      	movs	r0, r3
   105c4:	4b2c      	ldr	r3, [pc, #176]	; (10678 <xTaskResumeAll+0xfc>)
   105c6:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   105c8:	68fb      	ldr	r3, [r7, #12]
   105ca:	3304      	adds	r3, #4
   105cc:	0018      	movs	r0, r3
   105ce:	4b2a      	ldr	r3, [pc, #168]	; (10678 <xTaskResumeAll+0xfc>)
   105d0:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
   105d2:	68fb      	ldr	r3, [r7, #12]
   105d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   105d6:	4b29      	ldr	r3, [pc, #164]	; (1067c <xTaskResumeAll+0x100>)
   105d8:	681b      	ldr	r3, [r3, #0]
   105da:	429a      	cmp	r2, r3
   105dc:	d903      	bls.n	105e6 <xTaskResumeAll+0x6a>
   105de:	68fb      	ldr	r3, [r7, #12]
   105e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   105e2:	4b26      	ldr	r3, [pc, #152]	; (1067c <xTaskResumeAll+0x100>)
   105e4:	601a      	str	r2, [r3, #0]
   105e6:	68fb      	ldr	r3, [r7, #12]
   105e8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   105ea:	0013      	movs	r3, r2
   105ec:	009b      	lsls	r3, r3, #2
   105ee:	189b      	adds	r3, r3, r2
   105f0:	009b      	lsls	r3, r3, #2
   105f2:	4a23      	ldr	r2, [pc, #140]	; (10680 <xTaskResumeAll+0x104>)
   105f4:	189a      	adds	r2, r3, r2
   105f6:	68fb      	ldr	r3, [r7, #12]
   105f8:	3304      	adds	r3, #4
   105fa:	0019      	movs	r1, r3
   105fc:	0010      	movs	r0, r2
   105fe:	4b21      	ldr	r3, [pc, #132]	; (10684 <xTaskResumeAll+0x108>)
   10600:	4798      	blx	r3

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   10602:	68fb      	ldr	r3, [r7, #12]
   10604:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10606:	4b20      	ldr	r3, [pc, #128]	; (10688 <xTaskResumeAll+0x10c>)
   10608:	681b      	ldr	r3, [r3, #0]
   1060a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1060c:	429a      	cmp	r2, r3
   1060e:	d302      	bcc.n	10616 <xTaskResumeAll+0x9a>
					{
						xYieldPending = pdTRUE;
   10610:	4b1e      	ldr	r3, [pc, #120]	; (1068c <xTaskResumeAll+0x110>)
   10612:	2201      	movs	r2, #1
   10614:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   10616:	4b17      	ldr	r3, [pc, #92]	; (10674 <xTaskResumeAll+0xf8>)
   10618:	681b      	ldr	r3, [r3, #0]
   1061a:	2b00      	cmp	r3, #0
   1061c:	d1cb      	bne.n	105b6 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   1061e:	68fb      	ldr	r3, [r7, #12]
   10620:	2b00      	cmp	r3, #0
   10622:	d001      	beq.n	10628 <xTaskResumeAll+0xac>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   10624:	4b1a      	ldr	r3, [pc, #104]	; (10690 <xTaskResumeAll+0x114>)
   10626:	4798      	blx	r3
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   10628:	4b1a      	ldr	r3, [pc, #104]	; (10694 <xTaskResumeAll+0x118>)
   1062a:	681b      	ldr	r3, [r3, #0]
   1062c:	60bb      	str	r3, [r7, #8]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   1062e:	68bb      	ldr	r3, [r7, #8]
   10630:	2b00      	cmp	r3, #0
   10632:	d00f      	beq.n	10654 <xTaskResumeAll+0xd8>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   10634:	4b18      	ldr	r3, [pc, #96]	; (10698 <xTaskResumeAll+0x11c>)
   10636:	4798      	blx	r3
   10638:	1e03      	subs	r3, r0, #0
   1063a:	d002      	beq.n	10642 <xTaskResumeAll+0xc6>
							{
								xYieldPending = pdTRUE;
   1063c:	4b13      	ldr	r3, [pc, #76]	; (1068c <xTaskResumeAll+0x110>)
   1063e:	2201      	movs	r2, #1
   10640:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   10642:	68bb      	ldr	r3, [r7, #8]
   10644:	3b01      	subs	r3, #1
   10646:	60bb      	str	r3, [r7, #8]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   10648:	68bb      	ldr	r3, [r7, #8]
   1064a:	2b00      	cmp	r3, #0
   1064c:	d1f2      	bne.n	10634 <xTaskResumeAll+0xb8>

						uxPendedTicks = 0;
   1064e:	4b11      	ldr	r3, [pc, #68]	; (10694 <xTaskResumeAll+0x118>)
   10650:	2200      	movs	r2, #0
   10652:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   10654:	4b0d      	ldr	r3, [pc, #52]	; (1068c <xTaskResumeAll+0x110>)
   10656:	681b      	ldr	r3, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   10658:	4b10      	ldr	r3, [pc, #64]	; (1069c <xTaskResumeAll+0x120>)
   1065a:	4798      	blx	r3

	return xAlreadyYielded;
   1065c:	687b      	ldr	r3, [r7, #4]
}
   1065e:	0018      	movs	r0, r3
   10660:	46bd      	mov	sp, r7
   10662:	b004      	add	sp, #16
   10664:	bd80      	pop	{r7, pc}
   10666:	46c0      	nop			; (mov r8, r8)
   10668:	20002dc4 	.word	0x20002dc4
   1066c:	0000faf9 	.word	0x0000faf9
   10670:	20002d9c 	.word	0x20002d9c
   10674:	20002d5c 	.word	0x20002d5c
   10678:	0000fdd5 	.word	0x0000fdd5
   1067c:	20002da4 	.word	0x20002da4
   10680:	20002cc8 	.word	0x20002cc8
   10684:	0000fd25 	.word	0x0000fd25
   10688:	20002cc4 	.word	0x20002cc4
   1068c:	20002db0 	.word	0x20002db0
   10690:	00010b65 	.word	0x00010b65
   10694:	20002dac 	.word	0x20002dac
   10698:	0001075d 	.word	0x0001075d
   1069c:	0000fb1d 	.word	0x0000fb1d

000106a0 <xTaskAbortDelay>:
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskAbortDelay == 1 )

	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
	{
   106a0:	b580      	push	{r7, lr}
   106a2:	b084      	sub	sp, #16
   106a4:	af00      	add	r7, sp, #0
   106a6:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB = ( TCB_t * ) xTask;
   106a8:	687b      	ldr	r3, [r7, #4]
   106aa:	60fb      	str	r3, [r7, #12]
	BaseType_t xReturn = pdFALSE;
   106ac:	2300      	movs	r3, #0
   106ae:	60bb      	str	r3, [r7, #8]

		configASSERT( pxTCB );
   106b0:	68fb      	ldr	r3, [r7, #12]
   106b2:	2b00      	cmp	r3, #0
   106b4:	d101      	bne.n	106ba <xTaskAbortDelay+0x1a>
   106b6:	b672      	cpsid	i
   106b8:	e7fe      	b.n	106b8 <xTaskAbortDelay+0x18>

		vTaskSuspendAll();
   106ba:	4b1f      	ldr	r3, [pc, #124]	; (10738 <xTaskAbortDelay+0x98>)
   106bc:	4798      	blx	r3
		{
			/* A task can only be prematurely removed from the Blocked state if
			it is actually in the Blocked state. */
			if( eTaskGetState( xTask ) == eBlocked )
   106be:	687b      	ldr	r3, [r7, #4]
   106c0:	0018      	movs	r0, r3
   106c2:	4b1e      	ldr	r3, [pc, #120]	; (1073c <xTaskAbortDelay+0x9c>)
   106c4:	4798      	blx	r3
   106c6:	1e03      	subs	r3, r0, #0
   106c8:	2b02      	cmp	r3, #2
   106ca:	d12d      	bne.n	10728 <xTaskAbortDelay+0x88>
			{
				/* Remove the reference to the task from the blocked list.  An
				interrupt won't touch the xStateListItem because the
				scheduler is suspended. */
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   106cc:	68fb      	ldr	r3, [r7, #12]
   106ce:	3304      	adds	r3, #4
   106d0:	0018      	movs	r0, r3
   106d2:	4b1b      	ldr	r3, [pc, #108]	; (10740 <xTaskAbortDelay+0xa0>)
   106d4:	4798      	blx	r3

				/* Is the task waiting on an event also?  If so remove it from
				the event list too.  Interrupts can touch the event list item,
				even though the scheduler is suspended, so a critical section
				is used. */
				taskENTER_CRITICAL();
   106d6:	4b1b      	ldr	r3, [pc, #108]	; (10744 <xTaskAbortDelay+0xa4>)
   106d8:	4798      	blx	r3
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   106da:	68fb      	ldr	r3, [r7, #12]
   106dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   106de:	2b00      	cmp	r3, #0
   106e0:	d008      	beq.n	106f4 <xTaskAbortDelay+0x54>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   106e2:	68fb      	ldr	r3, [r7, #12]
   106e4:	3318      	adds	r3, #24
   106e6:	0018      	movs	r0, r3
   106e8:	4b15      	ldr	r3, [pc, #84]	; (10740 <xTaskAbortDelay+0xa0>)
   106ea:	4798      	blx	r3
						pxTCB->ucDelayAborted = pdTRUE;
   106ec:	68fb      	ldr	r3, [r7, #12]
   106ee:	2249      	movs	r2, #73	; 0x49
   106f0:	2101      	movs	r1, #1
   106f2:	5499      	strb	r1, [r3, r2]
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				taskEXIT_CRITICAL();
   106f4:	4b14      	ldr	r3, [pc, #80]	; (10748 <xTaskAbortDelay+0xa8>)
   106f6:	4798      	blx	r3

				/* Place the unblocked task into the appropriate ready list. */
				prvAddTaskToReadyList( pxTCB );
   106f8:	68fb      	ldr	r3, [r7, #12]
   106fa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   106fc:	4b13      	ldr	r3, [pc, #76]	; (1074c <xTaskAbortDelay+0xac>)
   106fe:	681b      	ldr	r3, [r3, #0]
   10700:	429a      	cmp	r2, r3
   10702:	d903      	bls.n	1070c <xTaskAbortDelay+0x6c>
   10704:	68fb      	ldr	r3, [r7, #12]
   10706:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10708:	4b10      	ldr	r3, [pc, #64]	; (1074c <xTaskAbortDelay+0xac>)
   1070a:	601a      	str	r2, [r3, #0]
   1070c:	68fb      	ldr	r3, [r7, #12]
   1070e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10710:	0013      	movs	r3, r2
   10712:	009b      	lsls	r3, r3, #2
   10714:	189b      	adds	r3, r3, r2
   10716:	009b      	lsls	r3, r3, #2
   10718:	4a0d      	ldr	r2, [pc, #52]	; (10750 <xTaskAbortDelay+0xb0>)
   1071a:	189a      	adds	r2, r3, r2
   1071c:	68fb      	ldr	r3, [r7, #12]
   1071e:	3304      	adds	r3, #4
   10720:	0019      	movs	r1, r3
   10722:	0010      	movs	r0, r2
   10724:	4b0b      	ldr	r3, [pc, #44]	; (10754 <xTaskAbortDelay+0xb4>)
   10726:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xTaskResumeAll();
   10728:	4b0b      	ldr	r3, [pc, #44]	; (10758 <xTaskAbortDelay+0xb8>)
   1072a:	4798      	blx	r3

		return xReturn;
   1072c:	68bb      	ldr	r3, [r7, #8]
	}
   1072e:	0018      	movs	r0, r3
   10730:	46bd      	mov	sp, r7
   10732:	b004      	add	sp, #16
   10734:	bd80      	pop	{r7, pc}
   10736:	46c0      	nop			; (mov r8, r8)
   10738:	00010565 	.word	0x00010565
   1073c:	00010259 	.word	0x00010259
   10740:	0000fdd5 	.word	0x0000fdd5
   10744:	0000faf9 	.word	0x0000faf9
   10748:	0000fb1d 	.word	0x0000fb1d
   1074c:	20002da4 	.word	0x20002da4
   10750:	20002cc8 	.word	0x20002cc8
   10754:	0000fd25 	.word	0x0000fd25
   10758:	0001057d 	.word	0x0001057d

0001075c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   1075c:	b580      	push	{r7, lr}
   1075e:	b086      	sub	sp, #24
   10760:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   10762:	2300      	movs	r3, #0
   10764:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   10766:	4b42      	ldr	r3, [pc, #264]	; (10870 <xTaskIncrementTick+0x114>)
   10768:	681b      	ldr	r3, [r3, #0]
   1076a:	2b00      	cmp	r3, #0
   1076c:	d000      	beq.n	10770 <xTaskIncrementTick+0x14>
   1076e:	e073      	b.n	10858 <xTaskIncrementTick+0xfc>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
   10770:	4b40      	ldr	r3, [pc, #256]	; (10874 <xTaskIncrementTick+0x118>)
   10772:	681b      	ldr	r3, [r3, #0]
   10774:	3301      	adds	r3, #1
   10776:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   10778:	4b3e      	ldr	r3, [pc, #248]	; (10874 <xTaskIncrementTick+0x118>)
   1077a:	693a      	ldr	r2, [r7, #16]
   1077c:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U )
   1077e:	693b      	ldr	r3, [r7, #16]
   10780:	2b00      	cmp	r3, #0
   10782:	d117      	bne.n	107b4 <xTaskIncrementTick+0x58>
		{
			taskSWITCH_DELAYED_LISTS();
   10784:	4b3c      	ldr	r3, [pc, #240]	; (10878 <xTaskIncrementTick+0x11c>)
   10786:	681b      	ldr	r3, [r3, #0]
   10788:	681b      	ldr	r3, [r3, #0]
   1078a:	2b00      	cmp	r3, #0
   1078c:	d001      	beq.n	10792 <xTaskIncrementTick+0x36>
   1078e:	b672      	cpsid	i
   10790:	e7fe      	b.n	10790 <xTaskIncrementTick+0x34>
   10792:	4b39      	ldr	r3, [pc, #228]	; (10878 <xTaskIncrementTick+0x11c>)
   10794:	681b      	ldr	r3, [r3, #0]
   10796:	60fb      	str	r3, [r7, #12]
   10798:	4b38      	ldr	r3, [pc, #224]	; (1087c <xTaskIncrementTick+0x120>)
   1079a:	681a      	ldr	r2, [r3, #0]
   1079c:	4b36      	ldr	r3, [pc, #216]	; (10878 <xTaskIncrementTick+0x11c>)
   1079e:	601a      	str	r2, [r3, #0]
   107a0:	4b36      	ldr	r3, [pc, #216]	; (1087c <xTaskIncrementTick+0x120>)
   107a2:	68fa      	ldr	r2, [r7, #12]
   107a4:	601a      	str	r2, [r3, #0]
   107a6:	4b36      	ldr	r3, [pc, #216]	; (10880 <xTaskIncrementTick+0x124>)
   107a8:	681b      	ldr	r3, [r3, #0]
   107aa:	1c5a      	adds	r2, r3, #1
   107ac:	4b34      	ldr	r3, [pc, #208]	; (10880 <xTaskIncrementTick+0x124>)
   107ae:	601a      	str	r2, [r3, #0]
   107b0:	4b34      	ldr	r3, [pc, #208]	; (10884 <xTaskIncrementTick+0x128>)
   107b2:	4798      	blx	r3

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   107b4:	4b34      	ldr	r3, [pc, #208]	; (10888 <xTaskIncrementTick+0x12c>)
   107b6:	681b      	ldr	r3, [r3, #0]
   107b8:	693a      	ldr	r2, [r7, #16]
   107ba:	429a      	cmp	r2, r3
   107bc:	d345      	bcc.n	1084a <xTaskIncrementTick+0xee>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   107be:	4b2e      	ldr	r3, [pc, #184]	; (10878 <xTaskIncrementTick+0x11c>)
   107c0:	681b      	ldr	r3, [r3, #0]
   107c2:	681b      	ldr	r3, [r3, #0]
   107c4:	2b00      	cmp	r3, #0
   107c6:	d101      	bne.n	107cc <xTaskIncrementTick+0x70>
   107c8:	2301      	movs	r3, #1
   107ca:	e000      	b.n	107ce <xTaskIncrementTick+0x72>
   107cc:	2300      	movs	r3, #0
   107ce:	2b00      	cmp	r3, #0
   107d0:	d004      	beq.n	107dc <xTaskIncrementTick+0x80>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   107d2:	4b2d      	ldr	r3, [pc, #180]	; (10888 <xTaskIncrementTick+0x12c>)
   107d4:	2201      	movs	r2, #1
   107d6:	4252      	negs	r2, r2
   107d8:	601a      	str	r2, [r3, #0]
					break;
   107da:	e036      	b.n	1084a <xTaskIncrementTick+0xee>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   107dc:	4b26      	ldr	r3, [pc, #152]	; (10878 <xTaskIncrementTick+0x11c>)
   107de:	681b      	ldr	r3, [r3, #0]
   107e0:	68db      	ldr	r3, [r3, #12]
   107e2:	68db      	ldr	r3, [r3, #12]
   107e4:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   107e6:	68bb      	ldr	r3, [r7, #8]
   107e8:	685b      	ldr	r3, [r3, #4]
   107ea:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
   107ec:	693a      	ldr	r2, [r7, #16]
   107ee:	687b      	ldr	r3, [r7, #4]
   107f0:	429a      	cmp	r2, r3
   107f2:	d203      	bcs.n	107fc <xTaskIncrementTick+0xa0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   107f4:	4b24      	ldr	r3, [pc, #144]	; (10888 <xTaskIncrementTick+0x12c>)
   107f6:	687a      	ldr	r2, [r7, #4]
   107f8:	601a      	str	r2, [r3, #0]
						break;
   107fa:	e026      	b.n	1084a <xTaskIncrementTick+0xee>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   107fc:	68bb      	ldr	r3, [r7, #8]
   107fe:	3304      	adds	r3, #4
   10800:	0018      	movs	r0, r3
   10802:	4b22      	ldr	r3, [pc, #136]	; (1088c <xTaskIncrementTick+0x130>)
   10804:	4798      	blx	r3

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   10806:	68bb      	ldr	r3, [r7, #8]
   10808:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1080a:	2b00      	cmp	r3, #0
   1080c:	d004      	beq.n	10818 <xTaskIncrementTick+0xbc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1080e:	68bb      	ldr	r3, [r7, #8]
   10810:	3318      	adds	r3, #24
   10812:	0018      	movs	r0, r3
   10814:	4b1d      	ldr	r3, [pc, #116]	; (1088c <xTaskIncrementTick+0x130>)
   10816:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   10818:	68bb      	ldr	r3, [r7, #8]
   1081a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1081c:	4b1c      	ldr	r3, [pc, #112]	; (10890 <xTaskIncrementTick+0x134>)
   1081e:	681b      	ldr	r3, [r3, #0]
   10820:	429a      	cmp	r2, r3
   10822:	d903      	bls.n	1082c <xTaskIncrementTick+0xd0>
   10824:	68bb      	ldr	r3, [r7, #8]
   10826:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10828:	4b19      	ldr	r3, [pc, #100]	; (10890 <xTaskIncrementTick+0x134>)
   1082a:	601a      	str	r2, [r3, #0]
   1082c:	68bb      	ldr	r3, [r7, #8]
   1082e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10830:	0013      	movs	r3, r2
   10832:	009b      	lsls	r3, r3, #2
   10834:	189b      	adds	r3, r3, r2
   10836:	009b      	lsls	r3, r3, #2
   10838:	4a16      	ldr	r2, [pc, #88]	; (10894 <xTaskIncrementTick+0x138>)
   1083a:	189a      	adds	r2, r3, r2
   1083c:	68bb      	ldr	r3, [r7, #8]
   1083e:	3304      	adds	r3, #4
   10840:	0019      	movs	r1, r3
   10842:	0010      	movs	r0, r2
   10844:	4b14      	ldr	r3, [pc, #80]	; (10898 <xTaskIncrementTick+0x13c>)
   10846:	4798      	blx	r3
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
   10848:	e7b9      	b.n	107be <xTaskIncrementTick+0x62>

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
   1084a:	4b14      	ldr	r3, [pc, #80]	; (1089c <xTaskIncrementTick+0x140>)
   1084c:	681b      	ldr	r3, [r3, #0]
   1084e:	2b00      	cmp	r3, #0
   10850:	d109      	bne.n	10866 <xTaskIncrementTick+0x10a>
			{
				vApplicationTickHook();
   10852:	4b13      	ldr	r3, [pc, #76]	; (108a0 <xTaskIncrementTick+0x144>)
   10854:	4798      	blx	r3
   10856:	e006      	b.n	10866 <xTaskIncrementTick+0x10a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   10858:	4b10      	ldr	r3, [pc, #64]	; (1089c <xTaskIncrementTick+0x140>)
   1085a:	681b      	ldr	r3, [r3, #0]
   1085c:	1c5a      	adds	r2, r3, #1
   1085e:	4b0f      	ldr	r3, [pc, #60]	; (1089c <xTaskIncrementTick+0x140>)
   10860:	601a      	str	r2, [r3, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
   10862:	4b0f      	ldr	r3, [pc, #60]	; (108a0 <xTaskIncrementTick+0x144>)
   10864:	4798      	blx	r3
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   10866:	697b      	ldr	r3, [r7, #20]
}
   10868:	0018      	movs	r0, r3
   1086a:	46bd      	mov	sp, r7
   1086c:	b006      	add	sp, #24
   1086e:	bd80      	pop	{r7, pc}
   10870:	20002dc4 	.word	0x20002dc4
   10874:	20002da0 	.word	0x20002da0
   10878:	20002d54 	.word	0x20002d54
   1087c:	20002d58 	.word	0x20002d58
   10880:	20002db4 	.word	0x20002db4
   10884:	00010b65 	.word	0x00010b65
   10888:	20002dbc 	.word	0x20002dbc
   1088c:	0000fdd5 	.word	0x0000fdd5
   10890:	20002da4 	.word	0x20002da4
   10894:	20002cc8 	.word	0x20002cc8
   10898:	0000fd25 	.word	0x0000fd25
   1089c:	20002dac 	.word	0x20002dac
   108a0:	0001af19 	.word	0x0001af19

000108a4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   108a4:	b580      	push	{r7, lr}
   108a6:	b082      	sub	sp, #8
   108a8:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   108aa:	4b22      	ldr	r3, [pc, #136]	; (10934 <vTaskSwitchContext+0x90>)
   108ac:	681b      	ldr	r3, [r3, #0]
   108ae:	2b00      	cmp	r3, #0
   108b0:	d003      	beq.n	108ba <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   108b2:	4b21      	ldr	r3, [pc, #132]	; (10938 <vTaskSwitchContext+0x94>)
   108b4:	2201      	movs	r2, #1
   108b6:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   108b8:	e037      	b.n	1092a <vTaskSwitchContext+0x86>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
   108ba:	4b1f      	ldr	r3, [pc, #124]	; (10938 <vTaskSwitchContext+0x94>)
   108bc:	2200      	movs	r2, #0
   108be:	601a      	str	r2, [r3, #0]
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
   108c0:	4b1e      	ldr	r3, [pc, #120]	; (1093c <vTaskSwitchContext+0x98>)
   108c2:	681b      	ldr	r3, [r3, #0]
   108c4:	607b      	str	r3, [r7, #4]
   108c6:	e007      	b.n	108d8 <vTaskSwitchContext+0x34>
   108c8:	687b      	ldr	r3, [r7, #4]
   108ca:	2b00      	cmp	r3, #0
   108cc:	d101      	bne.n	108d2 <vTaskSwitchContext+0x2e>
   108ce:	b672      	cpsid	i
   108d0:	e7fe      	b.n	108d0 <vTaskSwitchContext+0x2c>
   108d2:	687b      	ldr	r3, [r7, #4]
   108d4:	3b01      	subs	r3, #1
   108d6:	607b      	str	r3, [r7, #4]
   108d8:	4919      	ldr	r1, [pc, #100]	; (10940 <vTaskSwitchContext+0x9c>)
   108da:	687a      	ldr	r2, [r7, #4]
   108dc:	0013      	movs	r3, r2
   108de:	009b      	lsls	r3, r3, #2
   108e0:	189b      	adds	r3, r3, r2
   108e2:	009b      	lsls	r3, r3, #2
   108e4:	585b      	ldr	r3, [r3, r1]
   108e6:	2b00      	cmp	r3, #0
   108e8:	d0ee      	beq.n	108c8 <vTaskSwitchContext+0x24>
   108ea:	687a      	ldr	r2, [r7, #4]
   108ec:	0013      	movs	r3, r2
   108ee:	009b      	lsls	r3, r3, #2
   108f0:	189b      	adds	r3, r3, r2
   108f2:	009b      	lsls	r3, r3, #2
   108f4:	4a12      	ldr	r2, [pc, #72]	; (10940 <vTaskSwitchContext+0x9c>)
   108f6:	189b      	adds	r3, r3, r2
   108f8:	603b      	str	r3, [r7, #0]
   108fa:	683b      	ldr	r3, [r7, #0]
   108fc:	685b      	ldr	r3, [r3, #4]
   108fe:	685a      	ldr	r2, [r3, #4]
   10900:	683b      	ldr	r3, [r7, #0]
   10902:	605a      	str	r2, [r3, #4]
   10904:	683b      	ldr	r3, [r7, #0]
   10906:	685a      	ldr	r2, [r3, #4]
   10908:	683b      	ldr	r3, [r7, #0]
   1090a:	3308      	adds	r3, #8
   1090c:	429a      	cmp	r2, r3
   1090e:	d104      	bne.n	1091a <vTaskSwitchContext+0x76>
   10910:	683b      	ldr	r3, [r7, #0]
   10912:	685b      	ldr	r3, [r3, #4]
   10914:	685a      	ldr	r2, [r3, #4]
   10916:	683b      	ldr	r3, [r7, #0]
   10918:	605a      	str	r2, [r3, #4]
   1091a:	683b      	ldr	r3, [r7, #0]
   1091c:	685b      	ldr	r3, [r3, #4]
   1091e:	68da      	ldr	r2, [r3, #12]
   10920:	4b08      	ldr	r3, [pc, #32]	; (10944 <vTaskSwitchContext+0xa0>)
   10922:	601a      	str	r2, [r3, #0]
   10924:	4b05      	ldr	r3, [pc, #20]	; (1093c <vTaskSwitchContext+0x98>)
   10926:	687a      	ldr	r2, [r7, #4]
   10928:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   1092a:	46c0      	nop			; (mov r8, r8)
   1092c:	46bd      	mov	sp, r7
   1092e:	b002      	add	sp, #8
   10930:	bd80      	pop	{r7, pc}
   10932:	46c0      	nop			; (mov r8, r8)
   10934:	20002dc4 	.word	0x20002dc4
   10938:	20002db0 	.word	0x20002db0
   1093c:	20002da4 	.word	0x20002da4
   10940:	20002cc8 	.word	0x20002cc8
   10944:	20002cc4 	.word	0x20002cc4

00010948 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   10948:	b580      	push	{r7, lr}
   1094a:	b084      	sub	sp, #16
   1094c:	af00      	add	r7, sp, #0
   1094e:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   10950:	687b      	ldr	r3, [r7, #4]
   10952:	68db      	ldr	r3, [r3, #12]
   10954:	68db      	ldr	r3, [r3, #12]
   10956:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
   10958:	68bb      	ldr	r3, [r7, #8]
   1095a:	2b00      	cmp	r3, #0
   1095c:	d101      	bne.n	10962 <xTaskRemoveFromEventList+0x1a>
   1095e:	b672      	cpsid	i
   10960:	e7fe      	b.n	10960 <xTaskRemoveFromEventList+0x18>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   10962:	68bb      	ldr	r3, [r7, #8]
   10964:	3318      	adds	r3, #24
   10966:	0018      	movs	r0, r3
   10968:	4b1f      	ldr	r3, [pc, #124]	; (109e8 <xTaskRemoveFromEventList+0xa0>)
   1096a:	4798      	blx	r3

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1096c:	4b1f      	ldr	r3, [pc, #124]	; (109ec <xTaskRemoveFromEventList+0xa4>)
   1096e:	681b      	ldr	r3, [r3, #0]
   10970:	2b00      	cmp	r3, #0
   10972:	d11d      	bne.n	109b0 <xTaskRemoveFromEventList+0x68>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   10974:	68bb      	ldr	r3, [r7, #8]
   10976:	3304      	adds	r3, #4
   10978:	0018      	movs	r0, r3
   1097a:	4b1b      	ldr	r3, [pc, #108]	; (109e8 <xTaskRemoveFromEventList+0xa0>)
   1097c:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
   1097e:	68bb      	ldr	r3, [r7, #8]
   10980:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10982:	4b1b      	ldr	r3, [pc, #108]	; (109f0 <xTaskRemoveFromEventList+0xa8>)
   10984:	681b      	ldr	r3, [r3, #0]
   10986:	429a      	cmp	r2, r3
   10988:	d903      	bls.n	10992 <xTaskRemoveFromEventList+0x4a>
   1098a:	68bb      	ldr	r3, [r7, #8]
   1098c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1098e:	4b18      	ldr	r3, [pc, #96]	; (109f0 <xTaskRemoveFromEventList+0xa8>)
   10990:	601a      	str	r2, [r3, #0]
   10992:	68bb      	ldr	r3, [r7, #8]
   10994:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10996:	0013      	movs	r3, r2
   10998:	009b      	lsls	r3, r3, #2
   1099a:	189b      	adds	r3, r3, r2
   1099c:	009b      	lsls	r3, r3, #2
   1099e:	4a15      	ldr	r2, [pc, #84]	; (109f4 <xTaskRemoveFromEventList+0xac>)
   109a0:	189a      	adds	r2, r3, r2
   109a2:	68bb      	ldr	r3, [r7, #8]
   109a4:	3304      	adds	r3, #4
   109a6:	0019      	movs	r1, r3
   109a8:	0010      	movs	r0, r2
   109aa:	4b13      	ldr	r3, [pc, #76]	; (109f8 <xTaskRemoveFromEventList+0xb0>)
   109ac:	4798      	blx	r3
   109ae:	e007      	b.n	109c0 <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   109b0:	68bb      	ldr	r3, [r7, #8]
   109b2:	3318      	adds	r3, #24
   109b4:	001a      	movs	r2, r3
   109b6:	4b11      	ldr	r3, [pc, #68]	; (109fc <xTaskRemoveFromEventList+0xb4>)
   109b8:	0011      	movs	r1, r2
   109ba:	0018      	movs	r0, r3
   109bc:	4b0e      	ldr	r3, [pc, #56]	; (109f8 <xTaskRemoveFromEventList+0xb0>)
   109be:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   109c0:	68bb      	ldr	r3, [r7, #8]
   109c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   109c4:	4b0e      	ldr	r3, [pc, #56]	; (10a00 <xTaskRemoveFromEventList+0xb8>)
   109c6:	681b      	ldr	r3, [r3, #0]
   109c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   109ca:	429a      	cmp	r2, r3
   109cc:	d905      	bls.n	109da <xTaskRemoveFromEventList+0x92>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   109ce:	2301      	movs	r3, #1
   109d0:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   109d2:	4b0c      	ldr	r3, [pc, #48]	; (10a04 <xTaskRemoveFromEventList+0xbc>)
   109d4:	2201      	movs	r2, #1
   109d6:	601a      	str	r2, [r3, #0]
   109d8:	e001      	b.n	109de <xTaskRemoveFromEventList+0x96>
	}
	else
	{
		xReturn = pdFALSE;
   109da:	2300      	movs	r3, #0
   109dc:	60fb      	str	r3, [r7, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   109de:	68fb      	ldr	r3, [r7, #12]
}
   109e0:	0018      	movs	r0, r3
   109e2:	46bd      	mov	sp, r7
   109e4:	b004      	add	sp, #16
   109e6:	bd80      	pop	{r7, pc}
   109e8:	0000fdd5 	.word	0x0000fdd5
   109ec:	20002dc4 	.word	0x20002dc4
   109f0:	20002da4 	.word	0x20002da4
   109f4:	20002cc8 	.word	0x20002cc8
   109f8:	0000fd25 	.word	0x0000fd25
   109fc:	20002d5c 	.word	0x20002d5c
   10a00:	20002cc4 	.word	0x20002cc4
   10a04:	20002db0 	.word	0x20002db0

00010a08 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   10a08:	b580      	push	{r7, lr}
   10a0a:	b082      	sub	sp, #8
   10a0c:	af00      	add	r7, sp, #0
   10a0e:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   10a10:	4b02      	ldr	r3, [pc, #8]	; (10a1c <prvIdleTask+0x14>)
   10a12:	4798      	blx	r3
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
   10a14:	4b02      	ldr	r3, [pc, #8]	; (10a20 <prvIdleTask+0x18>)
   10a16:	4798      	blx	r3
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
   10a18:	e7fa      	b.n	10a10 <prvIdleTask+0x8>
   10a1a:	46c0      	nop			; (mov r8, r8)
   10a1c:	00010ab1 	.word	0x00010ab1
   10a20:	0000fad9 	.word	0x0000fad9

00010a24 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   10a24:	b580      	push	{r7, lr}
   10a26:	b082      	sub	sp, #8
   10a28:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   10a2a:	2300      	movs	r3, #0
   10a2c:	607b      	str	r3, [r7, #4]
   10a2e:	e00c      	b.n	10a4a <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   10a30:	687a      	ldr	r2, [r7, #4]
   10a32:	0013      	movs	r3, r2
   10a34:	009b      	lsls	r3, r3, #2
   10a36:	189b      	adds	r3, r3, r2
   10a38:	009b      	lsls	r3, r3, #2
   10a3a:	4a14      	ldr	r2, [pc, #80]	; (10a8c <prvInitialiseTaskLists+0x68>)
   10a3c:	189b      	adds	r3, r3, r2
   10a3e:	0018      	movs	r0, r3
   10a40:	4b13      	ldr	r3, [pc, #76]	; (10a90 <prvInitialiseTaskLists+0x6c>)
   10a42:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   10a44:	687b      	ldr	r3, [r7, #4]
   10a46:	3301      	adds	r3, #1
   10a48:	607b      	str	r3, [r7, #4]
   10a4a:	687b      	ldr	r3, [r7, #4]
   10a4c:	2b04      	cmp	r3, #4
   10a4e:	d9ef      	bls.n	10a30 <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
   10a50:	4b10      	ldr	r3, [pc, #64]	; (10a94 <prvInitialiseTaskLists+0x70>)
   10a52:	0018      	movs	r0, r3
   10a54:	4b0e      	ldr	r3, [pc, #56]	; (10a90 <prvInitialiseTaskLists+0x6c>)
   10a56:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
   10a58:	4b0f      	ldr	r3, [pc, #60]	; (10a98 <prvInitialiseTaskLists+0x74>)
   10a5a:	0018      	movs	r0, r3
   10a5c:	4b0c      	ldr	r3, [pc, #48]	; (10a90 <prvInitialiseTaskLists+0x6c>)
   10a5e:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
   10a60:	4b0e      	ldr	r3, [pc, #56]	; (10a9c <prvInitialiseTaskLists+0x78>)
   10a62:	0018      	movs	r0, r3
   10a64:	4b0a      	ldr	r3, [pc, #40]	; (10a90 <prvInitialiseTaskLists+0x6c>)
   10a66:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   10a68:	4b0d      	ldr	r3, [pc, #52]	; (10aa0 <prvInitialiseTaskLists+0x7c>)
   10a6a:	0018      	movs	r0, r3
   10a6c:	4b08      	ldr	r3, [pc, #32]	; (10a90 <prvInitialiseTaskLists+0x6c>)
   10a6e:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   10a70:	4b0c      	ldr	r3, [pc, #48]	; (10aa4 <prvInitialiseTaskLists+0x80>)
   10a72:	0018      	movs	r0, r3
   10a74:	4b06      	ldr	r3, [pc, #24]	; (10a90 <prvInitialiseTaskLists+0x6c>)
   10a76:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   10a78:	4b0b      	ldr	r3, [pc, #44]	; (10aa8 <prvInitialiseTaskLists+0x84>)
   10a7a:	4a06      	ldr	r2, [pc, #24]	; (10a94 <prvInitialiseTaskLists+0x70>)
   10a7c:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   10a7e:	4b0b      	ldr	r3, [pc, #44]	; (10aac <prvInitialiseTaskLists+0x88>)
   10a80:	4a05      	ldr	r2, [pc, #20]	; (10a98 <prvInitialiseTaskLists+0x74>)
   10a82:	601a      	str	r2, [r3, #0]
}
   10a84:	46c0      	nop			; (mov r8, r8)
   10a86:	46bd      	mov	sp, r7
   10a88:	b002      	add	sp, #8
   10a8a:	bd80      	pop	{r7, pc}
   10a8c:	20002cc8 	.word	0x20002cc8
   10a90:	0000fcd1 	.word	0x0000fcd1
   10a94:	20002d2c 	.word	0x20002d2c
   10a98:	20002d40 	.word	0x20002d40
   10a9c:	20002d5c 	.word	0x20002d5c
   10aa0:	20002d70 	.word	0x20002d70
   10aa4:	20002d88 	.word	0x20002d88
   10aa8:	20002d54 	.word	0x20002d54
   10aac:	20002d58 	.word	0x20002d58

00010ab0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   10ab0:	b580      	push	{r7, lr}
   10ab2:	b082      	sub	sp, #8
   10ab4:	af00      	add	r7, sp, #0
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   10ab6:	e027      	b.n	10b08 <prvCheckTasksWaitingTermination+0x58>
		{
			vTaskSuspendAll();
   10ab8:	4b17      	ldr	r3, [pc, #92]	; (10b18 <prvCheckTasksWaitingTermination+0x68>)
   10aba:	4798      	blx	r3
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   10abc:	4b17      	ldr	r3, [pc, #92]	; (10b1c <prvCheckTasksWaitingTermination+0x6c>)
   10abe:	681b      	ldr	r3, [r3, #0]
   10ac0:	425a      	negs	r2, r3
   10ac2:	4153      	adcs	r3, r2
   10ac4:	b2db      	uxtb	r3, r3
   10ac6:	607b      	str	r3, [r7, #4]
			}
			( void ) xTaskResumeAll();
   10ac8:	4b15      	ldr	r3, [pc, #84]	; (10b20 <prvCheckTasksWaitingTermination+0x70>)
   10aca:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
   10acc:	687b      	ldr	r3, [r7, #4]
   10ace:	2b00      	cmp	r3, #0
   10ad0:	d11a      	bne.n	10b08 <prvCheckTasksWaitingTermination+0x58>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
   10ad2:	4b14      	ldr	r3, [pc, #80]	; (10b24 <prvCheckTasksWaitingTermination+0x74>)
   10ad4:	4798      	blx	r3
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   10ad6:	4b11      	ldr	r3, [pc, #68]	; (10b1c <prvCheckTasksWaitingTermination+0x6c>)
   10ad8:	68db      	ldr	r3, [r3, #12]
   10ada:	68db      	ldr	r3, [r3, #12]
   10adc:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   10ade:	683b      	ldr	r3, [r7, #0]
   10ae0:	3304      	adds	r3, #4
   10ae2:	0018      	movs	r0, r3
   10ae4:	4b10      	ldr	r3, [pc, #64]	; (10b28 <prvCheckTasksWaitingTermination+0x78>)
   10ae6:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
   10ae8:	4b10      	ldr	r3, [pc, #64]	; (10b2c <prvCheckTasksWaitingTermination+0x7c>)
   10aea:	681b      	ldr	r3, [r3, #0]
   10aec:	1e5a      	subs	r2, r3, #1
   10aee:	4b0f      	ldr	r3, [pc, #60]	; (10b2c <prvCheckTasksWaitingTermination+0x7c>)
   10af0:	601a      	str	r2, [r3, #0]
					--uxDeletedTasksWaitingCleanUp;
   10af2:	4b0f      	ldr	r3, [pc, #60]	; (10b30 <prvCheckTasksWaitingTermination+0x80>)
   10af4:	681b      	ldr	r3, [r3, #0]
   10af6:	1e5a      	subs	r2, r3, #1
   10af8:	4b0d      	ldr	r3, [pc, #52]	; (10b30 <prvCheckTasksWaitingTermination+0x80>)
   10afa:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
   10afc:	4b0d      	ldr	r3, [pc, #52]	; (10b34 <prvCheckTasksWaitingTermination+0x84>)
   10afe:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
   10b00:	683b      	ldr	r3, [r7, #0]
   10b02:	0018      	movs	r0, r3
   10b04:	4b0c      	ldr	r3, [pc, #48]	; (10b38 <prvCheckTasksWaitingTermination+0x88>)
   10b06:	4798      	blx	r3
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   10b08:	4b09      	ldr	r3, [pc, #36]	; (10b30 <prvCheckTasksWaitingTermination+0x80>)
   10b0a:	681b      	ldr	r3, [r3, #0]
   10b0c:	2b00      	cmp	r3, #0
   10b0e:	d1d3      	bne.n	10ab8 <prvCheckTasksWaitingTermination+0x8>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   10b10:	46c0      	nop			; (mov r8, r8)
   10b12:	46bd      	mov	sp, r7
   10b14:	b002      	add	sp, #8
   10b16:	bd80      	pop	{r7, pc}
   10b18:	00010565 	.word	0x00010565
   10b1c:	20002d70 	.word	0x20002d70
   10b20:	0001057d 	.word	0x0001057d
   10b24:	0000faf9 	.word	0x0000faf9
   10b28:	0000fdd5 	.word	0x0000fdd5
   10b2c:	20002d9c 	.word	0x20002d9c
   10b30:	20002d84 	.word	0x20002d84
   10b34:	0000fb1d 	.word	0x0000fb1d
   10b38:	00010b3d 	.word	0x00010b3d

00010b3c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   10b3c:	b580      	push	{r7, lr}
   10b3e:	b082      	sub	sp, #8
   10b40:	af00      	add	r7, sp, #0
   10b42:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
   10b44:	687b      	ldr	r3, [r7, #4]
   10b46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   10b48:	0018      	movs	r0, r3
   10b4a:	4b05      	ldr	r3, [pc, #20]	; (10b60 <prvDeleteTCB+0x24>)
   10b4c:	4798      	blx	r3
			vPortFree( pxTCB );
   10b4e:	687b      	ldr	r3, [r7, #4]
   10b50:	0018      	movs	r0, r3
   10b52:	4b03      	ldr	r3, [pc, #12]	; (10b60 <prvDeleteTCB+0x24>)
   10b54:	4798      	blx	r3
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
   10b56:	46c0      	nop			; (mov r8, r8)
   10b58:	46bd      	mov	sp, r7
   10b5a:	b002      	add	sp, #8
   10b5c:	bd80      	pop	{r7, pc}
   10b5e:	46c0      	nop			; (mov r8, r8)
   10b60:	0000fcb5 	.word	0x0000fcb5

00010b64 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   10b64:	b580      	push	{r7, lr}
   10b66:	b082      	sub	sp, #8
   10b68:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   10b6a:	4b0e      	ldr	r3, [pc, #56]	; (10ba4 <prvResetNextTaskUnblockTime+0x40>)
   10b6c:	681b      	ldr	r3, [r3, #0]
   10b6e:	681b      	ldr	r3, [r3, #0]
   10b70:	2b00      	cmp	r3, #0
   10b72:	d101      	bne.n	10b78 <prvResetNextTaskUnblockTime+0x14>
   10b74:	2301      	movs	r3, #1
   10b76:	e000      	b.n	10b7a <prvResetNextTaskUnblockTime+0x16>
   10b78:	2300      	movs	r3, #0
   10b7a:	2b00      	cmp	r3, #0
   10b7c:	d004      	beq.n	10b88 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   10b7e:	4b0a      	ldr	r3, [pc, #40]	; (10ba8 <prvResetNextTaskUnblockTime+0x44>)
   10b80:	2201      	movs	r2, #1
   10b82:	4252      	negs	r2, r2
   10b84:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
   10b86:	e008      	b.n	10b9a <prvResetNextTaskUnblockTime+0x36>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   10b88:	4b06      	ldr	r3, [pc, #24]	; (10ba4 <prvResetNextTaskUnblockTime+0x40>)
   10b8a:	681b      	ldr	r3, [r3, #0]
   10b8c:	68db      	ldr	r3, [r3, #12]
   10b8e:	68db      	ldr	r3, [r3, #12]
   10b90:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   10b92:	687b      	ldr	r3, [r7, #4]
   10b94:	685a      	ldr	r2, [r3, #4]
   10b96:	4b04      	ldr	r3, [pc, #16]	; (10ba8 <prvResetNextTaskUnblockTime+0x44>)
   10b98:	601a      	str	r2, [r3, #0]
	}
}
   10b9a:	46c0      	nop			; (mov r8, r8)
   10b9c:	46bd      	mov	sp, r7
   10b9e:	b002      	add	sp, #8
   10ba0:	bd80      	pop	{r7, pc}
   10ba2:	46c0      	nop			; (mov r8, r8)
   10ba4:	20002d54 	.word	0x20002d54
   10ba8:	20002dbc 	.word	0x20002dbc

00010bac <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
   10bac:	b580      	push	{r7, lr}
   10bae:	b084      	sub	sp, #16
   10bb0:	af00      	add	r7, sp, #0
   10bb2:	6078      	str	r0, [r7, #4]
   10bb4:	6039      	str	r1, [r7, #0]
	uint32_t ulReturn;

		taskENTER_CRITICAL();
   10bb6:	4b1d      	ldr	r3, [pc, #116]	; (10c2c <ulTaskNotifyTake+0x80>)
   10bb8:	4798      	blx	r3
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   10bba:	4b1d      	ldr	r3, [pc, #116]	; (10c30 <ulTaskNotifyTake+0x84>)
   10bbc:	681b      	ldr	r3, [r3, #0]
   10bbe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   10bc0:	2b00      	cmp	r3, #0
   10bc2:	d10e      	bne.n	10be2 <ulTaskNotifyTake+0x36>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   10bc4:	4b1a      	ldr	r3, [pc, #104]	; (10c30 <ulTaskNotifyTake+0x84>)
   10bc6:	681b      	ldr	r3, [r3, #0]
   10bc8:	2248      	movs	r2, #72	; 0x48
   10bca:	2101      	movs	r1, #1
   10bcc:	5499      	strb	r1, [r3, r2]

				if( xTicksToWait > ( TickType_t ) 0 )
   10bce:	683b      	ldr	r3, [r7, #0]
   10bd0:	2b00      	cmp	r3, #0
   10bd2:	d006      	beq.n	10be2 <ulTaskNotifyTake+0x36>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   10bd4:	683b      	ldr	r3, [r7, #0]
   10bd6:	2101      	movs	r1, #1
   10bd8:	0018      	movs	r0, r3
   10bda:	4b16      	ldr	r3, [pc, #88]	; (10c34 <ulTaskNotifyTake+0x88>)
   10bdc:	4798      	blx	r3

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
   10bde:	4b16      	ldr	r3, [pc, #88]	; (10c38 <ulTaskNotifyTake+0x8c>)
   10be0:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   10be2:	4b16      	ldr	r3, [pc, #88]	; (10c3c <ulTaskNotifyTake+0x90>)
   10be4:	4798      	blx	r3

		taskENTER_CRITICAL();
   10be6:	4b11      	ldr	r3, [pc, #68]	; (10c2c <ulTaskNotifyTake+0x80>)
   10be8:	4798      	blx	r3
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
   10bea:	4b11      	ldr	r3, [pc, #68]	; (10c30 <ulTaskNotifyTake+0x84>)
   10bec:	681b      	ldr	r3, [r3, #0]
   10bee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   10bf0:	60fb      	str	r3, [r7, #12]

			if( ulReturn != 0UL )
   10bf2:	68fb      	ldr	r3, [r7, #12]
   10bf4:	2b00      	cmp	r3, #0
   10bf6:	d00c      	beq.n	10c12 <ulTaskNotifyTake+0x66>
			{
				if( xClearCountOnExit != pdFALSE )
   10bf8:	687b      	ldr	r3, [r7, #4]
   10bfa:	2b00      	cmp	r3, #0
   10bfc:	d004      	beq.n	10c08 <ulTaskNotifyTake+0x5c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
   10bfe:	4b0c      	ldr	r3, [pc, #48]	; (10c30 <ulTaskNotifyTake+0x84>)
   10c00:	681b      	ldr	r3, [r3, #0]
   10c02:	2200      	movs	r2, #0
   10c04:	645a      	str	r2, [r3, #68]	; 0x44
   10c06:	e004      	b.n	10c12 <ulTaskNotifyTake+0x66>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
   10c08:	4b09      	ldr	r3, [pc, #36]	; (10c30 <ulTaskNotifyTake+0x84>)
   10c0a:	681b      	ldr	r3, [r3, #0]
   10c0c:	68fa      	ldr	r2, [r7, #12]
   10c0e:	3a01      	subs	r2, #1
   10c10:	645a      	str	r2, [r3, #68]	; 0x44
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   10c12:	4b07      	ldr	r3, [pc, #28]	; (10c30 <ulTaskNotifyTake+0x84>)
   10c14:	681b      	ldr	r3, [r3, #0]
   10c16:	2248      	movs	r2, #72	; 0x48
   10c18:	2100      	movs	r1, #0
   10c1a:	5499      	strb	r1, [r3, r2]
		}
		taskEXIT_CRITICAL();
   10c1c:	4b07      	ldr	r3, [pc, #28]	; (10c3c <ulTaskNotifyTake+0x90>)
   10c1e:	4798      	blx	r3

		return ulReturn;
   10c20:	68fb      	ldr	r3, [r7, #12]
	}
   10c22:	0018      	movs	r0, r3
   10c24:	46bd      	mov	sp, r7
   10c26:	b004      	add	sp, #16
   10c28:	bd80      	pop	{r7, pc}
   10c2a:	46c0      	nop			; (mov r8, r8)
   10c2c:	0000faf9 	.word	0x0000faf9
   10c30:	20002cc4 	.word	0x20002cc4
   10c34:	00010d45 	.word	0x00010d45
   10c38:	0000fad9 	.word	0x0000fad9
   10c3c:	0000fb1d 	.word	0x0000fb1d

00010c40 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
   10c40:	b580      	push	{r7, lr}
   10c42:	b086      	sub	sp, #24
   10c44:	af00      	add	r7, sp, #0
   10c46:	6078      	str	r0, [r7, #4]
   10c48:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
   10c4a:	687b      	ldr	r3, [r7, #4]
   10c4c:	2b00      	cmp	r3, #0
   10c4e:	d101      	bne.n	10c54 <vTaskNotifyGiveFromISR+0x14>
   10c50:	b672      	cpsid	i
   10c52:	e7fe      	b.n	10c52 <vTaskNotifyGiveFromISR+0x12>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
   10c54:	687b      	ldr	r3, [r7, #4]
   10c56:	617b      	str	r3, [r7, #20]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   10c58:	4b30      	ldr	r3, [pc, #192]	; (10d1c <vTaskNotifyGiveFromISR+0xdc>)
   10c5a:	4798      	blx	r3
   10c5c:	0003      	movs	r3, r0
   10c5e:	613b      	str	r3, [r7, #16]
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
   10c60:	230f      	movs	r3, #15
   10c62:	18fb      	adds	r3, r7, r3
   10c64:	697a      	ldr	r2, [r7, #20]
   10c66:	2148      	movs	r1, #72	; 0x48
   10c68:	5c52      	ldrb	r2, [r2, r1]
   10c6a:	701a      	strb	r2, [r3, #0]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   10c6c:	697b      	ldr	r3, [r7, #20]
   10c6e:	2248      	movs	r2, #72	; 0x48
   10c70:	2102      	movs	r1, #2
   10c72:	5499      	strb	r1, [r3, r2]

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
   10c74:	697b      	ldr	r3, [r7, #20]
   10c76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   10c78:	1c5a      	adds	r2, r3, #1
   10c7a:	697b      	ldr	r3, [r7, #20]
   10c7c:	645a      	str	r2, [r3, #68]	; 0x44

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   10c7e:	230f      	movs	r3, #15
   10c80:	18fb      	adds	r3, r7, r3
   10c82:	781b      	ldrb	r3, [r3, #0]
   10c84:	2b01      	cmp	r3, #1
   10c86:	d140      	bne.n	10d0a <vTaskNotifyGiveFromISR+0xca>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   10c88:	697b      	ldr	r3, [r7, #20]
   10c8a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10c8c:	2b00      	cmp	r3, #0
   10c8e:	d001      	beq.n	10c94 <vTaskNotifyGiveFromISR+0x54>
   10c90:	b672      	cpsid	i
   10c92:	e7fe      	b.n	10c92 <vTaskNotifyGiveFromISR+0x52>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   10c94:	4b22      	ldr	r3, [pc, #136]	; (10d20 <vTaskNotifyGiveFromISR+0xe0>)
   10c96:	681b      	ldr	r3, [r3, #0]
   10c98:	2b00      	cmp	r3, #0
   10c9a:	d11d      	bne.n	10cd8 <vTaskNotifyGiveFromISR+0x98>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   10c9c:	697b      	ldr	r3, [r7, #20]
   10c9e:	3304      	adds	r3, #4
   10ca0:	0018      	movs	r0, r3
   10ca2:	4b20      	ldr	r3, [pc, #128]	; (10d24 <vTaskNotifyGiveFromISR+0xe4>)
   10ca4:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
   10ca6:	697b      	ldr	r3, [r7, #20]
   10ca8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10caa:	4b1f      	ldr	r3, [pc, #124]	; (10d28 <vTaskNotifyGiveFromISR+0xe8>)
   10cac:	681b      	ldr	r3, [r3, #0]
   10cae:	429a      	cmp	r2, r3
   10cb0:	d903      	bls.n	10cba <vTaskNotifyGiveFromISR+0x7a>
   10cb2:	697b      	ldr	r3, [r7, #20]
   10cb4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10cb6:	4b1c      	ldr	r3, [pc, #112]	; (10d28 <vTaskNotifyGiveFromISR+0xe8>)
   10cb8:	601a      	str	r2, [r3, #0]
   10cba:	697b      	ldr	r3, [r7, #20]
   10cbc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10cbe:	0013      	movs	r3, r2
   10cc0:	009b      	lsls	r3, r3, #2
   10cc2:	189b      	adds	r3, r3, r2
   10cc4:	009b      	lsls	r3, r3, #2
   10cc6:	4a19      	ldr	r2, [pc, #100]	; (10d2c <vTaskNotifyGiveFromISR+0xec>)
   10cc8:	189a      	adds	r2, r3, r2
   10cca:	697b      	ldr	r3, [r7, #20]
   10ccc:	3304      	adds	r3, #4
   10cce:	0019      	movs	r1, r3
   10cd0:	0010      	movs	r0, r2
   10cd2:	4b17      	ldr	r3, [pc, #92]	; (10d30 <vTaskNotifyGiveFromISR+0xf0>)
   10cd4:	4798      	blx	r3
   10cd6:	e007      	b.n	10ce8 <vTaskNotifyGiveFromISR+0xa8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   10cd8:	697b      	ldr	r3, [r7, #20]
   10cda:	3318      	adds	r3, #24
   10cdc:	001a      	movs	r2, r3
   10cde:	4b15      	ldr	r3, [pc, #84]	; (10d34 <vTaskNotifyGiveFromISR+0xf4>)
   10ce0:	0011      	movs	r1, r2
   10ce2:	0018      	movs	r0, r3
   10ce4:	4b12      	ldr	r3, [pc, #72]	; (10d30 <vTaskNotifyGiveFromISR+0xf0>)
   10ce6:	4798      	blx	r3
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   10ce8:	697b      	ldr	r3, [r7, #20]
   10cea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10cec:	4b12      	ldr	r3, [pc, #72]	; (10d38 <vTaskNotifyGiveFromISR+0xf8>)
   10cee:	681b      	ldr	r3, [r3, #0]
   10cf0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10cf2:	429a      	cmp	r2, r3
   10cf4:	d909      	bls.n	10d0a <vTaskNotifyGiveFromISR+0xca>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   10cf6:	683b      	ldr	r3, [r7, #0]
   10cf8:	2b00      	cmp	r3, #0
   10cfa:	d003      	beq.n	10d04 <vTaskNotifyGiveFromISR+0xc4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   10cfc:	683b      	ldr	r3, [r7, #0]
   10cfe:	2201      	movs	r2, #1
   10d00:	601a      	str	r2, [r3, #0]
   10d02:	e002      	b.n	10d0a <vTaskNotifyGiveFromISR+0xca>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
   10d04:	4b0d      	ldr	r3, [pc, #52]	; (10d3c <vTaskNotifyGiveFromISR+0xfc>)
   10d06:	2201      	movs	r2, #1
   10d08:	601a      	str	r2, [r3, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   10d0a:	693b      	ldr	r3, [r7, #16]
   10d0c:	0018      	movs	r0, r3
   10d0e:	4b0c      	ldr	r3, [pc, #48]	; (10d40 <vTaskNotifyGiveFromISR+0x100>)
   10d10:	4798      	blx	r3
	}
   10d12:	46c0      	nop			; (mov r8, r8)
   10d14:	46bd      	mov	sp, r7
   10d16:	b006      	add	sp, #24
   10d18:	bd80      	pop	{r7, pc}
   10d1a:	46c0      	nop			; (mov r8, r8)
   10d1c:	0000fb4d 	.word	0x0000fb4d
   10d20:	20002dc4 	.word	0x20002dc4
   10d24:	0000fdd5 	.word	0x0000fdd5
   10d28:	20002da4 	.word	0x20002da4
   10d2c:	20002cc8 	.word	0x20002cc8
   10d30:	0000fd25 	.word	0x0000fd25
   10d34:	20002d5c 	.word	0x20002d5c
   10d38:	20002cc4 	.word	0x20002cc4
   10d3c:	20002db0 	.word	0x20002db0
   10d40:	0000fb59 	.word	0x0000fb59

00010d44 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   10d44:	b580      	push	{r7, lr}
   10d46:	b084      	sub	sp, #16
   10d48:	af00      	add	r7, sp, #0
   10d4a:	6078      	str	r0, [r7, #4]
   10d4c:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   10d4e:	4b24      	ldr	r3, [pc, #144]	; (10de0 <prvAddCurrentTaskToDelayedList+0x9c>)
   10d50:	681b      	ldr	r3, [r3, #0]
   10d52:	60fb      	str	r3, [r7, #12]
	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
		reset to pdFALSE so it can be detected as having been set to pdTRUE
		when the task leaves the Blocked state. */
		pxCurrentTCB->ucDelayAborted = pdFALSE;
   10d54:	4b23      	ldr	r3, [pc, #140]	; (10de4 <prvAddCurrentTaskToDelayedList+0xa0>)
   10d56:	681b      	ldr	r3, [r3, #0]
   10d58:	2249      	movs	r2, #73	; 0x49
   10d5a:	2100      	movs	r1, #0
   10d5c:	5499      	strb	r1, [r3, r2]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   10d5e:	4b21      	ldr	r3, [pc, #132]	; (10de4 <prvAddCurrentTaskToDelayedList+0xa0>)
   10d60:	681b      	ldr	r3, [r3, #0]
   10d62:	3304      	adds	r3, #4
   10d64:	0018      	movs	r0, r3
   10d66:	4b20      	ldr	r3, [pc, #128]	; (10de8 <prvAddCurrentTaskToDelayedList+0xa4>)
   10d68:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   10d6a:	687b      	ldr	r3, [r7, #4]
   10d6c:	3301      	adds	r3, #1
   10d6e:	d10b      	bne.n	10d88 <prvAddCurrentTaskToDelayedList+0x44>
   10d70:	683b      	ldr	r3, [r7, #0]
   10d72:	2b00      	cmp	r3, #0
   10d74:	d008      	beq.n	10d88 <prvAddCurrentTaskToDelayedList+0x44>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   10d76:	4b1b      	ldr	r3, [pc, #108]	; (10de4 <prvAddCurrentTaskToDelayedList+0xa0>)
   10d78:	681b      	ldr	r3, [r3, #0]
   10d7a:	1d1a      	adds	r2, r3, #4
   10d7c:	4b1b      	ldr	r3, [pc, #108]	; (10dec <prvAddCurrentTaskToDelayedList+0xa8>)
   10d7e:	0011      	movs	r1, r2
   10d80:	0018      	movs	r0, r3
   10d82:	4b1b      	ldr	r3, [pc, #108]	; (10df0 <prvAddCurrentTaskToDelayedList+0xac>)
   10d84:	4798      	blx	r3

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   10d86:	e026      	b.n	10dd6 <prvAddCurrentTaskToDelayedList+0x92>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
   10d88:	68fa      	ldr	r2, [r7, #12]
   10d8a:	687b      	ldr	r3, [r7, #4]
   10d8c:	18d3      	adds	r3, r2, r3
   10d8e:	60bb      	str	r3, [r7, #8]

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   10d90:	4b14      	ldr	r3, [pc, #80]	; (10de4 <prvAddCurrentTaskToDelayedList+0xa0>)
   10d92:	681b      	ldr	r3, [r3, #0]
   10d94:	68ba      	ldr	r2, [r7, #8]
   10d96:	605a      	str	r2, [r3, #4]

			if( xTimeToWake < xConstTickCount )
   10d98:	68ba      	ldr	r2, [r7, #8]
   10d9a:	68fb      	ldr	r3, [r7, #12]
   10d9c:	429a      	cmp	r2, r3
   10d9e:	d209      	bcs.n	10db4 <prvAddCurrentTaskToDelayedList+0x70>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   10da0:	4b14      	ldr	r3, [pc, #80]	; (10df4 <prvAddCurrentTaskToDelayedList+0xb0>)
   10da2:	681a      	ldr	r2, [r3, #0]
   10da4:	4b0f      	ldr	r3, [pc, #60]	; (10de4 <prvAddCurrentTaskToDelayedList+0xa0>)
   10da6:	681b      	ldr	r3, [r3, #0]
   10da8:	3304      	adds	r3, #4
   10daa:	0019      	movs	r1, r3
   10dac:	0010      	movs	r0, r2
   10dae:	4b12      	ldr	r3, [pc, #72]	; (10df8 <prvAddCurrentTaskToDelayedList+0xb4>)
   10db0:	4798      	blx	r3

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   10db2:	e010      	b.n	10dd6 <prvAddCurrentTaskToDelayedList+0x92>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   10db4:	4b11      	ldr	r3, [pc, #68]	; (10dfc <prvAddCurrentTaskToDelayedList+0xb8>)
   10db6:	681a      	ldr	r2, [r3, #0]
   10db8:	4b0a      	ldr	r3, [pc, #40]	; (10de4 <prvAddCurrentTaskToDelayedList+0xa0>)
   10dba:	681b      	ldr	r3, [r3, #0]
   10dbc:	3304      	adds	r3, #4
   10dbe:	0019      	movs	r1, r3
   10dc0:	0010      	movs	r0, r2
   10dc2:	4b0d      	ldr	r3, [pc, #52]	; (10df8 <prvAddCurrentTaskToDelayedList+0xb4>)
   10dc4:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
   10dc6:	4b0e      	ldr	r3, [pc, #56]	; (10e00 <prvAddCurrentTaskToDelayedList+0xbc>)
   10dc8:	681b      	ldr	r3, [r3, #0]
   10dca:	68ba      	ldr	r2, [r7, #8]
   10dcc:	429a      	cmp	r2, r3
   10dce:	d202      	bcs.n	10dd6 <prvAddCurrentTaskToDelayedList+0x92>
				{
					xNextTaskUnblockTime = xTimeToWake;
   10dd0:	4b0b      	ldr	r3, [pc, #44]	; (10e00 <prvAddCurrentTaskToDelayedList+0xbc>)
   10dd2:	68ba      	ldr	r2, [r7, #8]
   10dd4:	601a      	str	r2, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   10dd6:	46c0      	nop			; (mov r8, r8)
   10dd8:	46bd      	mov	sp, r7
   10dda:	b004      	add	sp, #16
   10ddc:	bd80      	pop	{r7, pc}
   10dde:	46c0      	nop			; (mov r8, r8)
   10de0:	20002da0 	.word	0x20002da0
   10de4:	20002cc4 	.word	0x20002cc4
   10de8:	0000fdd5 	.word	0x0000fdd5
   10dec:	20002d88 	.word	0x20002d88
   10df0:	0000fd25 	.word	0x0000fd25
   10df4:	20002d58 	.word	0x20002d58
   10df8:	0000fd69 	.word	0x0000fd69
   10dfc:	20002d54 	.word	0x20002d54
   10e00:	20002dbc 	.word	0x20002dbc

00010e04 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   10e04:	b580      	push	{r7, lr}
   10e06:	b084      	sub	sp, #16
   10e08:	af00      	add	r7, sp, #0
   10e0a:	0002      	movs	r2, r0
   10e0c:	1dfb      	adds	r3, r7, #7
   10e0e:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
   10e10:	230f      	movs	r3, #15
   10e12:	18fb      	adds	r3, r7, r3
   10e14:	1dfa      	adds	r2, r7, #7
   10e16:	7812      	ldrb	r2, [r2, #0]
   10e18:	09d2      	lsrs	r2, r2, #7
   10e1a:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
   10e1c:	230e      	movs	r3, #14
   10e1e:	18fb      	adds	r3, r7, r3
   10e20:	1dfa      	adds	r2, r7, #7
   10e22:	7812      	ldrb	r2, [r2, #0]
   10e24:	0952      	lsrs	r2, r2, #5
   10e26:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
   10e28:	4b0d      	ldr	r3, [pc, #52]	; (10e60 <system_pinmux_get_group_from_gpio_pin+0x5c>)
   10e2a:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
   10e2c:	230f      	movs	r3, #15
   10e2e:	18fb      	adds	r3, r7, r3
   10e30:	781b      	ldrb	r3, [r3, #0]
   10e32:	2b00      	cmp	r3, #0
   10e34:	d10f      	bne.n	10e56 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
   10e36:	230f      	movs	r3, #15
   10e38:	18fb      	adds	r3, r7, r3
   10e3a:	781b      	ldrb	r3, [r3, #0]
   10e3c:	009b      	lsls	r3, r3, #2
   10e3e:	2210      	movs	r2, #16
   10e40:	4694      	mov	ip, r2
   10e42:	44bc      	add	ip, r7
   10e44:	4463      	add	r3, ip
   10e46:	3b08      	subs	r3, #8
   10e48:	681a      	ldr	r2, [r3, #0]
   10e4a:	230e      	movs	r3, #14
   10e4c:	18fb      	adds	r3, r7, r3
   10e4e:	781b      	ldrb	r3, [r3, #0]
   10e50:	01db      	lsls	r3, r3, #7
   10e52:	18d3      	adds	r3, r2, r3
   10e54:	e000      	b.n	10e58 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
   10e56:	2300      	movs	r3, #0
	}
}
   10e58:	0018      	movs	r0, r3
   10e5a:	46bd      	mov	sp, r7
   10e5c:	b004      	add	sp, #16
   10e5e:	bd80      	pop	{r7, pc}
   10e60:	41004400 	.word	0x41004400

00010e64 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   10e64:	b580      	push	{r7, lr}
   10e66:	b082      	sub	sp, #8
   10e68:	af00      	add	r7, sp, #0
   10e6a:	0002      	movs	r2, r0
   10e6c:	1dfb      	adds	r3, r7, #7
   10e6e:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
   10e70:	1dfb      	adds	r3, r7, #7
   10e72:	781b      	ldrb	r3, [r3, #0]
   10e74:	0018      	movs	r0, r3
   10e76:	4b03      	ldr	r3, [pc, #12]	; (10e84 <port_get_group_from_gpio_pin+0x20>)
   10e78:	4798      	blx	r3
   10e7a:	0003      	movs	r3, r0
}
   10e7c:	0018      	movs	r0, r3
   10e7e:	46bd      	mov	sp, r7
   10e80:	b002      	add	sp, #8
   10e82:	bd80      	pop	{r7, pc}
   10e84:	00010e05 	.word	0x00010e05

00010e88 <port_pin_get_input_level>:
 *
 *  \return Status of the port pin's input buffer.
 */
static inline bool port_pin_get_input_level(
		const uint8_t gpio_pin)
{
   10e88:	b580      	push	{r7, lr}
   10e8a:	b084      	sub	sp, #16
   10e8c:	af00      	add	r7, sp, #0
   10e8e:	0002      	movs	r2, r0
   10e90:	1dfb      	adds	r3, r7, #7
   10e92:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
   10e94:	1dfb      	adds	r3, r7, #7
   10e96:	781b      	ldrb	r3, [r3, #0]
   10e98:	0018      	movs	r0, r3
   10e9a:	4b0b      	ldr	r3, [pc, #44]	; (10ec8 <port_pin_get_input_level+0x40>)
   10e9c:	4798      	blx	r3
   10e9e:	0003      	movs	r3, r0
   10ea0:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   10ea2:	1dfb      	adds	r3, r7, #7
   10ea4:	781b      	ldrb	r3, [r3, #0]
   10ea6:	221f      	movs	r2, #31
   10ea8:	4013      	ands	r3, r2
   10eaa:	2201      	movs	r2, #1
   10eac:	409a      	lsls	r2, r3
   10eae:	0013      	movs	r3, r2
   10eb0:	60bb      	str	r3, [r7, #8]

	return (port_base->IN.reg & pin_mask);
   10eb2:	68fb      	ldr	r3, [r7, #12]
   10eb4:	6a1b      	ldr	r3, [r3, #32]
   10eb6:	68ba      	ldr	r2, [r7, #8]
   10eb8:	4013      	ands	r3, r2
   10eba:	1e5a      	subs	r2, r3, #1
   10ebc:	4193      	sbcs	r3, r2
   10ebe:	b2db      	uxtb	r3, r3
}
   10ec0:	0018      	movs	r0, r3
   10ec2:	46bd      	mov	sp, r7
   10ec4:	b004      	add	sp, #16
   10ec6:	bd80      	pop	{r7, pc}
   10ec8:	00010e65 	.word	0x00010e65

00010ecc <SDMMC_UNSTUFF_BITS>:
 * \brief Macro function to extract a bits field from a large SD MMC register
 * Used by : CSD, SCR, Switch status
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
   10ecc:	b590      	push	{r4, r7, lr}
   10ece:	b087      	sub	sp, #28
   10ed0:	af00      	add	r7, sp, #0
   10ed2:	60f8      	str	r0, [r7, #12]
   10ed4:	000c      	movs	r4, r1
   10ed6:	0010      	movs	r0, r2
   10ed8:	0019      	movs	r1, r3
   10eda:	230a      	movs	r3, #10
   10edc:	18fb      	adds	r3, r7, r3
   10ede:	1c22      	adds	r2, r4, #0
   10ee0:	801a      	strh	r2, [r3, #0]
   10ee2:	2308      	movs	r3, #8
   10ee4:	18fb      	adds	r3, r7, r3
   10ee6:	1c02      	adds	r2, r0, #0
   10ee8:	801a      	strh	r2, [r3, #0]
   10eea:	1dfb      	adds	r3, r7, #7
   10eec:	1c0a      	adds	r2, r1, #0
   10eee:	701a      	strb	r2, [r3, #0]
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
   10ef0:	230a      	movs	r3, #10
   10ef2:	18fb      	adds	r3, r7, r3
   10ef4:	881a      	ldrh	r2, [r3, #0]
   10ef6:	2308      	movs	r3, #8
   10ef8:	18fb      	adds	r3, r7, r3
   10efa:	881b      	ldrh	r3, [r3, #0]
   10efc:	1ad3      	subs	r3, r2, r3
   10efe:	3307      	adds	r3, #7
   10f00:	2b00      	cmp	r3, #0
   10f02:	da00      	bge.n	10f06 <SDMMC_UNSTUFF_BITS+0x3a>
   10f04:	3307      	adds	r3, #7
   10f06:	10db      	asrs	r3, r3, #3
   10f08:	3b01      	subs	r3, #1
   10f0a:	68fa      	ldr	r2, [r7, #12]
   10f0c:	18d3      	adds	r3, r2, r3
   10f0e:	781b      	ldrb	r3, [r3, #0]
   10f10:	0019      	movs	r1, r3
   10f12:	2308      	movs	r3, #8
   10f14:	18fb      	adds	r3, r7, r3
   10f16:	881b      	ldrh	r3, [r3, #0]
   10f18:	2207      	movs	r2, #7
   10f1a:	4013      	ands	r3, r2
   10f1c:	4119      	asrs	r1, r3
   10f1e:	000b      	movs	r3, r1
   10f20:	617b      	str	r3, [r7, #20]
	if (((pos % 8) + size) > 8) {
   10f22:	2308      	movs	r3, #8
   10f24:	18fb      	adds	r3, r7, r3
   10f26:	881b      	ldrh	r3, [r3, #0]
   10f28:	2207      	movs	r2, #7
   10f2a:	401a      	ands	r2, r3
   10f2c:	1dfb      	adds	r3, r7, #7
   10f2e:	781b      	ldrb	r3, [r3, #0]
   10f30:	18d3      	adds	r3, r2, r3
   10f32:	2b08      	cmp	r3, #8
   10f34:	dd1c      	ble.n	10f70 <SDMMC_UNSTUFF_BITS+0xa4>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
   10f36:	230a      	movs	r3, #10
   10f38:	18fb      	adds	r3, r7, r3
   10f3a:	881a      	ldrh	r2, [r3, #0]
   10f3c:	2308      	movs	r3, #8
   10f3e:	18fb      	adds	r3, r7, r3
   10f40:	881b      	ldrh	r3, [r3, #0]
   10f42:	1ad3      	subs	r3, r2, r3
   10f44:	3307      	adds	r3, #7
   10f46:	2b00      	cmp	r3, #0
   10f48:	da00      	bge.n	10f4c <SDMMC_UNSTUFF_BITS+0x80>
   10f4a:	3307      	adds	r3, #7
   10f4c:	10db      	asrs	r3, r3, #3
   10f4e:	3b02      	subs	r3, #2
   10f50:	68fa      	ldr	r2, [r7, #12]
   10f52:	18d3      	adds	r3, r2, r3
   10f54:	781b      	ldrb	r3, [r3, #0]
   10f56:	0019      	movs	r1, r3
   10f58:	2308      	movs	r3, #8
   10f5a:	18fb      	adds	r3, r7, r3
   10f5c:	881b      	ldrh	r3, [r3, #0]
   10f5e:	2207      	movs	r2, #7
   10f60:	4013      	ands	r3, r2
   10f62:	2208      	movs	r2, #8
   10f64:	1ad3      	subs	r3, r2, r3
   10f66:	4099      	lsls	r1, r3
   10f68:	000b      	movs	r3, r1
   10f6a:	697a      	ldr	r2, [r7, #20]
   10f6c:	4313      	orrs	r3, r2
   10f6e:	617b      	str	r3, [r7, #20]
	}
	if (((pos % 8) + size) > 16) {
   10f70:	2308      	movs	r3, #8
   10f72:	18fb      	adds	r3, r7, r3
   10f74:	881b      	ldrh	r3, [r3, #0]
   10f76:	2207      	movs	r2, #7
   10f78:	401a      	ands	r2, r3
   10f7a:	1dfb      	adds	r3, r7, #7
   10f7c:	781b      	ldrb	r3, [r3, #0]
   10f7e:	18d3      	adds	r3, r2, r3
   10f80:	2b10      	cmp	r3, #16
   10f82:	dd1c      	ble.n	10fbe <SDMMC_UNSTUFF_BITS+0xf2>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
   10f84:	230a      	movs	r3, #10
   10f86:	18fb      	adds	r3, r7, r3
   10f88:	881a      	ldrh	r2, [r3, #0]
   10f8a:	2308      	movs	r3, #8
   10f8c:	18fb      	adds	r3, r7, r3
   10f8e:	881b      	ldrh	r3, [r3, #0]
   10f90:	1ad3      	subs	r3, r2, r3
   10f92:	3307      	adds	r3, #7
   10f94:	2b00      	cmp	r3, #0
   10f96:	da00      	bge.n	10f9a <SDMMC_UNSTUFF_BITS+0xce>
   10f98:	3307      	adds	r3, #7
   10f9a:	10db      	asrs	r3, r3, #3
   10f9c:	3b03      	subs	r3, #3
   10f9e:	68fa      	ldr	r2, [r7, #12]
   10fa0:	18d3      	adds	r3, r2, r3
   10fa2:	781b      	ldrb	r3, [r3, #0]
   10fa4:	0019      	movs	r1, r3
   10fa6:	2308      	movs	r3, #8
   10fa8:	18fb      	adds	r3, r7, r3
   10faa:	881b      	ldrh	r3, [r3, #0]
   10fac:	2207      	movs	r2, #7
   10fae:	4013      	ands	r3, r2
   10fb0:	2210      	movs	r2, #16
   10fb2:	1ad3      	subs	r3, r2, r3
   10fb4:	4099      	lsls	r1, r3
   10fb6:	000b      	movs	r3, r1
   10fb8:	697a      	ldr	r2, [r7, #20]
   10fba:	4313      	orrs	r3, r2
   10fbc:	617b      	str	r3, [r7, #20]
	}
	if (((pos % 8) + size) > 16) {
   10fbe:	2308      	movs	r3, #8
   10fc0:	18fb      	adds	r3, r7, r3
   10fc2:	881b      	ldrh	r3, [r3, #0]
   10fc4:	2207      	movs	r2, #7
   10fc6:	401a      	ands	r2, r3
   10fc8:	1dfb      	adds	r3, r7, #7
   10fca:	781b      	ldrb	r3, [r3, #0]
   10fcc:	18d3      	adds	r3, r2, r3
   10fce:	2b10      	cmp	r3, #16
   10fd0:	dd1c      	ble.n	1100c <SDMMC_UNSTUFF_BITS+0x140>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
   10fd2:	230a      	movs	r3, #10
   10fd4:	18fb      	adds	r3, r7, r3
   10fd6:	881a      	ldrh	r2, [r3, #0]
   10fd8:	2308      	movs	r3, #8
   10fda:	18fb      	adds	r3, r7, r3
   10fdc:	881b      	ldrh	r3, [r3, #0]
   10fde:	1ad3      	subs	r3, r2, r3
   10fe0:	3307      	adds	r3, #7
   10fe2:	2b00      	cmp	r3, #0
   10fe4:	da00      	bge.n	10fe8 <SDMMC_UNSTUFF_BITS+0x11c>
   10fe6:	3307      	adds	r3, #7
   10fe8:	10db      	asrs	r3, r3, #3
   10fea:	3b03      	subs	r3, #3
   10fec:	68fa      	ldr	r2, [r7, #12]
   10fee:	18d3      	adds	r3, r2, r3
   10ff0:	781b      	ldrb	r3, [r3, #0]
   10ff2:	0019      	movs	r1, r3
   10ff4:	2308      	movs	r3, #8
   10ff6:	18fb      	adds	r3, r7, r3
   10ff8:	881b      	ldrh	r3, [r3, #0]
   10ffa:	2207      	movs	r2, #7
   10ffc:	4013      	ands	r3, r2
   10ffe:	2210      	movs	r2, #16
   11000:	1ad3      	subs	r3, r2, r3
   11002:	4099      	lsls	r1, r3
   11004:	000b      	movs	r3, r1
   11006:	697a      	ldr	r2, [r7, #20]
   11008:	4313      	orrs	r3, r2
   1100a:	617b      	str	r3, [r7, #20]
	}
	value &=  ((uint32_t)1 << size) - 1;
   1100c:	1dfb      	adds	r3, r7, #7
   1100e:	781b      	ldrb	r3, [r3, #0]
   11010:	2201      	movs	r2, #1
   11012:	409a      	lsls	r2, r3
   11014:	0013      	movs	r3, r2
   11016:	1e5a      	subs	r2, r3, #1
   11018:	697b      	ldr	r3, [r7, #20]
   1101a:	4013      	ands	r3, r2
   1101c:	617b      	str	r3, [r7, #20]
	return value;
   1101e:	697b      	ldr	r3, [r7, #20]
}
   11020:	0018      	movs	r0, r3
   11022:	46bd      	mov	sp, r7
   11024:	b007      	add	sp, #28
   11026:	bd90      	pop	{r4, r7, pc}

00011028 <SD_MMC_START_TIMEOUT>:
#ifdef FREERTOS_USED
	static TimeOut_t xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
   11028:	b5b0      	push	{r4, r5, r7, lr}
   1102a:	af00      	add	r7, sp, #0
	if (!SysTick->CTRL) {
   1102c:	4b11      	ldr	r3, [pc, #68]	; (11074 <SD_MMC_START_TIMEOUT+0x4c>)
   1102e:	681b      	ldr	r3, [r3, #0]
   11030:	2b00      	cmp	r3, #0
   11032:	d114      	bne.n	1105e <SD_MMC_START_TIMEOUT+0x36>
		sd_mmc_sam_systick_used = true;
   11034:	4b10      	ldr	r3, [pc, #64]	; (11078 <SD_MMC_START_TIMEOUT+0x50>)
   11036:	2201      	movs	r2, #1
   11038:	701a      	strb	r2, [r3, #0]
		SysTick->LOAD = (system_gclk_gen_get_hz(0) / (8 * 1000))
   1103a:	4c0e      	ldr	r4, [pc, #56]	; (11074 <SD_MMC_START_TIMEOUT+0x4c>)
   1103c:	2000      	movs	r0, #0
   1103e:	4b0f      	ldr	r3, [pc, #60]	; (1107c <SD_MMC_START_TIMEOUT+0x54>)
   11040:	4798      	blx	r3
   11042:	4b0f      	ldr	r3, [pc, #60]	; (11080 <SD_MMC_START_TIMEOUT+0x58>)
   11044:	22fa      	movs	r2, #250	; 0xfa
   11046:	0151      	lsls	r1, r2, #5
   11048:	4798      	blx	r3
   1104a:	0003      	movs	r3, r0
   1104c:	001a      	movs	r2, r3
				* SD_MMC_DEBOUNCE_TIMEOUT;
   1104e:	23fa      	movs	r3, #250	; 0xfa
   11050:	009b      	lsls	r3, r3, #2
   11052:	4353      	muls	r3, r2

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (system_gclk_gen_get_hz(0) / (8 * 1000))
   11054:	6063      	str	r3, [r4, #4]
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
   11056:	4b07      	ldr	r3, [pc, #28]	; (11074 <SD_MMC_START_TIMEOUT+0x4c>)
   11058:	2201      	movs	r2, #1
   1105a:	601a      	str	r2, [r3, #0]
#else
        vTaskDelay(TASK_DELAY_MS(SD_MMC_DEBOUNCE_TIMEOUT));
		//delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
#endif
	}
}
   1105c:	e007      	b.n	1106e <SD_MMC_START_TIMEOUT+0x46>
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (system_gclk_gen_get_hz(0) / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
   1105e:	4b06      	ldr	r3, [pc, #24]	; (11078 <SD_MMC_START_TIMEOUT+0x50>)
   11060:	2200      	movs	r2, #0
   11062:	701a      	strb	r2, [r3, #0]
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
        vTaskDelay(TASK_DELAY_MS(SD_MMC_DEBOUNCE_TIMEOUT));
   11064:	23fa      	movs	r3, #250	; 0xfa
   11066:	009b      	lsls	r3, r3, #2
   11068:	0018      	movs	r0, r3
   1106a:	4b06      	ldr	r3, [pc, #24]	; (11084 <SD_MMC_START_TIMEOUT+0x5c>)
   1106c:	4798      	blx	r3
		//delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
#endif
	}
}
   1106e:	46c0      	nop			; (mov r8, r8)
   11070:	46bd      	mov	sp, r7
   11072:	bdb0      	pop	{r4, r5, r7, pc}
   11074:	e000e010 	.word	0xe000e010
   11078:	20002dd4 	.word	0x20002dd4
   1107c:	00016909 	.word	0x00016909
   11080:	0001d485 	.word	0x0001d485
   11084:	000101fd 	.word	0x000101fd

00011088 <SD_MMC_IS_TIMEOUT>:

static inline bool SD_MMC_IS_TIMEOUT(void)
{
   11088:	b580      	push	{r7, lr}
   1108a:	af00      	add	r7, sp, #0
	if (!sd_mmc_sam_systick_used) {
   1108c:	4b0b      	ldr	r3, [pc, #44]	; (110bc <SD_MMC_IS_TIMEOUT+0x34>)
   1108e:	781b      	ldrb	r3, [r3, #0]
   11090:	2201      	movs	r2, #1
   11092:	4053      	eors	r3, r2
   11094:	b2db      	uxtb	r3, r3
   11096:	2b00      	cmp	r3, #0
   11098:	d001      	beq.n	1109e <SD_MMC_IS_TIMEOUT+0x16>
#ifdef FREERTOS_USED
		TickType_t xTicksToWait =
				SD_MMC_DEBOUNCE_TIMEOUT / portTICK_PERIOD_MS;
		return (xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE);
#else
		return true;
   1109a:	2301      	movs	r3, #1
   1109c:	e00b      	b.n	110b6 <SD_MMC_IS_TIMEOUT+0x2e>
#endif
	}
	if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
   1109e:	4b08      	ldr	r3, [pc, #32]	; (110c0 <SD_MMC_IS_TIMEOUT+0x38>)
   110a0:	681a      	ldr	r2, [r3, #0]
   110a2:	2380      	movs	r3, #128	; 0x80
   110a4:	025b      	lsls	r3, r3, #9
   110a6:	4013      	ands	r3, r2
   110a8:	d004      	beq.n	110b4 <SD_MMC_IS_TIMEOUT+0x2c>
		SysTick->CTRL = 0;
   110aa:	4b05      	ldr	r3, [pc, #20]	; (110c0 <SD_MMC_IS_TIMEOUT+0x38>)
   110ac:	2200      	movs	r2, #0
   110ae:	601a      	str	r2, [r3, #0]
		return true;
   110b0:	2301      	movs	r3, #1
   110b2:	e000      	b.n	110b6 <SD_MMC_IS_TIMEOUT+0x2e>
	}
	return false;
   110b4:	2300      	movs	r3, #0
}
   110b6:	0018      	movs	r0, r3
   110b8:	46bd      	mov	sp, r7
   110ba:	bd80      	pop	{r7, pc}
   110bc:	20002dd4 	.word	0x20002dd4
   110c0:	e000e010 	.word	0xe000e010

000110c4 <SD_MMC_STOP_TIMEOUT>:

static inline void SD_MMC_STOP_TIMEOUT(void)
{
   110c4:	b580      	push	{r7, lr}
   110c6:	af00      	add	r7, sp, #0
	if (sd_mmc_sam_systick_used) {
   110c8:	4b04      	ldr	r3, [pc, #16]	; (110dc <SD_MMC_STOP_TIMEOUT+0x18>)
   110ca:	781b      	ldrb	r3, [r3, #0]
   110cc:	2b00      	cmp	r3, #0
   110ce:	d002      	beq.n	110d6 <SD_MMC_STOP_TIMEOUT+0x12>
		SysTick->CTRL = 0;
   110d0:	4b03      	ldr	r3, [pc, #12]	; (110e0 <SD_MMC_STOP_TIMEOUT+0x1c>)
   110d2:	2200      	movs	r2, #0
   110d4:	601a      	str	r2, [r3, #0]
	}
}
   110d6:	46c0      	nop			; (mov r8, r8)
   110d8:	46bd      	mov	sp, r7
   110da:	bd80      	pop	{r7, pc}
   110dc:	20002dd4 	.word	0x20002dd4
   110e0:	e000e010 	.word	0xe000e010

000110e4 <mmc_spi_op_cond>:
 * - CMD58 reads OCR
 *
 * \return true if success, otherwise false
 */
static bool mmc_spi_op_cond(void)
{
   110e4:	b580      	push	{r7, lr}
   110e6:	b082      	sub	sp, #8
   110e8:	af00      	add	r7, sp, #0
	/*
	 * Timeout 1s = 400KHz / ((6+1)*8) cylces = 7150 retry
	 * 6 = cmd byte size
	 * 1 = response byte size
	 */
	retry = 7150;
   110ea:	4b23      	ldr	r3, [pc, #140]	; (11178 <mmc_spi_op_cond+0x94>)
   110ec:	607b      	str	r3, [r7, #4]
	do {
		if (!driver_send_cmd(MMC_SPI_CMD1_SEND_OP_COND, 0)) {
   110ee:	4b23      	ldr	r3, [pc, #140]	; (1117c <mmc_spi_op_cond+0x98>)
   110f0:	2100      	movs	r1, #0
   110f2:	0018      	movs	r0, r3
   110f4:	4b22      	ldr	r3, [pc, #136]	; (11180 <mmc_spi_op_cond+0x9c>)
   110f6:	4798      	blx	r3
   110f8:	0003      	movs	r3, r0
   110fa:	001a      	movs	r2, r3
   110fc:	2301      	movs	r3, #1
   110fe:	4053      	eors	r3, r2
   11100:	b2db      	uxtb	r3, r3
   11102:	2b00      	cmp	r3, #0
   11104:	d001      	beq.n	1110a <mmc_spi_op_cond+0x26>
			sd_mmc_debug("%s: CMD1 SPI Fail - Busy retry %d\n\r",
					__func__, (int)(7150 - retry));
			return false;
   11106:	2300      	movs	r3, #0
   11108:	e031      	b.n	1116e <mmc_spi_op_cond+0x8a>
		}
		// Check busy flag
		resp = driver_get_response();
   1110a:	4b1e      	ldr	r3, [pc, #120]	; (11184 <mmc_spi_op_cond+0xa0>)
   1110c:	4798      	blx	r3
   1110e:	0003      	movs	r3, r0
   11110:	603b      	str	r3, [r7, #0]
		if (!(resp & R1_SPI_IDLE)) {
   11112:	683b      	ldr	r3, [r7, #0]
   11114:	2201      	movs	r2, #1
   11116:	4013      	ands	r3, r2
   11118:	d006      	beq.n	11128 <mmc_spi_op_cond+0x44>
			break;
		}
		if (retry-- == 0) {
   1111a:	687b      	ldr	r3, [r7, #4]
   1111c:	1e5a      	subs	r2, r3, #1
   1111e:	607a      	str	r2, [r7, #4]
   11120:	2b00      	cmp	r3, #0
   11122:	d1e4      	bne.n	110ee <mmc_spi_op_cond+0xa>
			sd_mmc_debug("%s: CMD1 Timeout on busy\n\r", __func__);
			return false;
   11124:	2300      	movs	r3, #0
   11126:	e022      	b.n	1116e <mmc_spi_op_cond+0x8a>
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
		if (!(resp & R1_SPI_IDLE)) {
			break;
   11128:	46c0      	nop			; (mov r8, r8)
			return false;
		}
	} while (1);

	// Read OCR for SPI mode
	if (!driver_send_cmd(SDMMC_SPI_CMD58_READ_OCR, 0)) {
   1112a:	4b17      	ldr	r3, [pc, #92]	; (11188 <mmc_spi_op_cond+0xa4>)
   1112c:	2100      	movs	r1, #0
   1112e:	0018      	movs	r0, r3
   11130:	4b13      	ldr	r3, [pc, #76]	; (11180 <mmc_spi_op_cond+0x9c>)
   11132:	4798      	blx	r3
   11134:	0003      	movs	r3, r0
   11136:	001a      	movs	r2, r3
   11138:	2301      	movs	r3, #1
   1113a:	4053      	eors	r3, r2
   1113c:	b2db      	uxtb	r3, r3
   1113e:	2b00      	cmp	r3, #0
   11140:	d001      	beq.n	11146 <mmc_spi_op_cond+0x62>
		sd_mmc_debug("%s: CMD58 Fail\n\r", __func__);
		return false;
   11142:	2300      	movs	r3, #0
   11144:	e013      	b.n	1116e <mmc_spi_op_cond+0x8a>
	}
	// Check OCR value
	if ((driver_get_response() & OCR_ACCESS_MODE_MASK)
   11146:	4b0f      	ldr	r3, [pc, #60]	; (11184 <mmc_spi_op_cond+0xa0>)
   11148:	4798      	blx	r3
   1114a:	0002      	movs	r2, r0
   1114c:	23c0      	movs	r3, #192	; 0xc0
   1114e:	05db      	lsls	r3, r3, #23
   11150:	401a      	ands	r2, r3
   11152:	2380      	movs	r3, #128	; 0x80
   11154:	05db      	lsls	r3, r3, #23
   11156:	429a      	cmp	r2, r3
   11158:	d108      	bne.n	1116c <mmc_spi_op_cond+0x88>
			== OCR_ACCESS_MODE_SECTOR) {
		sd_mmc_card->type |= CARD_TYPE_HC;
   1115a:	4b0c      	ldr	r3, [pc, #48]	; (1118c <mmc_spi_op_cond+0xa8>)
   1115c:	681a      	ldr	r2, [r3, #0]
   1115e:	4b0b      	ldr	r3, [pc, #44]	; (1118c <mmc_spi_op_cond+0xa8>)
   11160:	681b      	ldr	r3, [r3, #0]
   11162:	7bdb      	ldrb	r3, [r3, #15]
   11164:	2108      	movs	r1, #8
   11166:	430b      	orrs	r3, r1
   11168:	b2db      	uxtb	r3, r3
   1116a:	73d3      	strb	r3, [r2, #15]
	}
	return true;
   1116c:	2301      	movs	r3, #1
}
   1116e:	0018      	movs	r0, r3
   11170:	46bd      	mov	sp, r7
   11172:	b002      	add	sp, #8
   11174:	bd80      	pop	{r7, pc}
   11176:	46c0      	nop			; (mov r8, r8)
   11178:	00001bee 	.word	0x00001bee
   1117c:	00001101 	.word	0x00001101
   11180:	00012cfd 	.word	0x00012cfd
   11184:	00012f3d 	.word	0x00012f3d
   11188:	0000053a 	.word	0x0000053a
   1118c:	20002dcc 	.word	0x20002dcc

00011190 <sd_spi_op_cond>:
 * \param v2   Shall be 1 if it is a SD card V2
 *
 * \return true if success, otherwise false
 */
static bool sd_spi_op_cond(uint8_t v2)
{
   11190:	b580      	push	{r7, lr}
   11192:	b086      	sub	sp, #24
   11194:	af00      	add	r7, sp, #0
   11196:	0002      	movs	r2, r0
   11198:	1dfb      	adds	r3, r7, #7
   1119a:	701a      	strb	r2, [r3, #0]
	/*
	 * Timeout 1s = 400KHz / ((6+1)*8) cylces = 7150 retry
	 * 6 = cmd byte size
	 * 1 = response byte size
	 */
	retry = 7150;
   1119c:	4b2e      	ldr	r3, [pc, #184]	; (11258 <sd_spi_op_cond+0xc8>)
   1119e:	613b      	str	r3, [r7, #16]
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
   111a0:	4b2e      	ldr	r3, [pc, #184]	; (1125c <sd_spi_op_cond+0xcc>)
   111a2:	2100      	movs	r1, #0
   111a4:	0018      	movs	r0, r3
   111a6:	4b2e      	ldr	r3, [pc, #184]	; (11260 <sd_spi_op_cond+0xd0>)
   111a8:	4798      	blx	r3
   111aa:	0003      	movs	r3, r0
   111ac:	001a      	movs	r2, r3
   111ae:	2301      	movs	r3, #1
   111b0:	4053      	eors	r3, r2
   111b2:	b2db      	uxtb	r3, r3
   111b4:	2b00      	cmp	r3, #0
   111b6:	d001      	beq.n	111bc <sd_spi_op_cond+0x2c>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
   111b8:	2300      	movs	r3, #0
   111ba:	e048      	b.n	1124e <sd_spi_op_cond+0xbe>
		}

		// (ACMD41) Sends host OCR register
		arg = 0;
   111bc:	2300      	movs	r3, #0
   111be:	617b      	str	r3, [r7, #20]
		if (v2) {
   111c0:	1dfb      	adds	r3, r7, #7
   111c2:	781b      	ldrb	r3, [r3, #0]
   111c4:	2b00      	cmp	r3, #0
   111c6:	d004      	beq.n	111d2 <sd_spi_op_cond+0x42>
			arg |= SD_ACMD41_HCS;
   111c8:	697b      	ldr	r3, [r7, #20]
   111ca:	2280      	movs	r2, #128	; 0x80
   111cc:	05d2      	lsls	r2, r2, #23
   111ce:	4313      	orrs	r3, r2
   111d0:	617b      	str	r3, [r7, #20]
		}
		// Check response
		if (!driver_send_cmd(SD_SPI_ACMD41_SD_SEND_OP_COND, arg)) {
   111d2:	697b      	ldr	r3, [r7, #20]
   111d4:	4a23      	ldr	r2, [pc, #140]	; (11264 <sd_spi_op_cond+0xd4>)
   111d6:	0019      	movs	r1, r3
   111d8:	0010      	movs	r0, r2
   111da:	4b21      	ldr	r3, [pc, #132]	; (11260 <sd_spi_op_cond+0xd0>)
   111dc:	4798      	blx	r3
   111de:	0003      	movs	r3, r0
   111e0:	001a      	movs	r2, r3
   111e2:	2301      	movs	r3, #1
   111e4:	4053      	eors	r3, r2
   111e6:	b2db      	uxtb	r3, r3
   111e8:	2b00      	cmp	r3, #0
   111ea:	d001      	beq.n	111f0 <sd_spi_op_cond+0x60>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
   111ec:	2300      	movs	r3, #0
   111ee:	e02e      	b.n	1124e <sd_spi_op_cond+0xbe>
		}
		resp = driver_get_response();
   111f0:	4b1d      	ldr	r3, [pc, #116]	; (11268 <sd_spi_op_cond+0xd8>)
   111f2:	4798      	blx	r3
   111f4:	0003      	movs	r3, r0
   111f6:	60fb      	str	r3, [r7, #12]
		if (!(resp & R1_SPI_IDLE)) {
   111f8:	68fb      	ldr	r3, [r7, #12]
   111fa:	2201      	movs	r2, #1
   111fc:	4013      	ands	r3, r2
   111fe:	d006      	beq.n	1120e <sd_spi_op_cond+0x7e>
			// Card is ready
			break;
		}
		if (retry-- == 0) {
   11200:	693b      	ldr	r3, [r7, #16]
   11202:	1e5a      	subs	r2, r3, #1
   11204:	613a      	str	r2, [r7, #16]
   11206:	2b00      	cmp	r3, #0
   11208:	d1ca      	bne.n	111a0 <sd_spi_op_cond+0x10>
			sd_mmc_debug("%s: ACMD41 Timeout on busy, resp32 0x%08x \n\r",
					__func__, resp);
			return false;
   1120a:	2300      	movs	r3, #0
   1120c:	e01f      	b.n	1124e <sd_spi_op_cond+0xbe>
			return false;
		}
		resp = driver_get_response();
		if (!(resp & R1_SPI_IDLE)) {
			// Card is ready
			break;
   1120e:	46c0      	nop			; (mov r8, r8)
			return false;
		}
	} while (1);

	// Read OCR for SPI mode
	if (!driver_send_cmd(SDMMC_SPI_CMD58_READ_OCR, 0)) {
   11210:	4b16      	ldr	r3, [pc, #88]	; (1126c <sd_spi_op_cond+0xdc>)
   11212:	2100      	movs	r1, #0
   11214:	0018      	movs	r0, r3
   11216:	4b12      	ldr	r3, [pc, #72]	; (11260 <sd_spi_op_cond+0xd0>)
   11218:	4798      	blx	r3
   1121a:	0003      	movs	r3, r0
   1121c:	001a      	movs	r2, r3
   1121e:	2301      	movs	r3, #1
   11220:	4053      	eors	r3, r2
   11222:	b2db      	uxtb	r3, r3
   11224:	2b00      	cmp	r3, #0
   11226:	d001      	beq.n	1122c <sd_spi_op_cond+0x9c>
		sd_mmc_debug("%s: CMD58 Fail\n\r", __func__);
		return false;
   11228:	2300      	movs	r3, #0
   1122a:	e010      	b.n	1124e <sd_spi_op_cond+0xbe>
	}
	if ((driver_get_response() & OCR_CCS) != 0) {
   1122c:	4b0e      	ldr	r3, [pc, #56]	; (11268 <sd_spi_op_cond+0xd8>)
   1122e:	4798      	blx	r3
   11230:	0002      	movs	r2, r0
   11232:	2380      	movs	r3, #128	; 0x80
   11234:	05db      	lsls	r3, r3, #23
   11236:	4013      	ands	r3, r2
   11238:	d008      	beq.n	1124c <sd_spi_op_cond+0xbc>
		sd_mmc_card->type |= CARD_TYPE_HC;
   1123a:	4b0d      	ldr	r3, [pc, #52]	; (11270 <sd_spi_op_cond+0xe0>)
   1123c:	681a      	ldr	r2, [r3, #0]
   1123e:	4b0c      	ldr	r3, [pc, #48]	; (11270 <sd_spi_op_cond+0xe0>)
   11240:	681b      	ldr	r3, [r3, #0]
   11242:	7bdb      	ldrb	r3, [r3, #15]
   11244:	2108      	movs	r1, #8
   11246:	430b      	orrs	r3, r1
   11248:	b2db      	uxtb	r3, r3
   1124a:	73d3      	strb	r3, [r2, #15]
	}
	return true;
   1124c:	2301      	movs	r3, #1
}
   1124e:	0018      	movs	r0, r3
   11250:	46bd      	mov	sp, r7
   11252:	b006      	add	sp, #24
   11254:	bd80      	pop	{r7, pc}
   11256:	46c0      	nop			; (mov r8, r8)
   11258:	00001bee 	.word	0x00001bee
   1125c:	00001137 	.word	0x00001137
   11260:	00012cfd 	.word	0x00012cfd
   11264:	00001129 	.word	0x00001129
   11268:	00012f3d 	.word	0x00012f3d
   1126c:	0000053a 	.word	0x0000053a
   11270:	20002dcc 	.word	0x20002dcc

00011274 <sdio_op_cond>:
	return true;
}

#else
static bool sdio_op_cond(void)
{
   11274:	b580      	push	{r7, lr}
   11276:	af00      	add	r7, sp, #0
	return true; // No error but card type not updated
   11278:	2301      	movs	r3, #1
}
   1127a:	0018      	movs	r0, r3
   1127c:	46bd      	mov	sp, r7
   1127e:	bd80      	pop	{r7, pc}

00011280 <sd_cmd8>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_err.
 */
static bool sd_cmd8(uint8_t * v2)
{
   11280:	b580      	push	{r7, lr}
   11282:	b084      	sub	sp, #16
   11284:	af00      	add	r7, sp, #0
   11286:	6078      	str	r0, [r7, #4]
	uint32_t resp;

	*v2 = 0;
   11288:	687b      	ldr	r3, [r7, #4]
   1128a:	2200      	movs	r2, #0
   1128c:	701a      	strb	r2, [r3, #0]
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
   1128e:	23d5      	movs	r3, #213	; 0xd5
   11290:	005b      	lsls	r3, r3, #1
   11292:	4a14      	ldr	r2, [pc, #80]	; (112e4 <sd_cmd8+0x64>)
   11294:	0019      	movs	r1, r3
   11296:	0010      	movs	r0, r2
   11298:	4b13      	ldr	r3, [pc, #76]	; (112e8 <sd_cmd8+0x68>)
   1129a:	4798      	blx	r3
   1129c:	0003      	movs	r3, r0
   1129e:	001a      	movs	r2, r3
   112a0:	2301      	movs	r3, #1
   112a2:	4053      	eors	r3, r2
   112a4:	b2db      	uxtb	r3, r3
   112a6:	2b00      	cmp	r3, #0
   112a8:	d001      	beq.n	112ae <sd_cmd8+0x2e>
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
   112aa:	2301      	movs	r3, #1
   112ac:	e015      	b.n	112da <sd_cmd8+0x5a>
	}
	// Check R7 response
	resp = driver_get_response();
   112ae:	4b0f      	ldr	r3, [pc, #60]	; (112ec <sd_cmd8+0x6c>)
   112b0:	4798      	blx	r3
   112b2:	0003      	movs	r3, r0
   112b4:	60fb      	str	r3, [r7, #12]
	if (resp == 0xFFFFFFFF) {
   112b6:	68fb      	ldr	r3, [r7, #12]
   112b8:	3301      	adds	r3, #1
   112ba:	d101      	bne.n	112c0 <sd_cmd8+0x40>
		// No compliance R7 value
		return true; // It is not a V2
   112bc:	2301      	movs	r3, #1
   112be:	e00c      	b.n	112da <sd_cmd8+0x5a>
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
   112c0:	68fb      	ldr	r3, [r7, #12]
   112c2:	051b      	lsls	r3, r3, #20
   112c4:	0d1a      	lsrs	r2, r3, #20
   112c6:	23d5      	movs	r3, #213	; 0xd5
   112c8:	005b      	lsls	r3, r3, #1
   112ca:	429a      	cmp	r2, r3
   112cc:	d001      	beq.n	112d2 <sd_cmd8+0x52>
				!= (SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
   112ce:	2300      	movs	r3, #0
   112d0:	e003      	b.n	112da <sd_cmd8+0x5a>
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
   112d2:	687b      	ldr	r3, [r7, #4]
   112d4:	2201      	movs	r2, #1
   112d6:	701a      	strb	r2, [r3, #0]
	return true;
   112d8:	2301      	movs	r3, #1
}
   112da:	0018      	movs	r0, r3
   112dc:	46bd      	mov	sp, r7
   112de:	b004      	add	sp, #16
   112e0:	bd80      	pop	{r7, pc}
   112e2:	46c0      	nop			; (mov r8, r8)
   112e4:	00005508 	.word	0x00005508
   112e8:	00012cfd 	.word	0x00012cfd
   112ec:	00012f3d 	.word	0x00012f3d

000112f0 <mmc_cmd8>:
 * support information
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd8(uint8_t *b_authorize_high_speed)
{
   112f0:	b590      	push	{r4, r7, lr}
   112f2:	b089      	sub	sp, #36	; 0x24
   112f4:	af02      	add	r7, sp, #8
   112f6:	6078      	str	r0, [r7, #4]
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
   112f8:	2380      	movs	r3, #128	; 0x80
   112fa:	009a      	lsls	r2, r3, #2
   112fc:	4841      	ldr	r0, [pc, #260]	; (11404 <mmc_cmd8+0x114>)
   112fe:	2300      	movs	r3, #0
   11300:	9300      	str	r3, [sp, #0]
   11302:	2301      	movs	r3, #1
   11304:	2100      	movs	r1, #0
   11306:	4c40      	ldr	r4, [pc, #256]	; (11408 <mmc_cmd8+0x118>)
   11308:	47a0      	blx	r4
   1130a:	0003      	movs	r3, r0
   1130c:	001a      	movs	r2, r3
   1130e:	2301      	movs	r3, #1
   11310:	4053      	eors	r3, r2
   11312:	b2db      	uxtb	r3, r3
   11314:	2b00      	cmp	r3, #0
   11316:	d001      	beq.n	1131c <mmc_cmd8+0x2c>
			EXT_CSD_BSIZE, 1, false)) {
		return false;
   11318:	2300      	movs	r3, #0
   1131a:	e06e      	b.n	113fa <mmc_cmd8+0x10a>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
   1131c:	2316      	movs	r3, #22
   1131e:	18fb      	adds	r3, r7, r3
   11320:	2200      	movs	r2, #0
   11322:	801a      	strh	r2, [r3, #0]
   11324:	e014      	b.n	11350 <mmc_cmd8+0x60>
		if (!driver_read_word(&ext_csd)) {
   11326:	2310      	movs	r3, #16
   11328:	18fb      	adds	r3, r7, r3
   1132a:	0018      	movs	r0, r3
   1132c:	4b37      	ldr	r3, [pc, #220]	; (1140c <mmc_cmd8+0x11c>)
   1132e:	4798      	blx	r3
   11330:	0003      	movs	r3, r0
   11332:	001a      	movs	r2, r3
   11334:	2301      	movs	r3, #1
   11336:	4053      	eors	r3, r2
   11338:	b2db      	uxtb	r3, r3
   1133a:	2b00      	cmp	r3, #0
   1133c:	d001      	beq.n	11342 <mmc_cmd8+0x52>
			return false;
   1133e:	2300      	movs	r3, #0
   11340:	e05b      	b.n	113fa <mmc_cmd8+0x10a>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
   11342:	2316      	movs	r3, #22
   11344:	18fb      	adds	r3, r7, r3
   11346:	881a      	ldrh	r2, [r3, #0]
   11348:	2316      	movs	r3, #22
   1134a:	18fb      	adds	r3, r7, r3
   1134c:	3201      	adds	r2, #1
   1134e:	801a      	strh	r2, [r3, #0]
   11350:	2316      	movs	r3, #22
   11352:	18fb      	adds	r3, r7, r3
   11354:	881b      	ldrh	r3, [r3, #0]
   11356:	2b31      	cmp	r3, #49	; 0x31
   11358:	d9e5      	bls.n	11326 <mmc_cmd8+0x36>
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
   1135a:	693b      	ldr	r3, [r7, #16]
   1135c:	b2db      	uxtb	r3, r3
   1135e:	2202      	movs	r2, #2
   11360:	4013      	ands	r3, r2
   11362:	b2da      	uxtb	r2, r3
   11364:	687b      	ldr	r3, [r7, #4]
   11366:	701a      	strb	r2, [r3, #0]
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
   11368:	4b29      	ldr	r3, [pc, #164]	; (11410 <mmc_cmd8+0x120>)
   1136a:	681b      	ldr	r3, [r3, #0]
   1136c:	3312      	adds	r3, #18
   1136e:	0018      	movs	r0, r3
   11370:	230c      	movs	r3, #12
   11372:	223e      	movs	r2, #62	; 0x3e
   11374:	2180      	movs	r1, #128	; 0x80
   11376:	4c27      	ldr	r4, [pc, #156]	; (11414 <mmc_cmd8+0x124>)
   11378:	47a0      	blx	r4
   1137a:	1e02      	subs	r2, r0, #0
   1137c:	4b26      	ldr	r3, [pc, #152]	; (11418 <mmc_cmd8+0x128>)
   1137e:	429a      	cmp	r2, r3
   11380:	d135      	bne.n	113ee <mmc_cmd8+0xfe>
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
   11382:	e014      	b.n	113ae <mmc_cmd8+0xbe>
			if (!driver_read_word(&sec_count)) {
   11384:	230c      	movs	r3, #12
   11386:	18fb      	adds	r3, r7, r3
   11388:	0018      	movs	r0, r3
   1138a:	4b20      	ldr	r3, [pc, #128]	; (1140c <mmc_cmd8+0x11c>)
   1138c:	4798      	blx	r3
   1138e:	0003      	movs	r3, r0
   11390:	001a      	movs	r2, r3
   11392:	2301      	movs	r3, #1
   11394:	4053      	eors	r3, r2
   11396:	b2db      	uxtb	r3, r3
   11398:	2b00      	cmp	r3, #0
   1139a:	d001      	beq.n	113a0 <mmc_cmd8+0xb0>
				return false;
   1139c:	2300      	movs	r3, #0
   1139e:	e02c      	b.n	113fa <mmc_cmd8+0x10a>
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
   113a0:	2316      	movs	r3, #22
   113a2:	18fb      	adds	r3, r7, r3
   113a4:	881a      	ldrh	r2, [r3, #0]
   113a6:	2316      	movs	r3, #22
   113a8:	18fb      	adds	r3, r7, r3
   113aa:	3201      	adds	r2, #1
   113ac:	801a      	strh	r2, [r3, #0]
   113ae:	2316      	movs	r3, #22
   113b0:	18fb      	adds	r3, r7, r3
   113b2:	881b      	ldrh	r3, [r3, #0]
   113b4:	2b35      	cmp	r3, #53	; 0x35
   113b6:	d9e5      	bls.n	11384 <mmc_cmd8+0x94>
			if (!driver_read_word(&sec_count)) {
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
   113b8:	4b15      	ldr	r3, [pc, #84]	; (11410 <mmc_cmd8+0x120>)
   113ba:	681b      	ldr	r3, [r3, #0]
   113bc:	68fa      	ldr	r2, [r7, #12]
   113be:	0852      	lsrs	r2, r2, #1
   113c0:	605a      	str	r2, [r3, #4]
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
   113c2:	e014      	b.n	113ee <mmc_cmd8+0xfe>
		if (!driver_read_word(&sec_count)) {
   113c4:	230c      	movs	r3, #12
   113c6:	18fb      	adds	r3, r7, r3
   113c8:	0018      	movs	r0, r3
   113ca:	4b10      	ldr	r3, [pc, #64]	; (1140c <mmc_cmd8+0x11c>)
   113cc:	4798      	blx	r3
   113ce:	0003      	movs	r3, r0
   113d0:	001a      	movs	r2, r3
   113d2:	2301      	movs	r3, #1
   113d4:	4053      	eors	r3, r2
   113d6:	b2db      	uxtb	r3, r3
   113d8:	2b00      	cmp	r3, #0
   113da:	d001      	beq.n	113e0 <mmc_cmd8+0xf0>
			return false;
   113dc:	2300      	movs	r3, #0
   113de:	e00c      	b.n	113fa <mmc_cmd8+0x10a>
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
   113e0:	2316      	movs	r3, #22
   113e2:	18fb      	adds	r3, r7, r3
   113e4:	881a      	ldrh	r2, [r3, #0]
   113e6:	2316      	movs	r3, #22
   113e8:	18fb      	adds	r3, r7, r3
   113ea:	3201      	adds	r2, #1
   113ec:	801a      	strh	r2, [r3, #0]
   113ee:	2316      	movs	r3, #22
   113f0:	18fb      	adds	r3, r7, r3
   113f2:	881b      	ldrh	r3, [r3, #0]
   113f4:	2b7f      	cmp	r3, #127	; 0x7f
   113f6:	d9e5      	bls.n	113c4 <mmc_cmd8+0xd4>
		if (!driver_read_word(&sec_count)) {
			return false;
		}
	}
	return true;
   113f8:	2301      	movs	r3, #1
}
   113fa:	0018      	movs	r0, r3
   113fc:	46bd      	mov	sp, r7
   113fe:	b007      	add	sp, #28
   11400:	bd90      	pop	{r4, r7, pc}
   11402:	46c0      	nop			; (mov r8, r8)
   11404:	00081108 	.word	0x00081108
   11408:	00012d25 	.word	0x00012d25
   1140c:	00012f51 	.word	0x00012f51
   11410:	20002dcc 	.word	0x20002dcc
   11414:	00010ecd 	.word	0x00010ecd
   11418:	00000fff 	.word	0x00000fff

0001141c <sd_mmc_cmd9_spi>:
 * data (CSD) on the CMD line spi.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_spi(void)
{
   1141c:	b590      	push	{r4, r7, lr}
   1141e:	b083      	sub	sp, #12
   11420:	af02      	add	r7, sp, #8
	if (!driver_adtc_start(SDMMC_SPI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16,
   11422:	4b15      	ldr	r3, [pc, #84]	; (11478 <sd_mmc_cmd9_spi+0x5c>)
   11424:	681b      	ldr	r3, [r3, #0]
   11426:	899b      	ldrh	r3, [r3, #12]
   11428:	0419      	lsls	r1, r3, #16
   1142a:	4814      	ldr	r0, [pc, #80]	; (1147c <sd_mmc_cmd9_spi+0x60>)
   1142c:	2301      	movs	r3, #1
   1142e:	9300      	str	r3, [sp, #0]
   11430:	2301      	movs	r3, #1
   11432:	2210      	movs	r2, #16
   11434:	4c12      	ldr	r4, [pc, #72]	; (11480 <sd_mmc_cmd9_spi+0x64>)
   11436:	47a0      	blx	r4
   11438:	0003      	movs	r3, r0
   1143a:	001a      	movs	r2, r3
   1143c:	2301      	movs	r3, #1
   1143e:	4053      	eors	r3, r2
   11440:	b2db      	uxtb	r3, r3
   11442:	2b00      	cmp	r3, #0
   11444:	d001      	beq.n	1144a <sd_mmc_cmd9_spi+0x2e>
			CSD_REG_BSIZE, 1, true)) {
		return false;
   11446:	2300      	movs	r3, #0
   11448:	e012      	b.n	11470 <sd_mmc_cmd9_spi+0x54>
	}
	if (!driver_start_read_blocks(sd_mmc_card->csd, 1)) {
   1144a:	4b0b      	ldr	r3, [pc, #44]	; (11478 <sd_mmc_cmd9_spi+0x5c>)
   1144c:	681b      	ldr	r3, [r3, #0]
   1144e:	3312      	adds	r3, #18
   11450:	2101      	movs	r1, #1
   11452:	0018      	movs	r0, r3
   11454:	4b0b      	ldr	r3, [pc, #44]	; (11484 <sd_mmc_cmd9_spi+0x68>)
   11456:	4798      	blx	r3
   11458:	0003      	movs	r3, r0
   1145a:	001a      	movs	r2, r3
   1145c:	2301      	movs	r3, #1
   1145e:	4053      	eors	r3, r2
   11460:	b2db      	uxtb	r3, r3
   11462:	2b00      	cmp	r3, #0
   11464:	d001      	beq.n	1146a <sd_mmc_cmd9_spi+0x4e>
		return false;
   11466:	2300      	movs	r3, #0
   11468:	e002      	b.n	11470 <sd_mmc_cmd9_spi+0x54>
	}
	return driver_wait_end_of_read_blocks();
   1146a:	4b07      	ldr	r3, [pc, #28]	; (11488 <sd_mmc_cmd9_spi+0x6c>)
   1146c:	4798      	blx	r3
   1146e:	0003      	movs	r3, r0
}
   11470:	0018      	movs	r0, r3
   11472:	46bd      	mov	sp, r7
   11474:	b001      	add	sp, #4
   11476:	bd90      	pop	{r4, r7, pc}
   11478:	20002dcc 	.word	0x20002dcc
   1147c:	00081109 	.word	0x00081109
   11480:	00012d25 	.word	0x00012d25
   11484:	00012ff5 	.word	0x00012ff5
   11488:	00013099 	.word	0x00013099

0001148c <mmc_decode_csd>:

/**
 * \brief Decodes MMC CSD register
 */
static void mmc_decode_csd(void)
{
   1148c:	b5b0      	push	{r4, r5, r7, lr}
   1148e:	b084      	sub	sp, #16
   11490:	af00      	add	r7, sp, #0
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
   11492:	4b45      	ldr	r3, [pc, #276]	; (115a8 <mmc_decode_csd+0x11c>)
   11494:	681b      	ldr	r3, [r3, #0]
   11496:	3312      	adds	r3, #18
   11498:	0018      	movs	r0, r3
   1149a:	2304      	movs	r3, #4
   1149c:	227a      	movs	r2, #122	; 0x7a
   1149e:	2180      	movs	r1, #128	; 0x80
   114a0:	4c42      	ldr	r4, [pc, #264]	; (115ac <mmc_decode_csd+0x120>)
   114a2:	47a0      	blx	r4
   114a4:	1e03      	subs	r3, r0, #0
   114a6:	2b02      	cmp	r3, #2
   114a8:	d011      	beq.n	114ce <mmc_decode_csd+0x42>
   114aa:	d802      	bhi.n	114b2 <mmc_decode_csd+0x26>
   114ac:	2b01      	cmp	r3, #1
   114ae:	d009      	beq.n	114c4 <mmc_decode_csd+0x38>
   114b0:	e003      	b.n	114ba <mmc_decode_csd+0x2e>
   114b2:	2b03      	cmp	r3, #3
   114b4:	d010      	beq.n	114d8 <mmc_decode_csd+0x4c>
   114b6:	2b04      	cmp	r3, #4
   114b8:	d013      	beq.n	114e2 <mmc_decode_csd+0x56>
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
   114ba:	4b3b      	ldr	r3, [pc, #236]	; (115a8 <mmc_decode_csd+0x11c>)
   114bc:	681b      	ldr	r3, [r3, #0]
   114be:	2212      	movs	r2, #18
   114c0:	741a      	strb	r2, [r3, #16]
		break;
   114c2:	e013      	b.n	114ec <mmc_decode_csd+0x60>

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
   114c4:	4b38      	ldr	r3, [pc, #224]	; (115a8 <mmc_decode_csd+0x11c>)
   114c6:	681b      	ldr	r3, [r3, #0]
   114c8:	2214      	movs	r2, #20
   114ca:	741a      	strb	r2, [r3, #16]
		break;
   114cc:	e00e      	b.n	114ec <mmc_decode_csd+0x60>

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
   114ce:	4b36      	ldr	r3, [pc, #216]	; (115a8 <mmc_decode_csd+0x11c>)
   114d0:	681b      	ldr	r3, [r3, #0]
   114d2:	2222      	movs	r2, #34	; 0x22
   114d4:	741a      	strb	r2, [r3, #16]
		break;
   114d6:	e009      	b.n	114ec <mmc_decode_csd+0x60>

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
   114d8:	4b33      	ldr	r3, [pc, #204]	; (115a8 <mmc_decode_csd+0x11c>)
   114da:	681b      	ldr	r3, [r3, #0]
   114dc:	2230      	movs	r2, #48	; 0x30
   114de:	741a      	strb	r2, [r3, #16]
		break;
   114e0:	e004      	b.n	114ec <mmc_decode_csd+0x60>

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
   114e2:	4b31      	ldr	r3, [pc, #196]	; (115a8 <mmc_decode_csd+0x11c>)
   114e4:	681b      	ldr	r3, [r3, #0]
   114e6:	2240      	movs	r2, #64	; 0x40
   114e8:	741a      	strb	r2, [r3, #16]
		break;
   114ea:	46c0      	nop			; (mov r8, r8)
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
   114ec:	4b2e      	ldr	r3, [pc, #184]	; (115a8 <mmc_decode_csd+0x11c>)
   114ee:	681b      	ldr	r3, [r3, #0]
   114f0:	3312      	adds	r3, #18
   114f2:	0018      	movs	r0, r3
   114f4:	2308      	movs	r3, #8
   114f6:	2260      	movs	r2, #96	; 0x60
   114f8:	2180      	movs	r1, #128	; 0x80
   114fa:	4c2c      	ldr	r4, [pc, #176]	; (115ac <mmc_decode_csd+0x120>)
   114fc:	47a0      	blx	r4
   114fe:	0003      	movs	r3, r0
   11500:	60fb      	str	r3, [r7, #12]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
   11502:	68fb      	ldr	r3, [r7, #12]
   11504:	2207      	movs	r2, #7
   11506:	401a      	ands	r2, r3
   11508:	4b29      	ldr	r3, [pc, #164]	; (115b0 <mmc_decode_csd+0x124>)
   1150a:	0092      	lsls	r2, r2, #2
   1150c:	58d3      	ldr	r3, [r2, r3]
   1150e:	60bb      	str	r3, [r7, #8]
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
   11510:	68fb      	ldr	r3, [r7, #12]
   11512:	08db      	lsrs	r3, r3, #3
   11514:	220f      	movs	r2, #15
   11516:	401a      	ands	r2, r3
   11518:	4b26      	ldr	r3, [pc, #152]	; (115b4 <mmc_decode_csd+0x128>)
   1151a:	0092      	lsls	r2, r2, #2
   1151c:	58d3      	ldr	r3, [r2, r3]
   1151e:	607b      	str	r3, [r7, #4]
	sd_mmc_card->clock = unit * mul * 1000;
   11520:	4b21      	ldr	r3, [pc, #132]	; (115a8 <mmc_decode_csd+0x11c>)
   11522:	681b      	ldr	r3, [r3, #0]
   11524:	68ba      	ldr	r2, [r7, #8]
   11526:	6879      	ldr	r1, [r7, #4]
   11528:	434a      	muls	r2, r1
   1152a:	21fa      	movs	r1, #250	; 0xfa
   1152c:	0089      	lsls	r1, r1, #2
   1152e:	434a      	muls	r2, r1
   11530:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
   11532:	4b1d      	ldr	r3, [pc, #116]	; (115a8 <mmc_decode_csd+0x11c>)
   11534:	681b      	ldr	r3, [r3, #0]
   11536:	3312      	adds	r3, #18
   11538:	0018      	movs	r0, r3
   1153a:	230c      	movs	r3, #12
   1153c:	223e      	movs	r2, #62	; 0x3e
   1153e:	2180      	movs	r1, #128	; 0x80
   11540:	4c1a      	ldr	r4, [pc, #104]	; (115ac <mmc_decode_csd+0x120>)
   11542:	47a0      	blx	r4
   11544:	1e02      	subs	r2, r0, #0
   11546:	4b1c      	ldr	r3, [pc, #112]	; (115b8 <mmc_decode_csd+0x12c>)
   11548:	429a      	cmp	r2, r3
   1154a:	d028      	beq.n	1159e <mmc_decode_csd+0x112>
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
   1154c:	4b16      	ldr	r3, [pc, #88]	; (115a8 <mmc_decode_csd+0x11c>)
   1154e:	681b      	ldr	r3, [r3, #0]
   11550:	3312      	adds	r3, #18
   11552:	0018      	movs	r0, r3
   11554:	230c      	movs	r3, #12
   11556:	223e      	movs	r2, #62	; 0x3e
   11558:	2180      	movs	r1, #128	; 0x80
   1155a:	4c14      	ldr	r4, [pc, #80]	; (115ac <mmc_decode_csd+0x120>)
   1155c:	47a0      	blx	r4
   1155e:	0003      	movs	r3, r0
   11560:	1c5c      	adds	r4, r3, #1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
   11562:	4b11      	ldr	r3, [pc, #68]	; (115a8 <mmc_decode_csd+0x11c>)
   11564:	681b      	ldr	r3, [r3, #0]
   11566:	3312      	adds	r3, #18
   11568:	0018      	movs	r0, r3
   1156a:	2303      	movs	r3, #3
   1156c:	222f      	movs	r2, #47	; 0x2f
   1156e:	2180      	movs	r1, #128	; 0x80
   11570:	4d0e      	ldr	r5, [pc, #56]	; (115ac <mmc_decode_csd+0x120>)
   11572:	47a8      	blx	r5
   11574:	0003      	movs	r3, r0
   11576:	3302      	adds	r3, #2
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
   11578:	409c      	lsls	r4, r3
   1157a:	0023      	movs	r3, r4
   1157c:	603b      	str	r3, [r7, #0]
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
   1157e:	4b0a      	ldr	r3, [pc, #40]	; (115a8 <mmc_decode_csd+0x11c>)
   11580:	681c      	ldr	r4, [r3, #0]
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
   11582:	4b09      	ldr	r3, [pc, #36]	; (115a8 <mmc_decode_csd+0x11c>)
   11584:	681b      	ldr	r3, [r3, #0]
   11586:	3312      	adds	r3, #18
   11588:	0018      	movs	r0, r3
   1158a:	2304      	movs	r3, #4
   1158c:	2250      	movs	r2, #80	; 0x50
   1158e:	2180      	movs	r1, #128	; 0x80
   11590:	4d06      	ldr	r5, [pc, #24]	; (115ac <mmc_decode_csd+0x120>)
   11592:	47a8      	blx	r5
   11594:	0002      	movs	r2, r0
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
   11596:	683b      	ldr	r3, [r7, #0]
   11598:	4093      	lsls	r3, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
   1159a:	0a9b      	lsrs	r3, r3, #10
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
   1159c:	6063      	str	r3, [r4, #4]
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
	}
}
   1159e:	46c0      	nop			; (mov r8, r8)
   115a0:	46bd      	mov	sp, r7
   115a2:	b004      	add	sp, #16
   115a4:	bdb0      	pop	{r4, r5, r7, pc}
   115a6:	46c0      	nop			; (mov r8, r8)
   115a8:	20002dcc 	.word	0x20002dcc
   115ac:	00010ecd 	.word	0x00010ecd
   115b0:	00021004 	.word	0x00021004
   115b4:	00021060 	.word	0x00021060
   115b8:	00000fff 	.word	0x00000fff

000115bc <sd_decode_csd>:

/**
 * \brief Decodes SD CSD register
 */
static void sd_decode_csd(void)
{
   115bc:	b5b0      	push	{r4, r5, r7, lr}
   115be:	b084      	sub	sp, #16
   115c0:	af00      	add	r7, sp, #0
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
   115c2:	4b35      	ldr	r3, [pc, #212]	; (11698 <sd_decode_csd+0xdc>)
   115c4:	681b      	ldr	r3, [r3, #0]
   115c6:	3312      	adds	r3, #18
   115c8:	0018      	movs	r0, r3
   115ca:	2308      	movs	r3, #8
   115cc:	2260      	movs	r2, #96	; 0x60
   115ce:	2180      	movs	r1, #128	; 0x80
   115d0:	4c32      	ldr	r4, [pc, #200]	; (1169c <sd_decode_csd+0xe0>)
   115d2:	47a0      	blx	r4
   115d4:	0003      	movs	r3, r0
   115d6:	60fb      	str	r3, [r7, #12]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
   115d8:	68fb      	ldr	r3, [r7, #12]
   115da:	2207      	movs	r2, #7
   115dc:	401a      	ands	r2, r3
   115de:	4b30      	ldr	r3, [pc, #192]	; (116a0 <sd_decode_csd+0xe4>)
   115e0:	0092      	lsls	r2, r2, #2
   115e2:	58d3      	ldr	r3, [r2, r3]
   115e4:	60bb      	str	r3, [r7, #8]
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
   115e6:	68fb      	ldr	r3, [r7, #12]
   115e8:	08db      	lsrs	r3, r3, #3
   115ea:	220f      	movs	r2, #15
   115ec:	401a      	ands	r2, r3
   115ee:	4b2d      	ldr	r3, [pc, #180]	; (116a4 <sd_decode_csd+0xe8>)
   115f0:	0092      	lsls	r2, r2, #2
   115f2:	58d3      	ldr	r3, [r2, r3]
   115f4:	607b      	str	r3, [r7, #4]
	sd_mmc_card->clock = unit * mul * 1000;
   115f6:	4b28      	ldr	r3, [pc, #160]	; (11698 <sd_decode_csd+0xdc>)
   115f8:	681b      	ldr	r3, [r3, #0]
   115fa:	68ba      	ldr	r2, [r7, #8]
   115fc:	6879      	ldr	r1, [r7, #4]
   115fe:	434a      	muls	r2, r1
   11600:	21fa      	movs	r1, #250	; 0xfa
   11602:	0089      	lsls	r1, r1, #2
   11604:	434a      	muls	r2, r1
   11606:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
   11608:	4b23      	ldr	r3, [pc, #140]	; (11698 <sd_decode_csd+0xdc>)
   1160a:	681b      	ldr	r3, [r3, #0]
   1160c:	3312      	adds	r3, #18
   1160e:	0018      	movs	r0, r3
   11610:	2302      	movs	r3, #2
   11612:	227e      	movs	r2, #126	; 0x7e
   11614:	2180      	movs	r1, #128	; 0x80
   11616:	4c21      	ldr	r4, [pc, #132]	; (1169c <sd_decode_csd+0xe0>)
   11618:	47a0      	blx	r4
   1161a:	1e03      	subs	r3, r0, #0
   1161c:	d00f      	beq.n	1163e <sd_decode_csd+0x82>
		sd_mmc_card->capacity =
   1161e:	4b1e      	ldr	r3, [pc, #120]	; (11698 <sd_decode_csd+0xdc>)
   11620:	681c      	ldr	r4, [r3, #0]
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
   11622:	4b1d      	ldr	r3, [pc, #116]	; (11698 <sd_decode_csd+0xdc>)
   11624:	681b      	ldr	r3, [r3, #0]
   11626:	3312      	adds	r3, #18
   11628:	0018      	movs	r0, r3
   1162a:	2316      	movs	r3, #22
   1162c:	2230      	movs	r2, #48	; 0x30
   1162e:	2180      	movs	r1, #128	; 0x80
   11630:	4d1a      	ldr	r5, [pc, #104]	; (1169c <sd_decode_csd+0xe0>)
   11632:	47a8      	blx	r5
   11634:	0003      	movs	r3, r0
				* 512;
   11636:	3301      	adds	r3, #1
   11638:	025b      	lsls	r3, r3, #9
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
   1163a:	6063      	str	r3, [r4, #4]
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
	}
}
   1163c:	e028      	b.n	11690 <sd_decode_csd+0xd4>
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
   1163e:	4b16      	ldr	r3, [pc, #88]	; (11698 <sd_decode_csd+0xdc>)
   11640:	681b      	ldr	r3, [r3, #0]
   11642:	3312      	adds	r3, #18
   11644:	0018      	movs	r0, r3
   11646:	230c      	movs	r3, #12
   11648:	223e      	movs	r2, #62	; 0x3e
   1164a:	2180      	movs	r1, #128	; 0x80
   1164c:	4c13      	ldr	r4, [pc, #76]	; (1169c <sd_decode_csd+0xe0>)
   1164e:	47a0      	blx	r4
   11650:	0003      	movs	r3, r0
   11652:	1c5c      	adds	r4, r3, #1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
   11654:	4b10      	ldr	r3, [pc, #64]	; (11698 <sd_decode_csd+0xdc>)
   11656:	681b      	ldr	r3, [r3, #0]
   11658:	3312      	adds	r3, #18
   1165a:	0018      	movs	r0, r3
   1165c:	2303      	movs	r3, #3
   1165e:	222f      	movs	r2, #47	; 0x2f
   11660:	2180      	movs	r1, #128	; 0x80
   11662:	4d0e      	ldr	r5, [pc, #56]	; (1169c <sd_decode_csd+0xe0>)
   11664:	47a8      	blx	r5
   11666:	0003      	movs	r3, r0
   11668:	3302      	adds	r3, #2
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
   1166a:	409c      	lsls	r4, r3
   1166c:	0023      	movs	r3, r4
   1166e:	603b      	str	r3, [r7, #0]
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
   11670:	4b09      	ldr	r3, [pc, #36]	; (11698 <sd_decode_csd+0xdc>)
   11672:	681c      	ldr	r4, [r3, #0]
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
   11674:	4b08      	ldr	r3, [pc, #32]	; (11698 <sd_decode_csd+0xdc>)
   11676:	681b      	ldr	r3, [r3, #0]
   11678:	3312      	adds	r3, #18
   1167a:	0018      	movs	r0, r3
   1167c:	2304      	movs	r3, #4
   1167e:	2250      	movs	r2, #80	; 0x50
   11680:	2180      	movs	r1, #128	; 0x80
   11682:	4d06      	ldr	r5, [pc, #24]	; (1169c <sd_decode_csd+0xe0>)
   11684:	47a8      	blx	r5
   11686:	0002      	movs	r2, r0
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
   11688:	683b      	ldr	r3, [r7, #0]
   1168a:	4093      	lsls	r3, r2
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
   1168c:	0a9b      	lsrs	r3, r3, #10
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
   1168e:	6063      	str	r3, [r4, #4]
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
	}
}
   11690:	46c0      	nop			; (mov r8, r8)
   11692:	46bd      	mov	sp, r7
   11694:	b004      	add	sp, #16
   11696:	bdb0      	pop	{r4, r5, r7, pc}
   11698:	20002dcc 	.word	0x20002dcc
   1169c:	00010ecd 	.word	0x00010ecd
   116a0:	00021004 	.word	0x00021004
   116a4:	00021020 	.word	0x00021020

000116a8 <sd_mmc_cmd13>:
 * This function waits the clear of the busy flag
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd13(void)
{
   116a8:	b580      	push	{r7, lr}
   116aa:	b082      	sub	sp, #8
   116ac:	af00      	add	r7, sp, #0
	/* Wait for data ready status.
	 * Nec timing: 0 to unlimited
	 * However a timeout is used.
	 * 200 000 * 8 cycles
	 */
	nec_timeout = 200000;
   116ae:	4b11      	ldr	r3, [pc, #68]	; (116f4 <sd_mmc_cmd13+0x4c>)
   116b0:	607b      	str	r3, [r7, #4]
	do {
		if (sd_mmc_is_spi()) {
			if (!driver_send_cmd(SDMMC_SPI_CMD13_SEND_STATUS, 0)) {
   116b2:	4b11      	ldr	r3, [pc, #68]	; (116f8 <sd_mmc_cmd13+0x50>)
   116b4:	2100      	movs	r1, #0
   116b6:	0018      	movs	r0, r3
   116b8:	4b10      	ldr	r3, [pc, #64]	; (116fc <sd_mmc_cmd13+0x54>)
   116ba:	4798      	blx	r3
   116bc:	0003      	movs	r3, r0
   116be:	001a      	movs	r2, r3
   116c0:	2301      	movs	r3, #1
   116c2:	4053      	eors	r3, r2
   116c4:	b2db      	uxtb	r3, r3
   116c6:	2b00      	cmp	r3, #0
   116c8:	d001      	beq.n	116ce <sd_mmc_cmd13+0x26>
				return false;
   116ca:	2300      	movs	r3, #0
   116cc:	e00e      	b.n	116ec <sd_mmc_cmd13+0x44>
			}
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
   116ce:	4b0c      	ldr	r3, [pc, #48]	; (11700 <sd_mmc_cmd13+0x58>)
   116d0:	4798      	blx	r3
   116d2:	0002      	movs	r2, r0
   116d4:	23ff      	movs	r3, #255	; 0xff
   116d6:	4013      	ands	r3, r2
   116d8:	d006      	beq.n	116e8 <sd_mmc_cmd13+0x40>
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
				break;
			}
		}
		if (nec_timeout-- == 0) {
   116da:	687b      	ldr	r3, [r7, #4]
   116dc:	1e5a      	subs	r2, r3, #1
   116de:	607a      	str	r2, [r7, #4]
   116e0:	2b00      	cmp	r3, #0
   116e2:	d1e6      	bne.n	116b2 <sd_mmc_cmd13+0xa>
			sd_mmc_debug("%s: CMD13 Busy timeout\n\r", __func__);
			return false;
   116e4:	2300      	movs	r3, #0
   116e6:	e001      	b.n	116ec <sd_mmc_cmd13+0x44>
			if (!driver_send_cmd(SDMMC_SPI_CMD13_SEND_STATUS, 0)) {
				return false;
			}
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
   116e8:	46c0      	nop			; (mov r8, r8)
			sd_mmc_debug("%s: CMD13 Busy timeout\n\r", __func__);
			return false;
		}
	} while (1);

	return true;
   116ea:	2301      	movs	r3, #1
}
   116ec:	0018      	movs	r0, r3
   116ee:	46bd      	mov	sp, r7
   116f0:	b002      	add	sp, #8
   116f2:	bd80      	pop	{r7, pc}
   116f4:	00030d40 	.word	0x00030d40
   116f8:	00001b0d 	.word	0x00001b0d
   116fc:	00012cfd 	.word	0x00012cfd
   11700:	00012f3d 	.word	0x00012f3d

00011704 <sd_acmd51>:
 *
 *
 * \return true if success, otherwise false
 */
static bool sd_acmd51(void)
{
   11704:	b590      	push	{r4, r7, lr}
   11706:	b085      	sub	sp, #20
   11708:	af02      	add	r7, sp, #8
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
   1170a:	4b38      	ldr	r3, [pc, #224]	; (117ec <sd_acmd51+0xe8>)
   1170c:	681b      	ldr	r3, [r3, #0]
   1170e:	899b      	ldrh	r3, [r3, #12]
   11710:	041b      	lsls	r3, r3, #16
   11712:	4a37      	ldr	r2, [pc, #220]	; (117f0 <sd_acmd51+0xec>)
   11714:	0019      	movs	r1, r3
   11716:	0010      	movs	r0, r2
   11718:	4b36      	ldr	r3, [pc, #216]	; (117f4 <sd_acmd51+0xf0>)
   1171a:	4798      	blx	r3
   1171c:	0003      	movs	r3, r0
   1171e:	001a      	movs	r2, r3
   11720:	2301      	movs	r3, #1
   11722:	4053      	eors	r3, r2
   11724:	b2db      	uxtb	r3, r3
   11726:	2b00      	cmp	r3, #0
   11728:	d001      	beq.n	1172e <sd_acmd51+0x2a>
		return false;
   1172a:	2300      	movs	r3, #0
   1172c:	e059      	b.n	117e2 <sd_acmd51+0xde>
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
   1172e:	4832      	ldr	r0, [pc, #200]	; (117f8 <sd_acmd51+0xf4>)
   11730:	2301      	movs	r3, #1
   11732:	9300      	str	r3, [sp, #0]
   11734:	2301      	movs	r3, #1
   11736:	2208      	movs	r2, #8
   11738:	2100      	movs	r1, #0
   1173a:	4c30      	ldr	r4, [pc, #192]	; (117fc <sd_acmd51+0xf8>)
   1173c:	47a0      	blx	r4
   1173e:	0003      	movs	r3, r0
   11740:	001a      	movs	r2, r3
   11742:	2301      	movs	r3, #1
   11744:	4053      	eors	r3, r2
   11746:	b2db      	uxtb	r3, r3
   11748:	2b00      	cmp	r3, #0
   1174a:	d001      	beq.n	11750 <sd_acmd51+0x4c>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
   1174c:	2300      	movs	r3, #0
   1174e:	e048      	b.n	117e2 <sd_acmd51+0xde>
	}
	if (!driver_start_read_blocks(scr, 1)) {
   11750:	003b      	movs	r3, r7
   11752:	2101      	movs	r1, #1
   11754:	0018      	movs	r0, r3
   11756:	4b2a      	ldr	r3, [pc, #168]	; (11800 <sd_acmd51+0xfc>)
   11758:	4798      	blx	r3
   1175a:	0003      	movs	r3, r0
   1175c:	001a      	movs	r2, r3
   1175e:	2301      	movs	r3, #1
   11760:	4053      	eors	r3, r2
   11762:	b2db      	uxtb	r3, r3
   11764:	2b00      	cmp	r3, #0
   11766:	d001      	beq.n	1176c <sd_acmd51+0x68>
		return false;
   11768:	2300      	movs	r3, #0
   1176a:	e03a      	b.n	117e2 <sd_acmd51+0xde>
	}
	if (!driver_wait_end_of_read_blocks()) {
   1176c:	4b25      	ldr	r3, [pc, #148]	; (11804 <sd_acmd51+0x100>)
   1176e:	4798      	blx	r3
   11770:	0003      	movs	r3, r0
   11772:	001a      	movs	r2, r3
   11774:	2301      	movs	r3, #1
   11776:	4053      	eors	r3, r2
   11778:	b2db      	uxtb	r3, r3
   1177a:	2b00      	cmp	r3, #0
   1177c:	d001      	beq.n	11782 <sd_acmd51+0x7e>
		return false;
   1177e:	2300      	movs	r3, #0
   11780:	e02f      	b.n	117e2 <sd_acmd51+0xde>
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
   11782:	0038      	movs	r0, r7
   11784:	2304      	movs	r3, #4
   11786:	2238      	movs	r2, #56	; 0x38
   11788:	2140      	movs	r1, #64	; 0x40
   1178a:	4c1f      	ldr	r4, [pc, #124]	; (11808 <sd_acmd51+0x104>)
   1178c:	47a0      	blx	r4
   1178e:	1e03      	subs	r3, r0, #0
   11790:	2b01      	cmp	r3, #1
   11792:	d008      	beq.n	117a6 <sd_acmd51+0xa2>
   11794:	d302      	bcc.n	1179c <sd_acmd51+0x98>
   11796:	2b02      	cmp	r3, #2
   11798:	d00a      	beq.n	117b0 <sd_acmd51+0xac>
   1179a:	e01c      	b.n	117d6 <sd_acmd51+0xd2>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
   1179c:	4b13      	ldr	r3, [pc, #76]	; (117ec <sd_acmd51+0xe8>)
   1179e:	681b      	ldr	r3, [r3, #0]
   117a0:	2210      	movs	r2, #16
   117a2:	741a      	strb	r2, [r3, #16]
		break;
   117a4:	e01c      	b.n	117e0 <sd_acmd51+0xdc>

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
   117a6:	4b11      	ldr	r3, [pc, #68]	; (117ec <sd_acmd51+0xe8>)
   117a8:	681b      	ldr	r3, [r3, #0]
   117aa:	221a      	movs	r2, #26
   117ac:	741a      	strb	r2, [r3, #16]
		break;
   117ae:	e017      	b.n	117e0 <sd_acmd51+0xdc>

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
   117b0:	0038      	movs	r0, r7
   117b2:	2301      	movs	r3, #1
   117b4:	222f      	movs	r2, #47	; 0x2f
   117b6:	2140      	movs	r1, #64	; 0x40
   117b8:	4c13      	ldr	r4, [pc, #76]	; (11808 <sd_acmd51+0x104>)
   117ba:	47a0      	blx	r4
   117bc:	1e03      	subs	r3, r0, #0
   117be:	2b01      	cmp	r3, #1
   117c0:	d104      	bne.n	117cc <sd_acmd51+0xc8>
			sd_mmc_card->version = CARD_VER_SD_3_0;
   117c2:	4b0a      	ldr	r3, [pc, #40]	; (117ec <sd_acmd51+0xe8>)
   117c4:	681b      	ldr	r3, [r3, #0]
   117c6:	2230      	movs	r2, #48	; 0x30
   117c8:	741a      	strb	r2, [r3, #16]
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
		}
		break;
   117ca:	e009      	b.n	117e0 <sd_acmd51+0xdc>

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
			sd_mmc_card->version = CARD_VER_SD_3_0;
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
   117cc:	4b07      	ldr	r3, [pc, #28]	; (117ec <sd_acmd51+0xe8>)
   117ce:	681b      	ldr	r3, [r3, #0]
   117d0:	2220      	movs	r2, #32
   117d2:	741a      	strb	r2, [r3, #16]
		}
		break;
   117d4:	e004      	b.n	117e0 <sd_acmd51+0xdc>

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
   117d6:	4b05      	ldr	r3, [pc, #20]	; (117ec <sd_acmd51+0xe8>)
   117d8:	681b      	ldr	r3, [r3, #0]
   117da:	2210      	movs	r2, #16
   117dc:	741a      	strb	r2, [r3, #16]
		break;
   117de:	46c0      	nop			; (mov r8, r8)
	}
	return true;
   117e0:	2301      	movs	r3, #1
}
   117e2:	0018      	movs	r0, r3
   117e4:	46bd      	mov	sp, r7
   117e6:	b003      	add	sp, #12
   117e8:	bd90      	pop	{r4, r7, pc}
   117ea:	46c0      	nop			; (mov r8, r8)
   117ec:	20002dcc 	.word	0x20002dcc
   117f0:	00001137 	.word	0x00001137
   117f4:	00012cfd 	.word	0x00012cfd
   117f8:	00081133 	.word	0x00081133
   117fc:	00012d25 	.word	0x00012d25
   11800:	00012ff5 	.word	0x00012ff5
   11804:	00013099 	.word	0x00013099
   11808:	00010ecd 	.word	0x00010ecd

0001180c <sd_mmc_select_slot>:
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
   1180c:	b580      	push	{r7, lr}
   1180e:	b082      	sub	sp, #8
   11810:	af00      	add	r7, sp, #0
   11812:	0002      	movs	r2, r0
   11814:	1dfb      	adds	r3, r7, #7
   11816:	701a      	strb	r2, [r3, #0]
	if (slot >= SD_MMC_MEM_CNT) {
   11818:	1dfb      	adds	r3, r7, #7
   1181a:	781b      	ldrb	r3, [r3, #0]
   1181c:	2b00      	cmp	r3, #0
   1181e:	d001      	beq.n	11824 <sd_mmc_select_slot+0x18>
		return SD_MMC_ERR_SLOT;
   11820:	2304      	movs	r3, #4
   11822:	e0b3      	b.n	1198c <sd_mmc_select_slot+0x180>
	}
	Assert(sd_mmc_nb_block_remaining == 0);

#if (defined SD_MMC_0_CD_GPIO)
	//! Card Detect pins
	if (port_pin_get_input_level(sd_mmc_cards[slot].cd_gpio)
   11824:	1dfb      	adds	r3, r7, #7
   11826:	781a      	ldrb	r2, [r3, #0]
   11828:	495a      	ldr	r1, [pc, #360]	; (11994 <sd_mmc_select_slot+0x188>)
   1182a:	0013      	movs	r3, r2
   1182c:	00db      	lsls	r3, r3, #3
   1182e:	189b      	adds	r3, r3, r2
   11830:	009b      	lsls	r3, r3, #2
   11832:	18cb      	adds	r3, r1, r3
   11834:	3308      	adds	r3, #8
   11836:	681b      	ldr	r3, [r3, #0]
   11838:	b2db      	uxtb	r3, r3
   1183a:	0018      	movs	r0, r3
   1183c:	4b56      	ldr	r3, [pc, #344]	; (11998 <sd_mmc_select_slot+0x18c>)
   1183e:	4798      	blx	r3
   11840:	1e03      	subs	r3, r0, #0
   11842:	d01a      	beq.n	1187a <sd_mmc_select_slot+0x6e>
			!= SD_MMC_0_CD_DETECT_VALUE) {
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
   11844:	1dfb      	adds	r3, r7, #7
   11846:	781a      	ldrb	r2, [r3, #0]
   11848:	4952      	ldr	r1, [pc, #328]	; (11994 <sd_mmc_select_slot+0x188>)
   1184a:	0013      	movs	r3, r2
   1184c:	00db      	lsls	r3, r3, #3
   1184e:	189b      	adds	r3, r3, r2
   11850:	009b      	lsls	r3, r3, #2
   11852:	18cb      	adds	r3, r1, r3
   11854:	330e      	adds	r3, #14
   11856:	781b      	ldrb	r3, [r3, #0]
   11858:	2b01      	cmp	r3, #1
   1185a:	d101      	bne.n	11860 <sd_mmc_select_slot+0x54>
			SD_MMC_STOP_TIMEOUT();
   1185c:	4b4f      	ldr	r3, [pc, #316]	; (1199c <sd_mmc_select_slot+0x190>)
   1185e:	4798      	blx	r3
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
   11860:	1dfb      	adds	r3, r7, #7
   11862:	781a      	ldrb	r2, [r3, #0]
   11864:	494b      	ldr	r1, [pc, #300]	; (11994 <sd_mmc_select_slot+0x188>)
   11866:	0013      	movs	r3, r2
   11868:	00db      	lsls	r3, r3, #3
   1186a:	189b      	adds	r3, r3, r2
   1186c:	009b      	lsls	r3, r3, #2
   1186e:	18cb      	adds	r3, r1, r3
   11870:	330e      	adds	r3, #14
   11872:	2204      	movs	r2, #4
   11874:	701a      	strb	r2, [r3, #0]
		return SD_MMC_ERR_NO_CARD;
   11876:	2302      	movs	r3, #2
   11878:	e088      	b.n	1198c <sd_mmc_select_slot+0x180>
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
   1187a:	1dfb      	adds	r3, r7, #7
   1187c:	781a      	ldrb	r2, [r3, #0]
   1187e:	4945      	ldr	r1, [pc, #276]	; (11994 <sd_mmc_select_slot+0x188>)
   11880:	0013      	movs	r3, r2
   11882:	00db      	lsls	r3, r3, #3
   11884:	189b      	adds	r3, r3, r2
   11886:	009b      	lsls	r3, r3, #2
   11888:	18cb      	adds	r3, r1, r3
   1188a:	330e      	adds	r3, #14
   1188c:	781b      	ldrb	r3, [r3, #0]
   1188e:	2b04      	cmp	r3, #4
   11890:	d10e      	bne.n	118b0 <sd_mmc_select_slot+0xa4>
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
   11892:	1dfb      	adds	r3, r7, #7
   11894:	781a      	ldrb	r2, [r3, #0]
   11896:	493f      	ldr	r1, [pc, #252]	; (11994 <sd_mmc_select_slot+0x188>)
   11898:	0013      	movs	r3, r2
   1189a:	00db      	lsls	r3, r3, #3
   1189c:	189b      	adds	r3, r3, r2
   1189e:	009b      	lsls	r3, r3, #2
   118a0:	18cb      	adds	r3, r1, r3
   118a2:	330e      	adds	r3, #14
   118a4:	2201      	movs	r2, #1
   118a6:	701a      	strb	r2, [r3, #0]
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
   118a8:	4b3d      	ldr	r3, [pc, #244]	; (119a0 <sd_mmc_select_slot+0x194>)
   118aa:	4798      	blx	r3
		return SD_MMC_ERR_NO_CARD;
   118ac:	2302      	movs	r3, #2
   118ae:	e06d      	b.n	1198c <sd_mmc_select_slot+0x180>
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
   118b0:	1dfb      	adds	r3, r7, #7
   118b2:	781a      	ldrb	r2, [r3, #0]
   118b4:	4937      	ldr	r1, [pc, #220]	; (11994 <sd_mmc_select_slot+0x188>)
   118b6:	0013      	movs	r3, r2
   118b8:	00db      	lsls	r3, r3, #3
   118ba:	189b      	adds	r3, r3, r2
   118bc:	009b      	lsls	r3, r3, #2
   118be:	18cb      	adds	r3, r1, r3
   118c0:	330e      	adds	r3, #14
   118c2:	781b      	ldrb	r3, [r3, #0]
   118c4:	2b01      	cmp	r3, #1
   118c6:	d135      	bne.n	11934 <sd_mmc_select_slot+0x128>
		if (!SD_MMC_IS_TIMEOUT()) {
   118c8:	4b36      	ldr	r3, [pc, #216]	; (119a4 <sd_mmc_select_slot+0x198>)
   118ca:	4798      	blx	r3
   118cc:	0003      	movs	r3, r0
   118ce:	001a      	movs	r2, r3
   118d0:	2301      	movs	r3, #1
   118d2:	4053      	eors	r3, r2
   118d4:	b2db      	uxtb	r3, r3
   118d6:	2b00      	cmp	r3, #0
   118d8:	d001      	beq.n	118de <sd_mmc_select_slot+0xd2>
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
   118da:	2302      	movs	r3, #2
   118dc:	e056      	b.n	1198c <sd_mmc_select_slot+0x180>
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
   118de:	1dfb      	adds	r3, r7, #7
   118e0:	781a      	ldrb	r2, [r3, #0]
   118e2:	492c      	ldr	r1, [pc, #176]	; (11994 <sd_mmc_select_slot+0x188>)
   118e4:	0013      	movs	r3, r2
   118e6:	00db      	lsls	r3, r3, #3
   118e8:	189b      	adds	r3, r3, r2
   118ea:	009b      	lsls	r3, r3, #2
   118ec:	18cb      	adds	r3, r1, r3
   118ee:	330e      	adds	r3, #14
   118f0:	2202      	movs	r2, #2
   118f2:	701a      	strb	r2, [r3, #0]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
   118f4:	1dfb      	adds	r3, r7, #7
   118f6:	781a      	ldrb	r2, [r3, #0]
   118f8:	4926      	ldr	r1, [pc, #152]	; (11994 <sd_mmc_select_slot+0x188>)
   118fa:	0013      	movs	r3, r2
   118fc:	00db      	lsls	r3, r3, #3
   118fe:	189b      	adds	r3, r3, r2
   11900:	009b      	lsls	r3, r3, #2
   11902:	4a29      	ldr	r2, [pc, #164]	; (119a8 <sd_mmc_select_slot+0x19c>)
   11904:	505a      	str	r2, [r3, r1]
		sd_mmc_cards[slot].bus_width = 1;
   11906:	1dfb      	adds	r3, r7, #7
   11908:	781a      	ldrb	r2, [r3, #0]
   1190a:	4922      	ldr	r1, [pc, #136]	; (11994 <sd_mmc_select_slot+0x188>)
   1190c:	0013      	movs	r3, r2
   1190e:	00db      	lsls	r3, r3, #3
   11910:	189b      	adds	r3, r3, r2
   11912:	009b      	lsls	r3, r3, #2
   11914:	18cb      	adds	r3, r1, r3
   11916:	3311      	adds	r3, #17
   11918:	2201      	movs	r2, #1
   1191a:	701a      	strb	r2, [r3, #0]
		sd_mmc_cards[slot].high_speed = 0;
   1191c:	1dfb      	adds	r3, r7, #7
   1191e:	781a      	ldrb	r2, [r3, #0]
   11920:	491c      	ldr	r1, [pc, #112]	; (11994 <sd_mmc_select_slot+0x188>)
   11922:	2022      	movs	r0, #34	; 0x22
   11924:	0013      	movs	r3, r2
   11926:	00db      	lsls	r3, r3, #3
   11928:	189b      	adds	r3, r3, r2
   1192a:	009b      	lsls	r3, r3, #2
   1192c:	18cb      	adds	r3, r1, r3
   1192e:	181b      	adds	r3, r3, r0
   11930:	2200      	movs	r2, #0
   11932:	701a      	strb	r2, [r3, #0]
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
   11934:	1dfb      	adds	r3, r7, #7
   11936:	781a      	ldrb	r2, [r3, #0]
   11938:	4916      	ldr	r1, [pc, #88]	; (11994 <sd_mmc_select_slot+0x188>)
   1193a:	0013      	movs	r3, r2
   1193c:	00db      	lsls	r3, r3, #3
   1193e:	189b      	adds	r3, r3, r2
   11940:	009b      	lsls	r3, r3, #2
   11942:	18cb      	adds	r3, r1, r3
   11944:	330e      	adds	r3, #14
   11946:	781b      	ldrb	r3, [r3, #0]
   11948:	2b03      	cmp	r3, #3
   1194a:	d101      	bne.n	11950 <sd_mmc_select_slot+0x144>
		return SD_MMC_ERR_UNUSABLE;
   1194c:	2303      	movs	r3, #3
   1194e:	e01d      	b.n	1198c <sd_mmc_select_slot+0x180>
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
   11950:	4b16      	ldr	r3, [pc, #88]	; (119ac <sd_mmc_select_slot+0x1a0>)
   11952:	1dfa      	adds	r2, r7, #7
   11954:	7812      	ldrb	r2, [r2, #0]
   11956:	701a      	strb	r2, [r3, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
   11958:	1dfb      	adds	r3, r7, #7
   1195a:	781a      	ldrb	r2, [r3, #0]
   1195c:	0013      	movs	r3, r2
   1195e:	00db      	lsls	r3, r3, #3
   11960:	189b      	adds	r3, r3, r2
   11962:	009b      	lsls	r3, r3, #2
   11964:	4a0b      	ldr	r2, [pc, #44]	; (11994 <sd_mmc_select_slot+0x188>)
   11966:	189a      	adds	r2, r3, r2
   11968:	4b11      	ldr	r3, [pc, #68]	; (119b0 <sd_mmc_select_slot+0x1a4>)
   1196a:	601a      	str	r2, [r3, #0]
	sd_mmc_configure_slot();
   1196c:	4b11      	ldr	r3, [pc, #68]	; (119b4 <sd_mmc_select_slot+0x1a8>)
   1196e:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
   11970:	1dfb      	adds	r3, r7, #7
   11972:	781a      	ldrb	r2, [r3, #0]
   11974:	4907      	ldr	r1, [pc, #28]	; (11994 <sd_mmc_select_slot+0x188>)
   11976:	0013      	movs	r3, r2
   11978:	00db      	lsls	r3, r3, #3
   1197a:	189b      	adds	r3, r3, r2
   1197c:	009b      	lsls	r3, r3, #2
   1197e:	18cb      	adds	r3, r1, r3
   11980:	330e      	adds	r3, #14
   11982:	781b      	ldrb	r3, [r3, #0]
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
   11984:	3b02      	subs	r3, #2
   11986:	425a      	negs	r2, r3
   11988:	4153      	adcs	r3, r2
   1198a:	b2db      	uxtb	r3, r3
}
   1198c:	0018      	movs	r0, r3
   1198e:	46bd      	mov	sp, r7
   11990:	b002      	add	sp, #8
   11992:	bd80      	pop	{r7, pc}
   11994:	2000002c 	.word	0x2000002c
   11998:	00010e89 	.word	0x00010e89
   1199c:	000110c5 	.word	0x000110c5
   119a0:	00011029 	.word	0x00011029
   119a4:	00011089 	.word	0x00011089
   119a8:	00061a80 	.word	0x00061a80
   119ac:	20002dc8 	.word	0x20002dc8
   119b0:	20002dcc 	.word	0x20002dcc
   119b4:	000119b9 	.word	0x000119b9

000119b8 <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
   119b8:	b5b0      	push	{r4, r5, r7, lr}
   119ba:	af00      	add	r7, sp, #0
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
   119bc:	4b0a      	ldr	r3, [pc, #40]	; (119e8 <sd_mmc_configure_slot+0x30>)
   119be:	7818      	ldrb	r0, [r3, #0]
   119c0:	4b0a      	ldr	r3, [pc, #40]	; (119ec <sd_mmc_configure_slot+0x34>)
   119c2:	681b      	ldr	r3, [r3, #0]
   119c4:	6819      	ldr	r1, [r3, #0]
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
   119c6:	4b09      	ldr	r3, [pc, #36]	; (119ec <sd_mmc_configure_slot+0x34>)
   119c8:	681b      	ldr	r3, [r3, #0]
/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
   119ca:	7c5c      	ldrb	r4, [r3, #17]
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
   119cc:	4b07      	ldr	r3, [pc, #28]	; (119ec <sd_mmc_configure_slot+0x34>)
   119ce:	681b      	ldr	r3, [r3, #0]
   119d0:	2222      	movs	r2, #34	; 0x22
   119d2:	5c9b      	ldrb	r3, [r3, r2]
/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
   119d4:	1e5a      	subs	r2, r3, #1
   119d6:	4193      	sbcs	r3, r2
   119d8:	b2db      	uxtb	r3, r3
   119da:	0022      	movs	r2, r4
   119dc:	4c04      	ldr	r4, [pc, #16]	; (119f0 <sd_mmc_configure_slot+0x38>)
   119de:	47a0      	blx	r4
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
}
   119e0:	46c0      	nop			; (mov r8, r8)
   119e2:	46bd      	mov	sp, r7
   119e4:	bdb0      	pop	{r4, r5, r7, pc}
   119e6:	46c0      	nop			; (mov r8, r8)
   119e8:	20002dc8 	.word	0x20002dc8
   119ec:	20002dcc 	.word	0x20002dcc
   119f0:	00012be5 	.word	0x00012be5

000119f4 <sd_mmc_deselect_slot>:

/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
   119f4:	b580      	push	{r7, lr}
   119f6:	af00      	add	r7, sp, #0
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
   119f8:	4b05      	ldr	r3, [pc, #20]	; (11a10 <sd_mmc_deselect_slot+0x1c>)
   119fa:	781b      	ldrb	r3, [r3, #0]
   119fc:	2b00      	cmp	r3, #0
   119fe:	d104      	bne.n	11a0a <sd_mmc_deselect_slot+0x16>
		driver_deselect_device(sd_mmc_slot_sel);
   11a00:	4b03      	ldr	r3, [pc, #12]	; (11a10 <sd_mmc_deselect_slot+0x1c>)
   11a02:	781b      	ldrb	r3, [r3, #0]
   11a04:	0018      	movs	r0, r3
   11a06:	4b03      	ldr	r3, [pc, #12]	; (11a14 <sd_mmc_deselect_slot+0x20>)
   11a08:	4798      	blx	r3
	}
}
   11a0a:	46c0      	nop			; (mov r8, r8)
   11a0c:	46bd      	mov	sp, r7
   11a0e:	bd80      	pop	{r7, pc}
   11a10:	20002dc8 	.word	0x20002dc8
   11a14:	00012c6d 	.word	0x00012c6d

00011a18 <sd_mmc_spi_card_init>:
 * At last, it will automaticly enable maximum bus width and transfer speed.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_spi_card_init(void)
{
   11a18:	b580      	push	{r7, lr}
   11a1a:	b082      	sub	sp, #8
   11a1c:	af00      	add	r7, sp, #0
	uint8_t v2 = 0;
   11a1e:	1dfb      	adds	r3, r7, #7
   11a20:	2200      	movs	r2, #0
   11a22:	701a      	strb	r2, [r3, #0]

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
   11a24:	4b59      	ldr	r3, [pc, #356]	; (11b8c <sd_mmc_spi_card_init+0x174>)
   11a26:	681b      	ldr	r3, [r3, #0]
   11a28:	2201      	movs	r2, #1
   11a2a:	73da      	strb	r2, [r3, #15]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
   11a2c:	4b57      	ldr	r3, [pc, #348]	; (11b8c <sd_mmc_spi_card_init+0x174>)
   11a2e:	681b      	ldr	r3, [r3, #0]
   11a30:	2200      	movs	r2, #0
   11a32:	741a      	strb	r2, [r3, #16]
	sd_mmc_card->rca = 0;
   11a34:	4b55      	ldr	r3, [pc, #340]	; (11b8c <sd_mmc_spi_card_init+0x174>)
   11a36:	681b      	ldr	r3, [r3, #0]
   11a38:	2200      	movs	r2, #0
   11a3a:	819a      	strh	r2, [r3, #12]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
   11a3c:	4b54      	ldr	r3, [pc, #336]	; (11b90 <sd_mmc_spi_card_init+0x178>)
   11a3e:	4798      	blx	r3

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_SPI_CMD0_GO_IDLE_STATE, 0)) {
   11a40:	2388      	movs	r3, #136	; 0x88
   11a42:	015b      	lsls	r3, r3, #5
   11a44:	2100      	movs	r1, #0
   11a46:	0018      	movs	r0, r3
   11a48:	4b52      	ldr	r3, [pc, #328]	; (11b94 <sd_mmc_spi_card_init+0x17c>)
   11a4a:	4798      	blx	r3
   11a4c:	0003      	movs	r3, r0
   11a4e:	001a      	movs	r2, r3
   11a50:	2301      	movs	r3, #1
   11a52:	4053      	eors	r3, r2
   11a54:	b2db      	uxtb	r3, r3
   11a56:	2b00      	cmp	r3, #0
   11a58:	d001      	beq.n	11a5e <sd_mmc_spi_card_init+0x46>
		return false;
   11a5a:	2300      	movs	r3, #0
   11a5c:	e092      	b.n	11b84 <sd_mmc_spi_card_init+0x16c>
	}
	if (!sd_cmd8(&v2)) {
   11a5e:	1dfb      	adds	r3, r7, #7
   11a60:	0018      	movs	r0, r3
   11a62:	4b4d      	ldr	r3, [pc, #308]	; (11b98 <sd_mmc_spi_card_init+0x180>)
   11a64:	4798      	blx	r3
   11a66:	0003      	movs	r3, r0
   11a68:	001a      	movs	r2, r3
   11a6a:	2301      	movs	r3, #1
   11a6c:	4053      	eors	r3, r2
   11a6e:	b2db      	uxtb	r3, r3
   11a70:	2b00      	cmp	r3, #0
   11a72:	d001      	beq.n	11a78 <sd_mmc_spi_card_init+0x60>
		return false;
   11a74:	2300      	movs	r3, #0
   11a76:	e085      	b.n	11b84 <sd_mmc_spi_card_init+0x16c>
	}
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
   11a78:	4b48      	ldr	r3, [pc, #288]	; (11b9c <sd_mmc_spi_card_init+0x184>)
   11a7a:	4798      	blx	r3
   11a7c:	0003      	movs	r3, r0
   11a7e:	001a      	movs	r2, r3
   11a80:	2301      	movs	r3, #1
   11a82:	4053      	eors	r3, r2
   11a84:	b2db      	uxtb	r3, r3
   11a86:	2b00      	cmp	r3, #0
   11a88:	d001      	beq.n	11a8e <sd_mmc_spi_card_init+0x76>
		return false;
   11a8a:	2300      	movs	r3, #0
   11a8c:	e07a      	b.n	11b84 <sd_mmc_spi_card_init+0x16c>
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
   11a8e:	4b3f      	ldr	r3, [pc, #252]	; (11b8c <sd_mmc_spi_card_init+0x174>)
   11a90:	681b      	ldr	r3, [r3, #0]
   11a92:	7bdb      	ldrb	r3, [r3, #15]
   11a94:	001a      	movs	r2, r3
   11a96:	2301      	movs	r3, #1
   11a98:	4013      	ands	r3, r2
   11a9a:	d021      	beq.n	11ae0 <sd_mmc_spi_card_init+0xc8>
		// Try to get the SD card's operating condition
		if (!sd_spi_op_cond(v2)) {
   11a9c:	1dfb      	adds	r3, r7, #7
   11a9e:	781b      	ldrb	r3, [r3, #0]
   11aa0:	0018      	movs	r0, r3
   11aa2:	4b3f      	ldr	r3, [pc, #252]	; (11ba0 <sd_mmc_spi_card_init+0x188>)
   11aa4:	4798      	blx	r3
   11aa6:	0003      	movs	r3, r0
   11aa8:	001a      	movs	r2, r3
   11aaa:	2301      	movs	r3, #1
   11aac:	4053      	eors	r3, r2
   11aae:	b2db      	uxtb	r3, r3
   11ab0:	2b00      	cmp	r3, #0
   11ab2:	d007      	beq.n	11ac4 <sd_mmc_spi_card_init+0xac>
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
   11ab4:	4b35      	ldr	r3, [pc, #212]	; (11b8c <sd_mmc_spi_card_init+0x174>)
   11ab6:	681b      	ldr	r3, [r3, #0]
   11ab8:	2202      	movs	r2, #2
   11aba:	73da      	strb	r2, [r3, #15]
			return sd_mmc_spi_install_mmc();
   11abc:	4b39      	ldr	r3, [pc, #228]	; (11ba4 <sd_mmc_spi_card_init+0x18c>)
   11abe:	4798      	blx	r3
   11ac0:	0003      	movs	r3, r0
   11ac2:	e05f      	b.n	11b84 <sd_mmc_spi_card_init+0x16c>
		 * However, to be sure, the CRC OFF command is send.
		 * Unfortunately, specific SDIO card does not support it
		 * (H&D wireless card - HDG104 WiFi SIP)
		 * and the command is send only on SD card.
		 */
		if (!driver_send_cmd(SDMMC_SPI_CMD59_CRC_ON_OFF, 0)) {
   11ac4:	4b38      	ldr	r3, [pc, #224]	; (11ba8 <sd_mmc_spi_card_init+0x190>)
   11ac6:	2100      	movs	r1, #0
   11ac8:	0018      	movs	r0, r3
   11aca:	4b32      	ldr	r3, [pc, #200]	; (11b94 <sd_mmc_spi_card_init+0x17c>)
   11acc:	4798      	blx	r3
   11ace:	0003      	movs	r3, r0
   11ad0:	001a      	movs	r2, r3
   11ad2:	2301      	movs	r3, #1
   11ad4:	4053      	eors	r3, r2
   11ad6:	b2db      	uxtb	r3, r3
   11ad8:	2b00      	cmp	r3, #0
   11ada:	d001      	beq.n	11ae0 <sd_mmc_spi_card_init+0xc8>
			return false;
   11adc:	2300      	movs	r3, #0
   11ade:	e051      	b.n	11b84 <sd_mmc_spi_card_init+0x16c>
		}
	}
	// SD MEMORY
	if (sd_mmc_card->type & CARD_TYPE_SD) {
   11ae0:	4b2a      	ldr	r3, [pc, #168]	; (11b8c <sd_mmc_spi_card_init+0x174>)
   11ae2:	681b      	ldr	r3, [r3, #0]
   11ae4:	7bdb      	ldrb	r3, [r3, #15]
   11ae6:	001a      	movs	r2, r3
   11ae8:	2301      	movs	r3, #1
   11aea:	4013      	ands	r3, r2
   11aec:	d017      	beq.n	11b1e <sd_mmc_spi_card_init+0x106>
		// Get the Card-Specific Data
		if (!sd_mmc_cmd9_spi()) {
   11aee:	4b2f      	ldr	r3, [pc, #188]	; (11bac <sd_mmc_spi_card_init+0x194>)
   11af0:	4798      	blx	r3
   11af2:	0003      	movs	r3, r0
   11af4:	001a      	movs	r2, r3
   11af6:	2301      	movs	r3, #1
   11af8:	4053      	eors	r3, r2
   11afa:	b2db      	uxtb	r3, r3
   11afc:	2b00      	cmp	r3, #0
   11afe:	d001      	beq.n	11b04 <sd_mmc_spi_card_init+0xec>
			return false;
   11b00:	2300      	movs	r3, #0
   11b02:	e03f      	b.n	11b84 <sd_mmc_spi_card_init+0x16c>
		}
		sd_decode_csd();
   11b04:	4b2a      	ldr	r3, [pc, #168]	; (11bb0 <sd_mmc_spi_card_init+0x198>)
   11b06:	4798      	blx	r3
		// Read the SCR to get card version
		if (!sd_acmd51()) {
   11b08:	4b2a      	ldr	r3, [pc, #168]	; (11bb4 <sd_mmc_spi_card_init+0x19c>)
   11b0a:	4798      	blx	r3
   11b0c:	0003      	movs	r3, r0
   11b0e:	001a      	movs	r2, r3
   11b10:	2301      	movs	r3, #1
   11b12:	4053      	eors	r3, r2
   11b14:	b2db      	uxtb	r3, r3
   11b16:	2b00      	cmp	r3, #0
   11b18:	d001      	beq.n	11b1e <sd_mmc_spi_card_init+0x106>
			return false;
   11b1a:	2300      	movs	r3, #0
   11b1c:	e032      	b.n	11b84 <sd_mmc_spi_card_init+0x16c>
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	// SD MEMORY not HC, Set default block size
	if ((sd_mmc_card->type & CARD_TYPE_SD) &&
   11b1e:	4b1b      	ldr	r3, [pc, #108]	; (11b8c <sd_mmc_spi_card_init+0x174>)
   11b20:	681b      	ldr	r3, [r3, #0]
   11b22:	7bdb      	ldrb	r3, [r3, #15]
   11b24:	001a      	movs	r2, r3
   11b26:	2301      	movs	r3, #1
   11b28:	4013      	ands	r3, r2
   11b2a:	d016      	beq.n	11b5a <sd_mmc_spi_card_init+0x142>
			(0 == (sd_mmc_card->type & CARD_TYPE_HC))) {
   11b2c:	4b17      	ldr	r3, [pc, #92]	; (11b8c <sd_mmc_spi_card_init+0x174>)
   11b2e:	681b      	ldr	r3, [r3, #0]
   11b30:	7bdb      	ldrb	r3, [r3, #15]
   11b32:	001a      	movs	r2, r3
   11b34:	2308      	movs	r3, #8
   11b36:	4013      	ands	r3, r2
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	// SD MEMORY not HC, Set default block size
	if ((sd_mmc_card->type & CARD_TYPE_SD) &&
   11b38:	d10f      	bne.n	11b5a <sd_mmc_spi_card_init+0x142>
			(0 == (sd_mmc_card->type & CARD_TYPE_HC))) {
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
   11b3a:	2380      	movs	r3, #128	; 0x80
   11b3c:	009b      	lsls	r3, r3, #2
   11b3e:	4a1e      	ldr	r2, [pc, #120]	; (11bb8 <sd_mmc_spi_card_init+0x1a0>)
   11b40:	0019      	movs	r1, r3
   11b42:	0010      	movs	r0, r2
   11b44:	4b13      	ldr	r3, [pc, #76]	; (11b94 <sd_mmc_spi_card_init+0x17c>)
   11b46:	4798      	blx	r3
   11b48:	0003      	movs	r3, r0
   11b4a:	001a      	movs	r2, r3
   11b4c:	2301      	movs	r3, #1
   11b4e:	4053      	eors	r3, r2
   11b50:	b2db      	uxtb	r3, r3
   11b52:	2b00      	cmp	r3, #0
   11b54:	d001      	beq.n	11b5a <sd_mmc_spi_card_init+0x142>
			return false;
   11b56:	2300      	movs	r3, #0
   11b58:	e014      	b.n	11b84 <sd_mmc_spi_card_init+0x16c>
		}
	}
	// Check communication
	if (sd_mmc_card->type & CARD_TYPE_SD) {
   11b5a:	4b0c      	ldr	r3, [pc, #48]	; (11b8c <sd_mmc_spi_card_init+0x174>)
   11b5c:	681b      	ldr	r3, [r3, #0]
   11b5e:	7bdb      	ldrb	r3, [r3, #15]
   11b60:	001a      	movs	r2, r3
   11b62:	2301      	movs	r3, #1
   11b64:	4013      	ands	r3, r2
   11b66:	d00a      	beq.n	11b7e <sd_mmc_spi_card_init+0x166>
		if (!sd_mmc_cmd13()) {
   11b68:	4b14      	ldr	r3, [pc, #80]	; (11bbc <sd_mmc_spi_card_init+0x1a4>)
   11b6a:	4798      	blx	r3
   11b6c:	0003      	movs	r3, r0
   11b6e:	001a      	movs	r2, r3
   11b70:	2301      	movs	r3, #1
   11b72:	4053      	eors	r3, r2
   11b74:	b2db      	uxtb	r3, r3
   11b76:	2b00      	cmp	r3, #0
   11b78:	d001      	beq.n	11b7e <sd_mmc_spi_card_init+0x166>
			return false;
   11b7a:	2300      	movs	r3, #0
   11b7c:	e002      	b.n	11b84 <sd_mmc_spi_card_init+0x16c>
		}
	}
	// Reinitialize the slot with the new speed
	sd_mmc_configure_slot();
   11b7e:	4b10      	ldr	r3, [pc, #64]	; (11bc0 <sd_mmc_spi_card_init+0x1a8>)
   11b80:	4798      	blx	r3
	return true;
   11b82:	2301      	movs	r3, #1
}
   11b84:	0018      	movs	r0, r3
   11b86:	46bd      	mov	sp, r7
   11b88:	b002      	add	sp, #8
   11b8a:	bd80      	pop	{r7, pc}
   11b8c:	20002dcc 	.word	0x20002dcc
   11b90:	00012cb1 	.word	0x00012cb1
   11b94:	00012cfd 	.word	0x00012cfd
   11b98:	00011281 	.word	0x00011281
   11b9c:	00011275 	.word	0x00011275
   11ba0:	00011191 	.word	0x00011191
   11ba4:	00011bc5 	.word	0x00011bc5
   11ba8:	0000113b 	.word	0x0000113b
   11bac:	0001141d 	.word	0x0001141d
   11bb0:	000115bd 	.word	0x000115bd
   11bb4:	00011705 	.word	0x00011705
   11bb8:	00001110 	.word	0x00001110
   11bbc:	000116a9 	.word	0x000116a9
   11bc0:	000119b9 	.word	0x000119b9

00011bc4 <sd_mmc_spi_install_mmc>:
 * At last, it will automaticly enable maximum bus width and transfer speed.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_spi_install_mmc(void)
{
   11bc4:	b580      	push	{r7, lr}
   11bc6:	b082      	sub	sp, #8
   11bc8:	af00      	add	r7, sp, #0
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_SPI_CMD0_GO_IDLE_STATE, 0)) {
   11bca:	2388      	movs	r3, #136	; 0x88
   11bcc:	015b      	lsls	r3, r3, #5
   11bce:	2100      	movs	r1, #0
   11bd0:	0018      	movs	r0, r3
   11bd2:	4b32      	ldr	r3, [pc, #200]	; (11c9c <sd_mmc_spi_install_mmc+0xd8>)
   11bd4:	4798      	blx	r3
   11bd6:	0003      	movs	r3, r0
   11bd8:	001a      	movs	r2, r3
   11bda:	2301      	movs	r3, #1
   11bdc:	4053      	eors	r3, r2
   11bde:	b2db      	uxtb	r3, r3
   11be0:	2b00      	cmp	r3, #0
   11be2:	d001      	beq.n	11be8 <sd_mmc_spi_install_mmc+0x24>
		return false;
   11be4:	2300      	movs	r3, #0
   11be6:	e055      	b.n	11c94 <sd_mmc_spi_install_mmc+0xd0>
	}

	if (!mmc_spi_op_cond()) {
   11be8:	4b2d      	ldr	r3, [pc, #180]	; (11ca0 <sd_mmc_spi_install_mmc+0xdc>)
   11bea:	4798      	blx	r3
   11bec:	0003      	movs	r3, r0
   11bee:	001a      	movs	r2, r3
   11bf0:	2301      	movs	r3, #1
   11bf2:	4053      	eors	r3, r2
   11bf4:	b2db      	uxtb	r3, r3
   11bf6:	2b00      	cmp	r3, #0
   11bf8:	d001      	beq.n	11bfe <sd_mmc_spi_install_mmc+0x3a>
		return false;
   11bfa:	2300      	movs	r3, #0
   11bfc:	e04a      	b.n	11c94 <sd_mmc_spi_install_mmc+0xd0>
	}

	// Disable CRC check for SPI mode
	if (!driver_send_cmd(SDMMC_SPI_CMD59_CRC_ON_OFF, 0)) {
   11bfe:	4b29      	ldr	r3, [pc, #164]	; (11ca4 <sd_mmc_spi_install_mmc+0xe0>)
   11c00:	2100      	movs	r1, #0
   11c02:	0018      	movs	r0, r3
   11c04:	4b25      	ldr	r3, [pc, #148]	; (11c9c <sd_mmc_spi_install_mmc+0xd8>)
   11c06:	4798      	blx	r3
   11c08:	0003      	movs	r3, r0
   11c0a:	001a      	movs	r2, r3
   11c0c:	2301      	movs	r3, #1
   11c0e:	4053      	eors	r3, r2
   11c10:	b2db      	uxtb	r3, r3
   11c12:	2b00      	cmp	r3, #0
   11c14:	d001      	beq.n	11c1a <sd_mmc_spi_install_mmc+0x56>
		return false;
   11c16:	2300      	movs	r3, #0
   11c18:	e03c      	b.n	11c94 <sd_mmc_spi_install_mmc+0xd0>
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_spi()) {
   11c1a:	4b23      	ldr	r3, [pc, #140]	; (11ca8 <sd_mmc_spi_install_mmc+0xe4>)
   11c1c:	4798      	blx	r3
   11c1e:	0003      	movs	r3, r0
   11c20:	001a      	movs	r2, r3
   11c22:	2301      	movs	r3, #1
   11c24:	4053      	eors	r3, r2
   11c26:	b2db      	uxtb	r3, r3
   11c28:	2b00      	cmp	r3, #0
   11c2a:	d001      	beq.n	11c30 <sd_mmc_spi_install_mmc+0x6c>
		return false;
   11c2c:	2300      	movs	r3, #0
   11c2e:	e031      	b.n	11c94 <sd_mmc_spi_install_mmc+0xd0>
	}
	mmc_decode_csd();
   11c30:	4b1e      	ldr	r3, [pc, #120]	; (11cac <sd_mmc_spi_install_mmc+0xe8>)
   11c32:	4798      	blx	r3
	// For MMC 4.0 Higher version
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
   11c34:	4b1e      	ldr	r3, [pc, #120]	; (11cb0 <sd_mmc_spi_install_mmc+0xec>)
   11c36:	681b      	ldr	r3, [r3, #0]
   11c38:	7c1b      	ldrb	r3, [r3, #16]
   11c3a:	2b3f      	cmp	r3, #63	; 0x3f
   11c3c:	d90c      	bls.n	11c58 <sd_mmc_spi_install_mmc+0x94>
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
   11c3e:	1dfb      	adds	r3, r7, #7
   11c40:	0018      	movs	r0, r3
   11c42:	4b1c      	ldr	r3, [pc, #112]	; (11cb4 <sd_mmc_spi_install_mmc+0xf0>)
   11c44:	4798      	blx	r3
   11c46:	0003      	movs	r3, r0
   11c48:	001a      	movs	r2, r3
   11c4a:	2301      	movs	r3, #1
   11c4c:	4053      	eors	r3, r2
   11c4e:	b2db      	uxtb	r3, r3
   11c50:	2b00      	cmp	r3, #0
   11c52:	d001      	beq.n	11c58 <sd_mmc_spi_install_mmc+0x94>
			return false;
   11c54:	2300      	movs	r3, #0
   11c56:	e01d      	b.n	11c94 <sd_mmc_spi_install_mmc+0xd0>
		}
	}
	// Set default block size
	if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
   11c58:	2380      	movs	r3, #128	; 0x80
   11c5a:	009b      	lsls	r3, r3, #2
   11c5c:	4a16      	ldr	r2, [pc, #88]	; (11cb8 <sd_mmc_spi_install_mmc+0xf4>)
   11c5e:	0019      	movs	r1, r3
   11c60:	0010      	movs	r0, r2
   11c62:	4b0e      	ldr	r3, [pc, #56]	; (11c9c <sd_mmc_spi_install_mmc+0xd8>)
   11c64:	4798      	blx	r3
   11c66:	0003      	movs	r3, r0
   11c68:	001a      	movs	r2, r3
   11c6a:	2301      	movs	r3, #1
   11c6c:	4053      	eors	r3, r2
   11c6e:	b2db      	uxtb	r3, r3
   11c70:	2b00      	cmp	r3, #0
   11c72:	d001      	beq.n	11c78 <sd_mmc_spi_install_mmc+0xb4>
		return false;
   11c74:	2300      	movs	r3, #0
   11c76:	e00d      	b.n	11c94 <sd_mmc_spi_install_mmc+0xd0>
	}
	// Check communication
	if (!sd_mmc_cmd13()) {
   11c78:	4b10      	ldr	r3, [pc, #64]	; (11cbc <sd_mmc_spi_install_mmc+0xf8>)
   11c7a:	4798      	blx	r3
   11c7c:	0003      	movs	r3, r0
   11c7e:	001a      	movs	r2, r3
   11c80:	2301      	movs	r3, #1
   11c82:	4053      	eors	r3, r2
   11c84:	b2db      	uxtb	r3, r3
   11c86:	2b00      	cmp	r3, #0
   11c88:	d001      	beq.n	11c8e <sd_mmc_spi_install_mmc+0xca>
		return false;
   11c8a:	2300      	movs	r3, #0
   11c8c:	e002      	b.n	11c94 <sd_mmc_spi_install_mmc+0xd0>
	}
	// Reinitialize the slot with the new speed
	sd_mmc_configure_slot();
   11c8e:	4b0c      	ldr	r3, [pc, #48]	; (11cc0 <sd_mmc_spi_install_mmc+0xfc>)
   11c90:	4798      	blx	r3
	return true;
   11c92:	2301      	movs	r3, #1
}
   11c94:	0018      	movs	r0, r3
   11c96:	46bd      	mov	sp, r7
   11c98:	b002      	add	sp, #8
   11c9a:	bd80      	pop	{r7, pc}
   11c9c:	00012cfd 	.word	0x00012cfd
   11ca0:	000110e5 	.word	0x000110e5
   11ca4:	0000113b 	.word	0x0000113b
   11ca8:	0001141d 	.word	0x0001141d
   11cac:	0001148d 	.word	0x0001148d
   11cb0:	20002dcc 	.word	0x20002dcc
   11cb4:	000112f1 	.word	0x000112f1
   11cb8:	00001110 	.word	0x00001110
   11cbc:	000116a9 	.word	0x000116a9
   11cc0:	000119b9 	.word	0x000119b9

00011cc4 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
   11cc4:	b580      	push	{r7, lr}
   11cc6:	b082      	sub	sp, #8
   11cc8:	af00      	add	r7, sp, #0
# define SD_MMC_ENABLE_WP_PIN(slot, unused) \
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
   11cca:	1dfb      	adds	r3, r7, #7
   11ccc:	2200      	movs	r2, #0
   11cce:	701a      	strb	r2, [r3, #0]
   11cd0:	e00f      	b.n	11cf2 <sd_mmc_init+0x2e>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
   11cd2:	1dfb      	adds	r3, r7, #7
   11cd4:	781a      	ldrb	r2, [r3, #0]
   11cd6:	490d      	ldr	r1, [pc, #52]	; (11d0c <sd_mmc_init+0x48>)
   11cd8:	0013      	movs	r3, r2
   11cda:	00db      	lsls	r3, r3, #3
   11cdc:	189b      	adds	r3, r3, r2
   11cde:	009b      	lsls	r3, r3, #2
   11ce0:	18cb      	adds	r3, r1, r3
   11ce2:	330e      	adds	r3, #14
   11ce4:	2204      	movs	r2, #4
   11ce6:	701a      	strb	r2, [r3, #0]
# define SD_MMC_ENABLE_WP_PIN(slot, unused) \
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
   11ce8:	1dfb      	adds	r3, r7, #7
   11cea:	781a      	ldrb	r2, [r3, #0]
   11cec:	1dfb      	adds	r3, r7, #7
   11cee:	3201      	adds	r2, #1
   11cf0:	701a      	strb	r2, [r3, #0]
   11cf2:	1dfb      	adds	r3, r7, #7
   11cf4:	781b      	ldrb	r3, [r3, #0]
   11cf6:	2b00      	cmp	r3, #0
   11cf8:	d0eb      	beq.n	11cd2 <sd_mmc_init+0xe>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
   11cfa:	4b05      	ldr	r3, [pc, #20]	; (11d10 <sd_mmc_init+0x4c>)
   11cfc:	22ff      	movs	r2, #255	; 0xff
   11cfe:	701a      	strb	r2, [r3, #0]
	driver_init();
   11d00:	4b04      	ldr	r3, [pc, #16]	; (11d14 <sd_mmc_init+0x50>)
   11d02:	4798      	blx	r3
}
   11d04:	46c0      	nop			; (mov r8, r8)
   11d06:	46bd      	mov	sp, r7
   11d08:	b002      	add	sp, #8
   11d0a:	bd80      	pop	{r7, pc}
   11d0c:	2000002c 	.word	0x2000002c
   11d10:	20002dc8 	.word	0x20002dc8
   11d14:	00012af1 	.word	0x00012af1

00011d18 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
   11d18:	b590      	push	{r4, r7, lr}
   11d1a:	b085      	sub	sp, #20
   11d1c:	af00      	add	r7, sp, #0
   11d1e:	0002      	movs	r2, r0
   11d20:	1dfb      	adds	r3, r7, #7
   11d22:	701a      	strb	r2, [r3, #0]
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
   11d24:	230f      	movs	r3, #15
   11d26:	18fc      	adds	r4, r7, r3
   11d28:	1dfb      	adds	r3, r7, #7
   11d2a:	781b      	ldrb	r3, [r3, #0]
   11d2c:	0018      	movs	r0, r3
   11d2e:	4b13      	ldr	r3, [pc, #76]	; (11d7c <sd_mmc_check+0x64>)
   11d30:	4798      	blx	r3
   11d32:	0003      	movs	r3, r0
   11d34:	7023      	strb	r3, [r4, #0]
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
   11d36:	230f      	movs	r3, #15
   11d38:	18fb      	adds	r3, r7, r3
   11d3a:	781b      	ldrb	r3, [r3, #0]
   11d3c:	2b01      	cmp	r3, #1
   11d3e:	d005      	beq.n	11d4c <sd_mmc_check+0x34>
		sd_mmc_deselect_slot();
   11d40:	4b0f      	ldr	r3, [pc, #60]	; (11d80 <sd_mmc_check+0x68>)
   11d42:	4798      	blx	r3
		return sd_mmc_err;
   11d44:	230f      	movs	r3, #15
   11d46:	18fb      	adds	r3, r7, r3
   11d48:	781b      	ldrb	r3, [r3, #0]
   11d4a:	e012      	b.n	11d72 <sd_mmc_check+0x5a>
	}

	// Initialization of the card requested
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
   11d4c:	4b0d      	ldr	r3, [pc, #52]	; (11d84 <sd_mmc_check+0x6c>)
   11d4e:	4798      	blx	r3
   11d50:	1e03      	subs	r3, r0, #0
   11d52:	d007      	beq.n	11d64 <sd_mmc_check+0x4c>
			: sd_mmc_mci_card_init()) {
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
   11d54:	4b0c      	ldr	r3, [pc, #48]	; (11d88 <sd_mmc_check+0x70>)
   11d56:	681b      	ldr	r3, [r3, #0]
   11d58:	2200      	movs	r2, #0
   11d5a:	739a      	strb	r2, [r3, #14]
		sd_mmc_deselect_slot();
   11d5c:	4b08      	ldr	r3, [pc, #32]	; (11d80 <sd_mmc_check+0x68>)
   11d5e:	4798      	blx	r3
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
   11d60:	2301      	movs	r3, #1
   11d62:	e006      	b.n	11d72 <sd_mmc_check+0x5a>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
   11d64:	4b08      	ldr	r3, [pc, #32]	; (11d88 <sd_mmc_check+0x70>)
   11d66:	681b      	ldr	r3, [r3, #0]
   11d68:	2203      	movs	r2, #3
   11d6a:	739a      	strb	r2, [r3, #14]
	sd_mmc_deselect_slot();
   11d6c:	4b04      	ldr	r3, [pc, #16]	; (11d80 <sd_mmc_check+0x68>)
   11d6e:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
   11d70:	2303      	movs	r3, #3
}
   11d72:	0018      	movs	r0, r3
   11d74:	46bd      	mov	sp, r7
   11d76:	b005      	add	sp, #20
   11d78:	bd90      	pop	{r4, r7, pc}
   11d7a:	46c0      	nop			; (mov r8, r8)
   11d7c:	0001180d 	.word	0x0001180d
   11d80:	000119f5 	.word	0x000119f5
   11d84:	00011a19 	.word	0x00011a19
   11d88:	20002dcc 	.word	0x20002dcc

00011d8c <sd_mmc_get_type>:

card_type_t sd_mmc_get_type(uint8_t slot)
{
   11d8c:	b580      	push	{r7, lr}
   11d8e:	b082      	sub	sp, #8
   11d90:	af00      	add	r7, sp, #0
   11d92:	0002      	movs	r2, r0
   11d94:	1dfb      	adds	r3, r7, #7
   11d96:	701a      	strb	r2, [r3, #0]
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
   11d98:	1dfb      	adds	r3, r7, #7
   11d9a:	781b      	ldrb	r3, [r3, #0]
   11d9c:	0018      	movs	r0, r3
   11d9e:	4b07      	ldr	r3, [pc, #28]	; (11dbc <sd_mmc_get_type+0x30>)
   11da0:	4798      	blx	r3
   11da2:	1e03      	subs	r3, r0, #0
   11da4:	d001      	beq.n	11daa <sd_mmc_get_type+0x1e>
		return CARD_TYPE_UNKNOWN;
   11da6:	2300      	movs	r3, #0
   11da8:	e004      	b.n	11db4 <sd_mmc_get_type+0x28>
	}
	sd_mmc_deselect_slot();
   11daa:	4b05      	ldr	r3, [pc, #20]	; (11dc0 <sd_mmc_get_type+0x34>)
   11dac:	4798      	blx	r3
	return sd_mmc_card->type;
   11dae:	4b05      	ldr	r3, [pc, #20]	; (11dc4 <sd_mmc_get_type+0x38>)
   11db0:	681b      	ldr	r3, [r3, #0]
   11db2:	7bdb      	ldrb	r3, [r3, #15]
}
   11db4:	0018      	movs	r0, r3
   11db6:	46bd      	mov	sp, r7
   11db8:	b002      	add	sp, #8
   11dba:	bd80      	pop	{r7, pc}
   11dbc:	0001180d 	.word	0x0001180d
   11dc0:	000119f5 	.word	0x000119f5
   11dc4:	20002dcc 	.word	0x20002dcc

00011dc8 <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
   11dc8:	b580      	push	{r7, lr}
   11dca:	b082      	sub	sp, #8
   11dcc:	af00      	add	r7, sp, #0
   11dce:	0002      	movs	r2, r0
   11dd0:	1dfb      	adds	r3, r7, #7
   11dd2:	701a      	strb	r2, [r3, #0]
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
   11dd4:	1dfb      	adds	r3, r7, #7
   11dd6:	781b      	ldrb	r3, [r3, #0]
   11dd8:	0018      	movs	r0, r3
   11dda:	4b07      	ldr	r3, [pc, #28]	; (11df8 <sd_mmc_get_capacity+0x30>)
   11ddc:	4798      	blx	r3
   11dde:	1e03      	subs	r3, r0, #0
   11de0:	d001      	beq.n	11de6 <sd_mmc_get_capacity+0x1e>
		return 0;
   11de2:	2300      	movs	r3, #0
   11de4:	e004      	b.n	11df0 <sd_mmc_get_capacity+0x28>
	}
	sd_mmc_deselect_slot();
   11de6:	4b05      	ldr	r3, [pc, #20]	; (11dfc <sd_mmc_get_capacity+0x34>)
   11de8:	4798      	blx	r3
	return sd_mmc_card->capacity;
   11dea:	4b05      	ldr	r3, [pc, #20]	; (11e00 <sd_mmc_get_capacity+0x38>)
   11dec:	681b      	ldr	r3, [r3, #0]
   11dee:	685b      	ldr	r3, [r3, #4]
}
   11df0:	0018      	movs	r0, r3
   11df2:	46bd      	mov	sp, r7
   11df4:	b002      	add	sp, #8
   11df6:	bd80      	pop	{r7, pc}
   11df8:	0001180d 	.word	0x0001180d
   11dfc:	000119f5 	.word	0x000119f5
   11e00:	20002dcc 	.word	0x20002dcc

00011e04 <sd_mmc_is_write_protected>:

bool sd_mmc_is_write_protected(uint8_t slot)
{
   11e04:	b580      	push	{r7, lr}
   11e06:	b082      	sub	sp, #8
   11e08:	af00      	add	r7, sp, #0
   11e0a:	0002      	movs	r2, r0
   11e0c:	1dfb      	adds	r3, r7, #7
   11e0e:	701a      	strb	r2, [r3, #0]
	if (port_pin_get_input_level(sd_mmc_cards[slot].wp_gpio)
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
   11e10:	2300      	movs	r3, #0
}
   11e12:	0018      	movs	r0, r3
   11e14:	46bd      	mov	sp, r7
   11e16:	b002      	add	sp, #8
   11e18:	bd80      	pop	{r7, pc}
   11e1a:	46c0      	nop			; (mov r8, r8)

00011e1c <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
   11e1c:	b590      	push	{r4, r7, lr}
   11e1e:	b089      	sub	sp, #36	; 0x24
   11e20:	af02      	add	r7, sp, #8
   11e22:	6039      	str	r1, [r7, #0]
   11e24:	0011      	movs	r1, r2
   11e26:	1dfb      	adds	r3, r7, #7
   11e28:	1c02      	adds	r2, r0, #0
   11e2a:	701a      	strb	r2, [r3, #0]
   11e2c:	1d3b      	adds	r3, r7, #4
   11e2e:	1c0a      	adds	r2, r1, #0
   11e30:	801a      	strh	r2, [r3, #0]
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
   11e32:	230f      	movs	r3, #15
   11e34:	18fc      	adds	r4, r7, r3
   11e36:	1dfb      	adds	r3, r7, #7
   11e38:	781b      	ldrb	r3, [r3, #0]
   11e3a:	0018      	movs	r0, r3
   11e3c:	4b29      	ldr	r3, [pc, #164]	; (11ee4 <sd_mmc_init_read_blocks+0xc8>)
   11e3e:	4798      	blx	r3
   11e40:	0003      	movs	r3, r0
   11e42:	7023      	strb	r3, [r4, #0]
	if (sd_mmc_err != SD_MMC_OK) {
   11e44:	230f      	movs	r3, #15
   11e46:	18fb      	adds	r3, r7, r3
   11e48:	781b      	ldrb	r3, [r3, #0]
   11e4a:	2b00      	cmp	r3, #0
   11e4c:	d003      	beq.n	11e56 <sd_mmc_init_read_blocks+0x3a>
		return sd_mmc_err;
   11e4e:	230f      	movs	r3, #15
   11e50:	18fb      	adds	r3, r7, r3
   11e52:	781b      	ldrb	r3, [r3, #0]
   11e54:	e041      	b.n	11eda <sd_mmc_init_read_blocks+0xbe>
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
   11e56:	4b24      	ldr	r3, [pc, #144]	; (11ee8 <sd_mmc_init_read_blocks+0xcc>)
   11e58:	4798      	blx	r3
   11e5a:	0003      	movs	r3, r0
   11e5c:	001a      	movs	r2, r3
   11e5e:	2301      	movs	r3, #1
   11e60:	4053      	eors	r3, r2
   11e62:	b2db      	uxtb	r3, r3
   11e64:	2b00      	cmp	r3, #0
   11e66:	d003      	beq.n	11e70 <sd_mmc_init_read_blocks+0x54>
		sd_mmc_deselect_slot();
   11e68:	4b20      	ldr	r3, [pc, #128]	; (11eec <sd_mmc_init_read_blocks+0xd0>)
   11e6a:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
   11e6c:	2305      	movs	r3, #5
   11e6e:	e034      	b.n	11eda <sd_mmc_init_read_blocks+0xbe>
	}

	if (nb_block > 1) {
   11e70:	1d3b      	adds	r3, r7, #4
   11e72:	881b      	ldrh	r3, [r3, #0]
   11e74:	2b01      	cmp	r3, #1
   11e76:	d902      	bls.n	11e7e <sd_mmc_init_read_blocks+0x62>
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
   11e78:	4b1d      	ldr	r3, [pc, #116]	; (11ef0 <sd_mmc_init_read_blocks+0xd4>)
   11e7a:	617b      	str	r3, [r7, #20]
   11e7c:	e001      	b.n	11e82 <sd_mmc_init_read_blocks+0x66>
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
   11e7e:	4b1d      	ldr	r3, [pc, #116]	; (11ef4 <sd_mmc_init_read_blocks+0xd8>)
   11e80:	617b      	str	r3, [r7, #20]
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
   11e82:	4b1d      	ldr	r3, [pc, #116]	; (11ef8 <sd_mmc_init_read_blocks+0xdc>)
   11e84:	681b      	ldr	r3, [r3, #0]
   11e86:	7bdb      	ldrb	r3, [r3, #15]
   11e88:	001a      	movs	r2, r3
   11e8a:	2308      	movs	r3, #8
   11e8c:	4013      	ands	r3, r2
   11e8e:	d002      	beq.n	11e96 <sd_mmc_init_read_blocks+0x7a>
		arg = start;
   11e90:	683b      	ldr	r3, [r7, #0]
   11e92:	613b      	str	r3, [r7, #16]
   11e94:	e002      	b.n	11e9c <sd_mmc_init_read_blocks+0x80>
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
   11e96:	683b      	ldr	r3, [r7, #0]
   11e98:	025b      	lsls	r3, r3, #9
   11e9a:	613b      	str	r3, [r7, #16]
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
   11e9c:	1d3b      	adds	r3, r7, #4
   11e9e:	881c      	ldrh	r4, [r3, #0]
   11ea0:	2380      	movs	r3, #128	; 0x80
   11ea2:	009a      	lsls	r2, r3, #2
   11ea4:	6939      	ldr	r1, [r7, #16]
   11ea6:	6978      	ldr	r0, [r7, #20]
   11ea8:	2301      	movs	r3, #1
   11eaa:	9300      	str	r3, [sp, #0]
   11eac:	0023      	movs	r3, r4
   11eae:	4c13      	ldr	r4, [pc, #76]	; (11efc <sd_mmc_init_read_blocks+0xe0>)
   11eb0:	47a0      	blx	r4
   11eb2:	0003      	movs	r3, r0
   11eb4:	001a      	movs	r2, r3
   11eb6:	2301      	movs	r3, #1
   11eb8:	4053      	eors	r3, r2
   11eba:	b2db      	uxtb	r3, r3
   11ebc:	2b00      	cmp	r3, #0
   11ebe:	d003      	beq.n	11ec8 <sd_mmc_init_read_blocks+0xac>
		sd_mmc_deselect_slot();
   11ec0:	4b0a      	ldr	r3, [pc, #40]	; (11eec <sd_mmc_init_read_blocks+0xd0>)
   11ec2:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
   11ec4:	2305      	movs	r3, #5
   11ec6:	e008      	b.n	11eda <sd_mmc_init_read_blocks+0xbe>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
   11ec8:	4b0d      	ldr	r3, [pc, #52]	; (11f00 <sd_mmc_init_read_blocks+0xe4>)
   11eca:	1d3a      	adds	r2, r7, #4
   11ecc:	8812      	ldrh	r2, [r2, #0]
   11ece:	801a      	strh	r2, [r3, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
   11ed0:	4b0c      	ldr	r3, [pc, #48]	; (11f04 <sd_mmc_init_read_blocks+0xe8>)
   11ed2:	1d3a      	adds	r2, r7, #4
   11ed4:	8812      	ldrh	r2, [r2, #0]
   11ed6:	801a      	strh	r2, [r3, #0]
	return SD_MMC_OK;
   11ed8:	2300      	movs	r3, #0
}
   11eda:	0018      	movs	r0, r3
   11edc:	46bd      	mov	sp, r7
   11ede:	b007      	add	sp, #28
   11ee0:	bd90      	pop	{r4, r7, pc}
   11ee2:	46c0      	nop			; (mov r8, r8)
   11ee4:	0001180d 	.word	0x0001180d
   11ee8:	000116a9 	.word	0x000116a9
   11eec:	000119f5 	.word	0x000119f5
   11ef0:	00101112 	.word	0x00101112
   11ef4:	00081111 	.word	0x00081111
   11ef8:	20002dcc 	.word	0x20002dcc
   11efc:	00012d25 	.word	0x00012d25
   11f00:	20002dd2 	.word	0x20002dd2
   11f04:	20002dd0 	.word	0x20002dd0

00011f08 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
   11f08:	b580      	push	{r7, lr}
   11f0a:	b082      	sub	sp, #8
   11f0c:	af00      	add	r7, sp, #0
   11f0e:	6078      	str	r0, [r7, #4]
   11f10:	000a      	movs	r2, r1
   11f12:	1cbb      	adds	r3, r7, #2
   11f14:	801a      	strh	r2, [r3, #0]
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
   11f16:	1cbb      	adds	r3, r7, #2
   11f18:	881a      	ldrh	r2, [r3, #0]
   11f1a:	687b      	ldr	r3, [r7, #4]
   11f1c:	0011      	movs	r1, r2
   11f1e:	0018      	movs	r0, r3
   11f20:	4b0d      	ldr	r3, [pc, #52]	; (11f58 <sd_mmc_start_read_blocks+0x50>)
   11f22:	4798      	blx	r3
   11f24:	0003      	movs	r3, r0
   11f26:	001a      	movs	r2, r3
   11f28:	2301      	movs	r3, #1
   11f2a:	4053      	eors	r3, r2
   11f2c:	b2db      	uxtb	r3, r3
   11f2e:	2b00      	cmp	r3, #0
   11f30:	d004      	beq.n	11f3c <sd_mmc_start_read_blocks+0x34>
		sd_mmc_nb_block_remaining = 0;
   11f32:	4b0a      	ldr	r3, [pc, #40]	; (11f5c <sd_mmc_start_read_blocks+0x54>)
   11f34:	2200      	movs	r2, #0
   11f36:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
   11f38:	2305      	movs	r3, #5
   11f3a:	e008      	b.n	11f4e <sd_mmc_start_read_blocks+0x46>
	}
	sd_mmc_nb_block_remaining -= nb_block;
   11f3c:	4b07      	ldr	r3, [pc, #28]	; (11f5c <sd_mmc_start_read_blocks+0x54>)
   11f3e:	881a      	ldrh	r2, [r3, #0]
   11f40:	1cbb      	adds	r3, r7, #2
   11f42:	881b      	ldrh	r3, [r3, #0]
   11f44:	1ad3      	subs	r3, r2, r3
   11f46:	b29a      	uxth	r2, r3
   11f48:	4b04      	ldr	r3, [pc, #16]	; (11f5c <sd_mmc_start_read_blocks+0x54>)
   11f4a:	801a      	strh	r2, [r3, #0]
	return SD_MMC_OK;
   11f4c:	2300      	movs	r3, #0
}
   11f4e:	0018      	movs	r0, r3
   11f50:	46bd      	mov	sp, r7
   11f52:	b002      	add	sp, #8
   11f54:	bd80      	pop	{r7, pc}
   11f56:	46c0      	nop			; (mov r8, r8)
   11f58:	00012ff5 	.word	0x00012ff5
   11f5c:	20002dd2 	.word	0x20002dd2

00011f60 <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
   11f60:	b580      	push	{r7, lr}
   11f62:	b082      	sub	sp, #8
   11f64:	af00      	add	r7, sp, #0
   11f66:	0002      	movs	r2, r0
   11f68:	1dfb      	adds	r3, r7, #7
   11f6a:	701a      	strb	r2, [r3, #0]
	if (!driver_wait_end_of_read_blocks()) {
   11f6c:	4b1c      	ldr	r3, [pc, #112]	; (11fe0 <sd_mmc_wait_end_of_read_blocks+0x80>)
   11f6e:	4798      	blx	r3
   11f70:	0003      	movs	r3, r0
   11f72:	001a      	movs	r2, r3
   11f74:	2301      	movs	r3, #1
   11f76:	4053      	eors	r3, r2
   11f78:	b2db      	uxtb	r3, r3
   11f7a:	2b00      	cmp	r3, #0
   11f7c:	d001      	beq.n	11f82 <sd_mmc_wait_end_of_read_blocks+0x22>
		return SD_MMC_ERR_COMM;
   11f7e:	2305      	movs	r3, #5
   11f80:	e029      	b.n	11fd6 <sd_mmc_wait_end_of_read_blocks+0x76>
	}
	if (abort) {
   11f82:	1dfb      	adds	r3, r7, #7
   11f84:	781b      	ldrb	r3, [r3, #0]
   11f86:	2b00      	cmp	r3, #0
   11f88:	d003      	beq.n	11f92 <sd_mmc_wait_end_of_read_blocks+0x32>
		sd_mmc_nb_block_remaining = 0;
   11f8a:	4b16      	ldr	r3, [pc, #88]	; (11fe4 <sd_mmc_wait_end_of_read_blocks+0x84>)
   11f8c:	2200      	movs	r2, #0
   11f8e:	801a      	strh	r2, [r3, #0]
   11f90:	e005      	b.n	11f9e <sd_mmc_wait_end_of_read_blocks+0x3e>
	} else if (sd_mmc_nb_block_remaining) {
   11f92:	4b14      	ldr	r3, [pc, #80]	; (11fe4 <sd_mmc_wait_end_of_read_blocks+0x84>)
   11f94:	881b      	ldrh	r3, [r3, #0]
   11f96:	2b00      	cmp	r3, #0
   11f98:	d001      	beq.n	11f9e <sd_mmc_wait_end_of_read_blocks+0x3e>
		return SD_MMC_OK;
   11f9a:	2300      	movs	r3, #0
   11f9c:	e01b      	b.n	11fd6 <sd_mmc_wait_end_of_read_blocks+0x76>
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
   11f9e:	4b12      	ldr	r3, [pc, #72]	; (11fe8 <sd_mmc_wait_end_of_read_blocks+0x88>)
   11fa0:	881b      	ldrh	r3, [r3, #0]
   11fa2:	2b01      	cmp	r3, #1
   11fa4:	d103      	bne.n	11fae <sd_mmc_wait_end_of_read_blocks+0x4e>
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
   11fa6:	4b11      	ldr	r3, [pc, #68]	; (11fec <sd_mmc_wait_end_of_read_blocks+0x8c>)
   11fa8:	4798      	blx	r3
		return SD_MMC_OK;
   11faa:	2300      	movs	r3, #0
   11fac:	e013      	b.n	11fd6 <sd_mmc_wait_end_of_read_blocks+0x76>
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
   11fae:	4b10      	ldr	r3, [pc, #64]	; (11ff0 <sd_mmc_wait_end_of_read_blocks+0x90>)
   11fb0:	2100      	movs	r1, #0
   11fb2:	0018      	movs	r0, r3
   11fb4:	4b0f      	ldr	r3, [pc, #60]	; (11ff4 <sd_mmc_wait_end_of_read_blocks+0x94>)
   11fb6:	4798      	blx	r3
   11fb8:	0003      	movs	r3, r0
   11fba:	001a      	movs	r2, r3
   11fbc:	2301      	movs	r3, #1
   11fbe:	4053      	eors	r3, r2
   11fc0:	b2db      	uxtb	r3, r3
   11fc2:	2b00      	cmp	r3, #0
   11fc4:	d004      	beq.n	11fd0 <sd_mmc_wait_end_of_read_blocks+0x70>
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
   11fc6:	4b0a      	ldr	r3, [pc, #40]	; (11ff0 <sd_mmc_wait_end_of_read_blocks+0x90>)
   11fc8:	2100      	movs	r1, #0
   11fca:	0018      	movs	r0, r3
   11fcc:	4b09      	ldr	r3, [pc, #36]	; (11ff4 <sd_mmc_wait_end_of_read_blocks+0x94>)
   11fce:	4798      	blx	r3
	}
	sd_mmc_deselect_slot();
   11fd0:	4b06      	ldr	r3, [pc, #24]	; (11fec <sd_mmc_wait_end_of_read_blocks+0x8c>)
   11fd2:	4798      	blx	r3
	return SD_MMC_OK;
   11fd4:	2300      	movs	r3, #0
}
   11fd6:	0018      	movs	r0, r3
   11fd8:	46bd      	mov	sp, r7
   11fda:	b002      	add	sp, #8
   11fdc:	bd80      	pop	{r7, pc}
   11fde:	46c0      	nop			; (mov r8, r8)
   11fe0:	00013099 	.word	0x00013099
   11fe4:	20002dd2 	.word	0x20002dd2
   11fe8:	20002dd0 	.word	0x20002dd0
   11fec:	000119f5 	.word	0x000119f5
   11ff0:	0000310c 	.word	0x0000310c
   11ff4:	00012cfd 	.word	0x00012cfd

00011ff8 <sd_mmc_init_write_blocks>:

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
   11ff8:	b590      	push	{r4, r7, lr}
   11ffa:	b089      	sub	sp, #36	; 0x24
   11ffc:	af02      	add	r7, sp, #8
   11ffe:	6039      	str	r1, [r7, #0]
   12000:	0011      	movs	r1, r2
   12002:	1dfb      	adds	r3, r7, #7
   12004:	1c02      	adds	r2, r0, #0
   12006:	701a      	strb	r2, [r3, #0]
   12008:	1d3b      	adds	r3, r7, #4
   1200a:	1c0a      	adds	r2, r1, #0
   1200c:	801a      	strh	r2, [r3, #0]
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
   1200e:	230f      	movs	r3, #15
   12010:	18fc      	adds	r4, r7, r3
   12012:	1dfb      	adds	r3, r7, #7
   12014:	781b      	ldrb	r3, [r3, #0]
   12016:	0018      	movs	r0, r3
   12018:	4b28      	ldr	r3, [pc, #160]	; (120bc <sd_mmc_init_write_blocks+0xc4>)
   1201a:	4798      	blx	r3
   1201c:	0003      	movs	r3, r0
   1201e:	7023      	strb	r3, [r4, #0]
	if (sd_mmc_err != SD_MMC_OK) {
   12020:	230f      	movs	r3, #15
   12022:	18fb      	adds	r3, r7, r3
   12024:	781b      	ldrb	r3, [r3, #0]
   12026:	2b00      	cmp	r3, #0
   12028:	d003      	beq.n	12032 <sd_mmc_init_write_blocks+0x3a>
		return sd_mmc_err;
   1202a:	230f      	movs	r3, #15
   1202c:	18fb      	adds	r3, r7, r3
   1202e:	781b      	ldrb	r3, [r3, #0]
   12030:	e03f      	b.n	120b2 <sd_mmc_init_write_blocks+0xba>
	}
	if (sd_mmc_is_write_protected(slot)) {
   12032:	1dfb      	adds	r3, r7, #7
   12034:	781b      	ldrb	r3, [r3, #0]
   12036:	0018      	movs	r0, r3
   12038:	4b21      	ldr	r3, [pc, #132]	; (120c0 <sd_mmc_init_write_blocks+0xc8>)
   1203a:	4798      	blx	r3
   1203c:	1e03      	subs	r3, r0, #0
   1203e:	d003      	beq.n	12048 <sd_mmc_init_write_blocks+0x50>
		sd_mmc_deselect_slot();
   12040:	4b20      	ldr	r3, [pc, #128]	; (120c4 <sd_mmc_init_write_blocks+0xcc>)
   12042:	4798      	blx	r3
		return SD_MMC_ERR_WP;
   12044:	2307      	movs	r3, #7
   12046:	e034      	b.n	120b2 <sd_mmc_init_write_blocks+0xba>
	}

	if (nb_block > 1) {
   12048:	1d3b      	adds	r3, r7, #4
   1204a:	881b      	ldrh	r3, [r3, #0]
   1204c:	2b01      	cmp	r3, #1
   1204e:	d902      	bls.n	12056 <sd_mmc_init_write_blocks+0x5e>
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
   12050:	4b1d      	ldr	r3, [pc, #116]	; (120c8 <sd_mmc_init_write_blocks+0xd0>)
   12052:	617b      	str	r3, [r7, #20]
   12054:	e001      	b.n	1205a <sd_mmc_init_write_blocks+0x62>
	} else {
		cmd = SDMMC_CMD24_WRITE_BLOCK;
   12056:	4b1d      	ldr	r3, [pc, #116]	; (120cc <sd_mmc_init_write_blocks+0xd4>)
   12058:	617b      	str	r3, [r7, #20]
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
   1205a:	4b1d      	ldr	r3, [pc, #116]	; (120d0 <sd_mmc_init_write_blocks+0xd8>)
   1205c:	681b      	ldr	r3, [r3, #0]
   1205e:	7bdb      	ldrb	r3, [r3, #15]
   12060:	001a      	movs	r2, r3
   12062:	2308      	movs	r3, #8
   12064:	4013      	ands	r3, r2
   12066:	d002      	beq.n	1206e <sd_mmc_init_write_blocks+0x76>
		arg = start;
   12068:	683b      	ldr	r3, [r7, #0]
   1206a:	613b      	str	r3, [r7, #16]
   1206c:	e002      	b.n	12074 <sd_mmc_init_write_blocks+0x7c>
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
   1206e:	683b      	ldr	r3, [r7, #0]
   12070:	025b      	lsls	r3, r3, #9
   12072:	613b      	str	r3, [r7, #16]
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
   12074:	1d3b      	adds	r3, r7, #4
   12076:	881c      	ldrh	r4, [r3, #0]
   12078:	2380      	movs	r3, #128	; 0x80
   1207a:	009a      	lsls	r2, r3, #2
   1207c:	6939      	ldr	r1, [r7, #16]
   1207e:	6978      	ldr	r0, [r7, #20]
   12080:	2301      	movs	r3, #1
   12082:	9300      	str	r3, [sp, #0]
   12084:	0023      	movs	r3, r4
   12086:	4c13      	ldr	r4, [pc, #76]	; (120d4 <sd_mmc_init_write_blocks+0xdc>)
   12088:	47a0      	blx	r4
   1208a:	0003      	movs	r3, r0
   1208c:	001a      	movs	r2, r3
   1208e:	2301      	movs	r3, #1
   12090:	4053      	eors	r3, r2
   12092:	b2db      	uxtb	r3, r3
   12094:	2b00      	cmp	r3, #0
   12096:	d003      	beq.n	120a0 <sd_mmc_init_write_blocks+0xa8>
		sd_mmc_deselect_slot();
   12098:	4b0a      	ldr	r3, [pc, #40]	; (120c4 <sd_mmc_init_write_blocks+0xcc>)
   1209a:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
   1209c:	2305      	movs	r3, #5
   1209e:	e008      	b.n	120b2 <sd_mmc_init_write_blocks+0xba>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
   120a0:	4b0d      	ldr	r3, [pc, #52]	; (120d8 <sd_mmc_init_write_blocks+0xe0>)
   120a2:	1d3a      	adds	r2, r7, #4
   120a4:	8812      	ldrh	r2, [r2, #0]
   120a6:	801a      	strh	r2, [r3, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
   120a8:	4b0c      	ldr	r3, [pc, #48]	; (120dc <sd_mmc_init_write_blocks+0xe4>)
   120aa:	1d3a      	adds	r2, r7, #4
   120ac:	8812      	ldrh	r2, [r2, #0]
   120ae:	801a      	strh	r2, [r3, #0]
	return SD_MMC_OK;
   120b0:	2300      	movs	r3, #0
}
   120b2:	0018      	movs	r0, r3
   120b4:	46bd      	mov	sp, r7
   120b6:	b007      	add	sp, #28
   120b8:	bd90      	pop	{r4, r7, pc}
   120ba:	46c0      	nop			; (mov r8, r8)
   120bc:	0001180d 	.word	0x0001180d
   120c0:	00011e05 	.word	0x00011e05
   120c4:	000119f5 	.word	0x000119f5
   120c8:	00109119 	.word	0x00109119
   120cc:	00089118 	.word	0x00089118
   120d0:	20002dcc 	.word	0x20002dcc
   120d4:	00012d25 	.word	0x00012d25
   120d8:	20002dd2 	.word	0x20002dd2
   120dc:	20002dd0 	.word	0x20002dd0

000120e0 <sd_mmc_start_write_blocks>:

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
   120e0:	b580      	push	{r7, lr}
   120e2:	b082      	sub	sp, #8
   120e4:	af00      	add	r7, sp, #0
   120e6:	6078      	str	r0, [r7, #4]
   120e8:	000a      	movs	r2, r1
   120ea:	1cbb      	adds	r3, r7, #2
   120ec:	801a      	strh	r2, [r3, #0]
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
   120ee:	1cbb      	adds	r3, r7, #2
   120f0:	881a      	ldrh	r2, [r3, #0]
   120f2:	687b      	ldr	r3, [r7, #4]
   120f4:	0011      	movs	r1, r2
   120f6:	0018      	movs	r0, r3
   120f8:	4b0d      	ldr	r3, [pc, #52]	; (12130 <sd_mmc_start_write_blocks+0x50>)
   120fa:	4798      	blx	r3
   120fc:	0003      	movs	r3, r0
   120fe:	001a      	movs	r2, r3
   12100:	2301      	movs	r3, #1
   12102:	4053      	eors	r3, r2
   12104:	b2db      	uxtb	r3, r3
   12106:	2b00      	cmp	r3, #0
   12108:	d004      	beq.n	12114 <sd_mmc_start_write_blocks+0x34>
		sd_mmc_nb_block_remaining = 0;
   1210a:	4b0a      	ldr	r3, [pc, #40]	; (12134 <sd_mmc_start_write_blocks+0x54>)
   1210c:	2200      	movs	r2, #0
   1210e:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
   12110:	2305      	movs	r3, #5
   12112:	e008      	b.n	12126 <sd_mmc_start_write_blocks+0x46>
	}
	sd_mmc_nb_block_remaining -= nb_block;
   12114:	4b07      	ldr	r3, [pc, #28]	; (12134 <sd_mmc_start_write_blocks+0x54>)
   12116:	881a      	ldrh	r2, [r3, #0]
   12118:	1cbb      	adds	r3, r7, #2
   1211a:	881b      	ldrh	r3, [r3, #0]
   1211c:	1ad3      	subs	r3, r2, r3
   1211e:	b29a      	uxth	r2, r3
   12120:	4b04      	ldr	r3, [pc, #16]	; (12134 <sd_mmc_start_write_blocks+0x54>)
   12122:	801a      	strh	r2, [r3, #0]
	return SD_MMC_OK;
   12124:	2300      	movs	r3, #0
}
   12126:	0018      	movs	r0, r3
   12128:	46bd      	mov	sp, r7
   1212a:	b002      	add	sp, #8
   1212c:	bd80      	pop	{r7, pc}
   1212e:	46c0      	nop			; (mov r8, r8)
   12130:	000130a5 	.word	0x000130a5
   12134:	20002dd2 	.word	0x20002dd2

00012138 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
   12138:	b580      	push	{r7, lr}
   1213a:	b082      	sub	sp, #8
   1213c:	af00      	add	r7, sp, #0
   1213e:	0002      	movs	r2, r0
   12140:	1dfb      	adds	r3, r7, #7
   12142:	701a      	strb	r2, [r3, #0]
	if (!driver_wait_end_of_write_blocks()) {
   12144:	4b13      	ldr	r3, [pc, #76]	; (12194 <sd_mmc_wait_end_of_write_blocks+0x5c>)
   12146:	4798      	blx	r3
   12148:	0003      	movs	r3, r0
   1214a:	001a      	movs	r2, r3
   1214c:	2301      	movs	r3, #1
   1214e:	4053      	eors	r3, r2
   12150:	b2db      	uxtb	r3, r3
   12152:	2b00      	cmp	r3, #0
   12154:	d001      	beq.n	1215a <sd_mmc_wait_end_of_write_blocks+0x22>
		return SD_MMC_ERR_COMM;
   12156:	2305      	movs	r3, #5
   12158:	e018      	b.n	1218c <sd_mmc_wait_end_of_write_blocks+0x54>
	}
	if (abort) {
   1215a:	1dfb      	adds	r3, r7, #7
   1215c:	781b      	ldrb	r3, [r3, #0]
   1215e:	2b00      	cmp	r3, #0
   12160:	d003      	beq.n	1216a <sd_mmc_wait_end_of_write_blocks+0x32>
		sd_mmc_nb_block_remaining = 0;
   12162:	4b0d      	ldr	r3, [pc, #52]	; (12198 <sd_mmc_wait_end_of_write_blocks+0x60>)
   12164:	2200      	movs	r2, #0
   12166:	801a      	strh	r2, [r3, #0]
   12168:	e005      	b.n	12176 <sd_mmc_wait_end_of_write_blocks+0x3e>
	} else if (sd_mmc_nb_block_remaining) {
   1216a:	4b0b      	ldr	r3, [pc, #44]	; (12198 <sd_mmc_wait_end_of_write_blocks+0x60>)
   1216c:	881b      	ldrh	r3, [r3, #0]
   1216e:	2b00      	cmp	r3, #0
   12170:	d001      	beq.n	12176 <sd_mmc_wait_end_of_write_blocks+0x3e>
		return SD_MMC_OK;
   12172:	2300      	movs	r3, #0
   12174:	e00a      	b.n	1218c <sd_mmc_wait_end_of_write_blocks+0x54>
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
   12176:	4b09      	ldr	r3, [pc, #36]	; (1219c <sd_mmc_wait_end_of_write_blocks+0x64>)
   12178:	881b      	ldrh	r3, [r3, #0]
   1217a:	2b01      	cmp	r3, #1
   1217c:	d103      	bne.n	12186 <sd_mmc_wait_end_of_write_blocks+0x4e>
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
   1217e:	4b08      	ldr	r3, [pc, #32]	; (121a0 <sd_mmc_wait_end_of_write_blocks+0x68>)
   12180:	4798      	blx	r3
		return SD_MMC_OK;
   12182:	2300      	movs	r3, #0
   12184:	e002      	b.n	1218c <sd_mmc_wait_end_of_write_blocks+0x54>
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_deselect_slot();
   12186:	4b06      	ldr	r3, [pc, #24]	; (121a0 <sd_mmc_wait_end_of_write_blocks+0x68>)
   12188:	4798      	blx	r3
	return SD_MMC_OK;
   1218a:	2300      	movs	r3, #0
}
   1218c:	0018      	movs	r0, r3
   1218e:	46bd      	mov	sp, r7
   12190:	b002      	add	sp, #8
   12192:	bd80      	pop	{r7, pc}
   12194:	00013165 	.word	0x00013165
   12198:	20002dd2 	.word	0x20002dd2
   1219c:	20002dd0 	.word	0x20002dd0
   121a0:	000119f5 	.word	0x000119f5

000121a4 <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
   121a4:	b580      	push	{r7, lr}
   121a6:	b082      	sub	sp, #8
   121a8:	af00      	add	r7, sp, #0
   121aa:	0002      	movs	r2, r0
   121ac:	1dfb      	adds	r3, r7, #7
   121ae:	701a      	strb	r2, [r3, #0]
	switch (sd_mmc_check(slot))
   121b0:	1dfb      	adds	r3, r7, #7
   121b2:	781b      	ldrb	r3, [r3, #0]
   121b4:	0018      	movs	r0, r3
   121b6:	4b16      	ldr	r3, [pc, #88]	; (12210 <sd_mmc_test_unit_ready+0x6c>)
   121b8:	4798      	blx	r3
   121ba:	1e03      	subs	r3, r0, #0
   121bc:	2b01      	cmp	r3, #1
   121be:	d019      	beq.n	121f4 <sd_mmc_test_unit_ready+0x50>
   121c0:	2b02      	cmp	r3, #2
   121c2:	d019      	beq.n	121f8 <sd_mmc_test_unit_ready+0x54>
   121c4:	2b00      	cmp	r3, #0
   121c6:	d11e      	bne.n	12206 <sd_mmc_test_unit_ready+0x62>
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
   121c8:	1dfb      	adds	r3, r7, #7
   121ca:	781b      	ldrb	r3, [r3, #0]
   121cc:	4a11      	ldr	r2, [pc, #68]	; (12214 <sd_mmc_test_unit_ready+0x70>)
   121ce:	5cd3      	ldrb	r3, [r2, r3]
   121d0:	2b00      	cmp	r3, #0
   121d2:	d001      	beq.n	121d8 <sd_mmc_test_unit_ready+0x34>
			return CTRL_NO_PRESENT;
   121d4:	2302      	movs	r3, #2
   121d6:	e017      	b.n	12208 <sd_mmc_test_unit_ready+0x64>
		}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
   121d8:	1dfb      	adds	r3, r7, #7
   121da:	781b      	ldrb	r3, [r3, #0]
   121dc:	0018      	movs	r0, r3
   121de:	4b0e      	ldr	r3, [pc, #56]	; (12218 <sd_mmc_test_unit_ready+0x74>)
   121e0:	4798      	blx	r3
   121e2:	0003      	movs	r3, r0
   121e4:	001a      	movs	r2, r3
   121e6:	2303      	movs	r3, #3
   121e8:	4013      	ands	r3, r2
   121ea:	d001      	beq.n	121f0 <sd_mmc_test_unit_ready+0x4c>
			return CTRL_GOOD;
   121ec:	2300      	movs	r3, #0
   121ee:	e00b      	b.n	12208 <sd_mmc_test_unit_ready+0x64>
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;
   121f0:	2302      	movs	r3, #2
   121f2:	e009      	b.n	12208 <sd_mmc_test_unit_ready+0x64>

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
   121f4:	2303      	movs	r3, #3
   121f6:	e007      	b.n	12208 <sd_mmc_test_unit_ready+0x64>

	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
   121f8:	1dfb      	adds	r3, r7, #7
   121fa:	781b      	ldrb	r3, [r3, #0]
   121fc:	4a05      	ldr	r2, [pc, #20]	; (12214 <sd_mmc_test_unit_ready+0x70>)
   121fe:	2100      	movs	r1, #0
   12200:	54d1      	strb	r1, [r2, r3]
		return CTRL_NO_PRESENT;
   12202:	2302      	movs	r3, #2
   12204:	e000      	b.n	12208 <sd_mmc_test_unit_ready+0x64>

	default:
		return CTRL_FAIL;
   12206:	2301      	movs	r3, #1
	}
}
   12208:	0018      	movs	r0, r3
   1220a:	46bd      	mov	sp, r7
   1220c:	b002      	add	sp, #8
   1220e:	bd80      	pop	{r7, pc}
   12210:	00011d19 	.word	0x00011d19
   12214:	20002dd8 	.word	0x20002dd8
   12218:	00011d8d 	.word	0x00011d8d

0001221c <sd_mmc_test_unit_ready_0>:

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
   1221c:	b580      	push	{r7, lr}
   1221e:	af00      	add	r7, sp, #0
	return sd_mmc_test_unit_ready(0);
   12220:	2000      	movs	r0, #0
   12222:	4b03      	ldr	r3, [pc, #12]	; (12230 <sd_mmc_test_unit_ready_0+0x14>)
   12224:	4798      	blx	r3
   12226:	0003      	movs	r3, r0
}
   12228:	0018      	movs	r0, r3
   1222a:	46bd      	mov	sp, r7
   1222c:	bd80      	pop	{r7, pc}
   1222e:	46c0      	nop			; (mov r8, r8)
   12230:	000121a5 	.word	0x000121a5

00012234 <sd_mmc_read_capacity>:
{
	return sd_mmc_test_unit_ready(1);
}

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
   12234:	b580      	push	{r7, lr}
   12236:	b082      	sub	sp, #8
   12238:	af00      	add	r7, sp, #0
   1223a:	0002      	movs	r2, r0
   1223c:	6039      	str	r1, [r7, #0]
   1223e:	1dfb      	adds	r3, r7, #7
   12240:	701a      	strb	r2, [r3, #0]
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
   12242:	1dfb      	adds	r3, r7, #7
   12244:	781b      	ldrb	r3, [r3, #0]
   12246:	0018      	movs	r0, r3
   12248:	4b08      	ldr	r3, [pc, #32]	; (1226c <sd_mmc_read_capacity+0x38>)
   1224a:	4798      	blx	r3
   1224c:	0003      	movs	r3, r0
   1224e:	005b      	lsls	r3, r3, #1
   12250:	1e5a      	subs	r2, r3, #1
   12252:	683b      	ldr	r3, [r7, #0]
   12254:	601a      	str	r2, [r3, #0]
	return sd_mmc_test_unit_ready(slot);
   12256:	1dfb      	adds	r3, r7, #7
   12258:	781b      	ldrb	r3, [r3, #0]
   1225a:	0018      	movs	r0, r3
   1225c:	4b04      	ldr	r3, [pc, #16]	; (12270 <sd_mmc_read_capacity+0x3c>)
   1225e:	4798      	blx	r3
   12260:	0003      	movs	r3, r0
}
   12262:	0018      	movs	r0, r3
   12264:	46bd      	mov	sp, r7
   12266:	b002      	add	sp, #8
   12268:	bd80      	pop	{r7, pc}
   1226a:	46c0      	nop			; (mov r8, r8)
   1226c:	00011dc9 	.word	0x00011dc9
   12270:	000121a5 	.word	0x000121a5

00012274 <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
   12274:	b580      	push	{r7, lr}
   12276:	b082      	sub	sp, #8
   12278:	af00      	add	r7, sp, #0
   1227a:	6078      	str	r0, [r7, #4]
	return sd_mmc_read_capacity(0, nb_sector);
   1227c:	687b      	ldr	r3, [r7, #4]
   1227e:	0019      	movs	r1, r3
   12280:	2000      	movs	r0, #0
   12282:	4b03      	ldr	r3, [pc, #12]	; (12290 <sd_mmc_read_capacity_0+0x1c>)
   12284:	4798      	blx	r3
   12286:	0003      	movs	r3, r0
}
   12288:	0018      	movs	r0, r3
   1228a:	46bd      	mov	sp, r7
   1228c:	b002      	add	sp, #8
   1228e:	bd80      	pop	{r7, pc}
   12290:	00012235 	.word	0x00012235

00012294 <sd_mmc_unload>:
{
	return sd_mmc_read_capacity(1, nb_sector);
}

bool sd_mmc_unload(uint8_t slot, bool unload)
{
   12294:	b580      	push	{r7, lr}
   12296:	b082      	sub	sp, #8
   12298:	af00      	add	r7, sp, #0
   1229a:	0002      	movs	r2, r0
   1229c:	1dfb      	adds	r3, r7, #7
   1229e:	701a      	strb	r2, [r3, #0]
   122a0:	1dbb      	adds	r3, r7, #6
   122a2:	1c0a      	adds	r2, r1, #0
   122a4:	701a      	strb	r2, [r3, #0]
	sd_mmc_ejected[slot] = unload;
   122a6:	1dfb      	adds	r3, r7, #7
   122a8:	781b      	ldrb	r3, [r3, #0]
   122aa:	4a04      	ldr	r2, [pc, #16]	; (122bc <sd_mmc_unload+0x28>)
   122ac:	1db9      	adds	r1, r7, #6
   122ae:	7809      	ldrb	r1, [r1, #0]
   122b0:	54d1      	strb	r1, [r2, r3]
	return true;
   122b2:	2301      	movs	r3, #1
}
   122b4:	0018      	movs	r0, r3
   122b6:	46bd      	mov	sp, r7
   122b8:	b002      	add	sp, #8
   122ba:	bd80      	pop	{r7, pc}
   122bc:	20002dd8 	.word	0x20002dd8

000122c0 <sd_mmc_unload_0>:

bool sd_mmc_unload_0(bool unload)
{
   122c0:	b580      	push	{r7, lr}
   122c2:	b082      	sub	sp, #8
   122c4:	af00      	add	r7, sp, #0
   122c6:	0002      	movs	r2, r0
   122c8:	1dfb      	adds	r3, r7, #7
   122ca:	701a      	strb	r2, [r3, #0]
	return sd_mmc_unload(0, unload);
   122cc:	1dfb      	adds	r3, r7, #7
   122ce:	781b      	ldrb	r3, [r3, #0]
   122d0:	0019      	movs	r1, r3
   122d2:	2000      	movs	r0, #0
   122d4:	4b03      	ldr	r3, [pc, #12]	; (122e4 <sd_mmc_unload_0+0x24>)
   122d6:	4798      	blx	r3
   122d8:	0003      	movs	r3, r0
}
   122da:	0018      	movs	r0, r3
   122dc:	46bd      	mov	sp, r7
   122de:	b002      	add	sp, #8
   122e0:	bd80      	pop	{r7, pc}
   122e2:	46c0      	nop			; (mov r8, r8)
   122e4:	00012295 	.word	0x00012295

000122e8 <sd_mmc_wr_protect>:
{
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
   122e8:	b580      	push	{r7, lr}
   122ea:	b082      	sub	sp, #8
   122ec:	af00      	add	r7, sp, #0
   122ee:	0002      	movs	r2, r0
   122f0:	1dfb      	adds	r3, r7, #7
   122f2:	701a      	strb	r2, [r3, #0]
	return sd_mmc_is_write_protected(slot);
   122f4:	1dfb      	adds	r3, r7, #7
   122f6:	781b      	ldrb	r3, [r3, #0]
   122f8:	0018      	movs	r0, r3
   122fa:	4b03      	ldr	r3, [pc, #12]	; (12308 <sd_mmc_wr_protect+0x20>)
   122fc:	4798      	blx	r3
   122fe:	0003      	movs	r3, r0
}
   12300:	0018      	movs	r0, r3
   12302:	46bd      	mov	sp, r7
   12304:	b002      	add	sp, #8
   12306:	bd80      	pop	{r7, pc}
   12308:	00011e05 	.word	0x00011e05

0001230c <sd_mmc_wr_protect_0>:

bool sd_mmc_wr_protect_0(void)
{
   1230c:	b580      	push	{r7, lr}
   1230e:	af00      	add	r7, sp, #0
	return sd_mmc_wr_protect(0);
   12310:	2000      	movs	r0, #0
   12312:	4b03      	ldr	r3, [pc, #12]	; (12320 <sd_mmc_wr_protect_0+0x14>)
   12314:	4798      	blx	r3
   12316:	0003      	movs	r3, r0
}
   12318:	0018      	movs	r0, r3
   1231a:	46bd      	mov	sp, r7
   1231c:	bd80      	pop	{r7, pc}
   1231e:	46c0      	nop			; (mov r8, r8)
   12320:	000122e9 	.word	0x000122e9

00012324 <sd_mmc_removal>:
{
	return sd_mmc_wr_protect(1);
}

bool sd_mmc_removal(uint8_t slot)
{
   12324:	b580      	push	{r7, lr}
   12326:	b082      	sub	sp, #8
   12328:	af00      	add	r7, sp, #0
   1232a:	0002      	movs	r2, r0
   1232c:	1dfb      	adds	r3, r7, #7
   1232e:	701a      	strb	r2, [r3, #0]
	UNUSED(slot);
	return true;
   12330:	2301      	movs	r3, #1
}
   12332:	0018      	movs	r0, r3
   12334:	46bd      	mov	sp, r7
   12336:	b002      	add	sp, #8
   12338:	bd80      	pop	{r7, pc}
   1233a:	46c0      	nop			; (mov r8, r8)

0001233c <sd_mmc_removal_0>:

bool sd_mmc_removal_0(void)
{
   1233c:	b580      	push	{r7, lr}
   1233e:	af00      	add	r7, sp, #0
	return sd_mmc_removal(0);
   12340:	2000      	movs	r0, #0
   12342:	4b03      	ldr	r3, [pc, #12]	; (12350 <sd_mmc_removal_0+0x14>)
   12344:	4798      	blx	r3
   12346:	0003      	movs	r3, r0
}
   12348:	0018      	movs	r0, r3
   1234a:	46bd      	mov	sp, r7
   1234c:	bd80      	pop	{r7, pc}
   1234e:	46c0      	nop			; (mov r8, r8)
   12350:	00012325 	.word	0x00012325

00012354 <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
   12354:	b580      	push	{r7, lr}
   12356:	b084      	sub	sp, #16
   12358:	af00      	add	r7, sp, #0
   1235a:	60b9      	str	r1, [r7, #8]
   1235c:	607a      	str	r2, [r7, #4]
   1235e:	230f      	movs	r3, #15
   12360:	18fb      	adds	r3, r7, r3
   12362:	1c02      	adds	r2, r0, #0
   12364:	701a      	strb	r2, [r3, #0]
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
   12366:	68b9      	ldr	r1, [r7, #8]
   12368:	230f      	movs	r3, #15
   1236a:	18fb      	adds	r3, r7, r3
   1236c:	781b      	ldrb	r3, [r3, #0]
   1236e:	2201      	movs	r2, #1
   12370:	0018      	movs	r0, r3
   12372:	4b10      	ldr	r3, [pc, #64]	; (123b4 <sd_mmc_mem_2_ram+0x60>)
   12374:	4798      	blx	r3
   12376:	1e03      	subs	r3, r0, #0
   12378:	d005      	beq.n	12386 <sd_mmc_mem_2_ram+0x32>
   1237a:	2b02      	cmp	r3, #2
   1237c:	d101      	bne.n	12382 <sd_mmc_mem_2_ram+0x2e>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
   1237e:	2302      	movs	r3, #2
   12380:	e013      	b.n	123aa <sd_mmc_mem_2_ram+0x56>
	default:
		return CTRL_FAIL;
   12382:	2301      	movs	r3, #1
   12384:	e011      	b.n	123aa <sd_mmc_mem_2_ram+0x56>
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
	case SD_MMC_OK:
		break;
   12386:	46c0      	nop			; (mov r8, r8)
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
   12388:	687b      	ldr	r3, [r7, #4]
   1238a:	2101      	movs	r1, #1
   1238c:	0018      	movs	r0, r3
   1238e:	4b0a      	ldr	r3, [pc, #40]	; (123b8 <sd_mmc_mem_2_ram+0x64>)
   12390:	4798      	blx	r3
   12392:	1e03      	subs	r3, r0, #0
   12394:	d001      	beq.n	1239a <sd_mmc_mem_2_ram+0x46>
		return CTRL_FAIL;
   12396:	2301      	movs	r3, #1
   12398:	e007      	b.n	123aa <sd_mmc_mem_2_ram+0x56>
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
   1239a:	2000      	movs	r0, #0
   1239c:	4b07      	ldr	r3, [pc, #28]	; (123bc <sd_mmc_mem_2_ram+0x68>)
   1239e:	4798      	blx	r3
   123a0:	1e03      	subs	r3, r0, #0
   123a2:	d001      	beq.n	123a8 <sd_mmc_mem_2_ram+0x54>
		return CTRL_FAIL;
   123a4:	2301      	movs	r3, #1
   123a6:	e000      	b.n	123aa <sd_mmc_mem_2_ram+0x56>
	}
	return CTRL_GOOD;
   123a8:	2300      	movs	r3, #0
}
   123aa:	0018      	movs	r0, r3
   123ac:	46bd      	mov	sp, r7
   123ae:	b004      	add	sp, #16
   123b0:	bd80      	pop	{r7, pc}
   123b2:	46c0      	nop			; (mov r8, r8)
   123b4:	00011e1d 	.word	0x00011e1d
   123b8:	00011f09 	.word	0x00011f09
   123bc:	00011f61 	.word	0x00011f61

000123c0 <sd_mmc_mem_2_ram_0>:

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
   123c0:	b580      	push	{r7, lr}
   123c2:	b082      	sub	sp, #8
   123c4:	af00      	add	r7, sp, #0
   123c6:	6078      	str	r0, [r7, #4]
   123c8:	6039      	str	r1, [r7, #0]
	return sd_mmc_mem_2_ram(0, addr, ram);
   123ca:	683a      	ldr	r2, [r7, #0]
   123cc:	687b      	ldr	r3, [r7, #4]
   123ce:	0019      	movs	r1, r3
   123d0:	2000      	movs	r0, #0
   123d2:	4b03      	ldr	r3, [pc, #12]	; (123e0 <sd_mmc_mem_2_ram_0+0x20>)
   123d4:	4798      	blx	r3
   123d6:	0003      	movs	r3, r0
}
   123d8:	0018      	movs	r0, r3
   123da:	46bd      	mov	sp, r7
   123dc:	b002      	add	sp, #8
   123de:	bd80      	pop	{r7, pc}
   123e0:	00012355 	.word	0x00012355

000123e4 <sd_mmc_ram_2_mem>:
{
	return sd_mmc_mem_2_ram(1, addr, ram);
}

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
   123e4:	b580      	push	{r7, lr}
   123e6:	b084      	sub	sp, #16
   123e8:	af00      	add	r7, sp, #0
   123ea:	60b9      	str	r1, [r7, #8]
   123ec:	607a      	str	r2, [r7, #4]
   123ee:	230f      	movs	r3, #15
   123f0:	18fb      	adds	r3, r7, r3
   123f2:	1c02      	adds	r2, r0, #0
   123f4:	701a      	strb	r2, [r3, #0]
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
   123f6:	68b9      	ldr	r1, [r7, #8]
   123f8:	230f      	movs	r3, #15
   123fa:	18fb      	adds	r3, r7, r3
   123fc:	781b      	ldrb	r3, [r3, #0]
   123fe:	2201      	movs	r2, #1
   12400:	0018      	movs	r0, r3
   12402:	4b10      	ldr	r3, [pc, #64]	; (12444 <sd_mmc_ram_2_mem+0x60>)
   12404:	4798      	blx	r3
   12406:	1e03      	subs	r3, r0, #0
   12408:	d005      	beq.n	12416 <sd_mmc_ram_2_mem+0x32>
   1240a:	2b02      	cmp	r3, #2
   1240c:	d101      	bne.n	12412 <sd_mmc_ram_2_mem+0x2e>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
   1240e:	2302      	movs	r3, #2
   12410:	e013      	b.n	1243a <sd_mmc_ram_2_mem+0x56>
	default:
		return CTRL_FAIL;
   12412:	2301      	movs	r3, #1
   12414:	e011      	b.n	1243a <sd_mmc_ram_2_mem+0x56>

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
	case SD_MMC_OK:
		break;
   12416:	46c0      	nop			; (mov r8, r8)
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
   12418:	687b      	ldr	r3, [r7, #4]
   1241a:	2101      	movs	r1, #1
   1241c:	0018      	movs	r0, r3
   1241e:	4b0a      	ldr	r3, [pc, #40]	; (12448 <sd_mmc_ram_2_mem+0x64>)
   12420:	4798      	blx	r3
   12422:	1e03      	subs	r3, r0, #0
   12424:	d001      	beq.n	1242a <sd_mmc_ram_2_mem+0x46>
		return CTRL_FAIL;
   12426:	2301      	movs	r3, #1
   12428:	e007      	b.n	1243a <sd_mmc_ram_2_mem+0x56>
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
   1242a:	2000      	movs	r0, #0
   1242c:	4b07      	ldr	r3, [pc, #28]	; (1244c <sd_mmc_ram_2_mem+0x68>)
   1242e:	4798      	blx	r3
   12430:	1e03      	subs	r3, r0, #0
   12432:	d001      	beq.n	12438 <sd_mmc_ram_2_mem+0x54>
		return CTRL_FAIL;
   12434:	2301      	movs	r3, #1
   12436:	e000      	b.n	1243a <sd_mmc_ram_2_mem+0x56>
	}
	return CTRL_GOOD;
   12438:	2300      	movs	r3, #0
}
   1243a:	0018      	movs	r0, r3
   1243c:	46bd      	mov	sp, r7
   1243e:	b004      	add	sp, #16
   12440:	bd80      	pop	{r7, pc}
   12442:	46c0      	nop			; (mov r8, r8)
   12444:	00011ff9 	.word	0x00011ff9
   12448:	000120e1 	.word	0x000120e1
   1244c:	00012139 	.word	0x00012139

00012450 <sd_mmc_ram_2_mem_0>:

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
   12450:	b580      	push	{r7, lr}
   12452:	b082      	sub	sp, #8
   12454:	af00      	add	r7, sp, #0
   12456:	6078      	str	r0, [r7, #4]
   12458:	6039      	str	r1, [r7, #0]
	return sd_mmc_ram_2_mem(0, addr, ram);
   1245a:	683a      	ldr	r2, [r7, #0]
   1245c:	687b      	ldr	r3, [r7, #4]
   1245e:	0019      	movs	r1, r3
   12460:	2000      	movs	r0, #0
   12462:	4b03      	ldr	r3, [pc, #12]	; (12470 <sd_mmc_ram_2_mem_0+0x20>)
   12464:	4798      	blx	r3
   12466:	0003      	movs	r3, r0
}
   12468:	0018      	movs	r0, r3
   1246a:	46bd      	mov	sp, r7
   1246c:	b002      	add	sp, #8
   1246e:	bd80      	pop	{r7, pc}
   12470:	000123e5 	.word	0x000123e5

00012474 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   12474:	b580      	push	{r7, lr}
   12476:	b084      	sub	sp, #16
   12478:	af00      	add	r7, sp, #0
   1247a:	0002      	movs	r2, r0
   1247c:	1dfb      	adds	r3, r7, #7
   1247e:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
   12480:	230f      	movs	r3, #15
   12482:	18fb      	adds	r3, r7, r3
   12484:	1dfa      	adds	r2, r7, #7
   12486:	7812      	ldrb	r2, [r2, #0]
   12488:	09d2      	lsrs	r2, r2, #7
   1248a:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
   1248c:	230e      	movs	r3, #14
   1248e:	18fb      	adds	r3, r7, r3
   12490:	1dfa      	adds	r2, r7, #7
   12492:	7812      	ldrb	r2, [r2, #0]
   12494:	0952      	lsrs	r2, r2, #5
   12496:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
   12498:	4b0d      	ldr	r3, [pc, #52]	; (124d0 <system_pinmux_get_group_from_gpio_pin+0x5c>)
   1249a:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
   1249c:	230f      	movs	r3, #15
   1249e:	18fb      	adds	r3, r7, r3
   124a0:	781b      	ldrb	r3, [r3, #0]
   124a2:	2b00      	cmp	r3, #0
   124a4:	d10f      	bne.n	124c6 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
   124a6:	230f      	movs	r3, #15
   124a8:	18fb      	adds	r3, r7, r3
   124aa:	781b      	ldrb	r3, [r3, #0]
   124ac:	009b      	lsls	r3, r3, #2
   124ae:	2210      	movs	r2, #16
   124b0:	4694      	mov	ip, r2
   124b2:	44bc      	add	ip, r7
   124b4:	4463      	add	r3, ip
   124b6:	3b08      	subs	r3, #8
   124b8:	681a      	ldr	r2, [r3, #0]
   124ba:	230e      	movs	r3, #14
   124bc:	18fb      	adds	r3, r7, r3
   124be:	781b      	ldrb	r3, [r3, #0]
   124c0:	01db      	lsls	r3, r3, #7
   124c2:	18d3      	adds	r3, r2, r3
   124c4:	e000      	b.n	124c8 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
   124c6:	2300      	movs	r3, #0
	}
}
   124c8:	0018      	movs	r0, r3
   124ca:	46bd      	mov	sp, r7
   124cc:	b004      	add	sp, #16
   124ce:	bd80      	pop	{r7, pc}
   124d0:	41004400 	.word	0x41004400

000124d4 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   124d4:	b580      	push	{r7, lr}
   124d6:	b082      	sub	sp, #8
   124d8:	af00      	add	r7, sp, #0
   124da:	0002      	movs	r2, r0
   124dc:	1dfb      	adds	r3, r7, #7
   124de:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
   124e0:	1dfb      	adds	r3, r7, #7
   124e2:	781b      	ldrb	r3, [r3, #0]
   124e4:	0018      	movs	r0, r3
   124e6:	4b03      	ldr	r3, [pc, #12]	; (124f4 <port_get_group_from_gpio_pin+0x20>)
   124e8:	4798      	blx	r3
   124ea:	0003      	movs	r3, r0
}
   124ec:	0018      	movs	r0, r3
   124ee:	46bd      	mov	sp, r7
   124f0:	b002      	add	sp, #8
   124f2:	bd80      	pop	{r7, pc}
   124f4:	00012475 	.word	0x00012475

000124f8 <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
   124f8:	b580      	push	{r7, lr}
   124fa:	b082      	sub	sp, #8
   124fc:	af00      	add	r7, sp, #0
   124fe:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
   12500:	687b      	ldr	r3, [r7, #4]
   12502:	2200      	movs	r2, #0
   12504:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
   12506:	687b      	ldr	r3, [r7, #4]
   12508:	2201      	movs	r2, #1
   1250a:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
   1250c:	687b      	ldr	r3, [r7, #4]
   1250e:	2200      	movs	r2, #0
   12510:	709a      	strb	r2, [r3, #2]
}
   12512:	46c0      	nop			; (mov r8, r8)
   12514:	46bd      	mov	sp, r7
   12516:	b002      	add	sp, #8
   12518:	bd80      	pop	{r7, pc}
   1251a:	46c0      	nop			; (mov r8, r8)

0001251c <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
   1251c:	b580      	push	{r7, lr}
   1251e:	b084      	sub	sp, #16
   12520:	af00      	add	r7, sp, #0
   12522:	0002      	movs	r2, r0
   12524:	1dfb      	adds	r3, r7, #7
   12526:	701a      	strb	r2, [r3, #0]
   12528:	1dbb      	adds	r3, r7, #6
   1252a:	1c0a      	adds	r2, r1, #0
   1252c:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
   1252e:	1dfb      	adds	r3, r7, #7
   12530:	781b      	ldrb	r3, [r3, #0]
   12532:	0018      	movs	r0, r3
   12534:	4b0d      	ldr	r3, [pc, #52]	; (1256c <port_pin_set_output_level+0x50>)
   12536:	4798      	blx	r3
   12538:	0003      	movs	r3, r0
   1253a:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   1253c:	1dfb      	adds	r3, r7, #7
   1253e:	781b      	ldrb	r3, [r3, #0]
   12540:	221f      	movs	r2, #31
   12542:	4013      	ands	r3, r2
   12544:	2201      	movs	r2, #1
   12546:	409a      	lsls	r2, r3
   12548:	0013      	movs	r3, r2
   1254a:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
   1254c:	1dbb      	adds	r3, r7, #6
   1254e:	781b      	ldrb	r3, [r3, #0]
   12550:	2b00      	cmp	r3, #0
   12552:	d003      	beq.n	1255c <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
   12554:	68fb      	ldr	r3, [r7, #12]
   12556:	68ba      	ldr	r2, [r7, #8]
   12558:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
   1255a:	e002      	b.n	12562 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
   1255c:	68fb      	ldr	r3, [r7, #12]
   1255e:	68ba      	ldr	r2, [r7, #8]
   12560:	615a      	str	r2, [r3, #20]
	}
}
   12562:	46c0      	nop			; (mov r8, r8)
   12564:	46bd      	mov	sp, r7
   12566:	b004      	add	sp, #16
   12568:	bd80      	pop	{r7, pc}
   1256a:	46c0      	nop			; (mov r8, r8)
   1256c:	000124d5 	.word	0x000124d5

00012570 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
   12570:	b580      	push	{r7, lr}
   12572:	b082      	sub	sp, #8
   12574:	af00      	add	r7, sp, #0
   12576:	0002      	movs	r2, r0
   12578:	1dfb      	adds	r3, r7, #7
   1257a:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   1257c:	4b06      	ldr	r3, [pc, #24]	; (12598 <system_interrupt_enable+0x28>)
   1257e:	1dfa      	adds	r2, r7, #7
   12580:	7812      	ldrb	r2, [r2, #0]
   12582:	0011      	movs	r1, r2
   12584:	221f      	movs	r2, #31
   12586:	400a      	ands	r2, r1
   12588:	2101      	movs	r1, #1
   1258a:	4091      	lsls	r1, r2
   1258c:	000a      	movs	r2, r1
   1258e:	601a      	str	r2, [r3, #0]
}
   12590:	46c0      	nop			; (mov r8, r8)
   12592:	46bd      	mov	sp, r7
   12594:	b002      	add	sp, #8
   12596:	bd80      	pop	{r7, pc}
   12598:	e000e100 	.word	0xe000e100

0001259c <system_interrupt_disable>:
 *
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
   1259c:	b580      	push	{r7, lr}
   1259e:	b082      	sub	sp, #8
   125a0:	af00      	add	r7, sp, #0
   125a2:	0002      	movs	r2, r0
   125a4:	1dfb      	adds	r3, r7, #7
   125a6:	701a      	strb	r2, [r3, #0]
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   125a8:	4a07      	ldr	r2, [pc, #28]	; (125c8 <system_interrupt_disable+0x2c>)
   125aa:	1dfb      	adds	r3, r7, #7
   125ac:	781b      	ldrb	r3, [r3, #0]
   125ae:	0019      	movs	r1, r3
   125b0:	231f      	movs	r3, #31
   125b2:	400b      	ands	r3, r1
   125b4:	2101      	movs	r1, #1
   125b6:	4099      	lsls	r1, r3
   125b8:	000b      	movs	r3, r1
   125ba:	0019      	movs	r1, r3
   125bc:	2380      	movs	r3, #128	; 0x80
   125be:	50d1      	str	r1, [r2, r3]
}
   125c0:	46c0      	nop			; (mov r8, r8)
   125c2:	46bd      	mov	sp, r7
   125c4:	b002      	add	sp, #8
   125c6:	bd80      	pop	{r7, pc}
   125c8:	e000e100 	.word	0xe000e100

000125cc <spi_is_syncing>:
 * \retval false  Module synchronization is not ongoing
 *
 */
static inline bool spi_is_syncing(
		struct spi_module *const module)
{
   125cc:	b580      	push	{r7, lr}
   125ce:	b084      	sub	sp, #16
   125d0:	af00      	add	r7, sp, #0
   125d2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   125d4:	687b      	ldr	r3, [r7, #4]
   125d6:	681b      	ldr	r3, [r3, #0]
   125d8:	60fb      	str	r3, [r7, #12]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
   125da:	68fb      	ldr	r3, [r7, #12]
   125dc:	69db      	ldr	r3, [r3, #28]
   125de:	1e5a      	subs	r2, r3, #1
   125e0:	4193      	sbcs	r3, r2
   125e2:	b2db      	uxtb	r3, r3
#  else
	/* Return synchronization status */
	return (spi_module->STATUS.reg & SERCOM_SPI_STATUS_SYNCBUSY);
#  endif
}
   125e4:	0018      	movs	r0, r3
   125e6:	46bd      	mov	sp, r7
   125e8:	b004      	add	sp, #16
   125ea:	bd80      	pop	{r7, pc}

000125ec <spi_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void spi_get_config_defaults(
		struct spi_config *const config)
{
   125ec:	b580      	push	{r7, lr}
   125ee:	b082      	sub	sp, #8
   125f0:	af00      	add	r7, sp, #0
   125f2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
   125f4:	687b      	ldr	r3, [r7, #4]
   125f6:	2201      	movs	r2, #1
   125f8:	701a      	strb	r2, [r3, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
   125fa:	687b      	ldr	r3, [r7, #4]
   125fc:	2200      	movs	r2, #0
   125fe:	605a      	str	r2, [r3, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
   12600:	687b      	ldr	r3, [r7, #4]
   12602:	2200      	movs	r2, #0
   12604:	609a      	str	r2, [r3, #8]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
   12606:	687b      	ldr	r3, [r7, #4]
   12608:	22c0      	movs	r2, #192	; 0xc0
   1260a:	0392      	lsls	r2, r2, #14
   1260c:	60da      	str	r2, [r3, #12]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
   1260e:	687b      	ldr	r3, [r7, #4]
   12610:	2200      	movs	r2, #0
   12612:	741a      	strb	r2, [r3, #16]
	config->run_in_standby   = false;
   12614:	687b      	ldr	r3, [r7, #4]
   12616:	2200      	movs	r2, #0
   12618:	745a      	strb	r2, [r3, #17]
	config->receiver_enable  = true;
   1261a:	687b      	ldr	r3, [r7, #4]
   1261c:	2201      	movs	r2, #1
   1261e:	749a      	strb	r2, [r3, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
   12620:	687b      	ldr	r3, [r7, #4]
   12622:	2201      	movs	r2, #1
   12624:	74da      	strb	r2, [r3, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
   12626:	687b      	ldr	r3, [r7, #4]
   12628:	2200      	movs	r2, #0
   1262a:	751a      	strb	r2, [r3, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
   1262c:	687b      	ldr	r3, [r7, #4]
   1262e:	2224      	movs	r2, #36	; 0x24
   12630:	2100      	movs	r1, #0
   12632:	5499      	strb	r1, [r3, r2]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
   12634:	687b      	ldr	r3, [r7, #4]
   12636:	3318      	adds	r3, #24
   12638:	220c      	movs	r2, #12
   1263a:	2100      	movs	r1, #0
   1263c:	0018      	movs	r0, r3
   1263e:	4b0a      	ldr	r3, [pc, #40]	; (12668 <spi_get_config_defaults+0x7c>)
   12640:	4798      	blx	r3

	/* Master config defaults */
	config->mode_specific.master.baudrate = 100000;
   12642:	687b      	ldr	r3, [r7, #4]
   12644:	4a09      	ldr	r2, [pc, #36]	; (1266c <spi_get_config_defaults+0x80>)
   12646:	619a      	str	r2, [r3, #24]

	/* pinmux config defaults */
	config->pinmux_pad0 = PINMUX_DEFAULT;
   12648:	687b      	ldr	r3, [r7, #4]
   1264a:	2200      	movs	r2, #0
   1264c:	629a      	str	r2, [r3, #40]	; 0x28
	config->pinmux_pad1 = PINMUX_DEFAULT;
   1264e:	687b      	ldr	r3, [r7, #4]
   12650:	2200      	movs	r2, #0
   12652:	62da      	str	r2, [r3, #44]	; 0x2c
	config->pinmux_pad2 = PINMUX_DEFAULT;
   12654:	687b      	ldr	r3, [r7, #4]
   12656:	2200      	movs	r2, #0
   12658:	631a      	str	r2, [r3, #48]	; 0x30
	config->pinmux_pad3 = PINMUX_DEFAULT;
   1265a:	687b      	ldr	r3, [r7, #4]
   1265c:	2200      	movs	r2, #0
   1265e:	635a      	str	r2, [r3, #52]	; 0x34

};
   12660:	46c0      	nop			; (mov r8, r8)
   12662:	46bd      	mov	sp, r7
   12664:	b002      	add	sp, #8
   12666:	bd80      	pop	{r7, pc}
   12668:	0001eead 	.word	0x0001eead
   1266c:	000186a0 	.word	0x000186a0

00012670 <spi_slave_inst_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void spi_slave_inst_get_config_defaults(
		struct spi_slave_inst_config *const config)
{
   12670:	b580      	push	{r7, lr}
   12672:	b082      	sub	sp, #8
   12674:	af00      	add	r7, sp, #0
   12676:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->ss_pin          = 10;
   12678:	687b      	ldr	r3, [r7, #4]
   1267a:	220a      	movs	r2, #10
   1267c:	701a      	strb	r2, [r3, #0]
	config->address_enabled = false;
   1267e:	687b      	ldr	r3, [r7, #4]
   12680:	2200      	movs	r2, #0
   12682:	705a      	strb	r2, [r3, #1]
	config->address         = 0;
   12684:	687b      	ldr	r3, [r7, #4]
   12686:	2200      	movs	r2, #0
   12688:	709a      	strb	r2, [r3, #2]
}
   1268a:	46c0      	nop			; (mov r8, r8)
   1268c:	46bd      	mov	sp, r7
   1268e:	b002      	add	sp, #8
   12690:	bd80      	pop	{r7, pc}
   12692:	46c0      	nop			; (mov r8, r8)

00012694 <spi_attach_slave>:
 *
 */
static inline void spi_attach_slave(
		struct spi_slave_inst *const slave,
		const struct spi_slave_inst_config *const config)
{
   12694:	b580      	push	{r7, lr}
   12696:	b084      	sub	sp, #16
   12698:	af00      	add	r7, sp, #0
   1269a:	6078      	str	r0, [r7, #4]
   1269c:	6039      	str	r1, [r7, #0]
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
   1269e:	683b      	ldr	r3, [r7, #0]
   126a0:	781a      	ldrb	r2, [r3, #0]
   126a2:	687b      	ldr	r3, [r7, #4]
   126a4:	701a      	strb	r2, [r3, #0]
	slave->address_enabled = config->address_enabled;
   126a6:	683b      	ldr	r3, [r7, #0]
   126a8:	785a      	ldrb	r2, [r3, #1]
   126aa:	687b      	ldr	r3, [r7, #4]
   126ac:	705a      	strb	r2, [r3, #1]
	slave->address         = config->address;
   126ae:	683b      	ldr	r3, [r7, #0]
   126b0:	789a      	ldrb	r2, [r3, #2]
   126b2:	687b      	ldr	r3, [r7, #4]
   126b4:	709a      	strb	r2, [r3, #2]

	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);
   126b6:	230c      	movs	r3, #12
   126b8:	18fb      	adds	r3, r7, r3
   126ba:	0018      	movs	r0, r3
   126bc:	4b0b      	ldr	r3, [pc, #44]	; (126ec <spi_attach_slave+0x58>)
   126be:	4798      	blx	r3

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
   126c0:	230c      	movs	r3, #12
   126c2:	18fb      	adds	r3, r7, r3
   126c4:	2201      	movs	r2, #1
   126c6:	701a      	strb	r2, [r3, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
   126c8:	687b      	ldr	r3, [r7, #4]
   126ca:	781b      	ldrb	r3, [r3, #0]
   126cc:	220c      	movs	r2, #12
   126ce:	18ba      	adds	r2, r7, r2
   126d0:	0011      	movs	r1, r2
   126d2:	0018      	movs	r0, r3
   126d4:	4b06      	ldr	r3, [pc, #24]	; (126f0 <spi_attach_slave+0x5c>)
   126d6:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
   126d8:	687b      	ldr	r3, [r7, #4]
   126da:	781b      	ldrb	r3, [r3, #0]
   126dc:	2101      	movs	r1, #1
   126de:	0018      	movs	r0, r3
   126e0:	4b04      	ldr	r3, [pc, #16]	; (126f4 <spi_attach_slave+0x60>)
   126e2:	4798      	blx	r3
}
   126e4:	46c0      	nop			; (mov r8, r8)
   126e6:	46bd      	mov	sp, r7
   126e8:	b004      	add	sp, #16
   126ea:	bd80      	pop	{r7, pc}
   126ec:	000124f9 	.word	0x000124f9
   126f0:	0001355d 	.word	0x0001355d
   126f4:	0001251d 	.word	0x0001251d

000126f8 <spi_enable>:
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
static inline void spi_enable(
		struct spi_module *const module)
{
   126f8:	b580      	push	{r7, lr}
   126fa:	b084      	sub	sp, #16
   126fc:	af00      	add	r7, sp, #0
   126fe:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   12700:	687b      	ldr	r3, [r7, #4]
   12702:	681b      	ldr	r3, [r3, #0]
   12704:	60fb      	str	r3, [r7, #12]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
   12706:	687b      	ldr	r3, [r7, #4]
   12708:	681b      	ldr	r3, [r3, #0]
   1270a:	0018      	movs	r0, r3
   1270c:	4b0b      	ldr	r3, [pc, #44]	; (1273c <spi_enable+0x44>)
   1270e:	4798      	blx	r3
   12710:	0003      	movs	r3, r0
   12712:	0018      	movs	r0, r3
   12714:	4b0a      	ldr	r3, [pc, #40]	; (12740 <spi_enable+0x48>)
   12716:	4798      	blx	r3
#  endif

	while (spi_is_syncing(module)) {
   12718:	46c0      	nop			; (mov r8, r8)
   1271a:	687b      	ldr	r3, [r7, #4]
   1271c:	0018      	movs	r0, r3
   1271e:	4b09      	ldr	r3, [pc, #36]	; (12744 <spi_enable+0x4c>)
   12720:	4798      	blx	r3
   12722:	1e03      	subs	r3, r0, #0
   12724:	d1f9      	bne.n	1271a <spi_enable+0x22>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   12726:	68fb      	ldr	r3, [r7, #12]
   12728:	681b      	ldr	r3, [r3, #0]
   1272a:	2202      	movs	r2, #2
   1272c:	431a      	orrs	r2, r3
   1272e:	68fb      	ldr	r3, [r7, #12]
   12730:	601a      	str	r2, [r3, #0]
}
   12732:	46c0      	nop			; (mov r8, r8)
   12734:	46bd      	mov	sp, r7
   12736:	b004      	add	sp, #16
   12738:	bd80      	pop	{r7, pc}
   1273a:	46c0      	nop			; (mov r8, r8)
   1273c:	00014119 	.word	0x00014119
   12740:	00012571 	.word	0x00012571
   12744:	000125cd 	.word	0x000125cd

00012748 <spi_disable>:
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
static inline void spi_disable(
		struct spi_module *const module)
{
   12748:	b580      	push	{r7, lr}
   1274a:	b084      	sub	sp, #16
   1274c:	af00      	add	r7, sp, #0
   1274e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   12750:	687b      	ldr	r3, [r7, #4]
   12752:	681b      	ldr	r3, [r3, #0]
   12754:	60fb      	str	r3, [r7, #12]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
   12756:	687b      	ldr	r3, [r7, #4]
   12758:	681b      	ldr	r3, [r3, #0]
   1275a:	0018      	movs	r0, r3
   1275c:	4b0b      	ldr	r3, [pc, #44]	; (1278c <spi_disable+0x44>)
   1275e:	4798      	blx	r3
   12760:	0003      	movs	r3, r0
   12762:	0018      	movs	r0, r3
   12764:	4b0a      	ldr	r3, [pc, #40]	; (12790 <spi_disable+0x48>)
   12766:	4798      	blx	r3
#  endif

	while (spi_is_syncing(module)) {
   12768:	46c0      	nop			; (mov r8, r8)
   1276a:	687b      	ldr	r3, [r7, #4]
   1276c:	0018      	movs	r0, r3
   1276e:	4b09      	ldr	r3, [pc, #36]	; (12794 <spi_disable+0x4c>)
   12770:	4798      	blx	r3
   12772:	1e03      	subs	r3, r0, #0
   12774:	d1f9      	bne.n	1276a <spi_disable+0x22>
		/* Wait until the synchronization is complete */
	}

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   12776:	68fb      	ldr	r3, [r7, #12]
   12778:	681b      	ldr	r3, [r3, #0]
   1277a:	2202      	movs	r2, #2
   1277c:	4393      	bics	r3, r2
   1277e:	001a      	movs	r2, r3
   12780:	68fb      	ldr	r3, [r7, #12]
   12782:	601a      	str	r2, [r3, #0]
}
   12784:	46c0      	nop			; (mov r8, r8)
   12786:	46bd      	mov	sp, r7
   12788:	b004      	add	sp, #16
   1278a:	bd80      	pop	{r7, pc}
   1278c:	00014119 	.word	0x00014119
   12790:	0001259d 	.word	0x0001259d
   12794:	000125cd 	.word	0x000125cd

00012798 <sd_mmc_spi_crc7>:
 * \param size    Size of buffer data
 *
 * \return CRC7 computed
 */
static uint8_t sd_mmc_spi_crc7(uint8_t * buf, uint8_t size)
{
   12798:	b580      	push	{r7, lr}
   1279a:	b084      	sub	sp, #16
   1279c:	af00      	add	r7, sp, #0
   1279e:	6078      	str	r0, [r7, #4]
   127a0:	000a      	movs	r2, r1
   127a2:	1cfb      	adds	r3, r7, #3
   127a4:	701a      	strb	r2, [r3, #0]
	uint8_t crc, value, i;

	crc = 0;
   127a6:	230f      	movs	r3, #15
   127a8:	18fb      	adds	r3, r7, r3
   127aa:	2200      	movs	r2, #0
   127ac:	701a      	strb	r2, [r3, #0]
	while (size--) {
   127ae:	e038      	b.n	12822 <sd_mmc_spi_crc7+0x8a>
		value = *buf++;
   127b0:	687b      	ldr	r3, [r7, #4]
   127b2:	1c5a      	adds	r2, r3, #1
   127b4:	607a      	str	r2, [r7, #4]
   127b6:	220e      	movs	r2, #14
   127b8:	18ba      	adds	r2, r7, r2
   127ba:	781b      	ldrb	r3, [r3, #0]
   127bc:	7013      	strb	r3, [r2, #0]
		for (i = 0; i < 8; i++) {
   127be:	230d      	movs	r3, #13
   127c0:	18fb      	adds	r3, r7, r3
   127c2:	2200      	movs	r2, #0
   127c4:	701a      	strb	r2, [r3, #0]
   127c6:	e027      	b.n	12818 <sd_mmc_spi_crc7+0x80>
			crc <<= 1;
   127c8:	230f      	movs	r3, #15
   127ca:	18fa      	adds	r2, r7, r3
   127cc:	230f      	movs	r3, #15
   127ce:	18fb      	adds	r3, r7, r3
   127d0:	781b      	ldrb	r3, [r3, #0]
   127d2:	18db      	adds	r3, r3, r3
   127d4:	7013      	strb	r3, [r2, #0]
			if ((value & 0x80) ^ (crc & 0x80)) {
   127d6:	230e      	movs	r3, #14
   127d8:	18fa      	adds	r2, r7, r3
   127da:	230f      	movs	r3, #15
   127dc:	18fb      	adds	r3, r7, r3
   127de:	7812      	ldrb	r2, [r2, #0]
   127e0:	781b      	ldrb	r3, [r3, #0]
   127e2:	4053      	eors	r3, r2
   127e4:	b2db      	uxtb	r3, r3
   127e6:	b25b      	sxtb	r3, r3
   127e8:	2b00      	cmp	r3, #0
   127ea:	da07      	bge.n	127fc <sd_mmc_spi_crc7+0x64>
				crc ^= 0x09;
   127ec:	230f      	movs	r3, #15
   127ee:	18fb      	adds	r3, r7, r3
   127f0:	220f      	movs	r2, #15
   127f2:	18ba      	adds	r2, r7, r2
   127f4:	7812      	ldrb	r2, [r2, #0]
   127f6:	2109      	movs	r1, #9
   127f8:	404a      	eors	r2, r1
   127fa:	701a      	strb	r2, [r3, #0]
			}
			value <<= 1;
   127fc:	230e      	movs	r3, #14
   127fe:	18fa      	adds	r2, r7, r3
   12800:	230e      	movs	r3, #14
   12802:	18fb      	adds	r3, r7, r3
   12804:	781b      	ldrb	r3, [r3, #0]
   12806:	18db      	adds	r3, r3, r3
   12808:	7013      	strb	r3, [r2, #0]
	uint8_t crc, value, i;

	crc = 0;
	while (size--) {
		value = *buf++;
		for (i = 0; i < 8; i++) {
   1280a:	230d      	movs	r3, #13
   1280c:	18fb      	adds	r3, r7, r3
   1280e:	781a      	ldrb	r2, [r3, #0]
   12810:	230d      	movs	r3, #13
   12812:	18fb      	adds	r3, r7, r3
   12814:	3201      	adds	r2, #1
   12816:	701a      	strb	r2, [r3, #0]
   12818:	230d      	movs	r3, #13
   1281a:	18fb      	adds	r3, r7, r3
   1281c:	781b      	ldrb	r3, [r3, #0]
   1281e:	2b07      	cmp	r3, #7
   12820:	d9d2      	bls.n	127c8 <sd_mmc_spi_crc7+0x30>
static uint8_t sd_mmc_spi_crc7(uint8_t * buf, uint8_t size)
{
	uint8_t crc, value, i;

	crc = 0;
	while (size--) {
   12822:	1cfb      	adds	r3, r7, #3
   12824:	781b      	ldrb	r3, [r3, #0]
   12826:	1cfa      	adds	r2, r7, #3
   12828:	1e59      	subs	r1, r3, #1
   1282a:	7011      	strb	r1, [r2, #0]
   1282c:	2b00      	cmp	r3, #0
   1282e:	d1bf      	bne.n	127b0 <sd_mmc_spi_crc7+0x18>
				crc ^= 0x09;
			}
			value <<= 1;
		}
	}
	crc = (crc << 1) | 1;
   12830:	230f      	movs	r3, #15
   12832:	18fb      	adds	r3, r7, r3
   12834:	781b      	ldrb	r3, [r3, #0]
   12836:	005b      	lsls	r3, r3, #1
   12838:	b25b      	sxtb	r3, r3
   1283a:	2201      	movs	r2, #1
   1283c:	4313      	orrs	r3, r2
   1283e:	b25a      	sxtb	r2, r3
   12840:	230f      	movs	r3, #15
   12842:	18fb      	adds	r3, r7, r3
   12844:	701a      	strb	r2, [r3, #0]
	return crc;
   12846:	230f      	movs	r3, #15
   12848:	18fb      	adds	r3, r7, r3
   1284a:	781b      	ldrb	r3, [r3, #0]
}
   1284c:	0018      	movs	r0, r3
   1284e:	46bd      	mov	sp, r7
   12850:	b004      	add	sp, #16
   12852:	bd80      	pop	{r7, pc}

00012854 <sd_mmc_spi_wait_busy>:
 * \brief Wait the end of busy on DAT0 line
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_spi_wait_busy(void)
{
   12854:	b590      	push	{r4, r7, lr}
   12856:	b083      	sub	sp, #12
   12858:	af00      	add	r7, sp, #0
	uint8_t line = 0xFF;
   1285a:	1c7b      	adds	r3, r7, #1
   1285c:	22ff      	movs	r2, #255	; 0xff
   1285e:	701a      	strb	r2, [r3, #0]
	uint16_t dummy = 0xFF;
   12860:	1cbb      	adds	r3, r7, #2
   12862:	22ff      	movs	r2, #255	; 0xff
   12864:	801a      	strh	r2, [r3, #0]

	/* Delay before check busy
	 * Nbr timing minimum = 8 cylces
	 */
	spi_read_buffer_wait(&sd_mmc_master, &line, 1,
   12866:	1cbb      	adds	r3, r7, #2
   12868:	881b      	ldrh	r3, [r3, #0]
   1286a:	1c79      	adds	r1, r7, #1
   1286c:	4811      	ldr	r0, [pc, #68]	; (128b4 <sd_mmc_spi_wait_busy+0x60>)
   1286e:	2201      	movs	r2, #1
   12870:	4c11      	ldr	r4, [pc, #68]	; (128b8 <sd_mmc_spi_wait_busy+0x64>)
   12872:	47a0      	blx	r4
	/* Wait end of busy signal
	 * Nec timing: 0 to unlimited
	 * However a timeout is used.
	 * 200 000 * 8 cycles
	 */
	uint32_t nec_timeout = 200000;
   12874:	4b11      	ldr	r3, [pc, #68]	; (128bc <sd_mmc_spi_wait_busy+0x68>)
   12876:	607b      	str	r3, [r7, #4]
	spi_read_buffer_wait(&sd_mmc_master, &line, 1,
   12878:	1cbb      	adds	r3, r7, #2
   1287a:	881b      	ldrh	r3, [r3, #0]
   1287c:	1c79      	adds	r1, r7, #1
   1287e:	480d      	ldr	r0, [pc, #52]	; (128b4 <sd_mmc_spi_wait_busy+0x60>)
   12880:	2201      	movs	r2, #1
   12882:	4c0d      	ldr	r4, [pc, #52]	; (128b8 <sd_mmc_spi_wait_busy+0x64>)
   12884:	47a0      	blx	r4
			dummy);
	do {
		spi_read_buffer_wait(&sd_mmc_master, &line, 1,
   12886:	1cbb      	adds	r3, r7, #2
   12888:	881b      	ldrh	r3, [r3, #0]
   1288a:	1c79      	adds	r1, r7, #1
   1288c:	4809      	ldr	r0, [pc, #36]	; (128b4 <sd_mmc_spi_wait_busy+0x60>)
   1288e:	2201      	movs	r2, #1
   12890:	4c09      	ldr	r4, [pc, #36]	; (128b8 <sd_mmc_spi_wait_busy+0x64>)
   12892:	47a0      	blx	r4
			dummy);
		if (!(nec_timeout--)) {
   12894:	687b      	ldr	r3, [r7, #4]
   12896:	1e5a      	subs	r2, r3, #1
   12898:	607a      	str	r2, [r7, #4]
   1289a:	2b00      	cmp	r3, #0
   1289c:	d101      	bne.n	128a2 <sd_mmc_spi_wait_busy+0x4e>
			return false;
   1289e:	2300      	movs	r3, #0
   128a0:	e004      	b.n	128ac <sd_mmc_spi_wait_busy+0x58>
		}
	} while (line != 0xFF);
   128a2:	1c7b      	adds	r3, r7, #1
   128a4:	781b      	ldrb	r3, [r3, #0]
   128a6:	2bff      	cmp	r3, #255	; 0xff
   128a8:	d1ed      	bne.n	12886 <sd_mmc_spi_wait_busy+0x32>
	return true;
   128aa:	2301      	movs	r3, #1
}
   128ac:	0018      	movs	r0, r3
   128ae:	46bd      	mov	sp, r7
   128b0:	b003      	add	sp, #12
   128b2:	bd90      	pop	{r4, r7, pc}
   128b4:	20002ddc 	.word	0x20002ddc
   128b8:	00014a5d 	.word	0x00014a5d
   128bc:	00030d40 	.word	0x00030d40

000128c0 <sd_mmc_spi_start_read_block>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_spi_err.
 */
static bool sd_mmc_spi_start_read_block(void)
{
   128c0:	b590      	push	{r4, r7, lr}
   128c2:	b083      	sub	sp, #12
   128c4:	af00      	add	r7, sp, #0
	uint32_t i;
	uint8_t token;
	uint16_t dummy = 0xFF;
   128c6:	1cbb      	adds	r3, r7, #2
   128c8:	22ff      	movs	r2, #255	; 0xff
   128ca:	801a      	strh	r2, [r3, #0]
	 * Compute the maximum timeout:
	 * Frequency maximum = 25MHz
	 * 1 byte = 8 cycles
	 * 100ms = 312500 x spi_read_buffer_wait() maximum
	 */
	token = 0;
   128cc:	1c7b      	adds	r3, r7, #1
   128ce:	2200      	movs	r2, #0
   128d0:	701a      	strb	r2, [r3, #0]
	i = 500000;
   128d2:	4b18      	ldr	r3, [pc, #96]	; (12934 <sd_mmc_spi_start_read_block+0x74>)
   128d4:	607b      	str	r3, [r7, #4]
	do {
		if (i-- == 0) {
   128d6:	687b      	ldr	r3, [r7, #4]
   128d8:	1e5a      	subs	r2, r3, #1
   128da:	607a      	str	r2, [r7, #4]
   128dc:	2b00      	cmp	r3, #0
   128de:	d104      	bne.n	128ea <sd_mmc_spi_start_read_block+0x2a>
			sd_mmc_spi_err = SD_MMC_SPI_ERR_READ_TIMEOUT;
   128e0:	4b15      	ldr	r3, [pc, #84]	; (12938 <sd_mmc_spi_start_read_block+0x78>)
   128e2:	2204      	movs	r2, #4
   128e4:	701a      	strb	r2, [r3, #0]
			sd_mmc_spi_debug("%s: Read blocks timeout\n\r", __func__);
			return false;
   128e6:	2300      	movs	r3, #0
   128e8:	e020      	b.n	1292c <sd_mmc_spi_start_read_block+0x6c>
		}
		spi_read_buffer_wait(&sd_mmc_master, &token, 1,
   128ea:	1cbb      	adds	r3, r7, #2
   128ec:	881b      	ldrh	r3, [r3, #0]
   128ee:	1c79      	adds	r1, r7, #1
   128f0:	4812      	ldr	r0, [pc, #72]	; (1293c <sd_mmc_spi_start_read_block+0x7c>)
   128f2:	2201      	movs	r2, #1
   128f4:	4c12      	ldr	r4, [pc, #72]	; (12940 <sd_mmc_spi_start_read_block+0x80>)
   128f6:	47a0      	blx	r4
			dummy);
		if (SPI_TOKEN_DATA_ERROR_VALID(token)) {
   128f8:	1c7b      	adds	r3, r7, #1
   128fa:	781b      	ldrb	r3, [r3, #0]
   128fc:	001a      	movs	r2, r3
   128fe:	23f0      	movs	r3, #240	; 0xf0
   12900:	4013      	ands	r3, r2
   12902:	d10e      	bne.n	12922 <sd_mmc_spi_start_read_block+0x62>
			Assert(SPI_TOKEN_DATA_ERROR_ERRORS & token);
			if (token & (SPI_TOKEN_DATA_ERROR_ERROR
   12904:	1c7b      	adds	r3, r7, #1
   12906:	781b      	ldrb	r3, [r3, #0]
   12908:	001a      	movs	r2, r3
   1290a:	2307      	movs	r3, #7
   1290c:	4013      	ands	r3, r2
   1290e:	d003      	beq.n	12918 <sd_mmc_spi_start_read_block+0x58>
					| SPI_TOKEN_DATA_ERROR_ECC_ERROR
					| SPI_TOKEN_DATA_ERROR_CC_ERROR)) {
				sd_mmc_spi_debug("%s: CRC data error token\n\r", __func__);
				sd_mmc_spi_err = SD_MMC_SPI_ERR_READ_CRC;
   12910:	4b09      	ldr	r3, [pc, #36]	; (12938 <sd_mmc_spi_start_read_block+0x78>)
   12912:	2207      	movs	r2, #7
   12914:	701a      	strb	r2, [r3, #0]
   12916:	e002      	b.n	1291e <sd_mmc_spi_start_read_block+0x5e>
			} else {
				sd_mmc_spi_debug("%s: Out of range data error token\n\r", __func__);
				sd_mmc_spi_err = SD_MMC_SPI_ERR_OUT_OF_RANGE;
   12918:	4b07      	ldr	r3, [pc, #28]	; (12938 <sd_mmc_spi_start_read_block+0x78>)
   1291a:	220b      	movs	r2, #11
   1291c:	701a      	strb	r2, [r3, #0]
			}
			return false;
   1291e:	2300      	movs	r3, #0
   12920:	e004      	b.n	1292c <sd_mmc_spi_start_read_block+0x6c>
		}
	} while (token != SPI_TOKEN_SINGLE_MULTI_READ);
   12922:	1c7b      	adds	r3, r7, #1
   12924:	781b      	ldrb	r3, [r3, #0]
   12926:	2bfe      	cmp	r3, #254	; 0xfe
   12928:	d1d5      	bne.n	128d6 <sd_mmc_spi_start_read_block+0x16>

	return true;
   1292a:	2301      	movs	r3, #1
}
   1292c:	0018      	movs	r0, r3
   1292e:	46bd      	mov	sp, r7
   12930:	b003      	add	sp, #12
   12932:	bd90      	pop	{r4, r7, pc}
   12934:	0007a120 	.word	0x0007a120
   12938:	20002e1f 	.word	0x20002e1f
   1293c:	20002ddc 	.word	0x20002ddc
   12940:	00014a5d 	.word	0x00014a5d

00012944 <sd_mmc_spi_stop_read_block>:

/**
 * \brief Executed the end of a read block transfer
 */
static void sd_mmc_spi_stop_read_block(void)
{
   12944:	b590      	push	{r4, r7, lr}
   12946:	b083      	sub	sp, #12
   12948:	af00      	add	r7, sp, #0
	uint8_t crc[2];
	uint16_t dummy = 0xFF;
   1294a:	1dbb      	adds	r3, r7, #6
   1294c:	22ff      	movs	r2, #255	; 0xff
   1294e:	801a      	strh	r2, [r3, #0]
	// Read 16-bit CRC (not cheked)
	spi_read_buffer_wait(&sd_mmc_master, crc, 2,
   12950:	1dbb      	adds	r3, r7, #6
   12952:	881b      	ldrh	r3, [r3, #0]
   12954:	1d39      	adds	r1, r7, #4
   12956:	4804      	ldr	r0, [pc, #16]	; (12968 <sd_mmc_spi_stop_read_block+0x24>)
   12958:	2202      	movs	r2, #2
   1295a:	4c04      	ldr	r4, [pc, #16]	; (1296c <sd_mmc_spi_stop_read_block+0x28>)
   1295c:	47a0      	blx	r4
			dummy);
}
   1295e:	46c0      	nop			; (mov r8, r8)
   12960:	46bd      	mov	sp, r7
   12962:	b003      	add	sp, #12
   12964:	bd90      	pop	{r4, r7, pc}
   12966:	46c0      	nop			; (mov r8, r8)
   12968:	20002ddc 	.word	0x20002ddc
   1296c:	00014a5d 	.word	0x00014a5d

00012970 <sd_mmc_spi_start_write_block>:

/**
 * \brief Sends the correct TOKEN on the line to start a write block transfer
 */
static void sd_mmc_spi_start_write_block(void)
{
   12970:	b580      	push	{r7, lr}
   12972:	b082      	sub	sp, #8
   12974:	af00      	add	r7, sp, #0
	uint8_t dummy = 0xFF;
   12976:	1dfb      	adds	r3, r7, #7
   12978:	22ff      	movs	r2, #255	; 0xff
   1297a:	701a      	strb	r2, [r3, #0]
	Assert(!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size));
	// Delay before start write block:
	// Nwr timing minimum = 8 cylces
	spi_write_buffer_wait(&sd_mmc_master,&dummy, 1);
   1297c:	1df9      	adds	r1, r7, #7
   1297e:	4b0d      	ldr	r3, [pc, #52]	; (129b4 <sd_mmc_spi_start_write_block+0x44>)
   12980:	2201      	movs	r2, #1
   12982:	0018      	movs	r0, r3
   12984:	4b0c      	ldr	r3, [pc, #48]	; (129b8 <sd_mmc_spi_start_write_block+0x48>)
   12986:	4798      	blx	r3
	// Send start token
	uint8_t token;
	if (1 == sd_mmc_spi_nb_block) {
   12988:	4b0c      	ldr	r3, [pc, #48]	; (129bc <sd_mmc_spi_start_write_block+0x4c>)
   1298a:	881b      	ldrh	r3, [r3, #0]
   1298c:	2b01      	cmp	r3, #1
   1298e:	d103      	bne.n	12998 <sd_mmc_spi_start_write_block+0x28>
		token = SPI_TOKEN_SINGLE_WRITE;
   12990:	1dbb      	adds	r3, r7, #6
   12992:	22fe      	movs	r2, #254	; 0xfe
   12994:	701a      	strb	r2, [r3, #0]
   12996:	e002      	b.n	1299e <sd_mmc_spi_start_write_block+0x2e>
	} else {
		token = SPI_TOKEN_MULTI_WRITE;
   12998:	1dbb      	adds	r3, r7, #6
   1299a:	22fc      	movs	r2, #252	; 0xfc
   1299c:	701a      	strb	r2, [r3, #0]
	}
	spi_write_buffer_wait(&sd_mmc_master,&token, 1);
   1299e:	1db9      	adds	r1, r7, #6
   129a0:	4b04      	ldr	r3, [pc, #16]	; (129b4 <sd_mmc_spi_start_write_block+0x44>)
   129a2:	2201      	movs	r2, #1
   129a4:	0018      	movs	r0, r3
   129a6:	4b04      	ldr	r3, [pc, #16]	; (129b8 <sd_mmc_spi_start_write_block+0x48>)
   129a8:	4798      	blx	r3
}
   129aa:	46c0      	nop			; (mov r8, r8)
   129ac:	46bd      	mov	sp, r7
   129ae:	b002      	add	sp, #8
   129b0:	bd80      	pop	{r7, pc}
   129b2:	46c0      	nop			; (mov r8, r8)
   129b4:	20002ddc 	.word	0x20002ddc
   129b8:	00014d31 	.word	0x00014d31
   129bc:	20002e2a 	.word	0x20002e2a

000129c0 <sd_mmc_spi_stop_write_block>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_spi_err.
 */
static bool sd_mmc_spi_stop_write_block(void)
{
   129c0:	b590      	push	{r4, r7, lr}
   129c2:	b083      	sub	sp, #12
   129c4:	af00      	add	r7, sp, #0
	uint8_t resp;
	uint16_t crc;
	uint16_t dummy = 0xFF;
   129c6:	1dbb      	adds	r3, r7, #6
   129c8:	22ff      	movs	r2, #255	; 0xff
   129ca:	801a      	strh	r2, [r3, #0]

	// Send CRC
	crc = 0xFFFF; /// CRC is disabled in SPI mode
   129cc:	1cbb      	adds	r3, r7, #2
   129ce:	2201      	movs	r2, #1
   129d0:	4252      	negs	r2, r2
   129d2:	801a      	strh	r2, [r3, #0]
	spi_write_buffer_wait(&sd_mmc_master, (uint8_t *)&crc, 2);
   129d4:	1cb9      	adds	r1, r7, #2
   129d6:	4b1b      	ldr	r3, [pc, #108]	; (12a44 <sd_mmc_spi_stop_write_block+0x84>)
   129d8:	2202      	movs	r2, #2
   129da:	0018      	movs	r0, r3
   129dc:	4b1a      	ldr	r3, [pc, #104]	; (12a48 <sd_mmc_spi_stop_write_block+0x88>)
   129de:	4798      	blx	r3
	// Receiv data response token
	spi_read_buffer_wait(&sd_mmc_master, &resp, 1,
   129e0:	1dbb      	adds	r3, r7, #6
   129e2:	881b      	ldrh	r3, [r3, #0]
   129e4:	1d79      	adds	r1, r7, #5
   129e6:	4817      	ldr	r0, [pc, #92]	; (12a44 <sd_mmc_spi_stop_write_block+0x84>)
   129e8:	2201      	movs	r2, #1
   129ea:	4c18      	ldr	r4, [pc, #96]	; (12a4c <sd_mmc_spi_stop_write_block+0x8c>)
   129ec:	47a0      	blx	r4
			dummy);
	if (!SPI_TOKEN_DATA_RESP_VALID(resp)) {
   129ee:	1d7b      	adds	r3, r7, #5
   129f0:	781b      	ldrb	r3, [r3, #0]
   129f2:	001a      	movs	r2, r3
   129f4:	2310      	movs	r3, #16
   129f6:	4013      	ands	r3, r2
   129f8:	d105      	bne.n	12a06 <sd_mmc_spi_stop_write_block+0x46>
   129fa:	1d7b      	adds	r3, r7, #5
   129fc:	781b      	ldrb	r3, [r3, #0]
   129fe:	001a      	movs	r2, r3
   12a00:	2301      	movs	r3, #1
   12a02:	4013      	ands	r3, r2
   12a04:	d104      	bne.n	12a10 <sd_mmc_spi_stop_write_block+0x50>
		sd_mmc_spi_err = SD_MMC_SPI_ERR;
   12a06:	4b12      	ldr	r3, [pc, #72]	; (12a50 <sd_mmc_spi_stop_write_block+0x90>)
   12a08:	2201      	movs	r2, #1
   12a0a:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Invalid Data Response Token 0x%x\n\r", __func__, resp);
		return false;
   12a0c:	2300      	movs	r3, #0
   12a0e:	e014      	b.n	12a3a <sd_mmc_spi_stop_write_block+0x7a>
	}
	// Check data response
	switch (SPI_TOKEN_DATA_RESP_CODE(resp)) {
   12a10:	1d7b      	adds	r3, r7, #5
   12a12:	781b      	ldrb	r3, [r3, #0]
   12a14:	001a      	movs	r2, r3
   12a16:	231e      	movs	r3, #30
   12a18:	4013      	ands	r3, r2
   12a1a:	2b04      	cmp	r3, #4
   12a1c:	d00b      	beq.n	12a36 <sd_mmc_spi_stop_write_block+0x76>
   12a1e:	2b0a      	cmp	r3, #10
   12a20:	d104      	bne.n	12a2c <sd_mmc_spi_stop_write_block+0x6c>
	case SPI_TOKEN_DATA_RESP_ACCEPTED:
		break;
	case SPI_TOKEN_DATA_RESP_CRC_ERR:
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_CRC;
   12a22:	4b0b      	ldr	r3, [pc, #44]	; (12a50 <sd_mmc_spi_stop_write_block+0x90>)
   12a24:	2208      	movs	r2, #8
   12a26:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Write blocks, SD_MMC_SPI_ERR_CRC, resp 0x%x\n\r",
				__func__, resp);
		return false;
   12a28:	2300      	movs	r3, #0
   12a2a:	e006      	b.n	12a3a <sd_mmc_spi_stop_write_block+0x7a>
	case SPI_TOKEN_DATA_RESP_WRITE_ERR:
	default:
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE;
   12a2c:	4b08      	ldr	r3, [pc, #32]	; (12a50 <sd_mmc_spi_stop_write_block+0x90>)
   12a2e:	220a      	movs	r2, #10
   12a30:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Write blocks SD_MMC_SPI_ERR_WR, resp 0x%x\n\r",
				__func__, resp);
		return false;
   12a32:	2300      	movs	r3, #0
   12a34:	e001      	b.n	12a3a <sd_mmc_spi_stop_write_block+0x7a>
		return false;
	}
	// Check data response
	switch (SPI_TOKEN_DATA_RESP_CODE(resp)) {
	case SPI_TOKEN_DATA_RESP_ACCEPTED:
		break;
   12a36:	46c0      	nop			; (mov r8, r8)
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE;
		sd_mmc_spi_debug("%s: Write blocks SD_MMC_SPI_ERR_WR, resp 0x%x\n\r",
				__func__, resp);
		return false;
	}
	return true;
   12a38:	2301      	movs	r3, #1
}
   12a3a:	0018      	movs	r0, r3
   12a3c:	46bd      	mov	sp, r7
   12a3e:	b003      	add	sp, #12
   12a40:	bd90      	pop	{r4, r7, pc}
   12a42:	46c0      	nop			; (mov r8, r8)
   12a44:	20002ddc 	.word	0x20002ddc
   12a48:	00014d31 	.word	0x00014d31
   12a4c:	00014a5d 	.word	0x00014a5d
   12a50:	20002e1f 	.word	0x20002e1f

00012a54 <sd_mmc_spi_stop_multiwrite_block>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_spi_err.
 */
static bool sd_mmc_spi_stop_multiwrite_block(void)
{
   12a54:	b590      	push	{r4, r7, lr}
   12a56:	b083      	sub	sp, #12
   12a58:	af00      	add	r7, sp, #0
	uint8_t value;

	if (1 == sd_mmc_spi_nb_block) {
   12a5a:	4b1d      	ldr	r3, [pc, #116]	; (12ad0 <sd_mmc_spi_stop_multiwrite_block+0x7c>)
   12a5c:	881b      	ldrh	r3, [r3, #0]
   12a5e:	2b01      	cmp	r3, #1
   12a60:	d101      	bne.n	12a66 <sd_mmc_spi_stop_multiwrite_block+0x12>
		return true; // Single block write
   12a62:	2301      	movs	r3, #1
   12a64:	e030      	b.n	12ac8 <sd_mmc_spi_stop_multiwrite_block+0x74>
	}
	if (sd_mmc_spi_nb_block >
   12a66:	4b1a      	ldr	r3, [pc, #104]	; (12ad0 <sd_mmc_spi_stop_multiwrite_block+0x7c>)
   12a68:	881b      	ldrh	r3, [r3, #0]
   12a6a:	001c      	movs	r4, r3
		(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size)) {
   12a6c:	4b19      	ldr	r3, [pc, #100]	; (12ad4 <sd_mmc_spi_stop_multiwrite_block+0x80>)
   12a6e:	681a      	ldr	r2, [r3, #0]
   12a70:	4b19      	ldr	r3, [pc, #100]	; (12ad8 <sd_mmc_spi_stop_multiwrite_block+0x84>)
   12a72:	881b      	ldrh	r3, [r3, #0]
   12a74:	0019      	movs	r1, r3
   12a76:	4b19      	ldr	r3, [pc, #100]	; (12adc <sd_mmc_spi_stop_multiwrite_block+0x88>)
   12a78:	0010      	movs	r0, r2
   12a7a:	4798      	blx	r3
   12a7c:	0003      	movs	r3, r0
	uint8_t value;

	if (1 == sd_mmc_spi_nb_block) {
		return true; // Single block write
	}
	if (sd_mmc_spi_nb_block >
   12a7e:	429c      	cmp	r4, r3
   12a80:	d901      	bls.n	12a86 <sd_mmc_spi_stop_multiwrite_block+0x32>
		(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size)) {
		return true; // It is not the End of multi write
   12a82:	2301      	movs	r3, #1
   12a84:	e020      	b.n	12ac8 <sd_mmc_spi_stop_multiwrite_block+0x74>
	}

	// Delay before start write block:
	// Nwr timing minimum = 8 cylces
	value = 0xFF;
   12a86:	1dfb      	adds	r3, r7, #7
   12a88:	22ff      	movs	r2, #255	; 0xff
   12a8a:	701a      	strb	r2, [r3, #0]
	spi_write_buffer_wait(&sd_mmc_master, &value, 1);
   12a8c:	1df9      	adds	r1, r7, #7
   12a8e:	4b14      	ldr	r3, [pc, #80]	; (12ae0 <sd_mmc_spi_stop_multiwrite_block+0x8c>)
   12a90:	2201      	movs	r2, #1
   12a92:	0018      	movs	r0, r3
   12a94:	4b13      	ldr	r3, [pc, #76]	; (12ae4 <sd_mmc_spi_stop_multiwrite_block+0x90>)
   12a96:	4798      	blx	r3
	// Send stop token
	value = SPI_TOKEN_STOP_TRAN;
   12a98:	1dfb      	adds	r3, r7, #7
   12a9a:	22fd      	movs	r2, #253	; 0xfd
   12a9c:	701a      	strb	r2, [r3, #0]
	spi_write_buffer_wait(&sd_mmc_master, &value, 1);
   12a9e:	1df9      	adds	r1, r7, #7
   12aa0:	4b0f      	ldr	r3, [pc, #60]	; (12ae0 <sd_mmc_spi_stop_multiwrite_block+0x8c>)
   12aa2:	2201      	movs	r2, #1
   12aa4:	0018      	movs	r0, r3
   12aa6:	4b0f      	ldr	r3, [pc, #60]	; (12ae4 <sd_mmc_spi_stop_multiwrite_block+0x90>)
   12aa8:	4798      	blx	r3
	// Wait busy
	if (!sd_mmc_spi_wait_busy()) {
   12aaa:	4b0f      	ldr	r3, [pc, #60]	; (12ae8 <sd_mmc_spi_stop_multiwrite_block+0x94>)
   12aac:	4798      	blx	r3
   12aae:	0003      	movs	r3, r0
   12ab0:	001a      	movs	r2, r3
   12ab2:	2301      	movs	r3, #1
   12ab4:	4053      	eors	r3, r2
   12ab6:	b2db      	uxtb	r3, r3
   12ab8:	2b00      	cmp	r3, #0
   12aba:	d004      	beq.n	12ac6 <sd_mmc_spi_stop_multiwrite_block+0x72>
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_TIMEOUT;
   12abc:	4b0b      	ldr	r3, [pc, #44]	; (12aec <sd_mmc_spi_stop_multiwrite_block+0x98>)
   12abe:	2205      	movs	r2, #5
   12ac0:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Stop write blocks timeout\n\r",
				__func__);
		return false;
   12ac2:	2300      	movs	r3, #0
   12ac4:	e000      	b.n	12ac8 <sd_mmc_spi_stop_multiwrite_block+0x74>
	}
	return true;
   12ac6:	2301      	movs	r3, #1
}
   12ac8:	0018      	movs	r0, r3
   12aca:	46bd      	mov	sp, r7
   12acc:	b003      	add	sp, #12
   12ace:	bd90      	pop	{r4, r7, pc}
   12ad0:	20002e2a 	.word	0x20002e2a
   12ad4:	20002e24 	.word	0x20002e24
   12ad8:	20002e28 	.word	0x20002e28
   12adc:	0001d485 	.word	0x0001d485
   12ae0:	20002ddc 	.word	0x20002ddc
   12ae4:	00014d31 	.word	0x00014d31
   12ae8:	00012855 	.word	0x00012855
   12aec:	20002e1f 	.word	0x20002e1f

00012af0 <sd_mmc_spi_init>:
{
	return sd_mmc_spi_err;
}

void sd_mmc_spi_init(void)
{
   12af0:	b580      	push	{r7, lr}
   12af2:	b090      	sub	sp, #64	; 0x40
   12af4:	af00      	add	r7, sp, #0
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   12af6:	4b29      	ldr	r3, [pc, #164]	; (12b9c <sd_mmc_spi_init+0xac>)
   12af8:	2200      	movs	r2, #0
   12afa:	701a      	strb	r2, [r3, #0]

	// Initialize card detect pin
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);
   12afc:	233c      	movs	r3, #60	; 0x3c
   12afe:	18fb      	adds	r3, r7, r3
   12b00:	0018      	movs	r0, r3
   12b02:	4b27      	ldr	r3, [pc, #156]	; (12ba0 <sd_mmc_spi_init+0xb0>)
   12b04:	4798      	blx	r3

	// Set card detect pin as inputs
	pin_conf.direction	= PORT_PIN_DIR_INPUT;
   12b06:	233c      	movs	r3, #60	; 0x3c
   12b08:	18fb      	adds	r3, r7, r3
   12b0a:	2200      	movs	r2, #0
   12b0c:	701a      	strb	r2, [r3, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
   12b0e:	233c      	movs	r3, #60	; 0x3c
   12b10:	18fb      	adds	r3, r7, r3
   12b12:	2201      	movs	r2, #1
   12b14:	705a      	strb	r2, [r3, #1]
	port_pin_set_config(SD_MMC_0_CD_GPIO, &pin_conf);
   12b16:	233c      	movs	r3, #60	; 0x3c
   12b18:	18fb      	adds	r3, r7, r3
   12b1a:	0019      	movs	r1, r3
   12b1c:	202f      	movs	r0, #47	; 0x2f
   12b1e:	4b21      	ldr	r3, [pc, #132]	; (12ba4 <sd_mmc_spi_init+0xb4>)
   12b20:	4798      	blx	r3

	// Initialize SPI interface and enable it
	struct spi_config config;
	spi_get_config_defaults(&config);
   12b22:	1d3b      	adds	r3, r7, #4
   12b24:	0018      	movs	r0, r3
   12b26:	4b20      	ldr	r3, [pc, #128]	; (12ba8 <sd_mmc_spi_init+0xb8>)
   12b28:	4798      	blx	r3

	config.mux_setting = SD_MMC_SPI_PINMUX_SETTING;
   12b2a:	1d3b      	adds	r3, r7, #4
   12b2c:	2280      	movs	r2, #128	; 0x80
   12b2e:	0252      	lsls	r2, r2, #9
   12b30:	60da      	str	r2, [r3, #12]
	config.pinmux_pad0 = SD_MMC_SPI_PINMUX_PAD0;
   12b32:	1d3b      	adds	r3, r7, #4
   12b34:	4a1d      	ldr	r2, [pc, #116]	; (12bac <sd_mmc_spi_init+0xbc>)
   12b36:	629a      	str	r2, [r3, #40]	; 0x28
	config.pinmux_pad1 = SD_MMC_SPI_PINMUX_PAD1;
   12b38:	1d3b      	adds	r3, r7, #4
   12b3a:	2201      	movs	r2, #1
   12b3c:	4252      	negs	r2, r2
   12b3e:	62da      	str	r2, [r3, #44]	; 0x2c
	config.pinmux_pad2 = SD_MMC_SPI_PINMUX_PAD2;
   12b40:	1d3b      	adds	r3, r7, #4
   12b42:	4a1b      	ldr	r2, [pc, #108]	; (12bb0 <sd_mmc_spi_init+0xc0>)
   12b44:	631a      	str	r2, [r3, #48]	; 0x30
	config.pinmux_pad3 = SD_MMC_SPI_PINMUX_PAD3;
   12b46:	1d3b      	adds	r3, r7, #4
   12b48:	4a1a      	ldr	r2, [pc, #104]	; (12bb4 <sd_mmc_spi_init+0xc4>)
   12b4a:	635a      	str	r2, [r3, #52]	; 0x34
	config.generator_source = SD_MMC_SPI_SOURCE_CLOCK;
   12b4c:	1d3b      	adds	r3, r7, #4
   12b4e:	2224      	movs	r2, #36	; 0x24
   12b50:	2100      	movs	r1, #0
   12b52:	5499      	strb	r1, [r3, r2]
	config.mode_specific.master.baudrate = SDMMC_CLOCK_INIT;
   12b54:	1d3b      	adds	r3, r7, #4
   12b56:	4a18      	ldr	r2, [pc, #96]	; (12bb8 <sd_mmc_spi_init+0xc8>)
   12b58:	619a      	str	r2, [r3, #24]

    spi_disable(&sd_mmc_master);
   12b5a:	4b18      	ldr	r3, [pc, #96]	; (12bbc <sd_mmc_spi_init+0xcc>)
   12b5c:	0018      	movs	r0, r3
   12b5e:	4b18      	ldr	r3, [pc, #96]	; (12bc0 <sd_mmc_spi_init+0xd0>)
   12b60:	4798      	blx	r3
	spi_init(&sd_mmc_master, SD_MMC_SPI, &config);
   12b62:	1d3a      	adds	r2, r7, #4
   12b64:	4917      	ldr	r1, [pc, #92]	; (12bc4 <sd_mmc_spi_init+0xd4>)
   12b66:	4b15      	ldr	r3, [pc, #84]	; (12bbc <sd_mmc_spi_init+0xcc>)
   12b68:	0018      	movs	r0, r3
   12b6a:	4b17      	ldr	r3, [pc, #92]	; (12bc8 <sd_mmc_spi_init+0xd8>)
   12b6c:	4798      	blx	r3
	spi_enable(&sd_mmc_master);
   12b6e:	4b13      	ldr	r3, [pc, #76]	; (12bbc <sd_mmc_spi_init+0xcc>)
   12b70:	0018      	movs	r0, r3
   12b72:	4b16      	ldr	r3, [pc, #88]	; (12bcc <sd_mmc_spi_init+0xdc>)
   12b74:	4798      	blx	r3

	spi_slave_inst_get_config_defaults(&slave_configs[0]);
   12b76:	4b16      	ldr	r3, [pc, #88]	; (12bd0 <sd_mmc_spi_init+0xe0>)
   12b78:	0018      	movs	r0, r3
   12b7a:	4b16      	ldr	r3, [pc, #88]	; (12bd4 <sd_mmc_spi_init+0xe4>)
   12b7c:	4798      	blx	r3
	slave_configs[0].ss_pin = ss_pins[0];
   12b7e:	4b16      	ldr	r3, [pc, #88]	; (12bd8 <sd_mmc_spi_init+0xe8>)
   12b80:	781a      	ldrb	r2, [r3, #0]
   12b82:	4b13      	ldr	r3, [pc, #76]	; (12bd0 <sd_mmc_spi_init+0xe0>)
   12b84:	701a      	strb	r2, [r3, #0]
	spi_attach_slave(&sd_mmc_spi_devices[0], &slave_configs[0]);
   12b86:	4a12      	ldr	r2, [pc, #72]	; (12bd0 <sd_mmc_spi_init+0xe0>)
   12b88:	4b14      	ldr	r3, [pc, #80]	; (12bdc <sd_mmc_spi_init+0xec>)
   12b8a:	0011      	movs	r1, r2
   12b8c:	0018      	movs	r0, r3
   12b8e:	4b14      	ldr	r3, [pc, #80]	; (12be0 <sd_mmc_spi_init+0xf0>)
   12b90:	4798      	blx	r3
}
   12b92:	46c0      	nop			; (mov r8, r8)
   12b94:	46bd      	mov	sp, r7
   12b96:	b010      	add	sp, #64	; 0x40
   12b98:	bd80      	pop	{r7, pc}
   12b9a:	46c0      	nop			; (mov r8, r8)
   12b9c:	20002e1f 	.word	0x20002e1f
   12ba0:	000124f9 	.word	0x000124f9
   12ba4:	0001355d 	.word	0x0001355d
   12ba8:	000125ed 	.word	0x000125ed
   12bac:	00100003 	.word	0x00100003
   12bb0:	00120003 	.word	0x00120003
   12bb4:	00130003 	.word	0x00130003
   12bb8:	00061a80 	.word	0x00061a80
   12bbc:	20002ddc 	.word	0x20002ddc
   12bc0:	00012749 	.word	0x00012749
   12bc4:	42001400 	.word	0x42001400
   12bc8:	000148cd 	.word	0x000148cd
   12bcc:	000126f9 	.word	0x000126f9
   12bd0:	20002e1c 	.word	0x20002e1c
   12bd4:	00012671 	.word	0x00012671
   12bd8:	20000050 	.word	0x20000050
   12bdc:	20002e18 	.word	0x20002e18
   12be0:	00012695 	.word	0x00012695

00012be4 <sd_mmc_spi_select_device>:

void sd_mmc_spi_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width,
		bool high_speed)
{
   12be4:	b590      	push	{r4, r7, lr}
   12be6:	b083      	sub	sp, #12
   12be8:	af00      	add	r7, sp, #0
   12bea:	0004      	movs	r4, r0
   12bec:	6039      	str	r1, [r7, #0]
   12bee:	0010      	movs	r0, r2
   12bf0:	0019      	movs	r1, r3
   12bf2:	1dfb      	adds	r3, r7, #7
   12bf4:	1c22      	adds	r2, r4, #0
   12bf6:	701a      	strb	r2, [r3, #0]
   12bf8:	1dbb      	adds	r3, r7, #6
   12bfa:	1c02      	adds	r2, r0, #0
   12bfc:	701a      	strb	r2, [r3, #0]
   12bfe:	1d7b      	adds	r3, r7, #5
   12c00:	1c0a      	adds	r2, r1, #0
   12c02:	701a      	strb	r2, [r3, #0]
	UNUSED(bus_width);
	UNUSED(high_speed);
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   12c04:	4b13      	ldr	r3, [pc, #76]	; (12c54 <sd_mmc_spi_select_device+0x70>)
   12c06:	2200      	movs	r2, #0
   12c08:	701a      	strb	r2, [r3, #0]

#ifdef SD_MMC_SPI_MAX_CLOCK
	if (clock > SD_MMC_SPI_MAX_CLOCK) {
   12c0a:	683b      	ldr	r3, [r7, #0]
   12c0c:	4a12      	ldr	r2, [pc, #72]	; (12c58 <sd_mmc_spi_select_device+0x74>)
   12c0e:	4293      	cmp	r3, r2
   12c10:	d907      	bls.n	12c22 <sd_mmc_spi_select_device+0x3e>
		clock = SD_MMC_SPI_MAX_CLOCK;
   12c12:	4b11      	ldr	r3, [pc, #68]	; (12c58 <sd_mmc_spi_select_device+0x74>)
   12c14:	603b      	str	r3, [r7, #0]
	}
#endif
	while (STATUS_ERR_INVALID_ARG == spi_set_baudrate(&sd_mmc_master, clock)) {
   12c16:	e004      	b.n	12c22 <sd_mmc_spi_select_device+0x3e>
		clock -= clock / 8;
   12c18:	683b      	ldr	r3, [r7, #0]
   12c1a:	08db      	lsrs	r3, r3, #3
   12c1c:	683a      	ldr	r2, [r7, #0]
   12c1e:	1ad3      	subs	r3, r2, r3
   12c20:	603b      	str	r3, [r7, #0]
#ifdef SD_MMC_SPI_MAX_CLOCK
	if (clock > SD_MMC_SPI_MAX_CLOCK) {
		clock = SD_MMC_SPI_MAX_CLOCK;
	}
#endif
	while (STATUS_ERR_INVALID_ARG == spi_set_baudrate(&sd_mmc_master, clock)) {
   12c22:	683a      	ldr	r2, [r7, #0]
   12c24:	4b0d      	ldr	r3, [pc, #52]	; (12c5c <sd_mmc_spi_select_device+0x78>)
   12c26:	0011      	movs	r1, r2
   12c28:	0018      	movs	r0, r3
   12c2a:	4b0d      	ldr	r3, [pc, #52]	; (12c60 <sd_mmc_spi_select_device+0x7c>)
   12c2c:	4798      	blx	r3
   12c2e:	1e03      	subs	r3, r0, #0
   12c30:	2b17      	cmp	r3, #23
   12c32:	d0f1      	beq.n	12c18 <sd_mmc_spi_select_device+0x34>
		clock -= clock / 8;
	}
	spi_select_slave(&sd_mmc_master, &sd_mmc_spi_devices[slot], true);
   12c34:	1dfb      	adds	r3, r7, #7
   12c36:	781a      	ldrb	r2, [r3, #0]
   12c38:	0013      	movs	r3, r2
   12c3a:	005b      	lsls	r3, r3, #1
   12c3c:	189b      	adds	r3, r3, r2
   12c3e:	4a09      	ldr	r2, [pc, #36]	; (12c64 <sd_mmc_spi_select_device+0x80>)
   12c40:	1899      	adds	r1, r3, r2
   12c42:	4b06      	ldr	r3, [pc, #24]	; (12c5c <sd_mmc_spi_select_device+0x78>)
   12c44:	2201      	movs	r2, #1
   12c46:	0018      	movs	r0, r3
   12c48:	4b07      	ldr	r3, [pc, #28]	; (12c68 <sd_mmc_spi_select_device+0x84>)
   12c4a:	4798      	blx	r3
}
   12c4c:	46c0      	nop			; (mov r8, r8)
   12c4e:	46bd      	mov	sp, r7
   12c50:	b003      	add	sp, #12
   12c52:	bd90      	pop	{r4, r7, pc}
   12c54:	20002e1f 	.word	0x20002e1f
   12c58:	00b71b00 	.word	0x00b71b00
   12c5c:	20002ddc 	.word	0x20002ddc
   12c60:	000145f5 	.word	0x000145f5
   12c64:	20002e18 	.word	0x20002e18
   12c68:	00014c41 	.word	0x00014c41

00012c6c <sd_mmc_spi_deselect_device>:

void sd_mmc_spi_deselect_device(uint8_t slot)
{
   12c6c:	b580      	push	{r7, lr}
   12c6e:	b082      	sub	sp, #8
   12c70:	af00      	add	r7, sp, #0
   12c72:	0002      	movs	r2, r0
   12c74:	1dfb      	adds	r3, r7, #7
   12c76:	701a      	strb	r2, [r3, #0]
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   12c78:	4b09      	ldr	r3, [pc, #36]	; (12ca0 <sd_mmc_spi_deselect_device+0x34>)
   12c7a:	2200      	movs	r2, #0
   12c7c:	701a      	strb	r2, [r3, #0]
	spi_select_slave(&sd_mmc_master, &sd_mmc_spi_devices[slot], false);
   12c7e:	1dfb      	adds	r3, r7, #7
   12c80:	781a      	ldrb	r2, [r3, #0]
   12c82:	0013      	movs	r3, r2
   12c84:	005b      	lsls	r3, r3, #1
   12c86:	189b      	adds	r3, r3, r2
   12c88:	4a06      	ldr	r2, [pc, #24]	; (12ca4 <sd_mmc_spi_deselect_device+0x38>)
   12c8a:	1899      	adds	r1, r3, r2
   12c8c:	4b06      	ldr	r3, [pc, #24]	; (12ca8 <sd_mmc_spi_deselect_device+0x3c>)
   12c8e:	2200      	movs	r2, #0
   12c90:	0018      	movs	r0, r3
   12c92:	4b06      	ldr	r3, [pc, #24]	; (12cac <sd_mmc_spi_deselect_device+0x40>)
   12c94:	4798      	blx	r3
}
   12c96:	46c0      	nop			; (mov r8, r8)
   12c98:	46bd      	mov	sp, r7
   12c9a:	b002      	add	sp, #8
   12c9c:	bd80      	pop	{r7, pc}
   12c9e:	46c0      	nop			; (mov r8, r8)
   12ca0:	20002e1f 	.word	0x20002e1f
   12ca4:	20002e18 	.word	0x20002e18
   12ca8:	20002ddc 	.word	0x20002ddc
   12cac:	00014c41 	.word	0x00014c41

00012cb0 <sd_mmc_spi_send_clock>:

void sd_mmc_spi_send_clock(void)
{
   12cb0:	b580      	push	{r7, lr}
   12cb2:	b082      	sub	sp, #8
   12cb4:	af00      	add	r7, sp, #0
	uint8_t i;
	uint8_t dummy = 0xFF;
   12cb6:	1dbb      	adds	r3, r7, #6
   12cb8:	22ff      	movs	r2, #255	; 0xff
   12cba:	701a      	strb	r2, [r3, #0]

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   12cbc:	4b0c      	ldr	r3, [pc, #48]	; (12cf0 <sd_mmc_spi_send_clock+0x40>)
   12cbe:	2200      	movs	r2, #0
   12cc0:	701a      	strb	r2, [r3, #0]
	//! Send 80 cycles
	for (i = 0; i < 10; i++) {
   12cc2:	1dfb      	adds	r3, r7, #7
   12cc4:	2200      	movs	r2, #0
   12cc6:	701a      	strb	r2, [r3, #0]
   12cc8:	e00a      	b.n	12ce0 <sd_mmc_spi_send_clock+0x30>
		spi_write_buffer_wait(&sd_mmc_master, &dummy, 1); // 8 cycles
   12cca:	1db9      	adds	r1, r7, #6
   12ccc:	4b09      	ldr	r3, [pc, #36]	; (12cf4 <sd_mmc_spi_send_clock+0x44>)
   12cce:	2201      	movs	r2, #1
   12cd0:	0018      	movs	r0, r3
   12cd2:	4b09      	ldr	r3, [pc, #36]	; (12cf8 <sd_mmc_spi_send_clock+0x48>)
   12cd4:	4798      	blx	r3
	uint8_t i;
	uint8_t dummy = 0xFF;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
	//! Send 80 cycles
	for (i = 0; i < 10; i++) {
   12cd6:	1dfb      	adds	r3, r7, #7
   12cd8:	781a      	ldrb	r2, [r3, #0]
   12cda:	1dfb      	adds	r3, r7, #7
   12cdc:	3201      	adds	r2, #1
   12cde:	701a      	strb	r2, [r3, #0]
   12ce0:	1dfb      	adds	r3, r7, #7
   12ce2:	781b      	ldrb	r3, [r3, #0]
   12ce4:	2b09      	cmp	r3, #9
   12ce6:	d9f0      	bls.n	12cca <sd_mmc_spi_send_clock+0x1a>
		spi_write_buffer_wait(&sd_mmc_master, &dummy, 1); // 8 cycles
	}
}
   12ce8:	46c0      	nop			; (mov r8, r8)
   12cea:	46bd      	mov	sp, r7
   12cec:	b002      	add	sp, #8
   12cee:	bd80      	pop	{r7, pc}
   12cf0:	20002e1f 	.word	0x20002e1f
   12cf4:	20002ddc 	.word	0x20002ddc
   12cf8:	00014d31 	.word	0x00014d31

00012cfc <sd_mmc_spi_send_cmd>:

bool sd_mmc_spi_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
   12cfc:	b590      	push	{r4, r7, lr}
   12cfe:	b085      	sub	sp, #20
   12d00:	af02      	add	r7, sp, #8
   12d02:	6078      	str	r0, [r7, #4]
   12d04:	6039      	str	r1, [r7, #0]
	return sd_mmc_spi_adtc_start(cmd, arg, 0, 0, false);
   12d06:	6839      	ldr	r1, [r7, #0]
   12d08:	6878      	ldr	r0, [r7, #4]
   12d0a:	2300      	movs	r3, #0
   12d0c:	9300      	str	r3, [sp, #0]
   12d0e:	2300      	movs	r3, #0
   12d10:	2200      	movs	r2, #0
   12d12:	4c03      	ldr	r4, [pc, #12]	; (12d20 <sd_mmc_spi_send_cmd+0x24>)
   12d14:	47a0      	blx	r4
   12d16:	0003      	movs	r3, r0
}
   12d18:	0018      	movs	r0, r3
   12d1a:	46bd      	mov	sp, r7
   12d1c:	b003      	add	sp, #12
   12d1e:	bd90      	pop	{r4, r7, pc}
   12d20:	00012d25 	.word	0x00012d25

00012d24 <sd_mmc_spi_adtc_start>:

bool sd_mmc_spi_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg,
		uint16_t block_size, uint16_t nb_block, bool access_block)
{
   12d24:	b590      	push	{r4, r7, lr}
   12d26:	b089      	sub	sp, #36	; 0x24
   12d28:	af00      	add	r7, sp, #0
   12d2a:	60f8      	str	r0, [r7, #12]
   12d2c:	60b9      	str	r1, [r7, #8]
   12d2e:	0019      	movs	r1, r3
   12d30:	1dbb      	adds	r3, r7, #6
   12d32:	801a      	strh	r2, [r3, #0]
   12d34:	1d3b      	adds	r3, r7, #4
   12d36:	1c0a      	adds	r2, r1, #0
   12d38:	801a      	strh	r2, [r3, #0]
	uint8_t dummy = 0xFF;
   12d3a:	231b      	movs	r3, #27
   12d3c:	18fb      	adds	r3, r7, r3
   12d3e:	22ff      	movs	r2, #255	; 0xff
   12d40:	701a      	strb	r2, [r3, #0]
	uint8_t cmd_token[6];
	uint8_t ncr_timeout;
	uint8_t r1; //! R1 response
	uint16_t dummy2 = 0xFF;
   12d42:	231c      	movs	r3, #28
   12d44:	18fb      	adds	r3, r7, r3
   12d46:	22ff      	movs	r2, #255	; 0xff
   12d48:	801a      	strh	r2, [r3, #0]

	UNUSED(access_block);
	Assert(cmd & SDMMC_RESP_PRESENT); // Always a response in SPI mode
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   12d4a:	4b72      	ldr	r3, [pc, #456]	; (12f14 <sd_mmc_spi_adtc_start+0x1f0>)
   12d4c:	2200      	movs	r2, #0
   12d4e:	701a      	strb	r2, [r3, #0]

	// Encode SPI command
	cmd_token[0] = SPI_CMD_ENCODE(SDMMC_CMD_GET_INDEX(cmd));
   12d50:	68fb      	ldr	r3, [r7, #12]
   12d52:	b2db      	uxtb	r3, r3
   12d54:	223f      	movs	r2, #63	; 0x3f
   12d56:	4013      	ands	r3, r2
   12d58:	b2db      	uxtb	r3, r3
   12d5a:	2240      	movs	r2, #64	; 0x40
   12d5c:	4313      	orrs	r3, r2
   12d5e:	b2da      	uxtb	r2, r3
   12d60:	2314      	movs	r3, #20
   12d62:	18fb      	adds	r3, r7, r3
   12d64:	701a      	strb	r2, [r3, #0]
	cmd_token[1] = arg >> 24;
   12d66:	68bb      	ldr	r3, [r7, #8]
   12d68:	0e1b      	lsrs	r3, r3, #24
   12d6a:	b2da      	uxtb	r2, r3
   12d6c:	2314      	movs	r3, #20
   12d6e:	18fb      	adds	r3, r7, r3
   12d70:	705a      	strb	r2, [r3, #1]
	cmd_token[2] = arg >> 16;
   12d72:	68bb      	ldr	r3, [r7, #8]
   12d74:	0c1b      	lsrs	r3, r3, #16
   12d76:	b2da      	uxtb	r2, r3
   12d78:	2314      	movs	r3, #20
   12d7a:	18fb      	adds	r3, r7, r3
   12d7c:	709a      	strb	r2, [r3, #2]
	cmd_token[3] = arg >> 8;
   12d7e:	68bb      	ldr	r3, [r7, #8]
   12d80:	0a1b      	lsrs	r3, r3, #8
   12d82:	b2da      	uxtb	r2, r3
   12d84:	2314      	movs	r3, #20
   12d86:	18fb      	adds	r3, r7, r3
   12d88:	70da      	strb	r2, [r3, #3]
	cmd_token[4] = arg;
   12d8a:	68bb      	ldr	r3, [r7, #8]
   12d8c:	b2da      	uxtb	r2, r3
   12d8e:	2314      	movs	r3, #20
   12d90:	18fb      	adds	r3, r7, r3
   12d92:	711a      	strb	r2, [r3, #4]
	cmd_token[5] = sd_mmc_spi_crc7(cmd_token, 5);
   12d94:	2314      	movs	r3, #20
   12d96:	18fb      	adds	r3, r7, r3
   12d98:	2105      	movs	r1, #5
   12d9a:	0018      	movs	r0, r3
   12d9c:	4b5e      	ldr	r3, [pc, #376]	; (12f18 <sd_mmc_spi_adtc_start+0x1f4>)
   12d9e:	4798      	blx	r3
   12da0:	0003      	movs	r3, r0
   12da2:	001a      	movs	r2, r3
   12da4:	2314      	movs	r3, #20
   12da6:	18fb      	adds	r3, r7, r3
   12da8:	715a      	strb	r2, [r3, #5]

	// 8 cycles to respect Ncs timing
	// Note: This byte does not include start bit "0",
	// thus it is ignored by card.
	spi_write_buffer_wait(&sd_mmc_master, &dummy, 1);
   12daa:	231b      	movs	r3, #27
   12dac:	18f9      	adds	r1, r7, r3
   12dae:	4b5b      	ldr	r3, [pc, #364]	; (12f1c <sd_mmc_spi_adtc_start+0x1f8>)
   12db0:	2201      	movs	r2, #1
   12db2:	0018      	movs	r0, r3
   12db4:	4b5a      	ldr	r3, [pc, #360]	; (12f20 <sd_mmc_spi_adtc_start+0x1fc>)
   12db6:	4798      	blx	r3
	// Send command
	spi_write_buffer_wait(&sd_mmc_master, cmd_token, sizeof(cmd_token));
   12db8:	2314      	movs	r3, #20
   12dba:	18f9      	adds	r1, r7, r3
   12dbc:	4b57      	ldr	r3, [pc, #348]	; (12f1c <sd_mmc_spi_adtc_start+0x1f8>)
   12dbe:	2206      	movs	r2, #6
   12dc0:	0018      	movs	r0, r3
   12dc2:	4b57      	ldr	r3, [pc, #348]	; (12f20 <sd_mmc_spi_adtc_start+0x1fc>)
   12dc4:	4798      	blx	r3

	// Wait for response
	// Two retry will be done to manage the Ncr timing between command and reponse
	// Ncr: Min. 1x8 clock  cycle, Max. 8x8 clock cycles
	// WORKAROUND for no compliance card (Atmel Internal ref. SD13):
	r1 = 0xFF;
   12dc6:	2313      	movs	r3, #19
   12dc8:	18fb      	adds	r3, r7, r3
   12dca:	22ff      	movs	r2, #255	; 0xff
   12dcc:	701a      	strb	r2, [r3, #0]
	// Ignore first byte because Ncr min. = 8 clock cylces
	spi_read_buffer_wait(&sd_mmc_master, &r1, 1,
   12dce:	231c      	movs	r3, #28
   12dd0:	18fb      	adds	r3, r7, r3
   12dd2:	881b      	ldrh	r3, [r3, #0]
   12dd4:	2213      	movs	r2, #19
   12dd6:	18b9      	adds	r1, r7, r2
   12dd8:	4850      	ldr	r0, [pc, #320]	; (12f1c <sd_mmc_spi_adtc_start+0x1f8>)
   12dda:	2201      	movs	r2, #1
   12ddc:	4c51      	ldr	r4, [pc, #324]	; (12f24 <sd_mmc_spi_adtc_start+0x200>)
   12dde:	47a0      	blx	r4
			dummy2);
	ncr_timeout = 7;
   12de0:	231f      	movs	r3, #31
   12de2:	18fb      	adds	r3, r7, r3
   12de4:	2207      	movs	r2, #7
   12de6:	701a      	strb	r2, [r3, #0]
	while (1) {
		spi_read_buffer_wait(&sd_mmc_master, &r1, 1,
   12de8:	231c      	movs	r3, #28
   12dea:	18fb      	adds	r3, r7, r3
   12dec:	881b      	ldrh	r3, [r3, #0]
   12dee:	2213      	movs	r2, #19
   12df0:	18b9      	adds	r1, r7, r2
   12df2:	484a      	ldr	r0, [pc, #296]	; (12f1c <sd_mmc_spi_adtc_start+0x1f8>)
   12df4:	2201      	movs	r2, #1
   12df6:	4c4b      	ldr	r4, [pc, #300]	; (12f24 <sd_mmc_spi_adtc_start+0x200>)
   12df8:	47a0      	blx	r4
			dummy2); // 8 cycles
		if ((r1 & R1_SPI_ERROR) == 0) {
   12dfa:	2313      	movs	r3, #19
   12dfc:	18fb      	adds	r3, r7, r3
   12dfe:	781b      	ldrb	r3, [r3, #0]
   12e00:	b25b      	sxtb	r3, r3
   12e02:	2b00      	cmp	r3, #0
   12e04:	da10      	bge.n	12e28 <sd_mmc_spi_adtc_start+0x104>
			// Valid R1 response
			break;
		}
		if (--ncr_timeout == 0) {
   12e06:	231f      	movs	r3, #31
   12e08:	18fb      	adds	r3, r7, r3
   12e0a:	221f      	movs	r2, #31
   12e0c:	18ba      	adds	r2, r7, r2
   12e0e:	7812      	ldrb	r2, [r2, #0]
   12e10:	3a01      	subs	r2, #1
   12e12:	701a      	strb	r2, [r3, #0]
   12e14:	231f      	movs	r3, #31
   12e16:	18fb      	adds	r3, r7, r3
   12e18:	781b      	ldrb	r3, [r3, #0]
   12e1a:	2b00      	cmp	r3, #0
   12e1c:	d1e4      	bne.n	12de8 <sd_mmc_spi_adtc_start+0xc4>
			// Here Valid R1 response received
			sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lX, R1 timeout\n\r",
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg);
			sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_TIMEOUT;
   12e1e:	4b3d      	ldr	r3, [pc, #244]	; (12f14 <sd_mmc_spi_adtc_start+0x1f0>)
   12e20:	2202      	movs	r2, #2
   12e22:	701a      	strb	r2, [r3, #0]
			return false;
   12e24:	2300      	movs	r3, #0
   12e26:	e070      	b.n	12f0a <sd_mmc_spi_adtc_start+0x1e6>
	while (1) {
		spi_read_buffer_wait(&sd_mmc_master, &r1, 1,
			dummy2); // 8 cycles
		if ((r1 & R1_SPI_ERROR) == 0) {
			// Valid R1 response
			break;
   12e28:	46c0      	nop			; (mov r8, r8)
		}
	}

	// Save R1 (Specific to SPI interface) in 32 bit response
	// The R1_SPI_IDLE bit can be checked by high level
	sd_mmc_spi_response_32 = r1;
   12e2a:	2313      	movs	r3, #19
   12e2c:	18fb      	adds	r3, r7, r3
   12e2e:	781b      	ldrb	r3, [r3, #0]
   12e30:	001a      	movs	r2, r3
   12e32:	4b3d      	ldr	r3, [pc, #244]	; (12f28 <sd_mmc_spi_adtc_start+0x204>)
   12e34:	601a      	str	r2, [r3, #0]

	// Manage error in R1
	if (r1 & R1_SPI_COM_CRC) {
   12e36:	2313      	movs	r3, #19
   12e38:	18fb      	adds	r3, r7, r3
   12e3a:	781b      	ldrb	r3, [r3, #0]
   12e3c:	001a      	movs	r2, r3
   12e3e:	2308      	movs	r3, #8
   12e40:	4013      	ands	r3, r2
   12e42:	d004      	beq.n	12e4e <sd_mmc_spi_adtc_start+0x12a>
		sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lx, r1 0x%02x, R1_SPI_COM_CRC\n\r",
				__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg, r1);
		sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_CRC;
   12e44:	4b33      	ldr	r3, [pc, #204]	; (12f14 <sd_mmc_spi_adtc_start+0x1f0>)
   12e46:	2206      	movs	r2, #6
   12e48:	701a      	strb	r2, [r3, #0]
		return false;
   12e4a:	2300      	movs	r3, #0
   12e4c:	e05d      	b.n	12f0a <sd_mmc_spi_adtc_start+0x1e6>
	}
	if (r1 & R1_SPI_ILLEGAL_COMMAND) {
   12e4e:	2313      	movs	r3, #19
   12e50:	18fb      	adds	r3, r7, r3
   12e52:	781b      	ldrb	r3, [r3, #0]
   12e54:	001a      	movs	r2, r3
   12e56:	2304      	movs	r3, #4
   12e58:	4013      	ands	r3, r2
   12e5a:	d004      	beq.n	12e66 <sd_mmc_spi_adtc_start+0x142>
		sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lx, r1 0x%x, R1 ILLEGAL_COMMAND\n\r",
				__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg, r1);
		sd_mmc_spi_err = SD_MMC_SPI_ERR_ILLEGAL_COMMAND;
   12e5c:	4b2d      	ldr	r3, [pc, #180]	; (12f14 <sd_mmc_spi_adtc_start+0x1f0>)
   12e5e:	2209      	movs	r2, #9
   12e60:	701a      	strb	r2, [r3, #0]
		return false;
   12e62:	2300      	movs	r3, #0
   12e64:	e051      	b.n	12f0a <sd_mmc_spi_adtc_start+0x1e6>
	}
	if (r1 & ~R1_SPI_IDLE) {
   12e66:	2313      	movs	r3, #19
   12e68:	18fb      	adds	r3, r7, r3
   12e6a:	781b      	ldrb	r3, [r3, #0]
   12e6c:	001a      	movs	r2, r3
   12e6e:	2301      	movs	r3, #1
   12e70:	439a      	bics	r2, r3
   12e72:	1e13      	subs	r3, r2, #0
   12e74:	d004      	beq.n	12e80 <sd_mmc_spi_adtc_start+0x15c>
		// Other error
		sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lx, r1 0x%x, R1 error\n\r",
				__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg, r1);
		sd_mmc_spi_err = SD_MMC_SPI_ERR;
   12e76:	4b27      	ldr	r3, [pc, #156]	; (12f14 <sd_mmc_spi_adtc_start+0x1f0>)
   12e78:	2201      	movs	r2, #1
   12e7a:	701a      	strb	r2, [r3, #0]
		return false;
   12e7c:	2300      	movs	r3, #0
   12e7e:	e044      	b.n	12f0a <sd_mmc_spi_adtc_start+0x1e6>
	}

	// Manage other responses
	if (cmd & SDMMC_RESP_BUSY) {
   12e80:	68fa      	ldr	r2, [r7, #12]
   12e82:	2380      	movs	r3, #128	; 0x80
   12e84:	019b      	lsls	r3, r3, #6
   12e86:	4013      	ands	r3, r2
   12e88:	d00d      	beq.n	12ea6 <sd_mmc_spi_adtc_start+0x182>
		if (!sd_mmc_spi_wait_busy()) {
   12e8a:	4b28      	ldr	r3, [pc, #160]	; (12f2c <sd_mmc_spi_adtc_start+0x208>)
   12e8c:	4798      	blx	r3
   12e8e:	0003      	movs	r3, r0
   12e90:	001a      	movs	r2, r3
   12e92:	2301      	movs	r3, #1
   12e94:	4053      	eors	r3, r2
   12e96:	b2db      	uxtb	r3, r3
   12e98:	2b00      	cmp	r3, #0
   12e9a:	d004      	beq.n	12ea6 <sd_mmc_spi_adtc_start+0x182>
			sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_BUSY_TIMEOUT;
   12e9c:	4b1d      	ldr	r3, [pc, #116]	; (12f14 <sd_mmc_spi_adtc_start+0x1f0>)
   12e9e:	2203      	movs	r2, #3
   12ea0:	701a      	strb	r2, [r3, #0]
			sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lx, Busy signal always high\n\r",
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg);
			return false;
   12ea2:	2300      	movs	r3, #0
   12ea4:	e031      	b.n	12f0a <sd_mmc_spi_adtc_start+0x1e6>
		}
	}
	if (cmd & SDMMC_RESP_8) {
   12ea6:	68fa      	ldr	r2, [r7, #12]
   12ea8:	2380      	movs	r3, #128	; 0x80
   12eaa:	009b      	lsls	r3, r3, #2
   12eac:	4013      	ands	r3, r2
   12eae:	d00e      	beq.n	12ece <sd_mmc_spi_adtc_start+0x1aa>
		sd_mmc_spi_response_32 = 0;
   12eb0:	4b1d      	ldr	r3, [pc, #116]	; (12f28 <sd_mmc_spi_adtc_start+0x204>)
   12eb2:	2200      	movs	r2, #0
   12eb4:	601a      	str	r2, [r3, #0]
		spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&sd_mmc_spi_response_32, 1,
   12eb6:	231c      	movs	r3, #28
   12eb8:	18fb      	adds	r3, r7, r3
   12eba:	881b      	ldrh	r3, [r3, #0]
   12ebc:	491a      	ldr	r1, [pc, #104]	; (12f28 <sd_mmc_spi_adtc_start+0x204>)
   12ebe:	4817      	ldr	r0, [pc, #92]	; (12f1c <sd_mmc_spi_adtc_start+0x1f8>)
   12ec0:	2201      	movs	r2, #1
   12ec2:	4c18      	ldr	r4, [pc, #96]	; (12f24 <sd_mmc_spi_adtc_start+0x200>)
   12ec4:	47a0      	blx	r4
			dummy2);
		sd_mmc_spi_response_32 = le32_to_cpu(sd_mmc_spi_response_32);
   12ec6:	4b18      	ldr	r3, [pc, #96]	; (12f28 <sd_mmc_spi_adtc_start+0x204>)
   12ec8:	681a      	ldr	r2, [r3, #0]
   12eca:	4b17      	ldr	r3, [pc, #92]	; (12f28 <sd_mmc_spi_adtc_start+0x204>)
   12ecc:	601a      	str	r2, [r3, #0]
	}
	if (cmd & SDMMC_RESP_32) {
   12ece:	68fa      	ldr	r2, [r7, #12]
   12ed0:	2380      	movs	r3, #128	; 0x80
   12ed2:	00db      	lsls	r3, r3, #3
   12ed4:	4013      	ands	r3, r2
   12ed6:	d00c      	beq.n	12ef2 <sd_mmc_spi_adtc_start+0x1ce>
		spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&sd_mmc_spi_response_32, 4,
   12ed8:	231c      	movs	r3, #28
   12eda:	18fb      	adds	r3, r7, r3
   12edc:	881b      	ldrh	r3, [r3, #0]
   12ede:	4912      	ldr	r1, [pc, #72]	; (12f28 <sd_mmc_spi_adtc_start+0x204>)
   12ee0:	480e      	ldr	r0, [pc, #56]	; (12f1c <sd_mmc_spi_adtc_start+0x1f8>)
   12ee2:	2204      	movs	r2, #4
   12ee4:	4c0f      	ldr	r4, [pc, #60]	; (12f24 <sd_mmc_spi_adtc_start+0x200>)
   12ee6:	47a0      	blx	r4
			dummy2);
		sd_mmc_spi_response_32 = be32_to_cpu(sd_mmc_spi_response_32);
   12ee8:	4b0f      	ldr	r3, [pc, #60]	; (12f28 <sd_mmc_spi_adtc_start+0x204>)
   12eea:	681b      	ldr	r3, [r3, #0]
   12eec:	ba1a      	rev	r2, r3
   12eee:	4b0e      	ldr	r3, [pc, #56]	; (12f28 <sd_mmc_spi_adtc_start+0x204>)
   12ef0:	601a      	str	r2, [r3, #0]
	}

	sd_mmc_spi_block_size = block_size;
   12ef2:	4b0f      	ldr	r3, [pc, #60]	; (12f30 <sd_mmc_spi_adtc_start+0x20c>)
   12ef4:	1dba      	adds	r2, r7, #6
   12ef6:	8812      	ldrh	r2, [r2, #0]
   12ef8:	801a      	strh	r2, [r3, #0]
	sd_mmc_spi_nb_block = nb_block;
   12efa:	4b0e      	ldr	r3, [pc, #56]	; (12f34 <sd_mmc_spi_adtc_start+0x210>)
   12efc:	1d3a      	adds	r2, r7, #4
   12efe:	8812      	ldrh	r2, [r2, #0]
   12f00:	801a      	strh	r2, [r3, #0]
	sd_mmc_spi_transfert_pos = 0;
   12f02:	4b0d      	ldr	r3, [pc, #52]	; (12f38 <sd_mmc_spi_adtc_start+0x214>)
   12f04:	2200      	movs	r2, #0
   12f06:	601a      	str	r2, [r3, #0]
	return true; // Command complete
   12f08:	2301      	movs	r3, #1
}
   12f0a:	0018      	movs	r0, r3
   12f0c:	46bd      	mov	sp, r7
   12f0e:	b009      	add	sp, #36	; 0x24
   12f10:	bd90      	pop	{r4, r7, pc}
   12f12:	46c0      	nop			; (mov r8, r8)
   12f14:	20002e1f 	.word	0x20002e1f
   12f18:	00012799 	.word	0x00012799
   12f1c:	20002ddc 	.word	0x20002ddc
   12f20:	00014d31 	.word	0x00014d31
   12f24:	00014a5d 	.word	0x00014a5d
   12f28:	20002e20 	.word	0x20002e20
   12f2c:	00012855 	.word	0x00012855
   12f30:	20002e28 	.word	0x20002e28
   12f34:	20002e2a 	.word	0x20002e2a
   12f38:	20002e24 	.word	0x20002e24

00012f3c <sd_mmc_spi_get_response>:

uint32_t sd_mmc_spi_get_response(void)
{
   12f3c:	b580      	push	{r7, lr}
   12f3e:	af00      	add	r7, sp, #0
	return sd_mmc_spi_response_32;
   12f40:	4b02      	ldr	r3, [pc, #8]	; (12f4c <sd_mmc_spi_get_response+0x10>)
   12f42:	681b      	ldr	r3, [r3, #0]
}
   12f44:	0018      	movs	r0, r3
   12f46:	46bd      	mov	sp, r7
   12f48:	bd80      	pop	{r7, pc}
   12f4a:	46c0      	nop			; (mov r8, r8)
   12f4c:	20002e20 	.word	0x20002e20

00012f50 <sd_mmc_spi_read_word>:

bool sd_mmc_spi_read_word(uint32_t* value)
{
   12f50:	b590      	push	{r4, r7, lr}
   12f52:	b085      	sub	sp, #20
   12f54:	af00      	add	r7, sp, #0
   12f56:	6078      	str	r0, [r7, #4]
	uint16_t dummy = 0xFF;
   12f58:	230e      	movs	r3, #14
   12f5a:	18fb      	adds	r3, r7, r3
   12f5c:	22ff      	movs	r2, #255	; 0xff
   12f5e:	801a      	strh	r2, [r3, #0]

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   12f60:	4b1c      	ldr	r3, [pc, #112]	; (12fd4 <sd_mmc_spi_read_word+0x84>)
   12f62:	2200      	movs	r2, #0
   12f64:	701a      	strb	r2, [r3, #0]
	Assert(sd_mmc_spi_nb_block >
			(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size));

	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
   12f66:	4b1c      	ldr	r3, [pc, #112]	; (12fd8 <sd_mmc_spi_read_word+0x88>)
   12f68:	681a      	ldr	r2, [r3, #0]
   12f6a:	4b1c      	ldr	r3, [pc, #112]	; (12fdc <sd_mmc_spi_read_word+0x8c>)
   12f6c:	881b      	ldrh	r3, [r3, #0]
   12f6e:	0019      	movs	r1, r3
   12f70:	4b1b      	ldr	r3, [pc, #108]	; (12fe0 <sd_mmc_spi_read_word+0x90>)
   12f72:	0010      	movs	r0, r2
   12f74:	4798      	blx	r3
   12f76:	1e0b      	subs	r3, r1, #0
   12f78:	d10a      	bne.n	12f90 <sd_mmc_spi_read_word+0x40>
		// New block
		if (!sd_mmc_spi_start_read_block()) {
   12f7a:	4b1a      	ldr	r3, [pc, #104]	; (12fe4 <sd_mmc_spi_read_word+0x94>)
   12f7c:	4798      	blx	r3
   12f7e:	0003      	movs	r3, r0
   12f80:	001a      	movs	r2, r3
   12f82:	2301      	movs	r3, #1
   12f84:	4053      	eors	r3, r2
   12f86:	b2db      	uxtb	r3, r3
   12f88:	2b00      	cmp	r3, #0
   12f8a:	d001      	beq.n	12f90 <sd_mmc_spi_read_word+0x40>
			return false;
   12f8c:	2300      	movs	r3, #0
   12f8e:	e01d      	b.n	12fcc <sd_mmc_spi_read_word+0x7c>
		}
	}
	// Read data
	spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&value, 4,
   12f90:	230e      	movs	r3, #14
   12f92:	18fb      	adds	r3, r7, r3
   12f94:	881b      	ldrh	r3, [r3, #0]
   12f96:	1d39      	adds	r1, r7, #4
   12f98:	4813      	ldr	r0, [pc, #76]	; (12fe8 <sd_mmc_spi_read_word+0x98>)
   12f9a:	2204      	movs	r2, #4
   12f9c:	4c13      	ldr	r4, [pc, #76]	; (12fec <sd_mmc_spi_read_word+0x9c>)
   12f9e:	47a0      	blx	r4
			dummy);
	*value = le32_to_cpu(*value);
   12fa0:	687b      	ldr	r3, [r7, #4]
   12fa2:	687a      	ldr	r2, [r7, #4]
   12fa4:	6812      	ldr	r2, [r2, #0]
   12fa6:	601a      	str	r2, [r3, #0]
	sd_mmc_spi_transfert_pos += 4;
   12fa8:	4b0b      	ldr	r3, [pc, #44]	; (12fd8 <sd_mmc_spi_read_word+0x88>)
   12faa:	681b      	ldr	r3, [r3, #0]
   12fac:	1d1a      	adds	r2, r3, #4
   12fae:	4b0a      	ldr	r3, [pc, #40]	; (12fd8 <sd_mmc_spi_read_word+0x88>)
   12fb0:	601a      	str	r2, [r3, #0]

	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
   12fb2:	4b09      	ldr	r3, [pc, #36]	; (12fd8 <sd_mmc_spi_read_word+0x88>)
   12fb4:	681a      	ldr	r2, [r3, #0]
   12fb6:	4b09      	ldr	r3, [pc, #36]	; (12fdc <sd_mmc_spi_read_word+0x8c>)
   12fb8:	881b      	ldrh	r3, [r3, #0]
   12fba:	0019      	movs	r1, r3
   12fbc:	4b08      	ldr	r3, [pc, #32]	; (12fe0 <sd_mmc_spi_read_word+0x90>)
   12fbe:	0010      	movs	r0, r2
   12fc0:	4798      	blx	r3
   12fc2:	1e0b      	subs	r3, r1, #0
   12fc4:	d101      	bne.n	12fca <sd_mmc_spi_read_word+0x7a>
		// End of block
		sd_mmc_spi_stop_read_block();
   12fc6:	4b0a      	ldr	r3, [pc, #40]	; (12ff0 <sd_mmc_spi_read_word+0xa0>)
   12fc8:	4798      	blx	r3
	}
	return true;
   12fca:	2301      	movs	r3, #1
}
   12fcc:	0018      	movs	r0, r3
   12fce:	46bd      	mov	sp, r7
   12fd0:	b005      	add	sp, #20
   12fd2:	bd90      	pop	{r4, r7, pc}
   12fd4:	20002e1f 	.word	0x20002e1f
   12fd8:	20002e24 	.word	0x20002e24
   12fdc:	20002e28 	.word	0x20002e28
   12fe0:	0001d591 	.word	0x0001d591
   12fe4:	000128c1 	.word	0x000128c1
   12fe8:	20002ddc 	.word	0x20002ddc
   12fec:	00014a5d 	.word	0x00014a5d
   12ff0:	00012945 	.word	0x00012945

00012ff4 <sd_mmc_spi_start_read_blocks>:
	}
	return sd_mmc_spi_stop_multiwrite_block();
}

bool sd_mmc_spi_start_read_blocks(void *dest, uint16_t nb_block)
{
   12ff4:	b590      	push	{r4, r7, lr}
   12ff6:	b085      	sub	sp, #20
   12ff8:	af00      	add	r7, sp, #0
   12ffa:	6078      	str	r0, [r7, #4]
   12ffc:	000a      	movs	r2, r1
   12ffe:	1cbb      	adds	r3, r7, #2
   13000:	801a      	strh	r2, [r3, #0]
	uint32_t pos;
	uint16_t dummy = 0xFF;
   13002:	230a      	movs	r3, #10
   13004:	18fb      	adds	r3, r7, r3
   13006:	22ff      	movs	r2, #255	; 0xff
   13008:	801a      	strh	r2, [r3, #0]

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1300a:	4b1c      	ldr	r3, [pc, #112]	; (1307c <sd_mmc_spi_start_read_blocks+0x88>)
   1300c:	2200      	movs	r2, #0
   1300e:	701a      	strb	r2, [r3, #0]
	pos = 0;
   13010:	2300      	movs	r3, #0
   13012:	60fb      	str	r3, [r7, #12]
	while (nb_block--) {
   13014:	e025      	b.n	13062 <sd_mmc_spi_start_read_blocks+0x6e>
		Assert(sd_mmc_spi_nb_block >
				(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size));
		if (!sd_mmc_spi_start_read_block()) {
   13016:	4b1a      	ldr	r3, [pc, #104]	; (13080 <sd_mmc_spi_start_read_blocks+0x8c>)
   13018:	4798      	blx	r3
   1301a:	0003      	movs	r3, r0
   1301c:	001a      	movs	r2, r3
   1301e:	2301      	movs	r3, #1
   13020:	4053      	eors	r3, r2
   13022:	b2db      	uxtb	r3, r3
   13024:	2b00      	cmp	r3, #0
   13026:	d001      	beq.n	1302c <sd_mmc_spi_start_read_blocks+0x38>
			return false;
   13028:	2300      	movs	r3, #0
   1302a:	e022      	b.n	13072 <sd_mmc_spi_start_read_blocks+0x7e>
		}

		// Read block
		spi_read_buffer_wait(&sd_mmc_master, &((uint8_t*)dest)[pos],
   1302c:	687a      	ldr	r2, [r7, #4]
   1302e:	68fb      	ldr	r3, [r7, #12]
   13030:	18d1      	adds	r1, r2, r3
   13032:	4b14      	ldr	r3, [pc, #80]	; (13084 <sd_mmc_spi_start_read_blocks+0x90>)
   13034:	881a      	ldrh	r2, [r3, #0]
   13036:	230a      	movs	r3, #10
   13038:	18fb      	adds	r3, r7, r3
   1303a:	881b      	ldrh	r3, [r3, #0]
   1303c:	4812      	ldr	r0, [pc, #72]	; (13088 <sd_mmc_spi_start_read_blocks+0x94>)
   1303e:	4c13      	ldr	r4, [pc, #76]	; (1308c <sd_mmc_spi_start_read_blocks+0x98>)
   13040:	47a0      	blx	r4
			sd_mmc_spi_block_size, dummy);
		pos += sd_mmc_spi_block_size;
   13042:	4b10      	ldr	r3, [pc, #64]	; (13084 <sd_mmc_spi_start_read_blocks+0x90>)
   13044:	881b      	ldrh	r3, [r3, #0]
   13046:	001a      	movs	r2, r3
   13048:	68fb      	ldr	r3, [r7, #12]
   1304a:	189b      	adds	r3, r3, r2
   1304c:	60fb      	str	r3, [r7, #12]
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
   1304e:	4b0d      	ldr	r3, [pc, #52]	; (13084 <sd_mmc_spi_start_read_blocks+0x90>)
   13050:	881b      	ldrh	r3, [r3, #0]
   13052:	001a      	movs	r2, r3
   13054:	4b0e      	ldr	r3, [pc, #56]	; (13090 <sd_mmc_spi_start_read_blocks+0x9c>)
   13056:	681b      	ldr	r3, [r3, #0]
   13058:	18d2      	adds	r2, r2, r3
   1305a:	4b0d      	ldr	r3, [pc, #52]	; (13090 <sd_mmc_spi_start_read_blocks+0x9c>)
   1305c:	601a      	str	r2, [r3, #0]

		sd_mmc_spi_stop_read_block();
   1305e:	4b0d      	ldr	r3, [pc, #52]	; (13094 <sd_mmc_spi_start_read_blocks+0xa0>)
   13060:	4798      	blx	r3
	uint32_t pos;
	uint16_t dummy = 0xFF;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
	pos = 0;
	while (nb_block--) {
   13062:	1cbb      	adds	r3, r7, #2
   13064:	881b      	ldrh	r3, [r3, #0]
   13066:	1cba      	adds	r2, r7, #2
   13068:	1e59      	subs	r1, r3, #1
   1306a:	8011      	strh	r1, [r2, #0]
   1306c:	2b00      	cmp	r3, #0
   1306e:	d1d2      	bne.n	13016 <sd_mmc_spi_start_read_blocks+0x22>
		pos += sd_mmc_spi_block_size;
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;

		sd_mmc_spi_stop_read_block();
	}
	return true;
   13070:	2301      	movs	r3, #1
}
   13072:	0018      	movs	r0, r3
   13074:	46bd      	mov	sp, r7
   13076:	b005      	add	sp, #20
   13078:	bd90      	pop	{r4, r7, pc}
   1307a:	46c0      	nop			; (mov r8, r8)
   1307c:	20002e1f 	.word	0x20002e1f
   13080:	000128c1 	.word	0x000128c1
   13084:	20002e28 	.word	0x20002e28
   13088:	20002ddc 	.word	0x20002ddc
   1308c:	00014a5d 	.word	0x00014a5d
   13090:	20002e24 	.word	0x20002e24
   13094:	00012945 	.word	0x00012945

00013098 <sd_mmc_spi_wait_end_of_read_blocks>:

bool sd_mmc_spi_wait_end_of_read_blocks(void)
{
   13098:	b580      	push	{r7, lr}
   1309a:	af00      	add	r7, sp, #0
	return true;
   1309c:	2301      	movs	r3, #1
}
   1309e:	0018      	movs	r0, r3
   130a0:	46bd      	mov	sp, r7
   130a2:	bd80      	pop	{r7, pc}

000130a4 <sd_mmc_spi_start_write_blocks>:

bool sd_mmc_spi_start_write_blocks(const void *src, uint16_t nb_block)
{
   130a4:	b580      	push	{r7, lr}
   130a6:	b084      	sub	sp, #16
   130a8:	af00      	add	r7, sp, #0
   130aa:	6078      	str	r0, [r7, #4]
   130ac:	000a      	movs	r2, r1
   130ae:	1cbb      	adds	r3, r7, #2
   130b0:	801a      	strh	r2, [r3, #0]
	uint32_t pos;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   130b2:	4b24      	ldr	r3, [pc, #144]	; (13144 <sd_mmc_spi_start_write_blocks+0xa0>)
   130b4:	2200      	movs	r2, #0
   130b6:	701a      	strb	r2, [r3, #0]
	pos = 0;
   130b8:	2300      	movs	r3, #0
   130ba:	60fb      	str	r3, [r7, #12]
	while (nb_block--) {
   130bc:	e035      	b.n	1312a <sd_mmc_spi_start_write_blocks+0x86>
		Assert(sd_mmc_spi_nb_block >
				(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size));
		sd_mmc_spi_start_write_block();
   130be:	4b22      	ldr	r3, [pc, #136]	; (13148 <sd_mmc_spi_start_write_blocks+0xa4>)
   130c0:	4798      	blx	r3

		// Write block
		spi_write_buffer_wait(&sd_mmc_master, &((uint8_t*)src)[pos],
   130c2:	687a      	ldr	r2, [r7, #4]
   130c4:	68fb      	ldr	r3, [r7, #12]
   130c6:	18d1      	adds	r1, r2, r3
   130c8:	4b20      	ldr	r3, [pc, #128]	; (1314c <sd_mmc_spi_start_write_blocks+0xa8>)
   130ca:	881a      	ldrh	r2, [r3, #0]
   130cc:	4b20      	ldr	r3, [pc, #128]	; (13150 <sd_mmc_spi_start_write_blocks+0xac>)
   130ce:	0018      	movs	r0, r3
   130d0:	4b20      	ldr	r3, [pc, #128]	; (13154 <sd_mmc_spi_start_write_blocks+0xb0>)
   130d2:	4798      	blx	r3
				sd_mmc_spi_block_size);
		pos += sd_mmc_spi_block_size;
   130d4:	4b1d      	ldr	r3, [pc, #116]	; (1314c <sd_mmc_spi_start_write_blocks+0xa8>)
   130d6:	881b      	ldrh	r3, [r3, #0]
   130d8:	001a      	movs	r2, r3
   130da:	68fb      	ldr	r3, [r7, #12]
   130dc:	189b      	adds	r3, r3, r2
   130de:	60fb      	str	r3, [r7, #12]
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
   130e0:	4b1a      	ldr	r3, [pc, #104]	; (1314c <sd_mmc_spi_start_write_blocks+0xa8>)
   130e2:	881b      	ldrh	r3, [r3, #0]
   130e4:	001a      	movs	r2, r3
   130e6:	4b1c      	ldr	r3, [pc, #112]	; (13158 <sd_mmc_spi_start_write_blocks+0xb4>)
   130e8:	681b      	ldr	r3, [r3, #0]
   130ea:	18d2      	adds	r2, r2, r3
   130ec:	4b1a      	ldr	r3, [pc, #104]	; (13158 <sd_mmc_spi_start_write_blocks+0xb4>)
   130ee:	601a      	str	r2, [r3, #0]

		if (!sd_mmc_spi_stop_write_block()) {
   130f0:	4b1a      	ldr	r3, [pc, #104]	; (1315c <sd_mmc_spi_start_write_blocks+0xb8>)
   130f2:	4798      	blx	r3
   130f4:	0003      	movs	r3, r0
   130f6:	001a      	movs	r2, r3
   130f8:	2301      	movs	r3, #1
   130fa:	4053      	eors	r3, r2
   130fc:	b2db      	uxtb	r3, r3
   130fe:	2b00      	cmp	r3, #0
   13100:	d001      	beq.n	13106 <sd_mmc_spi_start_write_blocks+0x62>
			return false;
   13102:	2300      	movs	r3, #0
   13104:	e019      	b.n	1313a <sd_mmc_spi_start_write_blocks+0x96>
		}
		// Do not check busy of last block
		// but delay it to mci_wait_end_of_write_blocks()
		if (nb_block) {
   13106:	1cbb      	adds	r3, r7, #2
   13108:	881b      	ldrh	r3, [r3, #0]
   1310a:	2b00      	cmp	r3, #0
   1310c:	d00d      	beq.n	1312a <sd_mmc_spi_start_write_blocks+0x86>
			// Wait busy due to data programmation
			if (!sd_mmc_spi_wait_busy()) {
   1310e:	4b14      	ldr	r3, [pc, #80]	; (13160 <sd_mmc_spi_start_write_blocks+0xbc>)
   13110:	4798      	blx	r3
   13112:	0003      	movs	r3, r0
   13114:	001a      	movs	r2, r3
   13116:	2301      	movs	r3, #1
   13118:	4053      	eors	r3, r2
   1311a:	b2db      	uxtb	r3, r3
   1311c:	2b00      	cmp	r3, #0
   1311e:	d004      	beq.n	1312a <sd_mmc_spi_start_write_blocks+0x86>
				sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_TIMEOUT;
   13120:	4b08      	ldr	r3, [pc, #32]	; (13144 <sd_mmc_spi_start_write_blocks+0xa0>)
   13122:	2205      	movs	r2, #5
   13124:	701a      	strb	r2, [r3, #0]
				sd_mmc_spi_debug("%s: Write blocks timeout\n\r", __func__);
				return false;
   13126:	2300      	movs	r3, #0
   13128:	e007      	b.n	1313a <sd_mmc_spi_start_write_blocks+0x96>
{
	uint32_t pos;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
	pos = 0;
	while (nb_block--) {
   1312a:	1cbb      	adds	r3, r7, #2
   1312c:	881b      	ldrh	r3, [r3, #0]
   1312e:	1cba      	adds	r2, r7, #2
   13130:	1e59      	subs	r1, r3, #1
   13132:	8011      	strh	r1, [r2, #0]
   13134:	2b00      	cmp	r3, #0
   13136:	d1c2      	bne.n	130be <sd_mmc_spi_start_write_blocks+0x1a>
				sd_mmc_spi_debug("%s: Write blocks timeout\n\r", __func__);
				return false;
			}
		}
	}
	return true;
   13138:	2301      	movs	r3, #1
}
   1313a:	0018      	movs	r0, r3
   1313c:	46bd      	mov	sp, r7
   1313e:	b004      	add	sp, #16
   13140:	bd80      	pop	{r7, pc}
   13142:	46c0      	nop			; (mov r8, r8)
   13144:	20002e1f 	.word	0x20002e1f
   13148:	00012971 	.word	0x00012971
   1314c:	20002e28 	.word	0x20002e28
   13150:	20002ddc 	.word	0x20002ddc
   13154:	00014d31 	.word	0x00014d31
   13158:	20002e24 	.word	0x20002e24
   1315c:	000129c1 	.word	0x000129c1
   13160:	00012855 	.word	0x00012855

00013164 <sd_mmc_spi_wait_end_of_write_blocks>:

bool sd_mmc_spi_wait_end_of_write_blocks(void)
{
   13164:	b580      	push	{r7, lr}
   13166:	af00      	add	r7, sp, #0
	// Wait busy due to data programmation of last block writed
	if (!sd_mmc_spi_wait_busy()) {
   13168:	4b09      	ldr	r3, [pc, #36]	; (13190 <sd_mmc_spi_wait_end_of_write_blocks+0x2c>)
   1316a:	4798      	blx	r3
   1316c:	0003      	movs	r3, r0
   1316e:	001a      	movs	r2, r3
   13170:	2301      	movs	r3, #1
   13172:	4053      	eors	r3, r2
   13174:	b2db      	uxtb	r3, r3
   13176:	2b00      	cmp	r3, #0
   13178:	d004      	beq.n	13184 <sd_mmc_spi_wait_end_of_write_blocks+0x20>
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_TIMEOUT;
   1317a:	4b06      	ldr	r3, [pc, #24]	; (13194 <sd_mmc_spi_wait_end_of_write_blocks+0x30>)
   1317c:	2205      	movs	r2, #5
   1317e:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Write blocks timeout\n\r", __func__);
		return false;
   13180:	2300      	movs	r3, #0
   13182:	e002      	b.n	1318a <sd_mmc_spi_wait_end_of_write_blocks+0x26>
	}
	return sd_mmc_spi_stop_multiwrite_block();
   13184:	4b04      	ldr	r3, [pc, #16]	; (13198 <sd_mmc_spi_wait_end_of_write_blocks+0x34>)
   13186:	4798      	blx	r3
   13188:	0003      	movs	r3, r0
}
   1318a:	0018      	movs	r0, r3
   1318c:	46bd      	mov	sp, r7
   1318e:	bd80      	pop	{r7, pc}
   13190:	00012855 	.word	0x00012855
   13194:	20002e1f 	.word	0x20002e1f
   13198:	00012a55 	.word	0x00012a55

0001319c <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
   1319c:	b580      	push	{r7, lr}
   1319e:	b084      	sub	sp, #16
   131a0:	af00      	add	r7, sp, #0
   131a2:	0002      	movs	r2, r0
   131a4:	1dfb      	adds	r3, r7, #7
   131a6:	701a      	strb	r2, [r3, #0]
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
   131a8:	1dfb      	adds	r3, r7, #7
   131aa:	781b      	ldrb	r3, [r3, #0]
   131ac:	2b00      	cmp	r3, #0
   131ae:	d108      	bne.n	131c2 <mem_test_unit_ready+0x26>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
   131b0:	1dfb      	adds	r3, r7, #7
   131b2:	781a      	ldrb	r2, [r3, #0]
   131b4:	4b08      	ldr	r3, [pc, #32]	; (131d8 <mem_test_unit_ready+0x3c>)
   131b6:	0152      	lsls	r2, r2, #5
   131b8:	58d3      	ldr	r3, [r2, r3]
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
   131ba:	4798      	blx	r3
   131bc:	0003      	movs	r3, r0
   131be:	001a      	movs	r2, r3
   131c0:	e000      	b.n	131c4 <mem_test_unit_ready+0x28>
   131c2:	2201      	movs	r2, #1
   131c4:	230f      	movs	r3, #15
   131c6:	18fb      	adds	r3, r7, r3
   131c8:	701a      	strb	r2, [r3, #0]
                             CTRL_FAIL;
#endif

  Ctrl_access_unlock();

  return status;
   131ca:	230f      	movs	r3, #15
   131cc:	18fb      	adds	r3, r7, r3
   131ce:	781b      	ldrb	r3, [r3, #0]
}
   131d0:	0018      	movs	r0, r3
   131d2:	46bd      	mov	sp, r7
   131d4:	b004      	add	sp, #16
   131d6:	bd80      	pop	{r7, pc}
   131d8:	000210b8 	.word	0x000210b8

000131dc <mem_read_capacity>:


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
   131dc:	b580      	push	{r7, lr}
   131de:	b084      	sub	sp, #16
   131e0:	af00      	add	r7, sp, #0
   131e2:	0002      	movs	r2, r0
   131e4:	6039      	str	r1, [r7, #0]
   131e6:	1dfb      	adds	r3, r7, #7
   131e8:	701a      	strb	r2, [r3, #0]
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
   131ea:	1dfb      	adds	r3, r7, #7
   131ec:	781b      	ldrb	r3, [r3, #0]
   131ee:	2b00      	cmp	r3, #0
   131f0:	d10c      	bne.n	1320c <mem_read_capacity+0x30>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
   131f2:	1dfb      	adds	r3, r7, #7
   131f4:	781b      	ldrb	r3, [r3, #0]
   131f6:	4a0b      	ldr	r2, [pc, #44]	; (13224 <mem_read_capacity+0x48>)
   131f8:	015b      	lsls	r3, r3, #5
   131fa:	18d3      	adds	r3, r2, r3
   131fc:	3304      	adds	r3, #4
   131fe:	681b      	ldr	r3, [r3, #0]
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
   13200:	683a      	ldr	r2, [r7, #0]
   13202:	0010      	movs	r0, r2
   13204:	4798      	blx	r3
   13206:	0003      	movs	r3, r0
   13208:	001a      	movs	r2, r3
   1320a:	e000      	b.n	1320e <mem_read_capacity+0x32>
   1320c:	2201      	movs	r2, #1
   1320e:	230f      	movs	r3, #15
   13210:	18fb      	adds	r3, r7, r3
   13212:	701a      	strb	r2, [r3, #0]
                             CTRL_FAIL;
#endif

  Ctrl_access_unlock();

  return status;
   13214:	230f      	movs	r3, #15
   13216:	18fb      	adds	r3, r7, r3
   13218:	781b      	ldrb	r3, [r3, #0]
}
   1321a:	0018      	movs	r0, r3
   1321c:	46bd      	mov	sp, r7
   1321e:	b004      	add	sp, #16
   13220:	bd80      	pop	{r7, pc}
   13222:	46c0      	nop			; (mov r8, r8)
   13224:	000210b8 	.word	0x000210b8

00013228 <mem_sector_size>:


U8 mem_sector_size(U8 lun)
{
   13228:	b580      	push	{r7, lr}
   1322a:	b084      	sub	sp, #16
   1322c:	af00      	add	r7, sp, #0
   1322e:	0002      	movs	r2, r0
   13230:	1dfb      	adds	r3, r7, #7
   13232:	701a      	strb	r2, [r3, #0]

  if (!Ctrl_access_lock()) return 0;

  sector_size =
#if MAX_LUN
              (lun < MAX_LUN) ? 1 :
   13234:	1dfb      	adds	r3, r7, #7
   13236:	781b      	ldrb	r3, [r3, #0]
   13238:	425a      	negs	r2, r3
   1323a:	4153      	adcs	r3, r2
   1323c:	b2da      	uxtb	r2, r3
{
  U8 sector_size;

  if (!Ctrl_access_lock()) return 0;

  sector_size =
   1323e:	230f      	movs	r3, #15
   13240:	18fb      	adds	r3, r7, r3
   13242:	701a      	strb	r2, [r3, #0]
                                  0;
#endif

  Ctrl_access_unlock();

  return sector_size;
   13244:	230f      	movs	r3, #15
   13246:	18fb      	adds	r3, r7, r3
   13248:	781b      	ldrb	r3, [r3, #0]
}
   1324a:	0018      	movs	r0, r3
   1324c:	46bd      	mov	sp, r7
   1324e:	b004      	add	sp, #16
   13250:	bd80      	pop	{r7, pc}
   13252:	46c0      	nop			; (mov r8, r8)

00013254 <mem_wr_protect>:

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
   13254:	b580      	push	{r7, lr}
   13256:	b084      	sub	sp, #16
   13258:	af00      	add	r7, sp, #0
   1325a:	0002      	movs	r2, r0
   1325c:	1dfb      	adds	r3, r7, #7
   1325e:	701a      	strb	r2, [r3, #0]

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
   13260:	1dfb      	adds	r3, r7, #7
   13262:	781b      	ldrb	r3, [r3, #0]
   13264:	2b00      	cmp	r3, #0
   13266:	d109      	bne.n	1327c <mem_wr_protect+0x28>
   13268:	1dfb      	adds	r3, r7, #7
   1326a:	781b      	ldrb	r3, [r3, #0]
   1326c:	4a0a      	ldr	r2, [pc, #40]	; (13298 <mem_wr_protect+0x44>)
   1326e:	015b      	lsls	r3, r3, #5
   13270:	18d3      	adds	r3, r2, r3
   13272:	330c      	adds	r3, #12
   13274:	681b      	ldr	r3, [r3, #0]
   13276:	4798      	blx	r3
   13278:	1e03      	subs	r3, r0, #0
   1327a:	d001      	beq.n	13280 <mem_wr_protect+0x2c>
   1327c:	2201      	movs	r2, #1
   1327e:	e000      	b.n	13282 <mem_wr_protect+0x2e>
   13280:	2200      	movs	r2, #0
{
  bool wr_protect;

  if (!Ctrl_access_lock()) return true;

  wr_protect =
   13282:	230f      	movs	r3, #15
   13284:	18fb      	adds	r3, r7, r3
   13286:	701a      	strb	r2, [r3, #0]
                                 true;
#endif

  Ctrl_access_unlock();

  return wr_protect;
   13288:	230f      	movs	r3, #15
   1328a:	18fb      	adds	r3, r7, r3
   1328c:	781b      	ldrb	r3, [r3, #0]
}
   1328e:	0018      	movs	r0, r3
   13290:	46bd      	mov	sp, r7
   13292:	b004      	add	sp, #16
   13294:	bd80      	pop	{r7, pc}
   13296:	46c0      	nop			; (mov r8, r8)
   13298:	000210b8 	.word	0x000210b8

0001329c <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
   1329c:	b580      	push	{r7, lr}
   1329e:	b086      	sub	sp, #24
   132a0:	af00      	add	r7, sp, #0
   132a2:	60b9      	str	r1, [r7, #8]
   132a4:	607a      	str	r2, [r7, #4]
   132a6:	230f      	movs	r3, #15
   132a8:	18fb      	adds	r3, r7, r3
   132aa:	1c02      	adds	r2, r0, #0
   132ac:	701a      	strb	r2, [r3, #0]
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
   132ae:	230f      	movs	r3, #15
   132b0:	18fb      	adds	r3, r7, r3
   132b2:	781b      	ldrb	r3, [r3, #0]
   132b4:	2b00      	cmp	r3, #0
   132b6:	d10e      	bne.n	132d6 <memory_2_ram+0x3a>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
   132b8:	230f      	movs	r3, #15
   132ba:	18fb      	adds	r3, r7, r3
   132bc:	781b      	ldrb	r3, [r3, #0]
   132be:	4a0b      	ldr	r2, [pc, #44]	; (132ec <memory_2_ram+0x50>)
   132c0:	015b      	lsls	r3, r3, #5
   132c2:	18d3      	adds	r3, r2, r3
   132c4:	3314      	adds	r3, #20
   132c6:	681b      	ldr	r3, [r3, #0]
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
   132c8:	6879      	ldr	r1, [r7, #4]
   132ca:	68ba      	ldr	r2, [r7, #8]
   132cc:	0010      	movs	r0, r2
   132ce:	4798      	blx	r3
   132d0:	0003      	movs	r3, r0
   132d2:	001a      	movs	r2, r3
   132d4:	e000      	b.n	132d8 <memory_2_ram+0x3c>
   132d6:	2201      	movs	r2, #1
   132d8:	2317      	movs	r3, #23
   132da:	18fb      	adds	r3, r7, r3
   132dc:	701a      	strb	r2, [r3, #0]
#endif
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
   132de:	2317      	movs	r3, #23
   132e0:	18fb      	adds	r3, r7, r3
   132e2:	781b      	ldrb	r3, [r3, #0]
}
   132e4:	0018      	movs	r0, r3
   132e6:	46bd      	mov	sp, r7
   132e8:	b006      	add	sp, #24
   132ea:	bd80      	pop	{r7, pc}
   132ec:	000210b8 	.word	0x000210b8

000132f0 <ram_2_memory>:


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
   132f0:	b580      	push	{r7, lr}
   132f2:	b086      	sub	sp, #24
   132f4:	af00      	add	r7, sp, #0
   132f6:	60b9      	str	r1, [r7, #8]
   132f8:	607a      	str	r2, [r7, #4]
   132fa:	230f      	movs	r3, #15
   132fc:	18fb      	adds	r3, r7, r3
   132fe:	1c02      	adds	r2, r0, #0
   13300:	701a      	strb	r2, [r3, #0]
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
   13302:	230f      	movs	r3, #15
   13304:	18fb      	adds	r3, r7, r3
   13306:	781b      	ldrb	r3, [r3, #0]
   13308:	2b00      	cmp	r3, #0
   1330a:	d10e      	bne.n	1332a <ram_2_memory+0x3a>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
   1330c:	230f      	movs	r3, #15
   1330e:	18fb      	adds	r3, r7, r3
   13310:	781b      	ldrb	r3, [r3, #0]
   13312:	4a0b      	ldr	r2, [pc, #44]	; (13340 <ram_2_memory+0x50>)
   13314:	015b      	lsls	r3, r3, #5
   13316:	18d3      	adds	r3, r2, r3
   13318:	3318      	adds	r3, #24
   1331a:	681b      	ldr	r3, [r3, #0]
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
   1331c:	6879      	ldr	r1, [r7, #4]
   1331e:	68ba      	ldr	r2, [r7, #8]
   13320:	0010      	movs	r0, r2
   13322:	4798      	blx	r3
   13324:	0003      	movs	r3, r0
   13326:	001a      	movs	r2, r3
   13328:	e000      	b.n	1332c <ram_2_memory+0x3c>
   1332a:	2201      	movs	r2, #1
   1332c:	2317      	movs	r3, #23
   1332e:	18fb      	adds	r3, r7, r3
   13330:	701a      	strb	r2, [r3, #0]
#endif
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
   13332:	2317      	movs	r3, #23
   13334:	18fb      	adds	r3, r7, r3
   13336:	781b      	ldrb	r3, [r3, #0]
}
   13338:	0018      	movs	r0, r3
   1333a:	46bd      	mov	sp, r7
   1333c:	b006      	add	sp, #24
   1333e:	bd80      	pop	{r7, pc}
   13340:	000210b8 	.word	0x000210b8

00013344 <cpu_irq_enter_critical>:
 */
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
   13344:	b580      	push	{r7, lr}
   13346:	b082      	sub	sp, #8
   13348:	af00      	add	r7, sp, #0
	if (cpu_irq_critical_section_counter == 0) {
   1334a:	4b10      	ldr	r3, [pc, #64]	; (1338c <cpu_irq_enter_critical+0x48>)
   1334c:	681b      	ldr	r3, [r3, #0]
   1334e:	2b00      	cmp	r3, #0
   13350:	d112      	bne.n	13378 <cpu_irq_enter_critical+0x34>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   13352:	f3ef 8310 	mrs	r3, PRIMASK
   13356:	607b      	str	r3, [r7, #4]
  return(result);
   13358:	687b      	ldr	r3, [r7, #4]
		if (cpu_irq_is_enabled()) {
   1335a:	2b00      	cmp	r3, #0
   1335c:	d109      	bne.n	13372 <cpu_irq_enter_critical+0x2e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   1335e:	b672      	cpsid	i
   13360:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
   13364:	4b0a      	ldr	r3, [pc, #40]	; (13390 <cpu_irq_enter_critical+0x4c>)
   13366:	2200      	movs	r2, #0
   13368:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
   1336a:	4b0a      	ldr	r3, [pc, #40]	; (13394 <cpu_irq_enter_critical+0x50>)
   1336c:	2201      	movs	r2, #1
   1336e:	701a      	strb	r2, [r3, #0]
   13370:	e002      	b.n	13378 <cpu_irq_enter_critical+0x34>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
   13372:	4b08      	ldr	r3, [pc, #32]	; (13394 <cpu_irq_enter_critical+0x50>)
   13374:	2200      	movs	r2, #0
   13376:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
   13378:	4b04      	ldr	r3, [pc, #16]	; (1338c <cpu_irq_enter_critical+0x48>)
   1337a:	681b      	ldr	r3, [r3, #0]
   1337c:	1c5a      	adds	r2, r3, #1
   1337e:	4b03      	ldr	r3, [pc, #12]	; (1338c <cpu_irq_enter_critical+0x48>)
   13380:	601a      	str	r2, [r3, #0]
}
   13382:	46c0      	nop			; (mov r8, r8)
   13384:	46bd      	mov	sp, r7
   13386:	b002      	add	sp, #8
   13388:	bd80      	pop	{r7, pc}
   1338a:	46c0      	nop			; (mov r8, r8)
   1338c:	20002e2c 	.word	0x20002e2c
   13390:	20000051 	.word	0x20000051
   13394:	20002e30 	.word	0x20002e30

00013398 <cpu_irq_leave_critical>:

void cpu_irq_leave_critical(void)
{
   13398:	b580      	push	{r7, lr}
   1339a:	af00      	add	r7, sp, #0
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
   1339c:	4b0b      	ldr	r3, [pc, #44]	; (133cc <cpu_irq_leave_critical+0x34>)
   1339e:	681b      	ldr	r3, [r3, #0]
   133a0:	1e5a      	subs	r2, r3, #1
   133a2:	4b0a      	ldr	r3, [pc, #40]	; (133cc <cpu_irq_leave_critical+0x34>)
   133a4:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
   133a6:	4b09      	ldr	r3, [pc, #36]	; (133cc <cpu_irq_leave_critical+0x34>)
   133a8:	681b      	ldr	r3, [r3, #0]
   133aa:	2b00      	cmp	r3, #0
   133ac:	d10a      	bne.n	133c4 <cpu_irq_leave_critical+0x2c>
   133ae:	4b08      	ldr	r3, [pc, #32]	; (133d0 <cpu_irq_leave_critical+0x38>)
   133b0:	781b      	ldrb	r3, [r3, #0]
   133b2:	b2db      	uxtb	r3, r3
   133b4:	2b00      	cmp	r3, #0
   133b6:	d005      	beq.n	133c4 <cpu_irq_leave_critical+0x2c>
		cpu_irq_enable();
   133b8:	4b06      	ldr	r3, [pc, #24]	; (133d4 <cpu_irq_leave_critical+0x3c>)
   133ba:	2201      	movs	r2, #1
   133bc:	701a      	strb	r2, [r3, #0]
   133be:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   133c2:	b662      	cpsie	i
	}
}
   133c4:	46c0      	nop			; (mov r8, r8)
   133c6:	46bd      	mov	sp, r7
   133c8:	bd80      	pop	{r7, pc}
   133ca:	46c0      	nop			; (mov r8, r8)
   133cc:	20002e2c 	.word	0x20002e2c
   133d0:	20002e30 	.word	0x20002e30
   133d4:	20000051 	.word	0x20000051

000133d8 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   133d8:	b580      	push	{r7, lr}
   133da:	b084      	sub	sp, #16
   133dc:	af00      	add	r7, sp, #0
   133de:	0002      	movs	r2, r0
   133e0:	1dfb      	adds	r3, r7, #7
   133e2:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
   133e4:	230f      	movs	r3, #15
   133e6:	18fb      	adds	r3, r7, r3
   133e8:	1dfa      	adds	r2, r7, #7
   133ea:	7812      	ldrb	r2, [r2, #0]
   133ec:	09d2      	lsrs	r2, r2, #7
   133ee:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
   133f0:	230e      	movs	r3, #14
   133f2:	18fb      	adds	r3, r7, r3
   133f4:	1dfa      	adds	r2, r7, #7
   133f6:	7812      	ldrb	r2, [r2, #0]
   133f8:	0952      	lsrs	r2, r2, #5
   133fa:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
   133fc:	4b0d      	ldr	r3, [pc, #52]	; (13434 <system_pinmux_get_group_from_gpio_pin+0x5c>)
   133fe:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
   13400:	230f      	movs	r3, #15
   13402:	18fb      	adds	r3, r7, r3
   13404:	781b      	ldrb	r3, [r3, #0]
   13406:	2b00      	cmp	r3, #0
   13408:	d10f      	bne.n	1342a <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
   1340a:	230f      	movs	r3, #15
   1340c:	18fb      	adds	r3, r7, r3
   1340e:	781b      	ldrb	r3, [r3, #0]
   13410:	009b      	lsls	r3, r3, #2
   13412:	2210      	movs	r2, #16
   13414:	4694      	mov	ip, r2
   13416:	44bc      	add	ip, r7
   13418:	4463      	add	r3, ip
   1341a:	3b08      	subs	r3, #8
   1341c:	681a      	ldr	r2, [r3, #0]
   1341e:	230e      	movs	r3, #14
   13420:	18fb      	adds	r3, r7, r3
   13422:	781b      	ldrb	r3, [r3, #0]
   13424:	01db      	lsls	r3, r3, #7
   13426:	18d3      	adds	r3, r2, r3
   13428:	e000      	b.n	1342c <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
   1342a:	2300      	movs	r3, #0
	}
}
   1342c:	0018      	movs	r0, r3
   1342e:	46bd      	mov	sp, r7
   13430:	b004      	add	sp, #16
   13432:	bd80      	pop	{r7, pc}
   13434:	41004400 	.word	0x41004400

00013438 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   13438:	b580      	push	{r7, lr}
   1343a:	b082      	sub	sp, #8
   1343c:	af00      	add	r7, sp, #0
   1343e:	0002      	movs	r2, r0
   13440:	1dfb      	adds	r3, r7, #7
   13442:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
   13444:	1dfb      	adds	r3, r7, #7
   13446:	781b      	ldrb	r3, [r3, #0]
   13448:	0018      	movs	r0, r3
   1344a:	4b03      	ldr	r3, [pc, #12]	; (13458 <port_get_group_from_gpio_pin+0x20>)
   1344c:	4798      	blx	r3
   1344e:	0003      	movs	r3, r0
}
   13450:	0018      	movs	r0, r3
   13452:	46bd      	mov	sp, r7
   13454:	b002      	add	sp, #8
   13456:	bd80      	pop	{r7, pc}
   13458:	000133d9 	.word	0x000133d9

0001345c <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
   1345c:	b580      	push	{r7, lr}
   1345e:	b082      	sub	sp, #8
   13460:	af00      	add	r7, sp, #0
   13462:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
   13464:	687b      	ldr	r3, [r7, #4]
   13466:	2200      	movs	r2, #0
   13468:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
   1346a:	687b      	ldr	r3, [r7, #4]
   1346c:	2201      	movs	r2, #1
   1346e:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
   13470:	687b      	ldr	r3, [r7, #4]
   13472:	2200      	movs	r2, #0
   13474:	709a      	strb	r2, [r3, #2]
}
   13476:	46c0      	nop			; (mov r8, r8)
   13478:	46bd      	mov	sp, r7
   1347a:	b002      	add	sp, #8
   1347c:	bd80      	pop	{r7, pc}
   1347e:	46c0      	nop			; (mov r8, r8)

00013480 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
   13480:	b580      	push	{r7, lr}
   13482:	b084      	sub	sp, #16
   13484:	af00      	add	r7, sp, #0
   13486:	0002      	movs	r2, r0
   13488:	1dfb      	adds	r3, r7, #7
   1348a:	701a      	strb	r2, [r3, #0]
   1348c:	1dbb      	adds	r3, r7, #6
   1348e:	1c0a      	adds	r2, r1, #0
   13490:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
   13492:	1dfb      	adds	r3, r7, #7
   13494:	781b      	ldrb	r3, [r3, #0]
   13496:	0018      	movs	r0, r3
   13498:	4b0d      	ldr	r3, [pc, #52]	; (134d0 <port_pin_set_output_level+0x50>)
   1349a:	4798      	blx	r3
   1349c:	0003      	movs	r3, r0
   1349e:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   134a0:	1dfb      	adds	r3, r7, #7
   134a2:	781b      	ldrb	r3, [r3, #0]
   134a4:	221f      	movs	r2, #31
   134a6:	4013      	ands	r3, r2
   134a8:	2201      	movs	r2, #1
   134aa:	409a      	lsls	r2, r3
   134ac:	0013      	movs	r3, r2
   134ae:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
   134b0:	1dbb      	adds	r3, r7, #6
   134b2:	781b      	ldrb	r3, [r3, #0]
   134b4:	2b00      	cmp	r3, #0
   134b6:	d003      	beq.n	134c0 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
   134b8:	68fb      	ldr	r3, [r7, #12]
   134ba:	68ba      	ldr	r2, [r7, #8]
   134bc:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
   134be:	e002      	b.n	134c6 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
   134c0:	68fb      	ldr	r3, [r7, #12]
   134c2:	68ba      	ldr	r2, [r7, #8]
   134c4:	615a      	str	r2, [r3, #20]
	}
}
   134c6:	46c0      	nop			; (mov r8, r8)
   134c8:	46bd      	mov	sp, r7
   134ca:	b004      	add	sp, #16
   134cc:	bd80      	pop	{r7, pc}
   134ce:	46c0      	nop			; (mov r8, r8)
   134d0:	00013439 	.word	0x00013439

000134d4 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
   134d4:	b580      	push	{r7, lr}
   134d6:	b082      	sub	sp, #8
   134d8:	af00      	add	r7, sp, #0
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);
   134da:	1d3b      	adds	r3, r7, #4
   134dc:	0018      	movs	r0, r3
   134de:	4b12      	ldr	r3, [pc, #72]	; (13528 <system_board_init+0x54>)
   134e0:	4798      	blx	r3

	///* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
   134e2:	1d3b      	adds	r3, r7, #4
   134e4:	2201      	movs	r2, #1
   134e6:	701a      	strb	r2, [r3, #0]
    port_pin_set_config(LED_0_PIN, &pin_conf);
   134e8:	1d3b      	adds	r3, r7, #4
   134ea:	0019      	movs	r1, r3
   134ec:	203e      	movs	r0, #62	; 0x3e
   134ee:	4b0f      	ldr	r3, [pc, #60]	; (1352c <system_board_init+0x58>)
   134f0:	4798      	blx	r3
    port_pin_set_output_level(LED_0_PIN,true);
   134f2:	2101      	movs	r1, #1
   134f4:	203e      	movs	r0, #62	; 0x3e
   134f6:	4b0e      	ldr	r3, [pc, #56]	; (13530 <system_board_init+0x5c>)
   134f8:	4798      	blx	r3
	
    port_pin_set_config(RELAY_1, &pin_conf);
   134fa:	1d3b      	adds	r3, r7, #4
   134fc:	0019      	movs	r1, r3
   134fe:	2014      	movs	r0, #20
   13500:	4b0a      	ldr	r3, [pc, #40]	; (1352c <system_board_init+0x58>)
   13502:	4798      	blx	r3
    port_pin_set_output_level(RELAY_1,false);
   13504:	2100      	movs	r1, #0
   13506:	2014      	movs	r0, #20
   13508:	4b09      	ldr	r3, [pc, #36]	; (13530 <system_board_init+0x5c>)
   1350a:	4798      	blx	r3
	
    port_pin_set_config(RELAY_2, &pin_conf);
   1350c:	1d3b      	adds	r3, r7, #4
   1350e:	0019      	movs	r1, r3
   13510:	2015      	movs	r0, #21
   13512:	4b06      	ldr	r3, [pc, #24]	; (1352c <system_board_init+0x58>)
   13514:	4798      	blx	r3
    port_pin_set_output_level(RELAY_2,false);
   13516:	2100      	movs	r1, #0
   13518:	2015      	movs	r0, #21
   1351a:	4b05      	ldr	r3, [pc, #20]	; (13530 <system_board_init+0x5c>)
   1351c:	4798      	blx	r3
	port_pin_set_output_level(AT86RFX_RST_PIN, true);
	port_pin_set_output_level(AT86RFX_SLP_PIN, true);
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
#endif	
}
   1351e:	46c0      	nop			; (mov r8, r8)
   13520:	46bd      	mov	sp, r7
   13522:	b002      	add	sp, #8
   13524:	bd80      	pop	{r7, pc}
   13526:	46c0      	nop			; (mov r8, r8)
   13528:	0001345d 	.word	0x0001345d
   1352c:	0001355d 	.word	0x0001355d
   13530:	00013481 	.word	0x00013481

00013534 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
   13534:	b580      	push	{r7, lr}
   13536:	b082      	sub	sp, #8
   13538:	af00      	add	r7, sp, #0
   1353a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
   1353c:	687b      	ldr	r3, [r7, #4]
   1353e:	2280      	movs	r2, #128	; 0x80
   13540:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
   13542:	687b      	ldr	r3, [r7, #4]
   13544:	2200      	movs	r2, #0
   13546:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
   13548:	687b      	ldr	r3, [r7, #4]
   1354a:	2201      	movs	r2, #1
   1354c:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
   1354e:	687b      	ldr	r3, [r7, #4]
   13550:	2200      	movs	r2, #0
   13552:	70da      	strb	r2, [r3, #3]
}
   13554:	46c0      	nop			; (mov r8, r8)
   13556:	46bd      	mov	sp, r7
   13558:	b002      	add	sp, #8
   1355a:	bd80      	pop	{r7, pc}

0001355c <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
   1355c:	b580      	push	{r7, lr}
   1355e:	b084      	sub	sp, #16
   13560:	af00      	add	r7, sp, #0
   13562:	0002      	movs	r2, r0
   13564:	6039      	str	r1, [r7, #0]
   13566:	1dfb      	adds	r3, r7, #7
   13568:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);
   1356a:	230c      	movs	r3, #12
   1356c:	18fb      	adds	r3, r7, r3
   1356e:	0018      	movs	r0, r3
   13570:	4b10      	ldr	r3, [pc, #64]	; (135b4 <port_pin_set_config+0x58>)
   13572:	4798      	blx	r3

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
   13574:	230c      	movs	r3, #12
   13576:	18fb      	adds	r3, r7, r3
   13578:	2280      	movs	r2, #128	; 0x80
   1357a:	701a      	strb	r2, [r3, #0]
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
   1357c:	683b      	ldr	r3, [r7, #0]
   1357e:	781a      	ldrb	r2, [r3, #0]
   13580:	230c      	movs	r3, #12
   13582:	18fb      	adds	r3, r7, r3
   13584:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
   13586:	683b      	ldr	r3, [r7, #0]
   13588:	785a      	ldrb	r2, [r3, #1]
   1358a:	230c      	movs	r3, #12
   1358c:	18fb      	adds	r3, r7, r3
   1358e:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
   13590:	683b      	ldr	r3, [r7, #0]
   13592:	789a      	ldrb	r2, [r3, #2]
   13594:	230c      	movs	r3, #12
   13596:	18fb      	adds	r3, r7, r3
   13598:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
   1359a:	230c      	movs	r3, #12
   1359c:	18fa      	adds	r2, r7, r3
   1359e:	1dfb      	adds	r3, r7, #7
   135a0:	781b      	ldrb	r3, [r3, #0]
   135a2:	0011      	movs	r1, r2
   135a4:	0018      	movs	r0, r3
   135a6:	4b04      	ldr	r3, [pc, #16]	; (135b8 <port_pin_set_config+0x5c>)
   135a8:	4798      	blx	r3
}
   135aa:	46c0      	nop			; (mov r8, r8)
   135ac:	46bd      	mov	sp, r7
   135ae:	b004      	add	sp, #16
   135b0:	bd80      	pop	{r7, pc}
   135b2:	46c0      	nop			; (mov r8, r8)
   135b4:	00013535 	.word	0x00013535
   135b8:	00016d15 	.word	0x00016d15

000135bc <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
   135bc:	b580      	push	{r7, lr}
   135be:	b082      	sub	sp, #8
   135c0:	af00      	add	r7, sp, #0
   135c2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
   135c4:	687b      	ldr	r3, [r7, #4]
   135c6:	2200      	movs	r2, #0
   135c8:	701a      	strb	r2, [r3, #0]
}
   135ca:	46c0      	nop			; (mov r8, r8)
   135cc:	46bd      	mov	sp, r7
   135ce:	b002      	add	sp, #8
   135d0:	bd80      	pop	{r7, pc}
   135d2:	46c0      	nop			; (mov r8, r8)

000135d4 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
   135d4:	b580      	push	{r7, lr}
   135d6:	b082      	sub	sp, #8
   135d8:	af00      	add	r7, sp, #0
   135da:	0002      	movs	r2, r0
   135dc:	6039      	str	r1, [r7, #0]
   135de:	1dfb      	adds	r3, r7, #7
   135e0:	701a      	strb	r2, [r3, #0]
	switch (bus) {
   135e2:	1dfb      	adds	r3, r7, #7
   135e4:	781b      	ldrb	r3, [r3, #0]
   135e6:	2b01      	cmp	r3, #1
   135e8:	d00a      	beq.n	13600 <system_apb_clock_set_mask+0x2c>
   135ea:	2b02      	cmp	r3, #2
   135ec:	d00f      	beq.n	1360e <system_apb_clock_set_mask+0x3a>
   135ee:	2b00      	cmp	r3, #0
   135f0:	d114      	bne.n	1361c <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
   135f2:	4b0e      	ldr	r3, [pc, #56]	; (1362c <system_apb_clock_set_mask+0x58>)
   135f4:	4a0d      	ldr	r2, [pc, #52]	; (1362c <system_apb_clock_set_mask+0x58>)
   135f6:	6991      	ldr	r1, [r2, #24]
   135f8:	683a      	ldr	r2, [r7, #0]
   135fa:	430a      	orrs	r2, r1
   135fc:	619a      	str	r2, [r3, #24]
			break;
   135fe:	e00f      	b.n	13620 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
   13600:	4b0a      	ldr	r3, [pc, #40]	; (1362c <system_apb_clock_set_mask+0x58>)
   13602:	4a0a      	ldr	r2, [pc, #40]	; (1362c <system_apb_clock_set_mask+0x58>)
   13604:	69d1      	ldr	r1, [r2, #28]
   13606:	683a      	ldr	r2, [r7, #0]
   13608:	430a      	orrs	r2, r1
   1360a:	61da      	str	r2, [r3, #28]
			break;
   1360c:	e008      	b.n	13620 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
   1360e:	4b07      	ldr	r3, [pc, #28]	; (1362c <system_apb_clock_set_mask+0x58>)
   13610:	4a06      	ldr	r2, [pc, #24]	; (1362c <system_apb_clock_set_mask+0x58>)
   13612:	6a11      	ldr	r1, [r2, #32]
   13614:	683a      	ldr	r2, [r7, #0]
   13616:	430a      	orrs	r2, r1
   13618:	621a      	str	r2, [r3, #32]
			break;
   1361a:	e001      	b.n	13620 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
   1361c:	2317      	movs	r3, #23
   1361e:	e000      	b.n	13622 <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
   13620:	2300      	movs	r3, #0
}
   13622:	0018      	movs	r0, r3
   13624:	46bd      	mov	sp, r7
   13626:	b002      	add	sp, #8
   13628:	bd80      	pop	{r7, pc}
   1362a:	46c0      	nop			; (mov r8, r8)
   1362c:	40000400 	.word	0x40000400

00013630 <rtc_calendar_is_syncing>:
 *
 * \retval false If the module has completed synchronization
 * \retval true If the module synchronization is ongoing
 */
static inline bool rtc_calendar_is_syncing(struct rtc_module *const module)
{
   13630:	b580      	push	{r7, lr}
   13632:	b084      	sub	sp, #16
   13634:	af00      	add	r7, sp, #0
   13636:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   13638:	687b      	ldr	r3, [r7, #4]
   1363a:	681b      	ldr	r3, [r3, #0]
   1363c:	60fb      	str	r3, [r7, #12]

        if (rtc_module->MODE2.STATUS.reg & RTC_STATUS_SYNCBUSY) {
   1363e:	68fb      	ldr	r3, [r7, #12]
   13640:	7a9b      	ldrb	r3, [r3, #10]
   13642:	b2db      	uxtb	r3, r3
   13644:	b25b      	sxtb	r3, r3
   13646:	2b00      	cmp	r3, #0
   13648:	da01      	bge.n	1364e <rtc_calendar_is_syncing+0x1e>
                return true;
   1364a:	2301      	movs	r3, #1
   1364c:	e000      	b.n	13650 <rtc_calendar_is_syncing+0x20>
        }

        return false;
   1364e:	2300      	movs	r3, #0
}
   13650:	0018      	movs	r0, r3
   13652:	46bd      	mov	sp, r7
   13654:	b004      	add	sp, #16
   13656:	bd80      	pop	{r7, pc}

00013658 <rtc_calendar_enable>:
 * module configuration parameters cannot be altered while the module is enabled.
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
void rtc_calendar_enable(struct rtc_module *const module)
{
   13658:	b580      	push	{r7, lr}
   1365a:	b084      	sub	sp, #16
   1365c:	af00      	add	r7, sp, #0
   1365e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   13660:	687b      	ldr	r3, [r7, #4]
   13662:	681b      	ldr	r3, [r3, #0]
   13664:	60fb      	str	r3, [r7, #12]

#if RTC_CALENDAR_ASYNC == true
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_RTC);
#endif

	while (rtc_calendar_is_syncing(module)) {
   13666:	46c0      	nop			; (mov r8, r8)
   13668:	687b      	ldr	r3, [r7, #4]
   1366a:	0018      	movs	r0, r3
   1366c:	4b07      	ldr	r3, [pc, #28]	; (1368c <rtc_calendar_enable+0x34>)
   1366e:	4798      	blx	r3
   13670:	1e03      	subs	r3, r0, #0
   13672:	d1f9      	bne.n	13668 <rtc_calendar_enable+0x10>
		/* Wait for synchronization */
	}

	/* Enable RTC module. */
	rtc_module->MODE2.CTRL.reg |= RTC_MODE2_CTRL_ENABLE;
   13674:	68fb      	ldr	r3, [r7, #12]
   13676:	881b      	ldrh	r3, [r3, #0]
   13678:	b29b      	uxth	r3, r3
   1367a:	2202      	movs	r2, #2
   1367c:	4313      	orrs	r3, r2
   1367e:	b29a      	uxth	r2, r3
   13680:	68fb      	ldr	r3, [r7, #12]
   13682:	801a      	strh	r2, [r3, #0]
}
   13684:	46c0      	nop			; (mov r8, r8)
   13686:	46bd      	mov	sp, r7
   13688:	b004      	add	sp, #16
   1368a:	bd80      	pop	{r7, pc}
   1368c:	00013631 	.word	0x00013631

00013690 <rtc_calendar_disable>:
 * Disables the RTC module.
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
void rtc_calendar_disable(struct rtc_module *const module)
{
   13690:	b580      	push	{r7, lr}
   13692:	b084      	sub	sp, #16
   13694:	af00      	add	r7, sp, #0
   13696:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   13698:	687b      	ldr	r3, [r7, #4]
   1369a:	681b      	ldr	r3, [r3, #0]
   1369c:	60fb      	str	r3, [r7, #12]

#if RTC_CALENDAR_ASYNC == true
	system_interrupt_disable(SYSTEM_INTERRUPT_MODULE_RTC);
#endif

	while (rtc_calendar_is_syncing(module)) {
   1369e:	46c0      	nop			; (mov r8, r8)
   136a0:	687b      	ldr	r3, [r7, #4]
   136a2:	0018      	movs	r0, r3
   136a4:	4b07      	ldr	r3, [pc, #28]	; (136c4 <rtc_calendar_disable+0x34>)
   136a6:	4798      	blx	r3
   136a8:	1e03      	subs	r3, r0, #0
   136aa:	d1f9      	bne.n	136a0 <rtc_calendar_disable+0x10>
		/* Wait for synchronization */
	}

	/* Disable RTC module. */
	rtc_module->MODE2.CTRL.reg &= ~RTC_MODE2_CTRL_ENABLE;
   136ac:	68fb      	ldr	r3, [r7, #12]
   136ae:	881b      	ldrh	r3, [r3, #0]
   136b0:	b29b      	uxth	r3, r3
   136b2:	2202      	movs	r2, #2
   136b4:	4393      	bics	r3, r2
   136b6:	b29a      	uxth	r2, r3
   136b8:	68fb      	ldr	r3, [r7, #12]
   136ba:	801a      	strh	r2, [r3, #0]
}
   136bc:	46c0      	nop			; (mov r8, r8)
   136be:	46bd      	mov	sp, r7
   136c0:	b004      	add	sp, #16
   136c2:	bd80      	pop	{r7, pc}
   136c4:	00013631 	.word	0x00013631

000136c8 <rtc_calendar_reset>:
 * Resets the RTC module to hardware defaults.
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
void rtc_calendar_reset(struct rtc_module *const module)
{
   136c8:	b580      	push	{r7, lr}
   136ca:	b084      	sub	sp, #16
   136cc:	af00      	add	r7, sp, #0
   136ce:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   136d0:	687b      	ldr	r3, [r7, #4]
   136d2:	681b      	ldr	r3, [r3, #0]
   136d4:	60fb      	str	r3, [r7, #12]

	/* Disable module before reset. */
	rtc_calendar_disable(module);
   136d6:	687b      	ldr	r3, [r7, #4]
   136d8:	0018      	movs	r0, r3
   136da:	4b0a      	ldr	r3, [pc, #40]	; (13704 <rtc_calendar_reset+0x3c>)
   136dc:	4798      	blx	r3
#if RTC_CALENDAR_ASYNC == true
	module->registered_callback = 0;
	module->enabled_callback    = 0;
#endif

	while (rtc_calendar_is_syncing(module)) {
   136de:	46c0      	nop			; (mov r8, r8)
   136e0:	687b      	ldr	r3, [r7, #4]
   136e2:	0018      	movs	r0, r3
   136e4:	4b08      	ldr	r3, [pc, #32]	; (13708 <rtc_calendar_reset+0x40>)
   136e6:	4798      	blx	r3
   136e8:	1e03      	subs	r3, r0, #0
   136ea:	d1f9      	bne.n	136e0 <rtc_calendar_reset+0x18>
		/* Wait for synchronization */
	}

	/* Initiate software reset. */
	rtc_module->MODE2.CTRL.reg |= RTC_MODE2_CTRL_SWRST;
   136ec:	68fb      	ldr	r3, [r7, #12]
   136ee:	881b      	ldrh	r3, [r3, #0]
   136f0:	b29b      	uxth	r3, r3
   136f2:	2201      	movs	r2, #1
   136f4:	4313      	orrs	r3, r2
   136f6:	b29a      	uxth	r2, r3
   136f8:	68fb      	ldr	r3, [r7, #12]
   136fa:	801a      	strh	r2, [r3, #0]
}
   136fc:	46c0      	nop			; (mov r8, r8)
   136fe:	46bd      	mov	sp, r7
   13700:	b004      	add	sp, #16
   13702:	bd80      	pop	{r7, pc}
   13704:	00013691 	.word	0x00013691
   13708:	00013631 	.word	0x00013631

0001370c <rtc_calendar_time_to_register_value>:
 * \return 32-bit value
 */
uint32_t rtc_calendar_time_to_register_value(
		struct rtc_module *const module,
		const struct rtc_calendar_time *const time)
{
   1370c:	b580      	push	{r7, lr}
   1370e:	b084      	sub	sp, #16
   13710:	af00      	add	r7, sp, #0
   13712:	6078      	str	r0, [r7, #4]
   13714:	6039      	str	r1, [r7, #0]
	/* Initialize return value. */
	uint32_t register_value;

	/* Set year value into register_value minus initial year. */
	register_value = (time->year - module->year_init_value) <<
   13716:	683b      	ldr	r3, [r7, #0]
   13718:	88db      	ldrh	r3, [r3, #6]
   1371a:	001a      	movs	r2, r3
   1371c:	687b      	ldr	r3, [r7, #4]
   1371e:	88db      	ldrh	r3, [r3, #6]
   13720:	1ad3      	subs	r3, r2, r3
   13722:	069b      	lsls	r3, r3, #26
   13724:	60fb      	str	r3, [r7, #12]
			RTC_MODE2_CLOCK_YEAR_Pos;

	/* Set month value into register_value. */
	register_value |= (time->month << RTC_MODE2_CLOCK_MONTH_Pos);
   13726:	683b      	ldr	r3, [r7, #0]
   13728:	795b      	ldrb	r3, [r3, #5]
   1372a:	059b      	lsls	r3, r3, #22
   1372c:	001a      	movs	r2, r3
   1372e:	68fb      	ldr	r3, [r7, #12]
   13730:	4313      	orrs	r3, r2
   13732:	60fb      	str	r3, [r7, #12]

	/* Set day value into register_value. */
	register_value |= (time->day << RTC_MODE2_CLOCK_DAY_Pos);
   13734:	683b      	ldr	r3, [r7, #0]
   13736:	791b      	ldrb	r3, [r3, #4]
   13738:	045b      	lsls	r3, r3, #17
   1373a:	001a      	movs	r2, r3
   1373c:	68fb      	ldr	r3, [r7, #12]
   1373e:	4313      	orrs	r3, r2
   13740:	60fb      	str	r3, [r7, #12]

	/* Set 24 hour value into register_value. */
	register_value |= (time->hour << RTC_MODE2_CLOCK_HOUR_Pos);
   13742:	683b      	ldr	r3, [r7, #0]
   13744:	789b      	ldrb	r3, [r3, #2]
   13746:	031b      	lsls	r3, r3, #12
   13748:	001a      	movs	r2, r3
   1374a:	68fb      	ldr	r3, [r7, #12]
   1374c:	4313      	orrs	r3, r2
   1374e:	60fb      	str	r3, [r7, #12]

	/* Check if 24 h clock and set pm flag. */
	if (!(module->clock_24h) && (time->pm)) {
   13750:	687b      	ldr	r3, [r7, #4]
   13752:	791b      	ldrb	r3, [r3, #4]
   13754:	2201      	movs	r2, #1
   13756:	4053      	eors	r3, r2
   13758:	b2db      	uxtb	r3, r3
   1375a:	2b00      	cmp	r3, #0
   1375c:	d008      	beq.n	13770 <rtc_calendar_time_to_register_value+0x64>
   1375e:	683b      	ldr	r3, [r7, #0]
   13760:	78db      	ldrb	r3, [r3, #3]
   13762:	2b00      	cmp	r3, #0
   13764:	d004      	beq.n	13770 <rtc_calendar_time_to_register_value+0x64>
		/* Set pm flag. */
		register_value |= RTC_MODE2_CLOCK_HOUR_PM;
   13766:	68fb      	ldr	r3, [r7, #12]
   13768:	2280      	movs	r2, #128	; 0x80
   1376a:	0252      	lsls	r2, r2, #9
   1376c:	4313      	orrs	r3, r2
   1376e:	60fb      	str	r3, [r7, #12]
	}

	/* Set minute value into register_value. */
	register_value |= (time->minute << RTC_MODE2_CLOCK_MINUTE_Pos);
   13770:	683b      	ldr	r3, [r7, #0]
   13772:	785b      	ldrb	r3, [r3, #1]
   13774:	019b      	lsls	r3, r3, #6
   13776:	001a      	movs	r2, r3
   13778:	68fb      	ldr	r3, [r7, #12]
   1377a:	4313      	orrs	r3, r2
   1377c:	60fb      	str	r3, [r7, #12]

	/* Set second value into register_value. */
	register_value |= (time->second << RTC_MODE2_CLOCK_SECOND_Pos);
   1377e:	683b      	ldr	r3, [r7, #0]
   13780:	781b      	ldrb	r3, [r3, #0]
   13782:	001a      	movs	r2, r3
   13784:	68fb      	ldr	r3, [r7, #12]
   13786:	4313      	orrs	r3, r2
   13788:	60fb      	str	r3, [r7, #12]

	return register_value;
   1378a:	68fb      	ldr	r3, [r7, #12]
}
   1378c:	0018      	movs	r0, r3
   1378e:	46bd      	mov	sp, r7
   13790:	b004      	add	sp, #16
   13792:	bd80      	pop	{r7, pc}

00013794 <rtc_calendar_register_value_to_time>:
 */
void rtc_calendar_register_value_to_time(
		struct rtc_module *const module,
		const uint32_t register_value,
		struct rtc_calendar_time *const time)
{
   13794:	b580      	push	{r7, lr}
   13796:	b084      	sub	sp, #16
   13798:	af00      	add	r7, sp, #0
   1379a:	60f8      	str	r0, [r7, #12]
   1379c:	60b9      	str	r1, [r7, #8]
   1379e:	607a      	str	r2, [r7, #4]
	/* Set year plus value of initial year. */
	time->year = ((register_value & RTC_MODE2_CLOCK_YEAR_Msk) >>
   137a0:	68bb      	ldr	r3, [r7, #8]
   137a2:	0e9b      	lsrs	r3, r3, #26
   137a4:	b29a      	uxth	r2, r3
			RTC_MODE2_CLOCK_YEAR_Pos) + module->year_init_value;
   137a6:	68fb      	ldr	r3, [r7, #12]
   137a8:	88db      	ldrh	r3, [r3, #6]
		struct rtc_module *const module,
		const uint32_t register_value,
		struct rtc_calendar_time *const time)
{
	/* Set year plus value of initial year. */
	time->year = ((register_value & RTC_MODE2_CLOCK_YEAR_Msk) >>
   137aa:	18d3      	adds	r3, r2, r3
   137ac:	b29a      	uxth	r2, r3
   137ae:	687b      	ldr	r3, [r7, #4]
   137b0:	80da      	strh	r2, [r3, #6]
			RTC_MODE2_CLOCK_YEAR_Pos) + module->year_init_value;

	/* Set month value into time struct. */
	time->month = ((register_value & RTC_MODE2_CLOCK_MONTH_Msk) >>
   137b2:	68bb      	ldr	r3, [r7, #8]
   137b4:	0d9b      	lsrs	r3, r3, #22
   137b6:	b2db      	uxtb	r3, r3
   137b8:	220f      	movs	r2, #15
   137ba:	4013      	ands	r3, r2
   137bc:	b2da      	uxtb	r2, r3
   137be:	687b      	ldr	r3, [r7, #4]
   137c0:	715a      	strb	r2, [r3, #5]
			RTC_MODE2_CLOCK_MONTH_Pos);

	/* Set day value into time struct. */
	time->day = ((register_value & RTC_MODE2_CLOCK_DAY_Msk) >>
   137c2:	68bb      	ldr	r3, [r7, #8]
   137c4:	0c5b      	lsrs	r3, r3, #17
   137c6:	b2db      	uxtb	r3, r3
   137c8:	221f      	movs	r2, #31
   137ca:	4013      	ands	r3, r2
   137cc:	b2da      	uxtb	r2, r3
   137ce:	687b      	ldr	r3, [r7, #4]
   137d0:	711a      	strb	r2, [r3, #4]
			RTC_MODE2_CLOCK_DAY_Pos);

	if (module->clock_24h) {
   137d2:	68fb      	ldr	r3, [r7, #12]
   137d4:	791b      	ldrb	r3, [r3, #4]
   137d6:	2b00      	cmp	r3, #0
   137d8:	d008      	beq.n	137ec <rtc_calendar_register_value_to_time+0x58>
		/* Set hour in 24h mode. */
		time->hour = ((register_value & RTC_MODE2_CLOCK_HOUR_Msk) >>
   137da:	68bb      	ldr	r3, [r7, #8]
   137dc:	0b1b      	lsrs	r3, r3, #12
   137de:	b2db      	uxtb	r3, r3
   137e0:	221f      	movs	r2, #31
   137e2:	4013      	ands	r3, r2
   137e4:	b2da      	uxtb	r2, r3
   137e6:	687b      	ldr	r3, [r7, #4]
   137e8:	709a      	strb	r2, [r3, #2]
   137ea:	e010      	b.n	1380e <rtc_calendar_register_value_to_time+0x7a>
				RTC_MODE2_CLOCK_HOUR_Pos);
	} else {
		/* Set hour in 12h mode. */
		time->hour = ((register_value &
				(RTC_MODE2_CLOCK_HOUR_Msk & ~RTC_MODE2_CLOCK_HOUR_PM)) >>
   137ec:	68bb      	ldr	r3, [r7, #8]
   137ee:	0b1b      	lsrs	r3, r3, #12
		/* Set hour in 24h mode. */
		time->hour = ((register_value & RTC_MODE2_CLOCK_HOUR_Msk) >>
				RTC_MODE2_CLOCK_HOUR_Pos);
	} else {
		/* Set hour in 12h mode. */
		time->hour = ((register_value &
   137f0:	b2db      	uxtb	r3, r3
   137f2:	220f      	movs	r2, #15
   137f4:	4013      	ands	r3, r2
   137f6:	b2da      	uxtb	r2, r3
   137f8:	687b      	ldr	r3, [r7, #4]
   137fa:	709a      	strb	r2, [r3, #2]
				(RTC_MODE2_CLOCK_HOUR_Msk & ~RTC_MODE2_CLOCK_HOUR_PM)) >>
				RTC_MODE2_CLOCK_HOUR_Pos);

		/* Set pm flag */
		time->pm = ((register_value & RTC_MODE2_CLOCK_HOUR_PM) != 0);
   137fc:	68ba      	ldr	r2, [r7, #8]
   137fe:	2380      	movs	r3, #128	; 0x80
   13800:	025b      	lsls	r3, r3, #9
   13802:	4013      	ands	r3, r2
   13804:	1e5a      	subs	r2, r3, #1
   13806:	4193      	sbcs	r3, r2
   13808:	b2da      	uxtb	r2, r3
   1380a:	687b      	ldr	r3, [r7, #4]
   1380c:	70da      	strb	r2, [r3, #3]
	}

	/* Set minute value into time struct. */
	time->minute = ((register_value & RTC_MODE2_CLOCK_MINUTE_Msk) >>
   1380e:	68bb      	ldr	r3, [r7, #8]
   13810:	099b      	lsrs	r3, r3, #6
   13812:	b2db      	uxtb	r3, r3
   13814:	223f      	movs	r2, #63	; 0x3f
   13816:	4013      	ands	r3, r2
   13818:	b2da      	uxtb	r2, r3
   1381a:	687b      	ldr	r3, [r7, #4]
   1381c:	705a      	strb	r2, [r3, #1]
			RTC_MODE2_CLOCK_MINUTE_Pos);

	/* Set second value into time struct. */
	time->second = ((register_value & RTC_MODE2_CLOCK_SECOND_Msk) >>
   1381e:	68bb      	ldr	r3, [r7, #8]
   13820:	b2db      	uxtb	r3, r3
   13822:	223f      	movs	r2, #63	; 0x3f
   13824:	4013      	ands	r3, r2
   13826:	b2da      	uxtb	r2, r3
   13828:	687b      	ldr	r3, [r7, #4]
   1382a:	701a      	strb	r2, [r3, #0]
			RTC_MODE2_CLOCK_SECOND_Pos);
}
   1382c:	46c0      	nop			; (mov r8, r8)
   1382e:	46bd      	mov	sp, r7
   13830:	b004      	add	sp, #16
   13832:	bd80      	pop	{r7, pc}

00013834 <_rtc_calendar_set_config>:
 * \param[in] config  Pointer to the configuration structure.
 */
static void _rtc_calendar_set_config(
		struct rtc_module *const module,
		const struct rtc_calendar_config *const config)
{
   13834:	b580      	push	{r7, lr}
   13836:	b084      	sub	sp, #16
   13838:	af00      	add	r7, sp, #0
   1383a:	6078      	str	r0, [r7, #4]
   1383c:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   1383e:	687b      	ldr	r3, [r7, #4]
   13840:	681b      	ldr	r3, [r3, #0]
   13842:	60bb      	str	r3, [r7, #8]

	/* Set up temporary register value. */
	uint16_t tmp_reg;

	/* Set to calendar mode and set the prescaler. */
	tmp_reg = RTC_MODE2_CTRL_MODE(2) | config->prescaler;
   13844:	683b      	ldr	r3, [r7, #0]
   13846:	881a      	ldrh	r2, [r3, #0]
   13848:	230e      	movs	r3, #14
   1384a:	18fb      	adds	r3, r7, r3
   1384c:	2108      	movs	r1, #8
   1384e:	430a      	orrs	r2, r1
   13850:	801a      	strh	r2, [r3, #0]

	/* Check clock mode. */
	if (!(config->clock_24h)) {
   13852:	683b      	ldr	r3, [r7, #0]
   13854:	791b      	ldrb	r3, [r3, #4]
   13856:	2201      	movs	r2, #1
   13858:	4053      	eors	r3, r2
   1385a:	b2db      	uxtb	r3, r3
   1385c:	2b00      	cmp	r3, #0
   1385e:	d007      	beq.n	13870 <_rtc_calendar_set_config+0x3c>
		/* Set clock mode 12h. */
		tmp_reg |= RTC_MODE2_CTRL_CLKREP;
   13860:	230e      	movs	r3, #14
   13862:	18fb      	adds	r3, r7, r3
   13864:	220e      	movs	r2, #14
   13866:	18ba      	adds	r2, r7, r2
   13868:	8812      	ldrh	r2, [r2, #0]
   1386a:	2140      	movs	r1, #64	; 0x40
   1386c:	430a      	orrs	r2, r1
   1386e:	801a      	strh	r2, [r3, #0]
	}

	/* Check for clear on compare match. */
	if (config->clear_on_match) {
   13870:	683b      	ldr	r3, [r7, #0]
   13872:	789b      	ldrb	r3, [r3, #2]
   13874:	2b00      	cmp	r3, #0
   13876:	d007      	beq.n	13888 <_rtc_calendar_set_config+0x54>
		/* Set clear on compare match. */
		tmp_reg |= RTC_MODE2_CTRL_MATCHCLR;
   13878:	230e      	movs	r3, #14
   1387a:	18fb      	adds	r3, r7, r3
   1387c:	220e      	movs	r2, #14
   1387e:	18ba      	adds	r2, r7, r2
   13880:	8812      	ldrh	r2, [r2, #0]
   13882:	2180      	movs	r1, #128	; 0x80
   13884:	430a      	orrs	r2, r1
   13886:	801a      	strh	r2, [r3, #0]
	}

	/* Set temporary value to register. */
	rtc_module->MODE2.CTRL.reg = tmp_reg;
   13888:	68bb      	ldr	r3, [r7, #8]
   1388a:	220e      	movs	r2, #14
   1388c:	18ba      	adds	r2, r7, r2
   1388e:	8812      	ldrh	r2, [r2, #0]
   13890:	801a      	strh	r2, [r3, #0]

	/* Check to set continuously clock read update mode. */
	if (config->continuously_update) {
   13892:	683b      	ldr	r3, [r7, #0]
   13894:	78db      	ldrb	r3, [r3, #3]
   13896:	2b00      	cmp	r3, #0
   13898:	d008      	beq.n	138ac <_rtc_calendar_set_config+0x78>
		/* Set continuously mode. */
		rtc_module->MODE2.READREQ.reg |= RTC_READREQ_RCONT;
   1389a:	68bb      	ldr	r3, [r7, #8]
   1389c:	885b      	ldrh	r3, [r3, #2]
   1389e:	b29b      	uxth	r3, r3
   138a0:	2280      	movs	r2, #128	; 0x80
   138a2:	01d2      	lsls	r2, r2, #7
   138a4:	4313      	orrs	r3, r2
   138a6:	b29a      	uxth	r2, r3
   138a8:	68bb      	ldr	r3, [r7, #8]
   138aa:	805a      	strh	r2, [r3, #2]
	}

	/* Set alarm time registers. */
	for (uint8_t i = 0; i < RTC_NUM_OF_ALARMS; i++) {
   138ac:	230d      	movs	r3, #13
   138ae:	18fb      	adds	r3, r7, r3
   138b0:	2200      	movs	r2, #0
   138b2:	701a      	strb	r2, [r3, #0]
   138b4:	e017      	b.n	138e6 <_rtc_calendar_set_config+0xb2>
		rtc_calendar_set_alarm(module, &(config->alarm[i]), (enum rtc_calendar_alarm)i);
   138b6:	230d      	movs	r3, #13
   138b8:	18fb      	adds	r3, r7, r3
   138ba:	781a      	ldrb	r2, [r3, #0]
   138bc:	0013      	movs	r3, r2
   138be:	005b      	lsls	r3, r3, #1
   138c0:	189b      	adds	r3, r3, r2
   138c2:	009b      	lsls	r3, r3, #2
   138c4:	3308      	adds	r3, #8
   138c6:	683a      	ldr	r2, [r7, #0]
   138c8:	18d1      	adds	r1, r2, r3
   138ca:	230d      	movs	r3, #13
   138cc:	18fb      	adds	r3, r7, r3
   138ce:	781a      	ldrb	r2, [r3, #0]
   138d0:	687b      	ldr	r3, [r7, #4]
   138d2:	0018      	movs	r0, r3
   138d4:	4b08      	ldr	r3, [pc, #32]	; (138f8 <_rtc_calendar_set_config+0xc4>)
   138d6:	4798      	blx	r3
		/* Set continuously mode. */
		rtc_module->MODE2.READREQ.reg |= RTC_READREQ_RCONT;
	}

	/* Set alarm time registers. */
	for (uint8_t i = 0; i < RTC_NUM_OF_ALARMS; i++) {
   138d8:	230d      	movs	r3, #13
   138da:	18fb      	adds	r3, r7, r3
   138dc:	781a      	ldrb	r2, [r3, #0]
   138de:	230d      	movs	r3, #13
   138e0:	18fb      	adds	r3, r7, r3
   138e2:	3201      	adds	r2, #1
   138e4:	701a      	strb	r2, [r3, #0]
   138e6:	230d      	movs	r3, #13
   138e8:	18fb      	adds	r3, r7, r3
   138ea:	781b      	ldrb	r3, [r3, #0]
   138ec:	2b00      	cmp	r3, #0
   138ee:	d0e2      	beq.n	138b6 <_rtc_calendar_set_config+0x82>
		rtc_calendar_set_alarm(module, &(config->alarm[i]), (enum rtc_calendar_alarm)i);
	}
}
   138f0:	46c0      	nop			; (mov r8, r8)
   138f2:	46bd      	mov	sp, r7
   138f4:	b004      	add	sp, #16
   138f6:	bd80      	pop	{r7, pc}
   138f8:	00013a2d 	.word	0x00013a2d

000138fc <rtc_calendar_init>:
 */
void rtc_calendar_init(
		struct rtc_module *const module,
		Rtc *const hw,
		const struct rtc_calendar_config *const config)
{
   138fc:	b580      	push	{r7, lr}
   138fe:	b086      	sub	sp, #24
   13900:	af00      	add	r7, sp, #0
   13902:	60f8      	str	r0, [r7, #12]
   13904:	60b9      	str	r1, [r7, #8]
   13906:	607a      	str	r2, [r7, #4]
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
   13908:	68fb      	ldr	r3, [r7, #12]
   1390a:	68ba      	ldr	r2, [r7, #8]
   1390c:	601a      	str	r2, [r3, #0]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_RTC);
   1390e:	2120      	movs	r1, #32
   13910:	2000      	movs	r0, #0
   13912:	4b18      	ldr	r3, [pc, #96]	; (13974 <rtc_calendar_init+0x78>)
   13914:	4798      	blx	r3

	/* Set up GCLK */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
   13916:	2314      	movs	r3, #20
   13918:	18fb      	adds	r3, r7, r3
   1391a:	0018      	movs	r0, r3
   1391c:	4b16      	ldr	r3, [pc, #88]	; (13978 <rtc_calendar_init+0x7c>)
   1391e:	4798      	blx	r3
	gclk_chan_conf.source_generator = GCLK_GENERATOR_2;
   13920:	2314      	movs	r3, #20
   13922:	18fb      	adds	r3, r7, r3
   13924:	2202      	movs	r2, #2
   13926:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(RTC_GCLK_ID, &gclk_chan_conf);
   13928:	2314      	movs	r3, #20
   1392a:	18fb      	adds	r3, r7, r3
   1392c:	0019      	movs	r1, r3
   1392e:	2004      	movs	r0, #4
   13930:	4b12      	ldr	r3, [pc, #72]	; (1397c <rtc_calendar_init+0x80>)
   13932:	4798      	blx	r3
	system_gclk_chan_enable(RTC_GCLK_ID);
   13934:	2004      	movs	r0, #4
   13936:	4b12      	ldr	r3, [pc, #72]	; (13980 <rtc_calendar_init+0x84>)
   13938:	4798      	blx	r3

	/* Reset module to hardware defaults. */
	rtc_calendar_reset(module);
   1393a:	68fb      	ldr	r3, [r7, #12]
   1393c:	0018      	movs	r0, r3
   1393e:	4b11      	ldr	r3, [pc, #68]	; (13984 <rtc_calendar_init+0x88>)
   13940:	4798      	blx	r3

	/* Save conf_struct internally for continued use. */
	module->clock_24h           = config->clock_24h;
   13942:	687b      	ldr	r3, [r7, #4]
   13944:	791a      	ldrb	r2, [r3, #4]
   13946:	68fb      	ldr	r3, [r7, #12]
   13948:	711a      	strb	r2, [r3, #4]
	module->continuously_update = config->continuously_update;
   1394a:	687b      	ldr	r3, [r7, #4]
   1394c:	78da      	ldrb	r2, [r3, #3]
   1394e:	68fb      	ldr	r3, [r7, #12]
   13950:	715a      	strb	r2, [r3, #5]
	module->year_init_value     = config->year_init_value;
   13952:	687b      	ldr	r3, [r7, #4]
   13954:	88da      	ldrh	r2, [r3, #6]
   13956:	68fb      	ldr	r3, [r7, #12]
   13958:	80da      	strh	r2, [r3, #6]

#if (RTC_INST_NUM == 1)
	_rtc_instance[0] = module;
   1395a:	4b0b      	ldr	r3, [pc, #44]	; (13988 <rtc_calendar_init+0x8c>)
   1395c:	68fa      	ldr	r2, [r7, #12]
   1395e:	601a      	str	r2, [r3, #0]
	/* Register this instance for callbacks*/
	_rtc_instance[_rtc_get_inst_index(hw)] = module;
#endif

	/* Set config. */
	_rtc_calendar_set_config(module, config);
   13960:	687a      	ldr	r2, [r7, #4]
   13962:	68fb      	ldr	r3, [r7, #12]
   13964:	0011      	movs	r1, r2
   13966:	0018      	movs	r0, r3
   13968:	4b08      	ldr	r3, [pc, #32]	; (1398c <rtc_calendar_init+0x90>)
   1396a:	4798      	blx	r3
}
   1396c:	46c0      	nop			; (mov r8, r8)
   1396e:	46bd      	mov	sp, r7
   13970:	b006      	add	sp, #24
   13972:	bd80      	pop	{r7, pc}
   13974:	000135d5 	.word	0x000135d5
   13978:	000135bd 	.word	0x000135bd
   1397c:	000169e1 	.word	0x000169e1
   13980:	00016a25 	.word	0x00016a25
   13984:	000136c9 	.word	0x000136c9
   13988:	20004ba8 	.word	0x20004ba8
   1398c:	00013835 	.word	0x00013835

00013990 <rtc_calendar_set_time>:
 * \param[in] time  The time to set in the calendar
 */
void rtc_calendar_set_time(
		struct rtc_module *const module,
		const struct rtc_calendar_time *const time)
{
   13990:	b580      	push	{r7, lr}
   13992:	b084      	sub	sp, #16
   13994:	af00      	add	r7, sp, #0
   13996:	6078      	str	r0, [r7, #4]
   13998:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   1399a:	687b      	ldr	r3, [r7, #4]
   1399c:	681b      	ldr	r3, [r3, #0]
   1399e:	60fb      	str	r3, [r7, #12]

	uint32_t register_value = rtc_calendar_time_to_register_value(module, time);
   139a0:	683a      	ldr	r2, [r7, #0]
   139a2:	687b      	ldr	r3, [r7, #4]
   139a4:	0011      	movs	r1, r2
   139a6:	0018      	movs	r0, r3
   139a8:	4b08      	ldr	r3, [pc, #32]	; (139cc <rtc_calendar_set_time+0x3c>)
   139aa:	4798      	blx	r3
   139ac:	0003      	movs	r3, r0
   139ae:	60bb      	str	r3, [r7, #8]

	while (rtc_calendar_is_syncing(module)) {
   139b0:	46c0      	nop			; (mov r8, r8)
   139b2:	687b      	ldr	r3, [r7, #4]
   139b4:	0018      	movs	r0, r3
   139b6:	4b06      	ldr	r3, [pc, #24]	; (139d0 <rtc_calendar_set_time+0x40>)
   139b8:	4798      	blx	r3
   139ba:	1e03      	subs	r3, r0, #0
   139bc:	d1f9      	bne.n	139b2 <rtc_calendar_set_time+0x22>
		/* Wait for synchronization */
	}

	/* Write value to register. */
	rtc_module->MODE2.CLOCK.reg = register_value;
   139be:	68fb      	ldr	r3, [r7, #12]
   139c0:	68ba      	ldr	r2, [r7, #8]
   139c2:	611a      	str	r2, [r3, #16]
}
   139c4:	46c0      	nop			; (mov r8, r8)
   139c6:	46bd      	mov	sp, r7
   139c8:	b004      	add	sp, #16
   139ca:	bd80      	pop	{r7, pc}
   139cc:	0001370d 	.word	0x0001370d
   139d0:	00013631 	.word	0x00013631

000139d4 <rtc_calendar_get_time>:
 * \param[out] time  Pointer to value that will be filled with current time
 */
void rtc_calendar_get_time(
		struct rtc_module *const module,
		struct rtc_calendar_time *const time)
{
   139d4:	b580      	push	{r7, lr}
   139d6:	b084      	sub	sp, #16
   139d8:	af00      	add	r7, sp, #0
   139da:	6078      	str	r0, [r7, #4]
   139dc:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   139de:	687b      	ldr	r3, [r7, #4]
   139e0:	681b      	ldr	r3, [r3, #0]
   139e2:	60fb      	str	r3, [r7, #12]

	/* Change of read method based on value of continuously_update value in
	 * the configuration structure. */
	if (!(module->continuously_update)) {
   139e4:	687b      	ldr	r3, [r7, #4]
   139e6:	795b      	ldrb	r3, [r3, #5]
   139e8:	2201      	movs	r2, #1
   139ea:	4053      	eors	r3, r2
   139ec:	b2db      	uxtb	r3, r3
   139ee:	2b00      	cmp	r3, #0
   139f0:	d009      	beq.n	13a06 <rtc_calendar_get_time+0x32>
		/* Request read on CLOCK register. */
		rtc_module->MODE2.READREQ.reg = RTC_READREQ_RREQ;
   139f2:	68fb      	ldr	r3, [r7, #12]
   139f4:	4a0a      	ldr	r2, [pc, #40]	; (13a20 <rtc_calendar_get_time+0x4c>)
   139f6:	805a      	strh	r2, [r3, #2]

		while (rtc_calendar_is_syncing(module)) {
   139f8:	46c0      	nop			; (mov r8, r8)
   139fa:	687b      	ldr	r3, [r7, #4]
   139fc:	0018      	movs	r0, r3
   139fe:	4b09      	ldr	r3, [pc, #36]	; (13a24 <rtc_calendar_get_time+0x50>)
   13a00:	4798      	blx	r3
   13a02:	1e03      	subs	r3, r0, #0
   13a04:	d1f9      	bne.n	139fa <rtc_calendar_get_time+0x26>
			/* Wait for synchronization */
		}
	}

	/* Read value. */
	uint32_t register_value = rtc_module->MODE2.CLOCK.reg;
   13a06:	68fb      	ldr	r3, [r7, #12]
   13a08:	691b      	ldr	r3, [r3, #16]
   13a0a:	60bb      	str	r3, [r7, #8]

	/* Convert value to time structure. */
	rtc_calendar_register_value_to_time(module, register_value, time);
   13a0c:	683a      	ldr	r2, [r7, #0]
   13a0e:	68b9      	ldr	r1, [r7, #8]
   13a10:	687b      	ldr	r3, [r7, #4]
   13a12:	0018      	movs	r0, r3
   13a14:	4b04      	ldr	r3, [pc, #16]	; (13a28 <rtc_calendar_get_time+0x54>)
   13a16:	4798      	blx	r3
}
   13a18:	46c0      	nop			; (mov r8, r8)
   13a1a:	46bd      	mov	sp, r7
   13a1c:	b004      	add	sp, #16
   13a1e:	bd80      	pop	{r7, pc}
   13a20:	ffff8000 	.word	0xffff8000
   13a24:	00013631 	.word	0x00013631
   13a28:	00013795 	.word	0x00013795

00013a2c <rtc_calendar_set_alarm>:
 */
enum status_code rtc_calendar_set_alarm(
		struct rtc_module *const module,
		const struct rtc_calendar_alarm_time *const alarm,
		const enum rtc_calendar_alarm alarm_index)
{
   13a2c:	b580      	push	{r7, lr}
   13a2e:	b086      	sub	sp, #24
   13a30:	af00      	add	r7, sp, #0
   13a32:	60f8      	str	r0, [r7, #12]
   13a34:	60b9      	str	r1, [r7, #8]
   13a36:	1dfb      	adds	r3, r7, #7
   13a38:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   13a3a:	68fb      	ldr	r3, [r7, #12]
   13a3c:	681b      	ldr	r3, [r3, #0]
   13a3e:	617b      	str	r3, [r7, #20]

	/* Sanity check. */
	if ((uint32_t)alarm_index > RTC_NUM_OF_ALARMS) {
   13a40:	1dfb      	adds	r3, r7, #7
   13a42:	781b      	ldrb	r3, [r3, #0]
   13a44:	2b01      	cmp	r3, #1
   13a46:	d901      	bls.n	13a4c <rtc_calendar_set_alarm+0x20>
		return STATUS_ERR_INVALID_ARG;
   13a48:	2317      	movs	r3, #23
   13a4a:	e021      	b.n	13a90 <rtc_calendar_set_alarm+0x64>
	}

	/* Get register_value from time. */
	uint32_t register_value = rtc_calendar_time_to_register_value(module, &(alarm->time));
   13a4c:	68ba      	ldr	r2, [r7, #8]
   13a4e:	68fb      	ldr	r3, [r7, #12]
   13a50:	0011      	movs	r1, r2
   13a52:	0018      	movs	r0, r3
   13a54:	4b10      	ldr	r3, [pc, #64]	; (13a98 <rtc_calendar_set_alarm+0x6c>)
   13a56:	4798      	blx	r3
   13a58:	0003      	movs	r3, r0
   13a5a:	613b      	str	r3, [r7, #16]

	while (rtc_calendar_is_syncing(module)) {
   13a5c:	46c0      	nop			; (mov r8, r8)
   13a5e:	68fb      	ldr	r3, [r7, #12]
   13a60:	0018      	movs	r0, r3
   13a62:	4b0e      	ldr	r3, [pc, #56]	; (13a9c <rtc_calendar_set_alarm+0x70>)
   13a64:	4798      	blx	r3
   13a66:	1e03      	subs	r3, r0, #0
   13a68:	d1f9      	bne.n	13a5e <rtc_calendar_set_alarm+0x32>
		/* Wait for synchronization */
	}

	/* Set alarm value. */
	rtc_module->MODE2.Mode2Alarm[alarm_index].ALARM.reg = register_value;
   13a6a:	1dfb      	adds	r3, r7, #7
   13a6c:	781a      	ldrb	r2, [r3, #0]
   13a6e:	697b      	ldr	r3, [r7, #20]
   13a70:	3203      	adds	r2, #3
   13a72:	00d2      	lsls	r2, r2, #3
   13a74:	6939      	ldr	r1, [r7, #16]
   13a76:	50d1      	str	r1, [r2, r3]

	/* Set alarm mask */
	rtc_module->MODE2.Mode2Alarm[alarm_index].MASK.reg = alarm->mask;
   13a78:	1dfb      	adds	r3, r7, #7
   13a7a:	781b      	ldrb	r3, [r3, #0]
   13a7c:	68ba      	ldr	r2, [r7, #8]
   13a7e:	7a91      	ldrb	r1, [r2, #10]
   13a80:	697a      	ldr	r2, [r7, #20]
   13a82:	3303      	adds	r3, #3
   13a84:	00db      	lsls	r3, r3, #3
   13a86:	18d3      	adds	r3, r2, r3
   13a88:	3304      	adds	r3, #4
   13a8a:	1c0a      	adds	r2, r1, #0
   13a8c:	701a      	strb	r2, [r3, #0]

	return STATUS_OK;
   13a8e:	2300      	movs	r3, #0
}
   13a90:	0018      	movs	r0, r3
   13a92:	46bd      	mov	sp, r7
   13a94:	b006      	add	sp, #24
   13a96:	bd80      	pop	{r7, pc}
   13a98:	0001370d 	.word	0x0001370d
   13a9c:	00013631 	.word	0x00013631

00013aa0 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
   13aa0:	b580      	push	{r7, lr}
   13aa2:	b082      	sub	sp, #8
   13aa4:	af00      	add	r7, sp, #0
   13aa6:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
   13aa8:	687b      	ldr	r3, [r7, #4]
   13aaa:	2200      	movs	r2, #0
   13aac:	701a      	strb	r2, [r3, #0]
}
   13aae:	46c0      	nop			; (mov r8, r8)
   13ab0:	46bd      	mov	sp, r7
   13ab2:	b002      	add	sp, #8
   13ab4:	bd80      	pop	{r7, pc}
   13ab6:	46c0      	nop			; (mov r8, r8)

00013ab8 <long_division>:
/**
 * \internal Calculate 64 bit division, ref can be found in
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
   13ab8:	b5f0      	push	{r4, r5, r6, r7, lr}
   13aba:	b08d      	sub	sp, #52	; 0x34
   13abc:	af00      	add	r7, sp, #0
   13abe:	60b8      	str	r0, [r7, #8]
   13ac0:	60f9      	str	r1, [r7, #12]
   13ac2:	603a      	str	r2, [r7, #0]
   13ac4:	607b      	str	r3, [r7, #4]
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
   13ac6:	2300      	movs	r3, #0
   13ac8:	2400      	movs	r4, #0
   13aca:	623b      	str	r3, [r7, #32]
   13acc:	627c      	str	r4, [r7, #36]	; 0x24
   13ace:	2300      	movs	r3, #0
   13ad0:	2400      	movs	r4, #0
   13ad2:	61bb      	str	r3, [r7, #24]
   13ad4:	61fc      	str	r4, [r7, #28]
	for (i = 63; i >= 0; i--) {
   13ad6:	233f      	movs	r3, #63	; 0x3f
   13ad8:	62fb      	str	r3, [r7, #44]	; 0x2c
   13ada:	e053      	b.n	13b84 <long_division+0xcc>
		bit_shift = (uint64_t)1 << i;
   13adc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   13ade:	3b20      	subs	r3, #32
   13ae0:	2b00      	cmp	r3, #0
   13ae2:	db04      	blt.n	13aee <long_division+0x36>
   13ae4:	2201      	movs	r2, #1
   13ae6:	409a      	lsls	r2, r3
   13ae8:	0013      	movs	r3, r2
   13aea:	617b      	str	r3, [r7, #20]
   13aec:	e00b      	b.n	13b06 <long_division+0x4e>
   13aee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   13af0:	2220      	movs	r2, #32
   13af2:	1ad3      	subs	r3, r2, r3
   13af4:	2201      	movs	r2, #1
   13af6:	40da      	lsrs	r2, r3
   13af8:	0013      	movs	r3, r2
   13afa:	2100      	movs	r1, #0
   13afc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   13afe:	4091      	lsls	r1, r2
   13b00:	000a      	movs	r2, r1
   13b02:	4313      	orrs	r3, r2
   13b04:	617b      	str	r3, [r7, #20]
   13b06:	2201      	movs	r2, #1
   13b08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   13b0a:	409a      	lsls	r2, r3
   13b0c:	0013      	movs	r3, r2
   13b0e:	613b      	str	r3, [r7, #16]

		r = r << 1;
   13b10:	69bb      	ldr	r3, [r7, #24]
   13b12:	69fc      	ldr	r4, [r7, #28]
   13b14:	18db      	adds	r3, r3, r3
   13b16:	4164      	adcs	r4, r4
   13b18:	61bb      	str	r3, [r7, #24]
   13b1a:	61fc      	str	r4, [r7, #28]

		if (n & bit_shift) {
   13b1c:	68bb      	ldr	r3, [r7, #8]
   13b1e:	693a      	ldr	r2, [r7, #16]
   13b20:	401a      	ands	r2, r3
   13b22:	0015      	movs	r5, r2
   13b24:	68fb      	ldr	r3, [r7, #12]
   13b26:	697a      	ldr	r2, [r7, #20]
   13b28:	401a      	ands	r2, r3
   13b2a:	0016      	movs	r6, r2
   13b2c:	002b      	movs	r3, r5
   13b2e:	4333      	orrs	r3, r6
   13b30:	d007      	beq.n	13b42 <long_division+0x8a>
			r |= 0x01;
   13b32:	69bb      	ldr	r3, [r7, #24]
   13b34:	2201      	movs	r2, #1
   13b36:	4313      	orrs	r3, r2
   13b38:	61bb      	str	r3, [r7, #24]
   13b3a:	69fb      	ldr	r3, [r7, #28]
   13b3c:	2200      	movs	r2, #0
   13b3e:	4313      	orrs	r3, r2
   13b40:	61fb      	str	r3, [r7, #28]
		}

		if (r >= d) {
   13b42:	687a      	ldr	r2, [r7, #4]
   13b44:	69fb      	ldr	r3, [r7, #28]
   13b46:	429a      	cmp	r2, r3
   13b48:	d819      	bhi.n	13b7e <long_division+0xc6>
   13b4a:	687a      	ldr	r2, [r7, #4]
   13b4c:	69fb      	ldr	r3, [r7, #28]
   13b4e:	429a      	cmp	r2, r3
   13b50:	d103      	bne.n	13b5a <long_division+0xa2>
   13b52:	683a      	ldr	r2, [r7, #0]
   13b54:	69bb      	ldr	r3, [r7, #24]
   13b56:	429a      	cmp	r2, r3
   13b58:	d811      	bhi.n	13b7e <long_division+0xc6>
			r = r - d;
   13b5a:	69b9      	ldr	r1, [r7, #24]
   13b5c:	69fa      	ldr	r2, [r7, #28]
   13b5e:	683b      	ldr	r3, [r7, #0]
   13b60:	687c      	ldr	r4, [r7, #4]
   13b62:	1ac9      	subs	r1, r1, r3
   13b64:	41a2      	sbcs	r2, r4
   13b66:	000b      	movs	r3, r1
   13b68:	0014      	movs	r4, r2
   13b6a:	61bb      	str	r3, [r7, #24]
   13b6c:	61fc      	str	r4, [r7, #28]
			q |= bit_shift;
   13b6e:	6a3a      	ldr	r2, [r7, #32]
   13b70:	693b      	ldr	r3, [r7, #16]
   13b72:	4313      	orrs	r3, r2
   13b74:	623b      	str	r3, [r7, #32]
   13b76:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   13b78:	697b      	ldr	r3, [r7, #20]
   13b7a:	4313      	orrs	r3, r2
   13b7c:	627b      	str	r3, [r7, #36]	; 0x24
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
   13b7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   13b80:	3b01      	subs	r3, #1
   13b82:	62fb      	str	r3, [r7, #44]	; 0x2c
   13b84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   13b86:	2b00      	cmp	r3, #0
   13b88:	daa8      	bge.n	13adc <long_division+0x24>
			r = r - d;
			q |= bit_shift;
		}
	}

	return q;
   13b8a:	6a3b      	ldr	r3, [r7, #32]
   13b8c:	6a7c      	ldr	r4, [r7, #36]	; 0x24
}
   13b8e:	0018      	movs	r0, r3
   13b90:	0021      	movs	r1, r4
   13b92:	46bd      	mov	sp, r7
   13b94:	b00d      	add	sp, #52	; 0x34
   13b96:	bdf0      	pop	{r4, r5, r6, r7, pc}

00013b98 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
   13b98:	b580      	push	{r7, lr}
   13b9a:	b086      	sub	sp, #24
   13b9c:	af00      	add	r7, sp, #0
   13b9e:	60f8      	str	r0, [r7, #12]
   13ba0:	60b9      	str	r1, [r7, #8]
   13ba2:	607a      	str	r2, [r7, #4]
	/* Baud value variable */
	uint16_t baud_calculated = 0;
   13ba4:	2316      	movs	r3, #22
   13ba6:	18fb      	adds	r3, r7, r3
   13ba8:	2200      	movs	r2, #0
   13baa:	801a      	strh	r2, [r3, #0]
	uint32_t clock_value = external_clock;
   13bac:	68bb      	ldr	r3, [r7, #8]
   13bae:	613b      	str	r3, [r7, #16]


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
   13bb0:	68bb      	ldr	r3, [r7, #8]
   13bb2:	085a      	lsrs	r2, r3, #1
   13bb4:	68fb      	ldr	r3, [r7, #12]
   13bb6:	429a      	cmp	r2, r3
   13bb8:	d201      	bcs.n	13bbe <_sercom_get_sync_baud_val+0x26>
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
   13bba:	2340      	movs	r3, #64	; 0x40
   13bbc:	e026      	b.n	13c0c <_sercom_get_sync_baud_val+0x74>
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
   13bbe:	68bb      	ldr	r3, [r7, #8]
   13bc0:	085b      	lsrs	r3, r3, #1
   13bc2:	613b      	str	r3, [r7, #16]
	while (clock_value >= baudrate) {
   13bc4:	e00a      	b.n	13bdc <_sercom_get_sync_baud_val+0x44>
		clock_value = clock_value - baudrate;
   13bc6:	693a      	ldr	r2, [r7, #16]
   13bc8:	68fb      	ldr	r3, [r7, #12]
   13bca:	1ad3      	subs	r3, r2, r3
   13bcc:	613b      	str	r3, [r7, #16]
		baud_calculated++;
   13bce:	2316      	movs	r3, #22
   13bd0:	18fb      	adds	r3, r7, r3
   13bd2:	881a      	ldrh	r2, [r3, #0]
   13bd4:	2316      	movs	r3, #22
   13bd6:	18fb      	adds	r3, r7, r3
   13bd8:	3201      	adds	r2, #1
   13bda:	801a      	strh	r2, [r3, #0]
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
   13bdc:	693a      	ldr	r2, [r7, #16]
   13bde:	68fb      	ldr	r3, [r7, #12]
   13be0:	429a      	cmp	r2, r3
   13be2:	d2f0      	bcs.n	13bc6 <_sercom_get_sync_baud_val+0x2e>
		clock_value = clock_value - baudrate;
		baud_calculated++;
	}
	baud_calculated = baud_calculated - 1;
   13be4:	2316      	movs	r3, #22
   13be6:	18fb      	adds	r3, r7, r3
   13be8:	2216      	movs	r2, #22
   13bea:	18ba      	adds	r2, r7, r2
   13bec:	8812      	ldrh	r2, [r2, #0]
   13bee:	3a01      	subs	r2, #1
   13bf0:	801a      	strh	r2, [r3, #0]

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
   13bf2:	2316      	movs	r3, #22
   13bf4:	18fb      	adds	r3, r7, r3
   13bf6:	881b      	ldrh	r3, [r3, #0]
   13bf8:	2bff      	cmp	r3, #255	; 0xff
   13bfa:	d901      	bls.n	13c00 <_sercom_get_sync_baud_val+0x68>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
   13bfc:	2340      	movs	r3, #64	; 0x40
   13bfe:	e005      	b.n	13c0c <_sercom_get_sync_baud_val+0x74>
	} else {
		*baudvalue = baud_calculated;
   13c00:	687b      	ldr	r3, [r7, #4]
   13c02:	2216      	movs	r2, #22
   13c04:	18ba      	adds	r2, r7, r2
   13c06:	8812      	ldrh	r2, [r2, #0]
   13c08:	801a      	strh	r2, [r3, #0]
		return STATUS_OK;
   13c0a:	2300      	movs	r3, #0
	}
}
   13c0c:	0018      	movs	r0, r3
   13c0e:	46bd      	mov	sp, r7
   13c10:	b006      	add	sp, #24
   13c12:	bd80      	pop	{r7, pc}

00013c14 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
   13c14:	b5f0      	push	{r4, r5, r6, r7, lr}
   13c16:	b09d      	sub	sp, #116	; 0x74
   13c18:	af00      	add	r7, sp, #0
   13c1a:	63f8      	str	r0, [r7, #60]	; 0x3c
   13c1c:	63b9      	str	r1, [r7, #56]	; 0x38
   13c1e:	637a      	str	r2, [r7, #52]	; 0x34
   13c20:	2233      	movs	r2, #51	; 0x33
   13c22:	18ba      	adds	r2, r7, r2
   13c24:	7013      	strb	r3, [r2, #0]
	/* Temporary variables  */
	uint64_t ratio = 0;
   13c26:	2300      	movs	r3, #0
   13c28:	2400      	movs	r4, #0
   13c2a:	65bb      	str	r3, [r7, #88]	; 0x58
   13c2c:	65fc      	str	r4, [r7, #92]	; 0x5c
	uint64_t scale = 0;
   13c2e:	2300      	movs	r3, #0
   13c30:	2400      	movs	r4, #0
   13c32:	653b      	str	r3, [r7, #80]	; 0x50
   13c34:	657c      	str	r4, [r7, #84]	; 0x54
	uint64_t baud_calculated = 0;
   13c36:	2300      	movs	r3, #0
   13c38:	2400      	movs	r4, #0
   13c3a:	66bb      	str	r3, [r7, #104]	; 0x68
   13c3c:	66fc      	str	r4, [r7, #108]	; 0x6c
	uint8_t baud_fp;
	uint32_t baud_int = 0;
   13c3e:	2300      	movs	r3, #0
   13c40:	663b      	str	r3, [r7, #96]	; 0x60
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
   13c42:	2358      	movs	r3, #88	; 0x58
   13c44:	2230      	movs	r2, #48	; 0x30
   13c46:	4694      	mov	ip, r2
   13c48:	44bc      	add	ip, r7
   13c4a:	4463      	add	r3, ip
   13c4c:	781a      	ldrb	r2, [r3, #0]
   13c4e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   13c50:	435a      	muls	r2, r3
   13c52:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   13c54:	429a      	cmp	r2, r3
   13c56:	d901      	bls.n	13c5c <_sercom_get_async_baud_val+0x48>
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
   13c58:	2340      	movs	r3, #64	; 0x40
   13c5a:	e0c6      	b.n	13dea <_sercom_get_async_baud_val+0x1d6>
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
   13c5c:	2333      	movs	r3, #51	; 0x33
   13c5e:	18fb      	adds	r3, r7, r3
   13c60:	781b      	ldrb	r3, [r3, #0]
   13c62:	2b00      	cmp	r3, #0
   13c64:	d13d      	bne.n	13ce2 <_sercom_get_async_baud_val+0xce>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
   13c66:	2358      	movs	r3, #88	; 0x58
   13c68:	2230      	movs	r2, #48	; 0x30
   13c6a:	4694      	mov	ip, r2
   13c6c:	44bc      	add	ip, r7
   13c6e:	4463      	add	r3, ip
   13c70:	781b      	ldrb	r3, [r3, #0]
   13c72:	b2db      	uxtb	r3, r3
   13c74:	613b      	str	r3, [r7, #16]
   13c76:	2300      	movs	r3, #0
   13c78:	617b      	str	r3, [r7, #20]
   13c7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   13c7c:	60bb      	str	r3, [r7, #8]
   13c7e:	2300      	movs	r3, #0
   13c80:	60fb      	str	r3, [r7, #12]
   13c82:	4c5c      	ldr	r4, [pc, #368]	; (13df4 <_sercom_get_async_baud_val+0x1e0>)
   13c84:	68ba      	ldr	r2, [r7, #8]
   13c86:	68fb      	ldr	r3, [r7, #12]
   13c88:	6938      	ldr	r0, [r7, #16]
   13c8a:	6979      	ldr	r1, [r7, #20]
   13c8c:	47a0      	blx	r4
   13c8e:	0003      	movs	r3, r0
   13c90:	000c      	movs	r4, r1
   13c92:	001b      	movs	r3, r3
   13c94:	64fb      	str	r3, [r7, #76]	; 0x4c
   13c96:	2300      	movs	r3, #0
   13c98:	64bb      	str	r3, [r7, #72]	; 0x48
		ratio = long_division(temp1, peripheral_clock);
   13c9a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   13c9c:	603b      	str	r3, [r7, #0]
   13c9e:	2300      	movs	r3, #0
   13ca0:	607b      	str	r3, [r7, #4]
   13ca2:	6cb8      	ldr	r0, [r7, #72]	; 0x48
   13ca4:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   13ca6:	683a      	ldr	r2, [r7, #0]
   13ca8:	687b      	ldr	r3, [r7, #4]
   13caa:	4c53      	ldr	r4, [pc, #332]	; (13df8 <_sercom_get_async_baud_val+0x1e4>)
   13cac:	47a0      	blx	r4
   13cae:	0003      	movs	r3, r0
   13cb0:	000c      	movs	r4, r1
   13cb2:	65bb      	str	r3, [r7, #88]	; 0x58
   13cb4:	65fc      	str	r4, [r7, #92]	; 0x5c
		scale = ((uint64_t)1 << SHIFT) - ratio;
   13cb6:	2100      	movs	r1, #0
   13cb8:	2201      	movs	r2, #1
   13cba:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   13cbc:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
   13cbe:	1ac9      	subs	r1, r1, r3
   13cc0:	41a2      	sbcs	r2, r4
   13cc2:	000b      	movs	r3, r1
   13cc4:	0014      	movs	r4, r2
   13cc6:	653b      	str	r3, [r7, #80]	; 0x50
   13cc8:	657c      	str	r4, [r7, #84]	; 0x54
		baud_calculated = (65536 * scale) >> SHIFT;
   13cca:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   13ccc:	0c1b      	lsrs	r3, r3, #16
   13cce:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   13cd0:	0416      	lsls	r6, r2, #16
   13cd2:	431e      	orrs	r6, r3
   13cd4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   13cd6:	041d      	lsls	r5, r3, #16
   13cd8:	0033      	movs	r3, r6
   13cda:	66bb      	str	r3, [r7, #104]	; 0x68
   13cdc:	2300      	movs	r3, #0
   13cde:	66fb      	str	r3, [r7, #108]	; 0x6c
   13ce0:	e07d      	b.n	13dde <_sercom_get_async_baud_val+0x1ca>
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
   13ce2:	2333      	movs	r3, #51	; 0x33
   13ce4:	18fb      	adds	r3, r7, r3
   13ce6:	781b      	ldrb	r3, [r3, #0]
   13ce8:	2b01      	cmp	r3, #1
   13cea:	d000      	beq.n	13cee <_sercom_get_async_baud_val+0xda>
   13cec:	e077      	b.n	13dde <_sercom_get_async_baud_val+0x1ca>
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
   13cee:	2337      	movs	r3, #55	; 0x37
   13cf0:	2230      	movs	r2, #48	; 0x30
   13cf2:	4694      	mov	ip, r2
   13cf4:	44bc      	add	ip, r7
   13cf6:	4463      	add	r3, ip
   13cf8:	2200      	movs	r2, #0
   13cfa:	701a      	strb	r2, [r3, #0]
   13cfc:	e04e      	b.n	13d9c <_sercom_get_async_baud_val+0x188>
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
   13cfe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   13d00:	62bb      	str	r3, [r7, #40]	; 0x28
   13d02:	2300      	movs	r3, #0
   13d04:	62fb      	str	r3, [r7, #44]	; 0x2c
   13d06:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   13d08:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   13d0a:	0003      	movs	r3, r0
   13d0c:	0f5b      	lsrs	r3, r3, #29
   13d0e:	000a      	movs	r2, r1
   13d10:	00d2      	lsls	r2, r2, #3
   13d12:	4313      	orrs	r3, r2
   13d14:	64fb      	str	r3, [r7, #76]	; 0x4c
   13d16:	0003      	movs	r3, r0
   13d18:	00db      	lsls	r3, r3, #3
   13d1a:	64bb      	str	r3, [r7, #72]	; 0x48
			temp2 = ((uint64_t)baudrate * sample_num);
   13d1c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   13d1e:	623b      	str	r3, [r7, #32]
   13d20:	2300      	movs	r3, #0
   13d22:	627b      	str	r3, [r7, #36]	; 0x24
   13d24:	2358      	movs	r3, #88	; 0x58
   13d26:	2230      	movs	r2, #48	; 0x30
   13d28:	4694      	mov	ip, r2
   13d2a:	44bc      	add	ip, r7
   13d2c:	4463      	add	r3, ip
   13d2e:	781b      	ldrb	r3, [r3, #0]
   13d30:	b2db      	uxtb	r3, r3
   13d32:	61bb      	str	r3, [r7, #24]
   13d34:	2300      	movs	r3, #0
   13d36:	61fb      	str	r3, [r7, #28]
   13d38:	4c2e      	ldr	r4, [pc, #184]	; (13df4 <_sercom_get_async_baud_val+0x1e0>)
   13d3a:	69ba      	ldr	r2, [r7, #24]
   13d3c:	69fb      	ldr	r3, [r7, #28]
   13d3e:	6a38      	ldr	r0, [r7, #32]
   13d40:	6a79      	ldr	r1, [r7, #36]	; 0x24
   13d42:	47a0      	blx	r4
   13d44:	0003      	movs	r3, r0
   13d46:	000c      	movs	r4, r1
   13d48:	643b      	str	r3, [r7, #64]	; 0x40
   13d4a:	647c      	str	r4, [r7, #68]	; 0x44
			baud_int = long_division(temp1, temp2);
   13d4c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   13d4e:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   13d50:	6cb8      	ldr	r0, [r7, #72]	; 0x48
   13d52:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   13d54:	001a      	movs	r2, r3
   13d56:	0023      	movs	r3, r4
   13d58:	4c27      	ldr	r4, [pc, #156]	; (13df8 <_sercom_get_async_baud_val+0x1e4>)
   13d5a:	47a0      	blx	r4
   13d5c:	0003      	movs	r3, r0
   13d5e:	000c      	movs	r4, r1
   13d60:	663b      	str	r3, [r7, #96]	; 0x60
			baud_int -= baud_fp;
   13d62:	2337      	movs	r3, #55	; 0x37
   13d64:	2230      	movs	r2, #48	; 0x30
   13d66:	4694      	mov	ip, r2
   13d68:	44bc      	add	ip, r7
   13d6a:	4463      	add	r3, ip
   13d6c:	781b      	ldrb	r3, [r3, #0]
   13d6e:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   13d70:	1ad3      	subs	r3, r2, r3
   13d72:	663b      	str	r3, [r7, #96]	; 0x60
			baud_int = baud_int / BAUD_FP_MAX;
   13d74:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   13d76:	08db      	lsrs	r3, r3, #3
   13d78:	663b      	str	r3, [r7, #96]	; 0x60
			if(baud_int < BAUD_INT_MAX) {
   13d7a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   13d7c:	4a1f      	ldr	r2, [pc, #124]	; (13dfc <_sercom_get_async_baud_val+0x1e8>)
   13d7e:	4293      	cmp	r3, r2
   13d80:	d915      	bls.n	13dae <_sercom_get_async_baud_val+0x19a>
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
   13d82:	2337      	movs	r3, #55	; 0x37
   13d84:	2230      	movs	r2, #48	; 0x30
   13d86:	4694      	mov	ip, r2
   13d88:	44bc      	add	ip, r7
   13d8a:	4463      	add	r3, ip
   13d8c:	781a      	ldrb	r2, [r3, #0]
   13d8e:	2337      	movs	r3, #55	; 0x37
   13d90:	2130      	movs	r1, #48	; 0x30
   13d92:	468c      	mov	ip, r1
   13d94:	44bc      	add	ip, r7
   13d96:	4463      	add	r3, ip
   13d98:	3201      	adds	r2, #1
   13d9a:	701a      	strb	r2, [r3, #0]
   13d9c:	2337      	movs	r3, #55	; 0x37
   13d9e:	2230      	movs	r2, #48	; 0x30
   13da0:	4694      	mov	ip, r2
   13da2:	44bc      	add	ip, r7
   13da4:	4463      	add	r3, ip
   13da6:	781b      	ldrb	r3, [r3, #0]
   13da8:	2b07      	cmp	r3, #7
   13daa:	d9a8      	bls.n	13cfe <_sercom_get_async_baud_val+0xea>
   13dac:	e000      	b.n	13db0 <_sercom_get_async_baud_val+0x19c>
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
				break;
   13dae:	46c0      	nop			; (mov r8, r8)
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
   13db0:	2337      	movs	r3, #55	; 0x37
   13db2:	2230      	movs	r2, #48	; 0x30
   13db4:	4694      	mov	ip, r2
   13db6:	44bc      	add	ip, r7
   13db8:	4463      	add	r3, ip
   13dba:	781b      	ldrb	r3, [r3, #0]
   13dbc:	2b08      	cmp	r3, #8
   13dbe:	d101      	bne.n	13dc4 <_sercom_get_async_baud_val+0x1b0>
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
   13dc0:	2340      	movs	r3, #64	; 0x40
   13dc2:	e012      	b.n	13dea <_sercom_get_async_baud_val+0x1d6>
		}
		baud_calculated = baud_int | (baud_fp << 13);
   13dc4:	2337      	movs	r3, #55	; 0x37
   13dc6:	2230      	movs	r2, #48	; 0x30
   13dc8:	4694      	mov	ip, r2
   13dca:	44bc      	add	ip, r7
   13dcc:	4463      	add	r3, ip
   13dce:	781b      	ldrb	r3, [r3, #0]
   13dd0:	035b      	lsls	r3, r3, #13
   13dd2:	001a      	movs	r2, r3
   13dd4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   13dd6:	4313      	orrs	r3, r2
   13dd8:	66bb      	str	r3, [r7, #104]	; 0x68
   13dda:	2300      	movs	r3, #0
   13ddc:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	*baudval = baud_calculated;
   13dde:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13de0:	6efc      	ldr	r4, [r7, #108]	; 0x6c
   13de2:	b29a      	uxth	r2, r3
   13de4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   13de6:	801a      	strh	r2, [r3, #0]
	return STATUS_OK;
   13de8:	2300      	movs	r3, #0
}
   13dea:	0018      	movs	r0, r3
   13dec:	46bd      	mov	sp, r7
   13dee:	b01d      	add	sp, #116	; 0x74
   13df0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13df2:	46c0      	nop			; (mov r8, r8)
   13df4:	0001d7b1 	.word	0x0001d7b1
   13df8:	00013ab9 	.word	0x00013ab9
   13dfc:	00001fff 	.word	0x00001fff

00013e00 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
   13e00:	b580      	push	{r7, lr}
   13e02:	b084      	sub	sp, #16
   13e04:	af00      	add	r7, sp, #0
   13e06:	0002      	movs	r2, r0
   13e08:	1dfb      	adds	r3, r7, #7
   13e0a:	701a      	strb	r2, [r3, #0]
   13e0c:	1dbb      	adds	r3, r7, #6
   13e0e:	1c0a      	adds	r2, r1, #0
   13e10:	701a      	strb	r2, [r3, #0]
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
   13e12:	4b1a      	ldr	r3, [pc, #104]	; (13e7c <sercom_set_gclk_generator+0x7c>)
   13e14:	781b      	ldrb	r3, [r3, #0]
   13e16:	2201      	movs	r2, #1
   13e18:	4053      	eors	r3, r2
   13e1a:	b2db      	uxtb	r3, r3
   13e1c:	2b00      	cmp	r3, #0
   13e1e:	d103      	bne.n	13e28 <sercom_set_gclk_generator+0x28>
   13e20:	1dbb      	adds	r3, r7, #6
   13e22:	781b      	ldrb	r3, [r3, #0]
   13e24:	2b00      	cmp	r3, #0
   13e26:	d01b      	beq.n	13e60 <sercom_set_gclk_generator+0x60>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
   13e28:	230c      	movs	r3, #12
   13e2a:	18fb      	adds	r3, r7, r3
   13e2c:	0018      	movs	r0, r3
   13e2e:	4b14      	ldr	r3, [pc, #80]	; (13e80 <sercom_set_gclk_generator+0x80>)
   13e30:	4798      	blx	r3
		gclk_chan_conf.source_generator = generator_source;
   13e32:	230c      	movs	r3, #12
   13e34:	18fb      	adds	r3, r7, r3
   13e36:	1dfa      	adds	r2, r7, #7
   13e38:	7812      	ldrb	r2, [r2, #0]
   13e3a:	701a      	strb	r2, [r3, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
   13e3c:	230c      	movs	r3, #12
   13e3e:	18fb      	adds	r3, r7, r3
   13e40:	0019      	movs	r1, r3
   13e42:	2013      	movs	r0, #19
   13e44:	4b0f      	ldr	r3, [pc, #60]	; (13e84 <sercom_set_gclk_generator+0x84>)
   13e46:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
   13e48:	2013      	movs	r0, #19
   13e4a:	4b0f      	ldr	r3, [pc, #60]	; (13e88 <sercom_set_gclk_generator+0x88>)
   13e4c:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
   13e4e:	4b0b      	ldr	r3, [pc, #44]	; (13e7c <sercom_set_gclk_generator+0x7c>)
   13e50:	1dfa      	adds	r2, r7, #7
   13e52:	7812      	ldrb	r2, [r2, #0]
   13e54:	705a      	strb	r2, [r3, #1]
		_sercom_config.generator_is_set = true;
   13e56:	4b09      	ldr	r3, [pc, #36]	; (13e7c <sercom_set_gclk_generator+0x7c>)
   13e58:	2201      	movs	r2, #1
   13e5a:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
   13e5c:	2300      	movs	r3, #0
   13e5e:	e008      	b.n	13e72 <sercom_set_gclk_generator+0x72>
	} else if (generator_source == _sercom_config.generator_source) {
   13e60:	4b06      	ldr	r3, [pc, #24]	; (13e7c <sercom_set_gclk_generator+0x7c>)
   13e62:	785b      	ldrb	r3, [r3, #1]
   13e64:	1dfa      	adds	r2, r7, #7
   13e66:	7812      	ldrb	r2, [r2, #0]
   13e68:	429a      	cmp	r2, r3
   13e6a:	d101      	bne.n	13e70 <sercom_set_gclk_generator+0x70>
		/* Return status OK if same config */
		return STATUS_OK;
   13e6c:	2300      	movs	r3, #0
   13e6e:	e000      	b.n	13e72 <sercom_set_gclk_generator+0x72>
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
   13e70:	231d      	movs	r3, #29
}
   13e72:	0018      	movs	r0, r3
   13e74:	46bd      	mov	sp, r7
   13e76:	b004      	add	sp, #16
   13e78:	bd80      	pop	{r7, pc}
   13e7a:	46c0      	nop			; (mov r8, r8)
   13e7c:	20002e34 	.word	0x20002e34
   13e80:	00013aa1 	.word	0x00013aa1
   13e84:	000169e1 	.word	0x000169e1
   13e88:	00016a25 	.word	0x00016a25

00013e8c <_sercom_get_default_pad>:
 *
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
   13e8c:	b580      	push	{r7, lr}
   13e8e:	b082      	sub	sp, #8
   13e90:	af00      	add	r7, sp, #0
   13e92:	6078      	str	r0, [r7, #4]
   13e94:	000a      	movs	r2, r1
   13e96:	1cfb      	adds	r3, r7, #3
   13e98:	701a      	strb	r2, [r3, #0]
	switch ((uintptr_t)sercom_module) {
   13e9a:	687b      	ldr	r3, [r7, #4]
   13e9c:	4a4d      	ldr	r2, [pc, #308]	; (13fd4 <_sercom_get_default_pad+0x148>)
   13e9e:	4293      	cmp	r3, r2
   13ea0:	d03f      	beq.n	13f22 <_sercom_get_default_pad+0x96>
   13ea2:	4a4c      	ldr	r2, [pc, #304]	; (13fd4 <_sercom_get_default_pad+0x148>)
   13ea4:	4293      	cmp	r3, r2
   13ea6:	d806      	bhi.n	13eb6 <_sercom_get_default_pad+0x2a>
   13ea8:	4a4b      	ldr	r2, [pc, #300]	; (13fd8 <_sercom_get_default_pad+0x14c>)
   13eaa:	4293      	cmp	r3, r2
   13eac:	d00f      	beq.n	13ece <_sercom_get_default_pad+0x42>
   13eae:	4a4b      	ldr	r2, [pc, #300]	; (13fdc <_sercom_get_default_pad+0x150>)
   13eb0:	4293      	cmp	r3, r2
   13eb2:	d021      	beq.n	13ef8 <_sercom_get_default_pad+0x6c>
   13eb4:	e089      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13eb6:	4a4a      	ldr	r2, [pc, #296]	; (13fe0 <_sercom_get_default_pad+0x154>)
   13eb8:	4293      	cmp	r3, r2
   13eba:	d100      	bne.n	13ebe <_sercom_get_default_pad+0x32>
   13ebc:	e05b      	b.n	13f76 <_sercom_get_default_pad+0xea>
   13ebe:	4a49      	ldr	r2, [pc, #292]	; (13fe4 <_sercom_get_default_pad+0x158>)
   13ec0:	4293      	cmp	r3, r2
   13ec2:	d100      	bne.n	13ec6 <_sercom_get_default_pad+0x3a>
   13ec4:	e06c      	b.n	13fa0 <_sercom_get_default_pad+0x114>
   13ec6:	4a48      	ldr	r2, [pc, #288]	; (13fe8 <_sercom_get_default_pad+0x15c>)
   13ec8:	4293      	cmp	r3, r2
   13eca:	d03f      	beq.n	13f4c <_sercom_get_default_pad+0xc0>
   13ecc:	e07d      	b.n	13fca <_sercom_get_default_pad+0x13e>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
   13ece:	1cfb      	adds	r3, r7, #3
   13ed0:	781b      	ldrb	r3, [r3, #0]
   13ed2:	2b01      	cmp	r3, #1
   13ed4:	d00a      	beq.n	13eec <_sercom_get_default_pad+0x60>
   13ed6:	dc02      	bgt.n	13ede <_sercom_get_default_pad+0x52>
   13ed8:	2b00      	cmp	r3, #0
   13eda:	d005      	beq.n	13ee8 <_sercom_get_default_pad+0x5c>
   13edc:	e075      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13ede:	2b02      	cmp	r3, #2
   13ee0:	d006      	beq.n	13ef0 <_sercom_get_default_pad+0x64>
   13ee2:	2b03      	cmp	r3, #3
   13ee4:	d006      	beq.n	13ef4 <_sercom_get_default_pad+0x68>
   13ee6:	e070      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13ee8:	4b40      	ldr	r3, [pc, #256]	; (13fec <_sercom_get_default_pad+0x160>)
   13eea:	e06f      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13eec:	4b40      	ldr	r3, [pc, #256]	; (13ff0 <_sercom_get_default_pad+0x164>)
   13eee:	e06d      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13ef0:	4b40      	ldr	r3, [pc, #256]	; (13ff4 <_sercom_get_default_pad+0x168>)
   13ef2:	e06b      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13ef4:	4b40      	ldr	r3, [pc, #256]	; (13ff8 <_sercom_get_default_pad+0x16c>)
   13ef6:	e069      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13ef8:	1cfb      	adds	r3, r7, #3
   13efa:	781b      	ldrb	r3, [r3, #0]
   13efc:	2b01      	cmp	r3, #1
   13efe:	d00a      	beq.n	13f16 <_sercom_get_default_pad+0x8a>
   13f00:	dc02      	bgt.n	13f08 <_sercom_get_default_pad+0x7c>
   13f02:	2b00      	cmp	r3, #0
   13f04:	d005      	beq.n	13f12 <_sercom_get_default_pad+0x86>
   13f06:	e060      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13f08:	2b02      	cmp	r3, #2
   13f0a:	d006      	beq.n	13f1a <_sercom_get_default_pad+0x8e>
   13f0c:	2b03      	cmp	r3, #3
   13f0e:	d006      	beq.n	13f1e <_sercom_get_default_pad+0x92>
   13f10:	e05b      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13f12:	2303      	movs	r3, #3
   13f14:	e05a      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f16:	4b39      	ldr	r3, [pc, #228]	; (13ffc <_sercom_get_default_pad+0x170>)
   13f18:	e058      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f1a:	4b39      	ldr	r3, [pc, #228]	; (14000 <_sercom_get_default_pad+0x174>)
   13f1c:	e056      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f1e:	4b39      	ldr	r3, [pc, #228]	; (14004 <_sercom_get_default_pad+0x178>)
   13f20:	e054      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f22:	1cfb      	adds	r3, r7, #3
   13f24:	781b      	ldrb	r3, [r3, #0]
   13f26:	2b01      	cmp	r3, #1
   13f28:	d00a      	beq.n	13f40 <_sercom_get_default_pad+0xb4>
   13f2a:	dc02      	bgt.n	13f32 <_sercom_get_default_pad+0xa6>
   13f2c:	2b00      	cmp	r3, #0
   13f2e:	d005      	beq.n	13f3c <_sercom_get_default_pad+0xb0>
   13f30:	e04b      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13f32:	2b02      	cmp	r3, #2
   13f34:	d006      	beq.n	13f44 <_sercom_get_default_pad+0xb8>
   13f36:	2b03      	cmp	r3, #3
   13f38:	d006      	beq.n	13f48 <_sercom_get_default_pad+0xbc>
   13f3a:	e046      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13f3c:	4b32      	ldr	r3, [pc, #200]	; (14008 <_sercom_get_default_pad+0x17c>)
   13f3e:	e045      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f40:	4b32      	ldr	r3, [pc, #200]	; (1400c <_sercom_get_default_pad+0x180>)
   13f42:	e043      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f44:	4b32      	ldr	r3, [pc, #200]	; (14010 <_sercom_get_default_pad+0x184>)
   13f46:	e041      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f48:	4b32      	ldr	r3, [pc, #200]	; (14014 <_sercom_get_default_pad+0x188>)
   13f4a:	e03f      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f4c:	1cfb      	adds	r3, r7, #3
   13f4e:	781b      	ldrb	r3, [r3, #0]
   13f50:	2b01      	cmp	r3, #1
   13f52:	d00a      	beq.n	13f6a <_sercom_get_default_pad+0xde>
   13f54:	dc02      	bgt.n	13f5c <_sercom_get_default_pad+0xd0>
   13f56:	2b00      	cmp	r3, #0
   13f58:	d005      	beq.n	13f66 <_sercom_get_default_pad+0xda>
   13f5a:	e036      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13f5c:	2b02      	cmp	r3, #2
   13f5e:	d006      	beq.n	13f6e <_sercom_get_default_pad+0xe2>
   13f60:	2b03      	cmp	r3, #3
   13f62:	d006      	beq.n	13f72 <_sercom_get_default_pad+0xe6>
   13f64:	e031      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13f66:	4b2c      	ldr	r3, [pc, #176]	; (14018 <_sercom_get_default_pad+0x18c>)
   13f68:	e030      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f6a:	4b2c      	ldr	r3, [pc, #176]	; (1401c <_sercom_get_default_pad+0x190>)
   13f6c:	e02e      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f6e:	4b2c      	ldr	r3, [pc, #176]	; (14020 <_sercom_get_default_pad+0x194>)
   13f70:	e02c      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f72:	4b2c      	ldr	r3, [pc, #176]	; (14024 <_sercom_get_default_pad+0x198>)
   13f74:	e02a      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f76:	1cfb      	adds	r3, r7, #3
   13f78:	781b      	ldrb	r3, [r3, #0]
   13f7a:	2b01      	cmp	r3, #1
   13f7c:	d00a      	beq.n	13f94 <_sercom_get_default_pad+0x108>
   13f7e:	dc02      	bgt.n	13f86 <_sercom_get_default_pad+0xfa>
   13f80:	2b00      	cmp	r3, #0
   13f82:	d005      	beq.n	13f90 <_sercom_get_default_pad+0x104>
   13f84:	e021      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13f86:	2b02      	cmp	r3, #2
   13f88:	d006      	beq.n	13f98 <_sercom_get_default_pad+0x10c>
   13f8a:	2b03      	cmp	r3, #3
   13f8c:	d006      	beq.n	13f9c <_sercom_get_default_pad+0x110>
   13f8e:	e01c      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13f90:	4b25      	ldr	r3, [pc, #148]	; (14028 <_sercom_get_default_pad+0x19c>)
   13f92:	e01b      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f94:	4b25      	ldr	r3, [pc, #148]	; (1402c <_sercom_get_default_pad+0x1a0>)
   13f96:	e019      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f98:	4b25      	ldr	r3, [pc, #148]	; (14030 <_sercom_get_default_pad+0x1a4>)
   13f9a:	e017      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13f9c:	4b25      	ldr	r3, [pc, #148]	; (14034 <_sercom_get_default_pad+0x1a8>)
   13f9e:	e015      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13fa0:	1cfb      	adds	r3, r7, #3
   13fa2:	781b      	ldrb	r3, [r3, #0]
   13fa4:	2b01      	cmp	r3, #1
   13fa6:	d00a      	beq.n	13fbe <_sercom_get_default_pad+0x132>
   13fa8:	dc02      	bgt.n	13fb0 <_sercom_get_default_pad+0x124>
   13faa:	2b00      	cmp	r3, #0
   13fac:	d005      	beq.n	13fba <_sercom_get_default_pad+0x12e>
   13fae:	e00c      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13fb0:	2b02      	cmp	r3, #2
   13fb2:	d006      	beq.n	13fc2 <_sercom_get_default_pad+0x136>
   13fb4:	2b03      	cmp	r3, #3
   13fb6:	d006      	beq.n	13fc6 <_sercom_get_default_pad+0x13a>
   13fb8:	e007      	b.n	13fca <_sercom_get_default_pad+0x13e>
   13fba:	4b1f      	ldr	r3, [pc, #124]	; (14038 <_sercom_get_default_pad+0x1ac>)
   13fbc:	e006      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13fbe:	4b1f      	ldr	r3, [pc, #124]	; (1403c <_sercom_get_default_pad+0x1b0>)
   13fc0:	e004      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13fc2:	4b1f      	ldr	r3, [pc, #124]	; (14040 <_sercom_get_default_pad+0x1b4>)
   13fc4:	e002      	b.n	13fcc <_sercom_get_default_pad+0x140>
   13fc6:	4b1f      	ldr	r3, [pc, #124]	; (14044 <_sercom_get_default_pad+0x1b8>)
   13fc8:	e000      	b.n	13fcc <_sercom_get_default_pad+0x140>
	}

	Assert(false);
	return 0;
   13fca:	2300      	movs	r3, #0
}
   13fcc:	0018      	movs	r0, r3
   13fce:	46bd      	mov	sp, r7
   13fd0:	b002      	add	sp, #8
   13fd2:	bd80      	pop	{r7, pc}
   13fd4:	42001000 	.word	0x42001000
   13fd8:	42000800 	.word	0x42000800
   13fdc:	42000c00 	.word	0x42000c00
   13fe0:	42001800 	.word	0x42001800
   13fe4:	42001c00 	.word	0x42001c00
   13fe8:	42001400 	.word	0x42001400
   13fec:	00040003 	.word	0x00040003
   13ff0:	00050003 	.word	0x00050003
   13ff4:	00060003 	.word	0x00060003
   13ff8:	00070003 	.word	0x00070003
   13ffc:	00010003 	.word	0x00010003
   14000:	001e0003 	.word	0x001e0003
   14004:	001f0003 	.word	0x001f0003
   14008:	00080003 	.word	0x00080003
   1400c:	00090003 	.word	0x00090003
   14010:	000a0003 	.word	0x000a0003
   14014:	000b0003 	.word	0x000b0003
   14018:	00100003 	.word	0x00100003
   1401c:	00110003 	.word	0x00110003
   14020:	00120003 	.word	0x00120003
   14024:	00130003 	.word	0x00130003
   14028:	000c0003 	.word	0x000c0003
   1402c:	000d0003 	.word	0x000d0003
   14030:	000e0003 	.word	0x000e0003
   14034:	000f0003 	.word	0x000f0003
   14038:	00160003 	.word	0x00160003
   1403c:	00170003 	.word	0x00170003
   14040:	00180003 	.word	0x00180003
   14044:	00190003 	.word	0x00190003

00014048 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
   14048:	b590      	push	{r4, r7, lr}
   1404a:	b08b      	sub	sp, #44	; 0x2c
   1404c:	af00      	add	r7, sp, #0
   1404e:	6078      	str	r0, [r7, #4]
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
   14050:	230c      	movs	r3, #12
   14052:	18fb      	adds	r3, r7, r3
   14054:	4a0f      	ldr	r2, [pc, #60]	; (14094 <_sercom_get_sercom_inst_index+0x4c>)
   14056:	ca13      	ldmia	r2!, {r0, r1, r4}
   14058:	c313      	stmia	r3!, {r0, r1, r4}
   1405a:	ca13      	ldmia	r2!, {r0, r1, r4}
   1405c:	c313      	stmia	r3!, {r0, r1, r4}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   1405e:	2300      	movs	r3, #0
   14060:	627b      	str	r3, [r7, #36]	; 0x24
   14062:	e00e      	b.n	14082 <_sercom_get_sercom_inst_index+0x3a>
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
   14064:	230c      	movs	r3, #12
   14066:	18fb      	adds	r3, r7, r3
   14068:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1406a:	0092      	lsls	r2, r2, #2
   1406c:	58d3      	ldr	r3, [r2, r3]
   1406e:	1e1a      	subs	r2, r3, #0
   14070:	687b      	ldr	r3, [r7, #4]
   14072:	429a      	cmp	r2, r3
   14074:	d102      	bne.n	1407c <_sercom_get_sercom_inst_index+0x34>
			return i;
   14076:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   14078:	b2db      	uxtb	r3, r3
   1407a:	e006      	b.n	1408a <_sercom_get_sercom_inst_index+0x42>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   1407c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1407e:	3301      	adds	r3, #1
   14080:	627b      	str	r3, [r7, #36]	; 0x24
   14082:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   14084:	2b05      	cmp	r3, #5
   14086:	d9ed      	bls.n	14064 <_sercom_get_sercom_inst_index+0x1c>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
   14088:	2300      	movs	r3, #0
}
   1408a:	0018      	movs	r0, r3
   1408c:	46bd      	mov	sp, r7
   1408e:	b00b      	add	sp, #44	; 0x2c
   14090:	bd90      	pop	{r4, r7, pc}
   14092:	46c0      	nop			; (mov r8, r8)
   14094:	000210d8 	.word	0x000210d8

00014098 <_sercom_default_handler>:
 *
 * \param[in] instance SERCOM instance used.
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
   14098:	b580      	push	{r7, lr}
   1409a:	b082      	sub	sp, #8
   1409c:	af00      	add	r7, sp, #0
   1409e:	0002      	movs	r2, r0
   140a0:	1dfb      	adds	r3, r7, #7
   140a2:	701a      	strb	r2, [r3, #0]
	Assert(false);
}
   140a4:	46c0      	nop			; (mov r8, r8)
   140a6:	46bd      	mov	sp, r7
   140a8:	b002      	add	sp, #8
   140aa:	bd80      	pop	{r7, pc}

000140ac <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
   140ac:	b580      	push	{r7, lr}
   140ae:	b084      	sub	sp, #16
   140b0:	af00      	add	r7, sp, #0
   140b2:	0002      	movs	r2, r0
   140b4:	6039      	str	r1, [r7, #0]
   140b6:	1dfb      	adds	r3, r7, #7
   140b8:	701a      	strb	r2, [r3, #0]
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
   140ba:	4b13      	ldr	r3, [pc, #76]	; (14108 <_sercom_set_handler+0x5c>)
   140bc:	781b      	ldrb	r3, [r3, #0]
   140be:	2201      	movs	r2, #1
   140c0:	4053      	eors	r3, r2
   140c2:	b2db      	uxtb	r3, r3
   140c4:	2b00      	cmp	r3, #0
   140c6:	d015      	beq.n	140f4 <_sercom_set_handler+0x48>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   140c8:	2300      	movs	r3, #0
   140ca:	60fb      	str	r3, [r7, #12]
   140cc:	e00c      	b.n	140e8 <_sercom_set_handler+0x3c>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
   140ce:	4b0f      	ldr	r3, [pc, #60]	; (1410c <_sercom_set_handler+0x60>)
   140d0:	68fa      	ldr	r2, [r7, #12]
   140d2:	0092      	lsls	r2, r2, #2
   140d4:	490e      	ldr	r1, [pc, #56]	; (14110 <_sercom_set_handler+0x64>)
   140d6:	50d1      	str	r1, [r2, r3]
			_sercom_instances[i] = NULL;
   140d8:	4b0e      	ldr	r3, [pc, #56]	; (14114 <_sercom_set_handler+0x68>)
   140da:	68fa      	ldr	r2, [r7, #12]
   140dc:	0092      	lsls	r2, r2, #2
   140de:	2100      	movs	r1, #0
   140e0:	50d1      	str	r1, [r2, r3]
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   140e2:	68fb      	ldr	r3, [r7, #12]
   140e4:	3301      	adds	r3, #1
   140e6:	60fb      	str	r3, [r7, #12]
   140e8:	68fb      	ldr	r3, [r7, #12]
   140ea:	2b05      	cmp	r3, #5
   140ec:	d9ef      	bls.n	140ce <_sercom_set_handler+0x22>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
   140ee:	4b06      	ldr	r3, [pc, #24]	; (14108 <_sercom_set_handler+0x5c>)
   140f0:	2201      	movs	r2, #1
   140f2:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
   140f4:	1dfb      	adds	r3, r7, #7
   140f6:	781a      	ldrb	r2, [r3, #0]
   140f8:	4b04      	ldr	r3, [pc, #16]	; (1410c <_sercom_set_handler+0x60>)
   140fa:	0092      	lsls	r2, r2, #2
   140fc:	6839      	ldr	r1, [r7, #0]
   140fe:	50d1      	str	r1, [r2, r3]
}
   14100:	46c0      	nop			; (mov r8, r8)
   14102:	46bd      	mov	sp, r7
   14104:	b004      	add	sp, #16
   14106:	bd80      	pop	{r7, pc}
   14108:	20002e36 	.word	0x20002e36
   1410c:	20002e38 	.word	0x20002e38
   14110:	00014099 	.word	0x00014099
   14114:	20004bac 	.word	0x20004bac

00014118 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
   14118:	b590      	push	{r4, r7, lr}
   1411a:	b085      	sub	sp, #20
   1411c:	af00      	add	r7, sp, #0
   1411e:	6078      	str	r0, [r7, #4]
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
   14120:	2308      	movs	r3, #8
   14122:	18fa      	adds	r2, r7, r3
   14124:	4b0c      	ldr	r3, [pc, #48]	; (14158 <_sercom_get_interrupt_vector+0x40>)
   14126:	0010      	movs	r0, r2
   14128:	0019      	movs	r1, r3
   1412a:	2306      	movs	r3, #6
   1412c:	001a      	movs	r2, r3
   1412e:	4b0b      	ldr	r3, [pc, #44]	; (1415c <_sercom_get_interrupt_vector+0x44>)
   14130:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
   14132:	230f      	movs	r3, #15
   14134:	18fc      	adds	r4, r7, r3
   14136:	687b      	ldr	r3, [r7, #4]
   14138:	0018      	movs	r0, r3
   1413a:	4b09      	ldr	r3, [pc, #36]	; (14160 <_sercom_get_interrupt_vector+0x48>)
   1413c:	4798      	blx	r3
   1413e:	0003      	movs	r3, r0
   14140:	7023      	strb	r3, [r4, #0]

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
   14142:	230f      	movs	r3, #15
   14144:	18fb      	adds	r3, r7, r3
   14146:	781b      	ldrb	r3, [r3, #0]
   14148:	2208      	movs	r2, #8
   1414a:	18ba      	adds	r2, r7, r2
   1414c:	5cd3      	ldrb	r3, [r2, r3]
   1414e:	b25b      	sxtb	r3, r3
}
   14150:	0018      	movs	r0, r3
   14152:	46bd      	mov	sp, r7
   14154:	b005      	add	sp, #20
   14156:	bd90      	pop	{r4, r7, pc}
   14158:	000210f0 	.word	0x000210f0
   1415c:	0001ee9b 	.word	0x0001ee9b
   14160:	00014049 	.word	0x00014049

00014164 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
   14164:	b580      	push	{r7, lr}
   14166:	af00      	add	r7, sp, #0
   14168:	4b03      	ldr	r3, [pc, #12]	; (14178 <SERCOM0_Handler+0x14>)
   1416a:	681b      	ldr	r3, [r3, #0]
   1416c:	2000      	movs	r0, #0
   1416e:	4798      	blx	r3
   14170:	46c0      	nop			; (mov r8, r8)
   14172:	46bd      	mov	sp, r7
   14174:	bd80      	pop	{r7, pc}
   14176:	46c0      	nop			; (mov r8, r8)
   14178:	20002e38 	.word	0x20002e38

0001417c <SERCOM1_Handler>:
   1417c:	b580      	push	{r7, lr}
   1417e:	af00      	add	r7, sp, #0
   14180:	4b03      	ldr	r3, [pc, #12]	; (14190 <SERCOM1_Handler+0x14>)
   14182:	685b      	ldr	r3, [r3, #4]
   14184:	2001      	movs	r0, #1
   14186:	4798      	blx	r3
   14188:	46c0      	nop			; (mov r8, r8)
   1418a:	46bd      	mov	sp, r7
   1418c:	bd80      	pop	{r7, pc}
   1418e:	46c0      	nop			; (mov r8, r8)
   14190:	20002e38 	.word	0x20002e38

00014194 <SERCOM2_Handler>:
   14194:	b580      	push	{r7, lr}
   14196:	af00      	add	r7, sp, #0
   14198:	4b03      	ldr	r3, [pc, #12]	; (141a8 <SERCOM2_Handler+0x14>)
   1419a:	689b      	ldr	r3, [r3, #8]
   1419c:	2002      	movs	r0, #2
   1419e:	4798      	blx	r3
   141a0:	46c0      	nop			; (mov r8, r8)
   141a2:	46bd      	mov	sp, r7
   141a4:	bd80      	pop	{r7, pc}
   141a6:	46c0      	nop			; (mov r8, r8)
   141a8:	20002e38 	.word	0x20002e38

000141ac <SERCOM3_Handler>:
   141ac:	b580      	push	{r7, lr}
   141ae:	af00      	add	r7, sp, #0
   141b0:	4b03      	ldr	r3, [pc, #12]	; (141c0 <SERCOM3_Handler+0x14>)
   141b2:	68db      	ldr	r3, [r3, #12]
   141b4:	2003      	movs	r0, #3
   141b6:	4798      	blx	r3
   141b8:	46c0      	nop			; (mov r8, r8)
   141ba:	46bd      	mov	sp, r7
   141bc:	bd80      	pop	{r7, pc}
   141be:	46c0      	nop			; (mov r8, r8)
   141c0:	20002e38 	.word	0x20002e38

000141c4 <SERCOM4_Handler>:
   141c4:	b580      	push	{r7, lr}
   141c6:	af00      	add	r7, sp, #0
   141c8:	4b03      	ldr	r3, [pc, #12]	; (141d8 <SERCOM4_Handler+0x14>)
   141ca:	691b      	ldr	r3, [r3, #16]
   141cc:	2004      	movs	r0, #4
   141ce:	4798      	blx	r3
   141d0:	46c0      	nop			; (mov r8, r8)
   141d2:	46bd      	mov	sp, r7
   141d4:	bd80      	pop	{r7, pc}
   141d6:	46c0      	nop			; (mov r8, r8)
   141d8:	20002e38 	.word	0x20002e38

000141dc <SERCOM5_Handler>:
   141dc:	b580      	push	{r7, lr}
   141de:	af00      	add	r7, sp, #0
   141e0:	4b03      	ldr	r3, [pc, #12]	; (141f0 <SERCOM5_Handler+0x14>)
   141e2:	695b      	ldr	r3, [r3, #20]
   141e4:	2005      	movs	r0, #5
   141e6:	4798      	blx	r3
   141e8:	46c0      	nop			; (mov r8, r8)
   141ea:	46bd      	mov	sp, r7
   141ec:	bd80      	pop	{r7, pc}
   141ee:	46c0      	nop			; (mov r8, r8)
   141f0:	20002e38 	.word	0x20002e38

000141f4 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
   141f4:	b580      	push	{r7, lr}
   141f6:	b082      	sub	sp, #8
   141f8:	af00      	add	r7, sp, #0
   141fa:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
   141fc:	687b      	ldr	r3, [r7, #4]
   141fe:	2280      	movs	r2, #128	; 0x80
   14200:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
   14202:	687b      	ldr	r3, [r7, #4]
   14204:	2200      	movs	r2, #0
   14206:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
   14208:	687b      	ldr	r3, [r7, #4]
   1420a:	2201      	movs	r2, #1
   1420c:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
   1420e:	687b      	ldr	r3, [r7, #4]
   14210:	2200      	movs	r2, #0
   14212:	70da      	strb	r2, [r3, #3]
}
   14214:	46c0      	nop			; (mov r8, r8)
   14216:	46bd      	mov	sp, r7
   14218:	b002      	add	sp, #8
   1421a:	bd80      	pop	{r7, pc}

0001421c <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   1421c:	b580      	push	{r7, lr}
   1421e:	b084      	sub	sp, #16
   14220:	af00      	add	r7, sp, #0
   14222:	0002      	movs	r2, r0
   14224:	1dfb      	adds	r3, r7, #7
   14226:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
   14228:	230f      	movs	r3, #15
   1422a:	18fb      	adds	r3, r7, r3
   1422c:	1dfa      	adds	r2, r7, #7
   1422e:	7812      	ldrb	r2, [r2, #0]
   14230:	09d2      	lsrs	r2, r2, #7
   14232:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
   14234:	230e      	movs	r3, #14
   14236:	18fb      	adds	r3, r7, r3
   14238:	1dfa      	adds	r2, r7, #7
   1423a:	7812      	ldrb	r2, [r2, #0]
   1423c:	0952      	lsrs	r2, r2, #5
   1423e:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
   14240:	4b0d      	ldr	r3, [pc, #52]	; (14278 <system_pinmux_get_group_from_gpio_pin+0x5c>)
   14242:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
   14244:	230f      	movs	r3, #15
   14246:	18fb      	adds	r3, r7, r3
   14248:	781b      	ldrb	r3, [r3, #0]
   1424a:	2b00      	cmp	r3, #0
   1424c:	d10f      	bne.n	1426e <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
   1424e:	230f      	movs	r3, #15
   14250:	18fb      	adds	r3, r7, r3
   14252:	781b      	ldrb	r3, [r3, #0]
   14254:	009b      	lsls	r3, r3, #2
   14256:	2210      	movs	r2, #16
   14258:	4694      	mov	ip, r2
   1425a:	44bc      	add	ip, r7
   1425c:	4463      	add	r3, ip
   1425e:	3b08      	subs	r3, #8
   14260:	681a      	ldr	r2, [r3, #0]
   14262:	230e      	movs	r3, #14
   14264:	18fb      	adds	r3, r7, r3
   14266:	781b      	ldrb	r3, [r3, #0]
   14268:	01db      	lsls	r3, r3, #7
   1426a:	18d3      	adds	r3, r2, r3
   1426c:	e000      	b.n	14270 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
   1426e:	2300      	movs	r3, #0
	}
}
   14270:	0018      	movs	r0, r3
   14272:	46bd      	mov	sp, r7
   14274:	b004      	add	sp, #16
   14276:	bd80      	pop	{r7, pc}
   14278:	41004400 	.word	0x41004400

0001427c <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   1427c:	b580      	push	{r7, lr}
   1427e:	b082      	sub	sp, #8
   14280:	af00      	add	r7, sp, #0
   14282:	0002      	movs	r2, r0
   14284:	1dfb      	adds	r3, r7, #7
   14286:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
   14288:	1dfb      	adds	r3, r7, #7
   1428a:	781b      	ldrb	r3, [r3, #0]
   1428c:	0018      	movs	r0, r3
   1428e:	4b03      	ldr	r3, [pc, #12]	; (1429c <port_get_group_from_gpio_pin+0x20>)
   14290:	4798      	blx	r3
   14292:	0003      	movs	r3, r0
}
   14294:	0018      	movs	r0, r3
   14296:	46bd      	mov	sp, r7
   14298:	b002      	add	sp, #8
   1429a:	bd80      	pop	{r7, pc}
   1429c:	0001421d 	.word	0x0001421d

000142a0 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
   142a0:	b580      	push	{r7, lr}
   142a2:	b084      	sub	sp, #16
   142a4:	af00      	add	r7, sp, #0
   142a6:	0002      	movs	r2, r0
   142a8:	1dfb      	adds	r3, r7, #7
   142aa:	701a      	strb	r2, [r3, #0]
   142ac:	1dbb      	adds	r3, r7, #6
   142ae:	1c0a      	adds	r2, r1, #0
   142b0:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
   142b2:	1dfb      	adds	r3, r7, #7
   142b4:	781b      	ldrb	r3, [r3, #0]
   142b6:	0018      	movs	r0, r3
   142b8:	4b0d      	ldr	r3, [pc, #52]	; (142f0 <port_pin_set_output_level+0x50>)
   142ba:	4798      	blx	r3
   142bc:	0003      	movs	r3, r0
   142be:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   142c0:	1dfb      	adds	r3, r7, #7
   142c2:	781b      	ldrb	r3, [r3, #0]
   142c4:	221f      	movs	r2, #31
   142c6:	4013      	ands	r3, r2
   142c8:	2201      	movs	r2, #1
   142ca:	409a      	lsls	r2, r3
   142cc:	0013      	movs	r3, r2
   142ce:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
   142d0:	1dbb      	adds	r3, r7, #6
   142d2:	781b      	ldrb	r3, [r3, #0]
   142d4:	2b00      	cmp	r3, #0
   142d6:	d003      	beq.n	142e0 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
   142d8:	68fb      	ldr	r3, [r7, #12]
   142da:	68ba      	ldr	r2, [r7, #8]
   142dc:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
   142de:	e002      	b.n	142e6 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
   142e0:	68fb      	ldr	r3, [r7, #12]
   142e2:	68ba      	ldr	r2, [r7, #8]
   142e4:	615a      	str	r2, [r3, #20]
	}
}
   142e6:	46c0      	nop			; (mov r8, r8)
   142e8:	46bd      	mov	sp, r7
   142ea:	b004      	add	sp, #16
   142ec:	bd80      	pop	{r7, pc}
   142ee:	46c0      	nop			; (mov r8, r8)
   142f0:	0001427d 	.word	0x0001427d

000142f4 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
   142f4:	b580      	push	{r7, lr}
   142f6:	b082      	sub	sp, #8
   142f8:	af00      	add	r7, sp, #0
   142fa:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
   142fc:	687b      	ldr	r3, [r7, #4]
   142fe:	2200      	movs	r2, #0
   14300:	701a      	strb	r2, [r3, #0]
}
   14302:	46c0      	nop			; (mov r8, r8)
   14304:	46bd      	mov	sp, r7
   14306:	b002      	add	sp, #8
   14308:	bd80      	pop	{r7, pc}
   1430a:	46c0      	nop			; (mov r8, r8)

0001430c <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
   1430c:	b580      	push	{r7, lr}
   1430e:	b082      	sub	sp, #8
   14310:	af00      	add	r7, sp, #0
   14312:	0002      	movs	r2, r0
   14314:	6039      	str	r1, [r7, #0]
   14316:	1dfb      	adds	r3, r7, #7
   14318:	701a      	strb	r2, [r3, #0]
	switch (bus) {
   1431a:	1dfb      	adds	r3, r7, #7
   1431c:	781b      	ldrb	r3, [r3, #0]
   1431e:	2b01      	cmp	r3, #1
   14320:	d00a      	beq.n	14338 <system_apb_clock_set_mask+0x2c>
   14322:	2b02      	cmp	r3, #2
   14324:	d00f      	beq.n	14346 <system_apb_clock_set_mask+0x3a>
   14326:	2b00      	cmp	r3, #0
   14328:	d114      	bne.n	14354 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
   1432a:	4b0e      	ldr	r3, [pc, #56]	; (14364 <system_apb_clock_set_mask+0x58>)
   1432c:	4a0d      	ldr	r2, [pc, #52]	; (14364 <system_apb_clock_set_mask+0x58>)
   1432e:	6991      	ldr	r1, [r2, #24]
   14330:	683a      	ldr	r2, [r7, #0]
   14332:	430a      	orrs	r2, r1
   14334:	619a      	str	r2, [r3, #24]
			break;
   14336:	e00f      	b.n	14358 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
   14338:	4b0a      	ldr	r3, [pc, #40]	; (14364 <system_apb_clock_set_mask+0x58>)
   1433a:	4a0a      	ldr	r2, [pc, #40]	; (14364 <system_apb_clock_set_mask+0x58>)
   1433c:	69d1      	ldr	r1, [r2, #28]
   1433e:	683a      	ldr	r2, [r7, #0]
   14340:	430a      	orrs	r2, r1
   14342:	61da      	str	r2, [r3, #28]
			break;
   14344:	e008      	b.n	14358 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
   14346:	4b07      	ldr	r3, [pc, #28]	; (14364 <system_apb_clock_set_mask+0x58>)
   14348:	4a06      	ldr	r2, [pc, #24]	; (14364 <system_apb_clock_set_mask+0x58>)
   1434a:	6a11      	ldr	r1, [r2, #32]
   1434c:	683a      	ldr	r2, [r7, #0]
   1434e:	430a      	orrs	r2, r1
   14350:	621a      	str	r2, [r3, #32]
			break;
   14352:	e001      	b.n	14358 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
   14354:	2317      	movs	r3, #23
   14356:	e000      	b.n	1435a <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
   14358:	2300      	movs	r3, #0
}
   1435a:	0018      	movs	r0, r3
   1435c:	46bd      	mov	sp, r7
   1435e:	b002      	add	sp, #8
   14360:	bd80      	pop	{r7, pc}
   14362:	46c0      	nop			; (mov r8, r8)
   14364:	40000400 	.word	0x40000400

00014368 <system_is_debugger_present>:
 * \retval true  Debugger is connected to the system
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
   14368:	b580      	push	{r7, lr}
   1436a:	af00      	add	r7, sp, #0
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
   1436c:	4b05      	ldr	r3, [pc, #20]	; (14384 <system_is_debugger_present+0x1c>)
   1436e:	789b      	ldrb	r3, [r3, #2]
   14370:	b2db      	uxtb	r3, r3
   14372:	001a      	movs	r2, r3
   14374:	2302      	movs	r3, #2
   14376:	4013      	ands	r3, r2
   14378:	1e5a      	subs	r2, r3, #1
   1437a:	4193      	sbcs	r3, r2
   1437c:	b2db      	uxtb	r3, r3
}
   1437e:	0018      	movs	r0, r3
   14380:	46bd      	mov	sp, r7
   14382:	bd80      	pop	{r7, pc}
   14384:	41002000 	.word	0x41002000

00014388 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
   14388:	b580      	push	{r7, lr}
   1438a:	b082      	sub	sp, #8
   1438c:	af00      	add	r7, sp, #0
   1438e:	0002      	movs	r2, r0
   14390:	1dfb      	adds	r3, r7, #7
   14392:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   14394:	4b06      	ldr	r3, [pc, #24]	; (143b0 <system_interrupt_enable+0x28>)
   14396:	1dfa      	adds	r2, r7, #7
   14398:	7812      	ldrb	r2, [r2, #0]
   1439a:	0011      	movs	r1, r2
   1439c:	221f      	movs	r2, #31
   1439e:	400a      	ands	r2, r1
   143a0:	2101      	movs	r1, #1
   143a2:	4091      	lsls	r1, r2
   143a4:	000a      	movs	r2, r1
   143a6:	601a      	str	r2, [r3, #0]
}
   143a8:	46c0      	nop			; (mov r8, r8)
   143aa:	46bd      	mov	sp, r7
   143ac:	b002      	add	sp, #8
   143ae:	bd80      	pop	{r7, pc}
   143b0:	e000e100 	.word	0xe000e100

000143b4 <system_interrupt_disable>:
 *
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
   143b4:	b580      	push	{r7, lr}
   143b6:	b082      	sub	sp, #8
   143b8:	af00      	add	r7, sp, #0
   143ba:	0002      	movs	r2, r0
   143bc:	1dfb      	adds	r3, r7, #7
   143be:	701a      	strb	r2, [r3, #0]
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   143c0:	4a07      	ldr	r2, [pc, #28]	; (143e0 <system_interrupt_disable+0x2c>)
   143c2:	1dfb      	adds	r3, r7, #7
   143c4:	781b      	ldrb	r3, [r3, #0]
   143c6:	0019      	movs	r1, r3
   143c8:	231f      	movs	r3, #31
   143ca:	400b      	ands	r3, r1
   143cc:	2101      	movs	r1, #1
   143ce:	4099      	lsls	r1, r3
   143d0:	000b      	movs	r3, r1
   143d2:	0019      	movs	r1, r3
   143d4:	2380      	movs	r3, #128	; 0x80
   143d6:	50d1      	str	r1, [r2, r3]
}
   143d8:	46c0      	nop			; (mov r8, r8)
   143da:	46bd      	mov	sp, r7
   143dc:	b002      	add	sp, #8
   143de:	bd80      	pop	{r7, pc}
   143e0:	e000e100 	.word	0xe000e100

000143e4 <spi_is_syncing>:
 * \retval false  Module synchronization is not ongoing
 *
 */
static inline bool spi_is_syncing(
		struct spi_module *const module)
{
   143e4:	b580      	push	{r7, lr}
   143e6:	b084      	sub	sp, #16
   143e8:	af00      	add	r7, sp, #0
   143ea:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   143ec:	687b      	ldr	r3, [r7, #4]
   143ee:	681b      	ldr	r3, [r3, #0]
   143f0:	60fb      	str	r3, [r7, #12]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
   143f2:	68fb      	ldr	r3, [r7, #12]
   143f4:	69db      	ldr	r3, [r3, #28]
   143f6:	1e5a      	subs	r2, r3, #1
   143f8:	4193      	sbcs	r3, r2
   143fa:	b2db      	uxtb	r3, r3
#  else
	/* Return synchronization status */
	return (spi_module->STATUS.reg & SERCOM_SPI_STATUS_SYNCBUSY);
#  endif
}
   143fc:	0018      	movs	r0, r3
   143fe:	46bd      	mov	sp, r7
   14400:	b004      	add	sp, #16
   14402:	bd80      	pop	{r7, pc}

00014404 <spi_enable>:
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
static inline void spi_enable(
		struct spi_module *const module)
{
   14404:	b580      	push	{r7, lr}
   14406:	b084      	sub	sp, #16
   14408:	af00      	add	r7, sp, #0
   1440a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   1440c:	687b      	ldr	r3, [r7, #4]
   1440e:	681b      	ldr	r3, [r3, #0]
   14410:	60fb      	str	r3, [r7, #12]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
   14412:	687b      	ldr	r3, [r7, #4]
   14414:	681b      	ldr	r3, [r3, #0]
   14416:	0018      	movs	r0, r3
   14418:	4b0b      	ldr	r3, [pc, #44]	; (14448 <spi_enable+0x44>)
   1441a:	4798      	blx	r3
   1441c:	0003      	movs	r3, r0
   1441e:	0018      	movs	r0, r3
   14420:	4b0a      	ldr	r3, [pc, #40]	; (1444c <spi_enable+0x48>)
   14422:	4798      	blx	r3
#  endif

	while (spi_is_syncing(module)) {
   14424:	46c0      	nop			; (mov r8, r8)
   14426:	687b      	ldr	r3, [r7, #4]
   14428:	0018      	movs	r0, r3
   1442a:	4b09      	ldr	r3, [pc, #36]	; (14450 <spi_enable+0x4c>)
   1442c:	4798      	blx	r3
   1442e:	1e03      	subs	r3, r0, #0
   14430:	d1f9      	bne.n	14426 <spi_enable+0x22>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   14432:	68fb      	ldr	r3, [r7, #12]
   14434:	681b      	ldr	r3, [r3, #0]
   14436:	2202      	movs	r2, #2
   14438:	431a      	orrs	r2, r3
   1443a:	68fb      	ldr	r3, [r7, #12]
   1443c:	601a      	str	r2, [r3, #0]
}
   1443e:	46c0      	nop			; (mov r8, r8)
   14440:	46bd      	mov	sp, r7
   14442:	b004      	add	sp, #16
   14444:	bd80      	pop	{r7, pc}
   14446:	46c0      	nop			; (mov r8, r8)
   14448:	00014119 	.word	0x00014119
   1444c:	00014389 	.word	0x00014389
   14450:	000143e5 	.word	0x000143e5

00014454 <spi_disable>:
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
static inline void spi_disable(
		struct spi_module *const module)
{
   14454:	b580      	push	{r7, lr}
   14456:	b084      	sub	sp, #16
   14458:	af00      	add	r7, sp, #0
   1445a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   1445c:	687b      	ldr	r3, [r7, #4]
   1445e:	681b      	ldr	r3, [r3, #0]
   14460:	60fb      	str	r3, [r7, #12]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
   14462:	687b      	ldr	r3, [r7, #4]
   14464:	681b      	ldr	r3, [r3, #0]
   14466:	0018      	movs	r0, r3
   14468:	4b0b      	ldr	r3, [pc, #44]	; (14498 <spi_disable+0x44>)
   1446a:	4798      	blx	r3
   1446c:	0003      	movs	r3, r0
   1446e:	0018      	movs	r0, r3
   14470:	4b0a      	ldr	r3, [pc, #40]	; (1449c <spi_disable+0x48>)
   14472:	4798      	blx	r3
#  endif

	while (spi_is_syncing(module)) {
   14474:	46c0      	nop			; (mov r8, r8)
   14476:	687b      	ldr	r3, [r7, #4]
   14478:	0018      	movs	r0, r3
   1447a:	4b09      	ldr	r3, [pc, #36]	; (144a0 <spi_disable+0x4c>)
   1447c:	4798      	blx	r3
   1447e:	1e03      	subs	r3, r0, #0
   14480:	d1f9      	bne.n	14476 <spi_disable+0x22>
		/* Wait until the synchronization is complete */
	}

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   14482:	68fb      	ldr	r3, [r7, #12]
   14484:	681b      	ldr	r3, [r3, #0]
   14486:	2202      	movs	r2, #2
   14488:	4393      	bics	r3, r2
   1448a:	001a      	movs	r2, r3
   1448c:	68fb      	ldr	r3, [r7, #12]
   1448e:	601a      	str	r2, [r3, #0]
}
   14490:	46c0      	nop			; (mov r8, r8)
   14492:	46bd      	mov	sp, r7
   14494:	b004      	add	sp, #16
   14496:	bd80      	pop	{r7, pc}
   14498:	00014119 	.word	0x00014119
   1449c:	000143b5 	.word	0x000143b5
   144a0:	000143e5 	.word	0x000143e5

000144a4 <spi_is_write_complete>:
 *                has been drawn high for SPI slave
 * \retval false  If the SPI master module has not shifted out data
 */
static inline bool spi_is_write_complete(
		struct spi_module *const module)
{
   144a4:	b580      	push	{r7, lr}
   144a6:	b084      	sub	sp, #16
   144a8:	af00      	add	r7, sp, #0
   144aa:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   144ac:	687b      	ldr	r3, [r7, #4]
   144ae:	681b      	ldr	r3, [r3, #0]
   144b0:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
   144b2:	68fb      	ldr	r3, [r7, #12]
   144b4:	7e1b      	ldrb	r3, [r3, #24]
   144b6:	b2db      	uxtb	r3, r3
   144b8:	001a      	movs	r2, r3
   144ba:	2302      	movs	r3, #2
   144bc:	4013      	ands	r3, r2
   144be:	1e5a      	subs	r2, r3, #1
   144c0:	4193      	sbcs	r3, r2
   144c2:	b2db      	uxtb	r3, r3
}
   144c4:	0018      	movs	r0, r3
   144c6:	46bd      	mov	sp, r7
   144c8:	b004      	add	sp, #16
   144ca:	bd80      	pop	{r7, pc}

000144cc <spi_is_ready_to_write>:
 * \retval true   If the SPI module is ready to write data
 * \retval false  If the SPI module is not ready to write data
 */
static inline bool spi_is_ready_to_write(
		struct spi_module *const module)
{
   144cc:	b580      	push	{r7, lr}
   144ce:	b084      	sub	sp, #16
   144d0:	af00      	add	r7, sp, #0
   144d2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   144d4:	687b      	ldr	r3, [r7, #4]
   144d6:	681b      	ldr	r3, [r3, #0]
   144d8:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   144da:	68fb      	ldr	r3, [r7, #12]
   144dc:	7e1b      	ldrb	r3, [r3, #24]
   144de:	b2db      	uxtb	r3, r3
   144e0:	001a      	movs	r2, r3
   144e2:	2301      	movs	r3, #1
   144e4:	4013      	ands	r3, r2
   144e6:	1e5a      	subs	r2, r3, #1
   144e8:	4193      	sbcs	r3, r2
   144ea:	b2db      	uxtb	r3, r3
}
   144ec:	0018      	movs	r0, r3
   144ee:	46bd      	mov	sp, r7
   144f0:	b004      	add	sp, #16
   144f2:	bd80      	pop	{r7, pc}

000144f4 <spi_is_ready_to_read>:
 * \retval true   If the SPI module is ready to read data
 * \retval false  If the SPI module is not ready to read data
 */
static inline bool spi_is_ready_to_read(
		struct spi_module *const module)
{
   144f4:	b580      	push	{r7, lr}
   144f6:	b084      	sub	sp, #16
   144f8:	af00      	add	r7, sp, #0
   144fa:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   144fc:	687b      	ldr	r3, [r7, #4]
   144fe:	681b      	ldr	r3, [r3, #0]
   14500:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   14502:	68fb      	ldr	r3, [r7, #12]
   14504:	7e1b      	ldrb	r3, [r3, #24]
   14506:	b2db      	uxtb	r3, r3
   14508:	001a      	movs	r2, r3
   1450a:	2304      	movs	r3, #4
   1450c:	4013      	ands	r3, r2
   1450e:	1e5a      	subs	r2, r3, #1
   14510:	4193      	sbcs	r3, r2
   14512:	b2db      	uxtb	r3, r3
}
   14514:	0018      	movs	r0, r3
   14516:	46bd      	mov	sp, r7
   14518:	b004      	add	sp, #16
   1451a:	bd80      	pop	{r7, pc}

0001451c <spi_write>:
 * \retval STATUS_BUSY  If the last write was not completed
 */
static inline enum status_code spi_write(
		struct spi_module *module,
		uint16_t tx_data)
{
   1451c:	b580      	push	{r7, lr}
   1451e:	b084      	sub	sp, #16
   14520:	af00      	add	r7, sp, #0
   14522:	6078      	str	r0, [r7, #4]
   14524:	000a      	movs	r2, r1
   14526:	1cbb      	adds	r3, r7, #2
   14528:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   1452a:	687b      	ldr	r3, [r7, #4]
   1452c:	681b      	ldr	r3, [r3, #0]
   1452e:	60fb      	str	r3, [r7, #12]

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
   14530:	687b      	ldr	r3, [r7, #4]
   14532:	0018      	movs	r0, r3
   14534:	4b0a      	ldr	r3, [pc, #40]	; (14560 <spi_write+0x44>)
   14536:	4798      	blx	r3
   14538:	0003      	movs	r3, r0
   1453a:	001a      	movs	r2, r3
   1453c:	2301      	movs	r3, #1
   1453e:	4053      	eors	r3, r2
   14540:	b2db      	uxtb	r3, r3
   14542:	2b00      	cmp	r3, #0
   14544:	d001      	beq.n	1454a <spi_write+0x2e>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
   14546:	2305      	movs	r3, #5
   14548:	e006      	b.n	14558 <spi_write+0x3c>
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
   1454a:	1cbb      	adds	r3, r7, #2
   1454c:	881b      	ldrh	r3, [r3, #0]
   1454e:	05db      	lsls	r3, r3, #23
   14550:	0dda      	lsrs	r2, r3, #23
   14552:	68fb      	ldr	r3, [r7, #12]
   14554:	629a      	str	r2, [r3, #40]	; 0x28

	return STATUS_OK;
   14556:	2300      	movs	r3, #0
}
   14558:	0018      	movs	r0, r3
   1455a:	46bd      	mov	sp, r7
   1455c:	b004      	add	sp, #16
   1455e:	bd80      	pop	{r7, pc}
   14560:	000144cd 	.word	0x000144cd

00014564 <spi_read>:
 * \retval STATUS_ERR_OVERFLOW  If the data is overflown
 */
static inline enum status_code spi_read(
		struct spi_module *const module,
		uint16_t *rx_data)
{
   14564:	b580      	push	{r7, lr}
   14566:	b084      	sub	sp, #16
   14568:	af00      	add	r7, sp, #0
   1456a:	6078      	str	r0, [r7, #4]
   1456c:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   1456e:	687b      	ldr	r3, [r7, #4]
   14570:	681b      	ldr	r3, [r3, #0]
   14572:	60bb      	str	r3, [r7, #8]

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
   14574:	687b      	ldr	r3, [r7, #4]
   14576:	0018      	movs	r0, r3
   14578:	4b1d      	ldr	r3, [pc, #116]	; (145f0 <spi_read+0x8c>)
   1457a:	4798      	blx	r3
   1457c:	0003      	movs	r3, r0
   1457e:	001a      	movs	r2, r3
   14580:	2301      	movs	r3, #1
   14582:	4053      	eors	r3, r2
   14584:	b2db      	uxtb	r3, r3
   14586:	2b00      	cmp	r3, #0
   14588:	d001      	beq.n	1458e <spi_read+0x2a>
		/* No data has been received, return */
		return STATUS_ERR_IO;
   1458a:	2310      	movs	r3, #16
   1458c:	e02c      	b.n	145e8 <spi_read+0x84>
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
   1458e:	230f      	movs	r3, #15
   14590:	18fb      	adds	r3, r7, r3
   14592:	2200      	movs	r2, #0
   14594:	701a      	strb	r2, [r3, #0]

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   14596:	68bb      	ldr	r3, [r7, #8]
   14598:	8b5b      	ldrh	r3, [r3, #26]
   1459a:	b29b      	uxth	r3, r3
   1459c:	001a      	movs	r2, r3
   1459e:	2304      	movs	r3, #4
   145a0:	4013      	ands	r3, r2
   145a2:	d00b      	beq.n	145bc <spi_read+0x58>
		retval = STATUS_ERR_OVERFLOW;
   145a4:	230f      	movs	r3, #15
   145a6:	18fb      	adds	r3, r7, r3
   145a8:	221e      	movs	r2, #30
   145aa:	701a      	strb	r2, [r3, #0]
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
   145ac:	68bb      	ldr	r3, [r7, #8]
   145ae:	8b5b      	ldrh	r3, [r3, #26]
   145b0:	b29b      	uxth	r3, r3
   145b2:	2204      	movs	r2, #4
   145b4:	4313      	orrs	r3, r2
   145b6:	b29a      	uxth	r2, r3
   145b8:	68bb      	ldr	r3, [r7, #8]
   145ba:	835a      	strh	r2, [r3, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   145bc:	687b      	ldr	r3, [r7, #4]
   145be:	799b      	ldrb	r3, [r3, #6]
   145c0:	2b01      	cmp	r3, #1
   145c2:	d108      	bne.n	145d6 <spi_read+0x72>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
   145c4:	68bb      	ldr	r3, [r7, #8]
   145c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   145c8:	b29b      	uxth	r3, r3
   145ca:	05db      	lsls	r3, r3, #23
   145cc:	0ddb      	lsrs	r3, r3, #23
   145ce:	b29a      	uxth	r2, r3
   145d0:	683b      	ldr	r3, [r7, #0]
   145d2:	801a      	strh	r2, [r3, #0]
   145d4:	e005      	b.n	145e2 <spi_read+0x7e>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
   145d6:	68bb      	ldr	r3, [r7, #8]
   145d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   145da:	b2db      	uxtb	r3, r3
   145dc:	b29a      	uxth	r2, r3
   145de:	683b      	ldr	r3, [r7, #0]
   145e0:	801a      	strh	r2, [r3, #0]
	}

	return retval;
   145e2:	230f      	movs	r3, #15
   145e4:	18fb      	adds	r3, r7, r3
   145e6:	781b      	ldrb	r3, [r3, #0]
}
   145e8:	0018      	movs	r0, r3
   145ea:	46bd      	mov	sp, r7
   145ec:	b004      	add	sp, #16
   145ee:	bd80      	pop	{r7, pc}
   145f0:	000144f5 	.word	0x000144f5

000145f4 <spi_set_baudrate>:
 * \retval STATUS_OK               If the configuration was written
 */
enum status_code spi_set_baudrate(
		struct spi_module *const module,
		uint32_t baudrate)
{
   145f4:	b590      	push	{r4, r7, lr}
   145f6:	b089      	sub	sp, #36	; 0x24
   145f8:	af00      	add	r7, sp, #0
   145fa:	6078      	str	r0, [r7, #4]
   145fc:	6039      	str	r1, [r7, #0]
	Assert(module);
	Assert(baudrate);
	Assert(module->hw);

	/* Value to write to BAUD register */
	uint16_t baud = 0;
   145fe:	230c      	movs	r3, #12
   14600:	18fb      	adds	r3, r7, r3
   14602:	2200      	movs	r2, #0
   14604:	801a      	strh	r2, [r3, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);
   14606:	687b      	ldr	r3, [r7, #4]
   14608:	681b      	ldr	r3, [r3, #0]
   1460a:	61fb      	str	r3, [r7, #28]

	/* Disable the module */
	spi_disable(module);
   1460c:	687b      	ldr	r3, [r7, #4]
   1460e:	0018      	movs	r0, r3
   14610:	4b24      	ldr	r3, [pc, #144]	; (146a4 <spi_set_baudrate+0xb0>)
   14612:	4798      	blx	r3

	while (spi_is_syncing(module)) {
   14614:	46c0      	nop			; (mov r8, r8)
   14616:	687b      	ldr	r3, [r7, #4]
   14618:	0018      	movs	r0, r3
   1461a:	4b23      	ldr	r3, [pc, #140]	; (146a8 <spi_set_baudrate+0xb4>)
   1461c:	4798      	blx	r3
   1461e:	1e03      	subs	r3, r0, #0
   14620:	d1f9      	bne.n	14616 <spi_set_baudrate+0x22>
		/* Wait until the synchronization is complete */
	}

	/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   14622:	687b      	ldr	r3, [r7, #4]
   14624:	681b      	ldr	r3, [r3, #0]
   14626:	0018      	movs	r0, r3
   14628:	4b20      	ldr	r3, [pc, #128]	; (146ac <spi_set_baudrate+0xb8>)
   1462a:	4798      	blx	r3
   1462c:	0003      	movs	r3, r0
   1462e:	61bb      	str	r3, [r7, #24]
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   14630:	69bb      	ldr	r3, [r7, #24]
   14632:	3314      	adds	r3, #20
   14634:	617b      	str	r3, [r7, #20]
	uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
   14636:	697b      	ldr	r3, [r7, #20]
   14638:	b2db      	uxtb	r3, r3
   1463a:	0018      	movs	r0, r3
   1463c:	4b1c      	ldr	r3, [pc, #112]	; (146b0 <spi_set_baudrate+0xbc>)
   1463e:	4798      	blx	r3
   14640:	0003      	movs	r3, r0
   14642:	613b      	str	r3, [r7, #16]

	/* Get baud value, based on baudrate and the internal clock frequency */
	enum status_code error_code = _sercom_get_sync_baud_val(
   14644:	230f      	movs	r3, #15
   14646:	18fc      	adds	r4, r7, r3
   14648:	230c      	movs	r3, #12
   1464a:	18fa      	adds	r2, r7, r3
   1464c:	6939      	ldr	r1, [r7, #16]
   1464e:	683b      	ldr	r3, [r7, #0]
   14650:	0018      	movs	r0, r3
   14652:	4b18      	ldr	r3, [pc, #96]	; (146b4 <spi_set_baudrate+0xc0>)
   14654:	4798      	blx	r3
   14656:	0003      	movs	r3, r0
   14658:	7023      	strb	r3, [r4, #0]
			baudrate, internal_clock, &baud);

	if (error_code != STATUS_OK) {
   1465a:	230f      	movs	r3, #15
   1465c:	18fb      	adds	r3, r7, r3
   1465e:	781b      	ldrb	r3, [r3, #0]
   14660:	2b00      	cmp	r3, #0
   14662:	d001      	beq.n	14668 <spi_set_baudrate+0x74>
		/* Baud rate calculation error, return status code */
		return STATUS_ERR_INVALID_ARG;
   14664:	2317      	movs	r3, #23
   14666:	e018      	b.n	1469a <spi_set_baudrate+0xa6>
	}

	spi_module->BAUD.reg = (uint8_t)baud;
   14668:	230c      	movs	r3, #12
   1466a:	18fb      	adds	r3, r7, r3
   1466c:	881b      	ldrh	r3, [r3, #0]
   1466e:	b2da      	uxtb	r2, r3
   14670:	69fb      	ldr	r3, [r7, #28]
   14672:	731a      	strb	r2, [r3, #12]

	while (spi_is_syncing(module)) {
   14674:	46c0      	nop			; (mov r8, r8)
   14676:	687b      	ldr	r3, [r7, #4]
   14678:	0018      	movs	r0, r3
   1467a:	4b0b      	ldr	r3, [pc, #44]	; (146a8 <spi_set_baudrate+0xb4>)
   1467c:	4798      	blx	r3
   1467e:	1e03      	subs	r3, r0, #0
   14680:	d1f9      	bne.n	14676 <spi_set_baudrate+0x82>
		/* Wait until the synchronization is complete */
	}

	/* Enable the module */
	spi_enable(module);
   14682:	687b      	ldr	r3, [r7, #4]
   14684:	0018      	movs	r0, r3
   14686:	4b0c      	ldr	r3, [pc, #48]	; (146b8 <spi_set_baudrate+0xc4>)
   14688:	4798      	blx	r3

	while (spi_is_syncing(module)) {
   1468a:	46c0      	nop			; (mov r8, r8)
   1468c:	687b      	ldr	r3, [r7, #4]
   1468e:	0018      	movs	r0, r3
   14690:	4b05      	ldr	r3, [pc, #20]	; (146a8 <spi_set_baudrate+0xb4>)
   14692:	4798      	blx	r3
   14694:	1e03      	subs	r3, r0, #0
   14696:	d1f9      	bne.n	1468c <spi_set_baudrate+0x98>
		/* Wait until the synchronization is complete */
	}

	return STATUS_OK;
   14698:	2300      	movs	r3, #0
}
   1469a:	0018      	movs	r0, r3
   1469c:	46bd      	mov	sp, r7
   1469e:	b009      	add	sp, #36	; 0x24
   146a0:	bd90      	pop	{r4, r7, pc}
   146a2:	46c0      	nop			; (mov r8, r8)
   146a4:	00014455 	.word	0x00014455
   146a8:	000143e5 	.word	0x000143e5
   146ac:	00014049 	.word	0x00014049
   146b0:	00016b4d 	.word	0x00016b4d
   146b4:	00013b99 	.word	0x00013b99
   146b8:	00014405 	.word	0x00014405

000146bc <_spi_set_config>:
 * \retval STATUS_OK               If the configuration was written
 */
static enum status_code _spi_set_config(
		struct spi_module *const module,
		const struct spi_config *const config)
{
   146bc:	b590      	push	{r4, r7, lr}
   146be:	b093      	sub	sp, #76	; 0x4c
   146c0:	af00      	add	r7, sp, #0
   146c2:	6078      	str	r0, [r7, #4]
   146c4:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   146c6:	687b      	ldr	r3, [r7, #4]
   146c8:	681b      	ldr	r3, [r3, #0]
   146ca:	637b      	str	r3, [r7, #52]	; 0x34
	Sercom *const hw = module->hw;
   146cc:	687b      	ldr	r3, [r7, #4]
   146ce:	681b      	ldr	r3, [r3, #0]
   146d0:	633b      	str	r3, [r7, #48]	; 0x30

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
   146d2:	231c      	movs	r3, #28
   146d4:	18fb      	adds	r3, r7, r3
   146d6:	0018      	movs	r0, r3
   146d8:	4b75      	ldr	r3, [pc, #468]	; (148b0 <_spi_set_config+0x1f4>)
   146da:	4798      	blx	r3
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
   146dc:	231c      	movs	r3, #28
   146de:	18fb      	adds	r3, r7, r3
   146e0:	2200      	movs	r2, #0
   146e2:	705a      	strb	r2, [r3, #1]
	if(config->mode == SPI_MODE_SLAVE) {
   146e4:	683b      	ldr	r3, [r7, #0]
   146e6:	781b      	ldrb	r3, [r3, #0]
   146e8:	2b00      	cmp	r3, #0
   146ea:	d103      	bne.n	146f4 <_spi_set_config+0x38>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
   146ec:	231c      	movs	r3, #28
   146ee:	18fb      	adds	r3, r7, r3
   146f0:	2200      	movs	r2, #0
   146f2:	709a      	strb	r2, [r3, #2]
	}

	uint32_t pad_pinmuxes[] = {
			config->pinmux_pad0, config->pinmux_pad1,
   146f4:	683b      	ldr	r3, [r7, #0]
   146f6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
	}

	uint32_t pad_pinmuxes[] = {
   146f8:	230c      	movs	r3, #12
   146fa:	18fb      	adds	r3, r7, r3
   146fc:	601a      	str	r2, [r3, #0]
			config->pinmux_pad0, config->pinmux_pad1,
   146fe:	683b      	ldr	r3, [r7, #0]
   14700:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
	}

	uint32_t pad_pinmuxes[] = {
   14702:	230c      	movs	r3, #12
   14704:	18fb      	adds	r3, r7, r3
   14706:	605a      	str	r2, [r3, #4]
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
   14708:	683b      	ldr	r3, [r7, #0]
   1470a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
	}

	uint32_t pad_pinmuxes[] = {
   1470c:	230c      	movs	r3, #12
   1470e:	18fb      	adds	r3, r7, r3
   14710:	609a      	str	r2, [r3, #8]
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
   14712:	683b      	ldr	r3, [r7, #0]
   14714:	6b5a      	ldr	r2, [r3, #52]	; 0x34
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
	}

	uint32_t pad_pinmuxes[] = {
   14716:	230c      	movs	r3, #12
   14718:	18fb      	adds	r3, r7, r3
   1471a:	60da      	str	r2, [r3, #12]
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
   1471c:	2347      	movs	r3, #71	; 0x47
   1471e:	18fb      	adds	r3, r7, r3
   14720:	2200      	movs	r2, #0
   14722:	701a      	strb	r2, [r3, #0]
   14724:	e02c      	b.n	14780 <_spi_set_config+0xc4>
		uint32_t current_pinmux = pad_pinmuxes[pad];
   14726:	2347      	movs	r3, #71	; 0x47
   14728:	18fb      	adds	r3, r7, r3
   1472a:	781a      	ldrb	r2, [r3, #0]
   1472c:	230c      	movs	r3, #12
   1472e:	18fb      	adds	r3, r7, r3
   14730:	0092      	lsls	r2, r2, #2
   14732:	58d3      	ldr	r3, [r2, r3]
   14734:	643b      	str	r3, [r7, #64]	; 0x40

		if (current_pinmux == PINMUX_DEFAULT) {
   14736:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   14738:	2b00      	cmp	r3, #0
   1473a:	d109      	bne.n	14750 <_spi_set_config+0x94>
			current_pinmux = _sercom_get_default_pad(hw, pad);
   1473c:	2347      	movs	r3, #71	; 0x47
   1473e:	18fb      	adds	r3, r7, r3
   14740:	781a      	ldrb	r2, [r3, #0]
   14742:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   14744:	0011      	movs	r1, r2
   14746:	0018      	movs	r0, r3
   14748:	4b5a      	ldr	r3, [pc, #360]	; (148b4 <_spi_set_config+0x1f8>)
   1474a:	4798      	blx	r3
   1474c:	0003      	movs	r3, r0
   1474e:	643b      	str	r3, [r7, #64]	; 0x40
		}

		if (current_pinmux != PINMUX_UNUSED) {
   14750:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   14752:	3301      	adds	r3, #1
   14754:	d00d      	beq.n	14772 <_spi_set_config+0xb6>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
   14756:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   14758:	b2da      	uxtb	r2, r3
   1475a:	231c      	movs	r3, #28
   1475c:	18fb      	adds	r3, r7, r3
   1475e:	701a      	strb	r2, [r3, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
   14760:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   14762:	0c1b      	lsrs	r3, r3, #16
   14764:	b2db      	uxtb	r3, r3
   14766:	221c      	movs	r2, #28
   14768:	18ba      	adds	r2, r7, r2
   1476a:	0011      	movs	r1, r2
   1476c:	0018      	movs	r0, r3
   1476e:	4b52      	ldr	r3, [pc, #328]	; (148b8 <_spi_set_config+0x1fc>)
   14770:	4798      	blx	r3
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
   14772:	2347      	movs	r3, #71	; 0x47
   14774:	18fb      	adds	r3, r7, r3
   14776:	781a      	ldrb	r2, [r3, #0]
   14778:	2347      	movs	r3, #71	; 0x47
   1477a:	18fb      	adds	r3, r7, r3
   1477c:	3201      	adds	r2, #1
   1477e:	701a      	strb	r2, [r3, #0]
   14780:	2347      	movs	r3, #71	; 0x47
   14782:	18fb      	adds	r3, r7, r3
   14784:	781b      	ldrb	r3, [r3, #0]
   14786:	2b03      	cmp	r3, #3
   14788:	d9cd      	bls.n	14726 <_spi_set_config+0x6a>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
   1478a:	683b      	ldr	r3, [r7, #0]
   1478c:	781a      	ldrb	r2, [r3, #0]
   1478e:	687b      	ldr	r3, [r7, #4]
   14790:	715a      	strb	r2, [r3, #5]
	module->character_size   = config->character_size;
   14792:	683b      	ldr	r3, [r7, #0]
   14794:	7c1a      	ldrb	r2, [r3, #16]
   14796:	687b      	ldr	r3, [r7, #4]
   14798:	719a      	strb	r2, [r3, #6]
	module->receiver_enabled = config->receiver_enable;
   1479a:	683b      	ldr	r3, [r7, #0]
   1479c:	7c9a      	ldrb	r2, [r3, #18]
   1479e:	687b      	ldr	r3, [r7, #4]
   147a0:	71da      	strb	r2, [r3, #7]
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	module->master_slave_select_enable = config->master_slave_select_enable;
   147a2:	683b      	ldr	r3, [r7, #0]
   147a4:	7d1a      	ldrb	r2, [r3, #20]
   147a6:	687b      	ldr	r3, [r7, #4]
   147a8:	721a      	strb	r2, [r3, #8]
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
   147aa:	230a      	movs	r3, #10
   147ac:	18fb      	adds	r3, r7, r3
   147ae:	2200      	movs	r2, #0
   147b0:	801a      	strh	r2, [r3, #0]
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
   147b2:	2300      	movs	r3, #0
   147b4:	63fb      	str	r3, [r7, #60]	; 0x3c
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;
   147b6:	2300      	movs	r3, #0
   147b8:	63bb      	str	r3, [r7, #56]	; 0x38

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
   147ba:	683b      	ldr	r3, [r7, #0]
   147bc:	781b      	ldrb	r3, [r3, #0]
   147be:	2b01      	cmp	r3, #1
   147c0:	d129      	bne.n	14816 <_spi_set_config+0x15a>
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   147c2:	687b      	ldr	r3, [r7, #4]
   147c4:	681b      	ldr	r3, [r3, #0]
   147c6:	0018      	movs	r0, r3
   147c8:	4b3c      	ldr	r3, [pc, #240]	; (148bc <_spi_set_config+0x200>)
   147ca:	4798      	blx	r3
   147cc:	0003      	movs	r3, r0
   147ce:	62fb      	str	r3, [r7, #44]	; 0x2c
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   147d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   147d2:	3314      	adds	r3, #20
   147d4:	62bb      	str	r3, [r7, #40]	; 0x28
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
   147d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   147d8:	b2db      	uxtb	r3, r3
   147da:	0018      	movs	r0, r3
   147dc:	4b38      	ldr	r3, [pc, #224]	; (148c0 <_spi_set_config+0x204>)
   147de:	4798      	blx	r3
   147e0:	0003      	movs	r3, r0
   147e2:	627b      	str	r3, [r7, #36]	; 0x24

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
   147e4:	683b      	ldr	r3, [r7, #0]
   147e6:	699b      	ldr	r3, [r3, #24]
   147e8:	2223      	movs	r2, #35	; 0x23
   147ea:	18bc      	adds	r4, r7, r2
   147ec:	220a      	movs	r2, #10
   147ee:	18ba      	adds	r2, r7, r2
   147f0:	6a79      	ldr	r1, [r7, #36]	; 0x24
   147f2:	0018      	movs	r0, r3
   147f4:	4b33      	ldr	r3, [pc, #204]	; (148c4 <_spi_set_config+0x208>)
   147f6:	4798      	blx	r3
   147f8:	0003      	movs	r3, r0
   147fa:	7023      	strb	r3, [r4, #0]
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
   147fc:	2323      	movs	r3, #35	; 0x23
   147fe:	18fb      	adds	r3, r7, r3
   14800:	781b      	ldrb	r3, [r3, #0]
   14802:	2b00      	cmp	r3, #0
   14804:	d001      	beq.n	1480a <_spi_set_config+0x14e>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
   14806:	2317      	movs	r3, #23
   14808:	e04e      	b.n	148a8 <_spi_set_config+0x1ec>
		}

		spi_module->BAUD.reg = (uint8_t)baud;
   1480a:	230a      	movs	r3, #10
   1480c:	18fb      	adds	r3, r7, r3
   1480e:	881b      	ldrh	r3, [r3, #0]
   14810:	b2da      	uxtb	r2, r3
   14812:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   14814:	731a      	strb	r2, [r3, #12]
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
		}
	}
# endif
	/* Set data order */
	ctrla |= config->data_order;
   14816:	683b      	ldr	r3, [r7, #0]
   14818:	685b      	ldr	r3, [r3, #4]
   1481a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   1481c:	4313      	orrs	r3, r2
   1481e:	63fb      	str	r3, [r7, #60]	; 0x3c

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;
   14820:	683b      	ldr	r3, [r7, #0]
   14822:	689b      	ldr	r3, [r3, #8]
   14824:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   14826:	4313      	orrs	r3, r2
   14828:	63fb      	str	r3, [r7, #60]	; 0x3c

	/* Set MUX setting */
	ctrla |= config->mux_setting;
   1482a:	683b      	ldr	r3, [r7, #0]
   1482c:	68db      	ldr	r3, [r3, #12]
   1482e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   14830:	4313      	orrs	r3, r2
   14832:	63fb      	str	r3, [r7, #60]	; 0x3c

	/* Set SPI character size */
	ctrlb |= config->character_size;
   14834:	683b      	ldr	r3, [r7, #0]
   14836:	7c1b      	ldrb	r3, [r3, #16]
   14838:	001a      	movs	r2, r3
   1483a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1483c:	4313      	orrs	r3, r2
   1483e:	63bb      	str	r3, [r7, #56]	; 0x38

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
   14840:	683b      	ldr	r3, [r7, #0]
   14842:	7c5b      	ldrb	r3, [r3, #17]
   14844:	2b00      	cmp	r3, #0
   14846:	d103      	bne.n	14850 <_spi_set_config+0x194>
   14848:	4b1f      	ldr	r3, [pc, #124]	; (148c8 <_spi_set_config+0x20c>)
   1484a:	4798      	blx	r3
   1484c:	1e03      	subs	r3, r0, #0
   1484e:	d003      	beq.n	14858 <_spi_set_config+0x19c>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
   14850:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   14852:	2280      	movs	r2, #128	; 0x80
   14854:	4313      	orrs	r3, r2
   14856:	63fb      	str	r3, [r7, #60]	; 0x3c
	}

	if (config->receiver_enable) {
   14858:	683b      	ldr	r3, [r7, #0]
   1485a:	7c9b      	ldrb	r3, [r3, #18]
   1485c:	2b00      	cmp	r3, #0
   1485e:	d004      	beq.n	1486a <_spi_set_config+0x1ae>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
   14860:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   14862:	2280      	movs	r2, #128	; 0x80
   14864:	0292      	lsls	r2, r2, #10
   14866:	4313      	orrs	r3, r2
   14868:	63bb      	str	r3, [r7, #56]	; 0x38
	}
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	if (config->select_slave_low_detect_enable) {
   1486a:	683b      	ldr	r3, [r7, #0]
   1486c:	7cdb      	ldrb	r3, [r3, #19]
   1486e:	2b00      	cmp	r3, #0
   14870:	d004      	beq.n	1487c <_spi_set_config+0x1c0>
		/* Enable Slave Select Low Detect */
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
   14872:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   14874:	2280      	movs	r2, #128	; 0x80
   14876:	0092      	lsls	r2, r2, #2
   14878:	4313      	orrs	r3, r2
   1487a:	63bb      	str	r3, [r7, #56]	; 0x38
	}
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if (config->master_slave_select_enable) {
   1487c:	683b      	ldr	r3, [r7, #0]
   1487e:	7d1b      	ldrb	r3, [r3, #20]
   14880:	2b00      	cmp	r3, #0
   14882:	d004      	beq.n	1488e <_spi_set_config+0x1d2>
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
   14884:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   14886:	2280      	movs	r2, #128	; 0x80
   14888:	0192      	lsls	r2, r2, #6
   1488a:	4313      	orrs	r3, r2
   1488c:	63bb      	str	r3, [r7, #56]	; 0x38
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
   1488e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   14890:	681a      	ldr	r2, [r3, #0]
   14892:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   14894:	431a      	orrs	r2, r3
   14896:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   14898:	601a      	str	r2, [r3, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;
   1489a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1489c:	685a      	ldr	r2, [r3, #4]
   1489e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   148a0:	431a      	orrs	r2, r3
   148a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   148a4:	605a      	str	r2, [r3, #4]

	return STATUS_OK;
   148a6:	2300      	movs	r3, #0
}
   148a8:	0018      	movs	r0, r3
   148aa:	46bd      	mov	sp, r7
   148ac:	b013      	add	sp, #76	; 0x4c
   148ae:	bd90      	pop	{r4, r7, pc}
   148b0:	000141f5 	.word	0x000141f5
   148b4:	00013e8d 	.word	0x00013e8d
   148b8:	00016d15 	.word	0x00016d15
   148bc:	00014049 	.word	0x00014049
   148c0:	00016b4d 	.word	0x00016b4d
   148c4:	00013b99 	.word	0x00013b99
   148c8:	00014369 	.word	0x00014369

000148cc <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
   148cc:	b590      	push	{r4, r7, lr}
   148ce:	b08b      	sub	sp, #44	; 0x2c
   148d0:	af00      	add	r7, sp, #0
   148d2:	60f8      	str	r0, [r7, #12]
   148d4:	60b9      	str	r1, [r7, #8]
   148d6:	607a      	str	r2, [r7, #4]
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
   148d8:	68fb      	ldr	r3, [r7, #12]
   148da:	68ba      	ldr	r2, [r7, #8]
   148dc:	601a      	str	r2, [r3, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);
   148de:	68fb      	ldr	r3, [r7, #12]
   148e0:	681b      	ldr	r3, [r3, #0]
   148e2:	623b      	str	r3, [r7, #32]

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
   148e4:	6a3b      	ldr	r3, [r7, #32]
   148e6:	681b      	ldr	r3, [r3, #0]
   148e8:	2202      	movs	r2, #2
   148ea:	4013      	ands	r3, r2
   148ec:	d001      	beq.n	148f2 <spi_init+0x26>
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
   148ee:	231c      	movs	r3, #28
   148f0:	e09c      	b.n	14a2c <spi_init+0x160>
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
   148f2:	6a3b      	ldr	r3, [r7, #32]
   148f4:	681b      	ldr	r3, [r3, #0]
   148f6:	2201      	movs	r2, #1
   148f8:	4013      	ands	r3, r2
   148fa:	d001      	beq.n	14900 <spi_init+0x34>
		return STATUS_BUSY;
   148fc:	2305      	movs	r3, #5
   148fe:	e095      	b.n	14a2c <spi_init+0x160>
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   14900:	68fb      	ldr	r3, [r7, #12]
   14902:	681b      	ldr	r3, [r3, #0]
   14904:	0018      	movs	r0, r3
   14906:	4b4b      	ldr	r3, [pc, #300]	; (14a34 <spi_init+0x168>)
   14908:	4798      	blx	r3
   1490a:	0003      	movs	r3, r0
   1490c:	61fb      	str	r3, [r7, #28]
	}
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
   1490e:	69fb      	ldr	r3, [r7, #28]
   14910:	3302      	adds	r3, #2
   14912:	61bb      	str	r3, [r7, #24]
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   14914:	69fb      	ldr	r3, [r7, #28]
   14916:	3314      	adds	r3, #20
   14918:	617b      	str	r3, [r7, #20]
#  endif
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
   1491a:	2201      	movs	r2, #1
   1491c:	69bb      	ldr	r3, [r7, #24]
   1491e:	409a      	lsls	r2, r3
   14920:	0013      	movs	r3, r2
   14922:	0019      	movs	r1, r3
   14924:	2002      	movs	r0, #2
   14926:	4b44      	ldr	r3, [pc, #272]	; (14a38 <spi_init+0x16c>)
   14928:	4798      	blx	r3
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
   1492a:	2310      	movs	r3, #16
   1492c:	18fb      	adds	r3, r7, r3
   1492e:	0018      	movs	r0, r3
   14930:	4b42      	ldr	r3, [pc, #264]	; (14a3c <spi_init+0x170>)
   14932:	4798      	blx	r3
	gclk_chan_conf.source_generator = config->generator_source;
   14934:	687b      	ldr	r3, [r7, #4]
   14936:	2224      	movs	r2, #36	; 0x24
   14938:	5c9a      	ldrb	r2, [r3, r2]
   1493a:	2310      	movs	r3, #16
   1493c:	18fb      	adds	r3, r7, r3
   1493e:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
   14940:	697b      	ldr	r3, [r7, #20]
   14942:	b2db      	uxtb	r3, r3
   14944:	2210      	movs	r2, #16
   14946:	18ba      	adds	r2, r7, r2
   14948:	0011      	movs	r1, r2
   1494a:	0018      	movs	r0, r3
   1494c:	4b3c      	ldr	r3, [pc, #240]	; (14a40 <spi_init+0x174>)
   1494e:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
   14950:	697b      	ldr	r3, [r7, #20]
   14952:	b2db      	uxtb	r3, r3
   14954:	0018      	movs	r0, r3
   14956:	4b3b      	ldr	r3, [pc, #236]	; (14a44 <spi_init+0x178>)
   14958:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
   1495a:	687b      	ldr	r3, [r7, #4]
   1495c:	2224      	movs	r2, #36	; 0x24
   1495e:	5c9b      	ldrb	r3, [r3, r2]
   14960:	2100      	movs	r1, #0
   14962:	0018      	movs	r0, r3
   14964:	4b38      	ldr	r3, [pc, #224]	; (14a48 <spi_init+0x17c>)
   14966:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
   14968:	687b      	ldr	r3, [r7, #4]
   1496a:	781b      	ldrb	r3, [r3, #0]
   1496c:	2b01      	cmp	r3, #1
   1496e:	d105      	bne.n	1497c <spi_init+0xb0>
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
   14970:	6a3b      	ldr	r3, [r7, #32]
   14972:	681b      	ldr	r3, [r3, #0]
   14974:	220c      	movs	r2, #12
   14976:	431a      	orrs	r2, r3
   14978:	6a3b      	ldr	r3, [r7, #32]
   1497a:	601a      	str	r2, [r3, #0]
	/* Temporary variables */
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
   1497c:	2327      	movs	r3, #39	; 0x27
   1497e:	18fb      	adds	r3, r7, r3
   14980:	2200      	movs	r2, #0
   14982:	701a      	strb	r2, [r3, #0]
   14984:	e010      	b.n	149a8 <spi_init+0xdc>
		module->callback[i]        = NULL;
   14986:	2327      	movs	r3, #39	; 0x27
   14988:	18fb      	adds	r3, r7, r3
   1498a:	781b      	ldrb	r3, [r3, #0]
   1498c:	68fa      	ldr	r2, [r7, #12]
   1498e:	3302      	adds	r3, #2
   14990:	009b      	lsls	r3, r3, #2
   14992:	18d3      	adds	r3, r2, r3
   14994:	3304      	adds	r3, #4
   14996:	2200      	movs	r2, #0
   14998:	601a      	str	r2, [r3, #0]
	/* Temporary variables */
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
   1499a:	2327      	movs	r3, #39	; 0x27
   1499c:	18fb      	adds	r3, r7, r3
   1499e:	781a      	ldrb	r2, [r3, #0]
   149a0:	2327      	movs	r3, #39	; 0x27
   149a2:	18fb      	adds	r3, r7, r3
   149a4:	3201      	adds	r2, #1
   149a6:	701a      	strb	r2, [r3, #0]
   149a8:	2327      	movs	r3, #39	; 0x27
   149aa:	18fb      	adds	r3, r7, r3
   149ac:	781b      	ldrb	r3, [r3, #0]
   149ae:	2b06      	cmp	r3, #6
   149b0:	d9e9      	bls.n	14986 <spi_init+0xba>
		module->callback[i]        = NULL;
	}
	module->tx_buffer_ptr              = NULL;
   149b2:	68fb      	ldr	r3, [r7, #12]
   149b4:	2200      	movs	r2, #0
   149b6:	62da      	str	r2, [r3, #44]	; 0x2c
	module->rx_buffer_ptr              = NULL;
   149b8:	68fb      	ldr	r3, [r7, #12]
   149ba:	2200      	movs	r2, #0
   149bc:	629a      	str	r2, [r3, #40]	; 0x28
	module->remaining_tx_buffer_length = 0x0000;
   149be:	68fb      	ldr	r3, [r7, #12]
   149c0:	2200      	movs	r2, #0
   149c2:	869a      	strh	r2, [r3, #52]	; 0x34
	module->remaining_rx_buffer_length = 0x0000;
   149c4:	68fb      	ldr	r3, [r7, #12]
   149c6:	2200      	movs	r2, #0
   149c8:	861a      	strh	r2, [r3, #48]	; 0x30
	module->registered_callback        = 0x00;
   149ca:	68fb      	ldr	r3, [r7, #12]
   149cc:	2236      	movs	r2, #54	; 0x36
   149ce:	2100      	movs	r1, #0
   149d0:	5499      	strb	r1, [r3, r2]
	module->enabled_callback           = 0x00;
   149d2:	68fb      	ldr	r3, [r7, #12]
   149d4:	2237      	movs	r2, #55	; 0x37
   149d6:	2100      	movs	r1, #0
   149d8:	5499      	strb	r1, [r3, r2]
	module->status                     = STATUS_OK;
   149da:	68fb      	ldr	r3, [r7, #12]
   149dc:	2238      	movs	r2, #56	; 0x38
   149de:	2100      	movs	r1, #0
   149e0:	5499      	strb	r1, [r3, r2]
	module->dir                        = SPI_DIRECTION_IDLE;
   149e2:	68fb      	ldr	r3, [r7, #12]
   149e4:	2203      	movs	r2, #3
   149e6:	725a      	strb	r2, [r3, #9]
	module->locked                     = false;
   149e8:	68fb      	ldr	r3, [r7, #12]
   149ea:	2200      	movs	r2, #0
   149ec:	711a      	strb	r2, [r3, #4]
	/*
	 * Set interrupt handler and register SPI software module struct in
	 * look-up table
	 */
	instance_index = _sercom_get_sercom_inst_index(module->hw);
   149ee:	68fb      	ldr	r3, [r7, #12]
   149f0:	681b      	ldr	r3, [r3, #0]
   149f2:	2213      	movs	r2, #19
   149f4:	18bc      	adds	r4, r7, r2
   149f6:	0018      	movs	r0, r3
   149f8:	4b0e      	ldr	r3, [pc, #56]	; (14a34 <spi_init+0x168>)
   149fa:	4798      	blx	r3
   149fc:	0003      	movs	r3, r0
   149fe:	7023      	strb	r3, [r4, #0]
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
   14a00:	4a12      	ldr	r2, [pc, #72]	; (14a4c <spi_init+0x180>)
   14a02:	2313      	movs	r3, #19
   14a04:	18fb      	adds	r3, r7, r3
   14a06:	781b      	ldrb	r3, [r3, #0]
   14a08:	0011      	movs	r1, r2
   14a0a:	0018      	movs	r0, r3
   14a0c:	4b10      	ldr	r3, [pc, #64]	; (14a50 <spi_init+0x184>)
   14a0e:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
   14a10:	2313      	movs	r3, #19
   14a12:	18fb      	adds	r3, r7, r3
   14a14:	781a      	ldrb	r2, [r3, #0]
   14a16:	4b0f      	ldr	r3, [pc, #60]	; (14a54 <spi_init+0x188>)
   14a18:	0092      	lsls	r2, r2, #2
   14a1a:	68f9      	ldr	r1, [r7, #12]
   14a1c:	50d1      	str	r1, [r2, r3]
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
   14a1e:	687a      	ldr	r2, [r7, #4]
   14a20:	68fb      	ldr	r3, [r7, #12]
   14a22:	0011      	movs	r1, r2
   14a24:	0018      	movs	r0, r3
   14a26:	4b0c      	ldr	r3, [pc, #48]	; (14a58 <spi_init+0x18c>)
   14a28:	4798      	blx	r3
   14a2a:	0003      	movs	r3, r0
}
   14a2c:	0018      	movs	r0, r3
   14a2e:	46bd      	mov	sp, r7
   14a30:	b00b      	add	sp, #44	; 0x2c
   14a32:	bd90      	pop	{r4, r7, pc}
   14a34:	00014049 	.word	0x00014049
   14a38:	0001430d 	.word	0x0001430d
   14a3c:	000142f5 	.word	0x000142f5
   14a40:	000169e1 	.word	0x000169e1
   14a44:	00016a25 	.word	0x00016a25
   14a48:	00013e01 	.word	0x00013e01
   14a4c:	00014fd5 	.word	0x00014fd5
   14a50:	000140ad 	.word	0x000140ad
   14a54:	20004bac 	.word	0x20004bac
   14a58:	000146bd 	.word	0x000146bd

00014a5c <spi_read_buffer_wait>:
enum status_code spi_read_buffer_wait(
		struct spi_module *const module,
		uint8_t *rx_data,
		uint16_t length,
		uint16_t dummy)
{
   14a5c:	b590      	push	{r4, r7, lr}
   14a5e:	b087      	sub	sp, #28
   14a60:	af00      	add	r7, sp, #0
   14a62:	60f8      	str	r0, [r7, #12]
   14a64:	60b9      	str	r1, [r7, #8]
   14a66:	0019      	movs	r1, r3
   14a68:	1dbb      	adds	r3, r7, #6
   14a6a:	801a      	strh	r2, [r3, #0]
   14a6c:	1d3b      	adds	r3, r7, #4
   14a6e:	1c0a      	adds	r2, r1, #0
   14a70:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
   14a72:	68fb      	ldr	r3, [r7, #12]
   14a74:	2238      	movs	r2, #56	; 0x38
   14a76:	5c9b      	ldrb	r3, [r3, r2]
   14a78:	b2db      	uxtb	r3, r3
   14a7a:	2b05      	cmp	r3, #5
   14a7c:	d101      	bne.n	14a82 <spi_read_buffer_wait+0x26>
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
   14a7e:	2305      	movs	r3, #5
   14a80:	e07a      	b.n	14b78 <spi_read_buffer_wait+0x11c>
	}
#  endif

	/* Sanity check arguments */
	if (length == 0) {
   14a82:	1dbb      	adds	r3, r7, #6
   14a84:	881b      	ldrh	r3, [r3, #0]
   14a86:	2b00      	cmp	r3, #0
   14a88:	d101      	bne.n	14a8e <spi_read_buffer_wait+0x32>
		return STATUS_ERR_INVALID_ARG;
   14a8a:	2317      	movs	r3, #23
   14a8c:	e074      	b.n	14b78 <spi_read_buffer_wait+0x11c>
	}

	if (!(module->receiver_enabled)) {
   14a8e:	68fb      	ldr	r3, [r7, #12]
   14a90:	79db      	ldrb	r3, [r3, #7]
   14a92:	2201      	movs	r2, #1
   14a94:	4053      	eors	r3, r2
   14a96:	b2db      	uxtb	r3, r3
   14a98:	2b00      	cmp	r3, #0
   14a9a:	d001      	beq.n	14aa0 <spi_read_buffer_wait+0x44>
		return STATUS_ERR_DENIED;
   14a9c:	231c      	movs	r3, #28
   14a9e:	e06b      	b.n	14b78 <spi_read_buffer_wait+0x11c>
	if ((module->mode == SPI_MODE_SLAVE) && (spi_is_write_complete(module))) {
		/* Clear TX complete flag */
		_spi_clear_tx_complete_flag(module);
	}
#  endif
	uint16_t rx_pos = 0;
   14aa0:	2316      	movs	r3, #22
   14aa2:	18fb      	adds	r3, r7, r3
   14aa4:	2200      	movs	r2, #0
   14aa6:	801a      	strh	r2, [r3, #0]

	while (length--) {
   14aa8:	e05e      	b.n	14b68 <spi_read_buffer_wait+0x10c>
#  if CONF_SPI_MASTER_ENABLE == true
		if (module->mode == SPI_MODE_MASTER) {
   14aaa:	68fb      	ldr	r3, [r7, #12]
   14aac:	795b      	ldrb	r3, [r3, #5]
   14aae:	2b01      	cmp	r3, #1
   14ab0:	d112      	bne.n	14ad8 <spi_read_buffer_wait+0x7c>
			/* Wait until the module is ready to write a character */
			while (!spi_is_ready_to_write(module)) {
   14ab2:	46c0      	nop			; (mov r8, r8)
   14ab4:	68fb      	ldr	r3, [r7, #12]
   14ab6:	0018      	movs	r0, r3
   14ab8:	4b31      	ldr	r3, [pc, #196]	; (14b80 <spi_read_buffer_wait+0x124>)
   14aba:	4798      	blx	r3
   14abc:	0003      	movs	r3, r0
   14abe:	001a      	movs	r2, r3
   14ac0:	2301      	movs	r3, #1
   14ac2:	4053      	eors	r3, r2
   14ac4:	b2db      	uxtb	r3, r3
   14ac6:	2b00      	cmp	r3, #0
   14ac8:	d1f4      	bne.n	14ab4 <spi_read_buffer_wait+0x58>
			}

			/* Send dummy SPI character to read in master mode */
			spi_write(module, dummy);
   14aca:	1d3b      	adds	r3, r7, #4
   14acc:	881a      	ldrh	r2, [r3, #0]
   14ace:	68fb      	ldr	r3, [r7, #12]
   14ad0:	0011      	movs	r1, r2
   14ad2:	0018      	movs	r0, r3
   14ad4:	4b2b      	ldr	r3, [pc, #172]	; (14b84 <spi_read_buffer_wait+0x128>)
   14ad6:	4798      	blx	r3
			}
		}
#  endif

		/* Wait until the module is ready to read a character */
		while (!spi_is_ready_to_read(module)) {
   14ad8:	46c0      	nop			; (mov r8, r8)
   14ada:	68fb      	ldr	r3, [r7, #12]
   14adc:	0018      	movs	r0, r3
   14ade:	4b2a      	ldr	r3, [pc, #168]	; (14b88 <spi_read_buffer_wait+0x12c>)
   14ae0:	4798      	blx	r3
   14ae2:	0003      	movs	r3, r0
   14ae4:	001a      	movs	r2, r3
   14ae6:	2301      	movs	r3, #1
   14ae8:	4053      	eors	r3, r2
   14aea:	b2db      	uxtb	r3, r3
   14aec:	2b00      	cmp	r3, #0
   14aee:	d1f4      	bne.n	14ada <spi_read_buffer_wait+0x7e>
		}

		uint16_t received_data = 0;
   14af0:	2312      	movs	r3, #18
   14af2:	18fb      	adds	r3, r7, r3
   14af4:	2200      	movs	r2, #0
   14af6:	801a      	strh	r2, [r3, #0]
		enum status_code retval = spi_read(module, &received_data);
   14af8:	2315      	movs	r3, #21
   14afa:	18fc      	adds	r4, r7, r3
   14afc:	2312      	movs	r3, #18
   14afe:	18fa      	adds	r2, r7, r3
   14b00:	68fb      	ldr	r3, [r7, #12]
   14b02:	0011      	movs	r1, r2
   14b04:	0018      	movs	r0, r3
   14b06:	4b21      	ldr	r3, [pc, #132]	; (14b8c <spi_read_buffer_wait+0x130>)
   14b08:	4798      	blx	r3
   14b0a:	0003      	movs	r3, r0
   14b0c:	7023      	strb	r3, [r4, #0]

		if (retval != STATUS_OK) {
   14b0e:	2315      	movs	r3, #21
   14b10:	18fb      	adds	r3, r7, r3
   14b12:	781b      	ldrb	r3, [r3, #0]
   14b14:	2b00      	cmp	r3, #0
   14b16:	d003      	beq.n	14b20 <spi_read_buffer_wait+0xc4>
			/* Overflow, abort */
			return retval;
   14b18:	2315      	movs	r3, #21
   14b1a:	18fb      	adds	r3, r7, r3
   14b1c:	781b      	ldrb	r3, [r3, #0]
   14b1e:	e02b      	b.n	14b78 <spi_read_buffer_wait+0x11c>
		}

		/* Read value will be at least 8-bits long */
		rx_data[rx_pos++] = received_data;
   14b20:	2316      	movs	r3, #22
   14b22:	18fb      	adds	r3, r7, r3
   14b24:	881b      	ldrh	r3, [r3, #0]
   14b26:	2216      	movs	r2, #22
   14b28:	18ba      	adds	r2, r7, r2
   14b2a:	1c59      	adds	r1, r3, #1
   14b2c:	8011      	strh	r1, [r2, #0]
   14b2e:	001a      	movs	r2, r3
   14b30:	68bb      	ldr	r3, [r7, #8]
   14b32:	189b      	adds	r3, r3, r2
   14b34:	2212      	movs	r2, #18
   14b36:	18ba      	adds	r2, r7, r2
   14b38:	8812      	ldrh	r2, [r2, #0]
   14b3a:	b2d2      	uxtb	r2, r2
   14b3c:	701a      	strb	r2, [r3, #0]

		/* If 9-bit data, write next received byte to the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   14b3e:	68fb      	ldr	r3, [r7, #12]
   14b40:	799b      	ldrb	r3, [r3, #6]
   14b42:	2b01      	cmp	r3, #1
   14b44:	d110      	bne.n	14b68 <spi_read_buffer_wait+0x10c>
			rx_data[rx_pos++] = (received_data >> 8);
   14b46:	2316      	movs	r3, #22
   14b48:	18fb      	adds	r3, r7, r3
   14b4a:	881b      	ldrh	r3, [r3, #0]
   14b4c:	2216      	movs	r2, #22
   14b4e:	18ba      	adds	r2, r7, r2
   14b50:	1c59      	adds	r1, r3, #1
   14b52:	8011      	strh	r1, [r2, #0]
   14b54:	001a      	movs	r2, r3
   14b56:	68bb      	ldr	r3, [r7, #8]
   14b58:	189b      	adds	r3, r3, r2
   14b5a:	2212      	movs	r2, #18
   14b5c:	18ba      	adds	r2, r7, r2
   14b5e:	8812      	ldrh	r2, [r2, #0]
   14b60:	0a12      	lsrs	r2, r2, #8
   14b62:	b292      	uxth	r2, r2
   14b64:	b2d2      	uxtb	r2, r2
   14b66:	701a      	strb	r2, [r3, #0]
		_spi_clear_tx_complete_flag(module);
	}
#  endif
	uint16_t rx_pos = 0;

	while (length--) {
   14b68:	1dbb      	adds	r3, r7, #6
   14b6a:	881b      	ldrh	r3, [r3, #0]
   14b6c:	1dba      	adds	r2, r7, #6
   14b6e:	1e59      	subs	r1, r3, #1
   14b70:	8011      	strh	r1, [r2, #0]
   14b72:	2b00      	cmp	r3, #0
   14b74:	d199      	bne.n	14aaa <spi_read_buffer_wait+0x4e>
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
			rx_data[rx_pos++] = (received_data >> 8);
		}
	}

	return STATUS_OK;
   14b76:	2300      	movs	r3, #0
}
   14b78:	0018      	movs	r0, r3
   14b7a:	46bd      	mov	sp, r7
   14b7c:	b007      	add	sp, #28
   14b7e:	bd90      	pop	{r4, r7, pc}
   14b80:	000144cd 	.word	0x000144cd
   14b84:	0001451d 	.word	0x0001451d
   14b88:	000144f5 	.word	0x000144f5
   14b8c:	00014565 	.word	0x00014565

00014b90 <spi_transceive_wait>:
 */
enum status_code spi_transceive_wait(
		struct spi_module *const module,
		uint16_t tx_data,
		uint16_t *rx_data)
{
   14b90:	b590      	push	{r4, r7, lr}
   14b92:	b087      	sub	sp, #28
   14b94:	af00      	add	r7, sp, #0
   14b96:	60f8      	str	r0, [r7, #12]
   14b98:	607a      	str	r2, [r7, #4]
   14b9a:	230a      	movs	r3, #10
   14b9c:	18fb      	adds	r3, r7, r3
   14b9e:	1c0a      	adds	r2, r1, #0
   14ba0:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);

	if (!(module->receiver_enabled)) {
   14ba2:	68fb      	ldr	r3, [r7, #12]
   14ba4:	79db      	ldrb	r3, [r3, #7]
   14ba6:	2201      	movs	r2, #1
   14ba8:	4053      	eors	r3, r2
   14baa:	b2db      	uxtb	r3, r3
   14bac:	2b00      	cmp	r3, #0
   14bae:	d001      	beq.n	14bb4 <spi_transceive_wait+0x24>
		return STATUS_ERR_DENIED;
   14bb0:	231c      	movs	r3, #28
   14bb2:	e038      	b.n	14c26 <spi_transceive_wait+0x96>
	}

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
   14bb4:	68fb      	ldr	r3, [r7, #12]
   14bb6:	2238      	movs	r2, #56	; 0x38
   14bb8:	5c9b      	ldrb	r3, [r3, r2]
   14bba:	b2db      	uxtb	r3, r3
   14bbc:	2b05      	cmp	r3, #5
   14bbe:	d101      	bne.n	14bc4 <spi_transceive_wait+0x34>
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
   14bc0:	2305      	movs	r3, #5
   14bc2:	e030      	b.n	14c26 <spi_transceive_wait+0x96>
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	uint16_t j;
#  endif
	enum status_code retval = STATUS_OK;
   14bc4:	2317      	movs	r3, #23
   14bc6:	18fb      	adds	r3, r7, r3
   14bc8:	2200      	movs	r2, #0
   14bca:	701a      	strb	r2, [r3, #0]
			}
		}
	}
#  endif
	/* Wait until the module is ready to write the character */
	while (!spi_is_ready_to_write(module)) {
   14bcc:	46c0      	nop			; (mov r8, r8)
   14bce:	68fb      	ldr	r3, [r7, #12]
   14bd0:	0018      	movs	r0, r3
   14bd2:	4b17      	ldr	r3, [pc, #92]	; (14c30 <spi_transceive_wait+0xa0>)
   14bd4:	4798      	blx	r3
   14bd6:	0003      	movs	r3, r0
   14bd8:	001a      	movs	r2, r3
   14bda:	2301      	movs	r3, #1
   14bdc:	4053      	eors	r3, r2
   14bde:	b2db      	uxtb	r3, r3
   14be0:	2b00      	cmp	r3, #0
   14be2:	d1f4      	bne.n	14bce <spi_transceive_wait+0x3e>
	}

	/* Write data */
	spi_write(module, tx_data);
   14be4:	230a      	movs	r3, #10
   14be6:	18fb      	adds	r3, r7, r3
   14be8:	881a      	ldrh	r2, [r3, #0]
   14bea:	68fb      	ldr	r3, [r7, #12]
   14bec:	0011      	movs	r1, r2
   14bee:	0018      	movs	r0, r3
   14bf0:	4b10      	ldr	r3, [pc, #64]	; (14c34 <spi_transceive_wait+0xa4>)
   14bf2:	4798      	blx	r3
		}
	}
#  endif

	/* Wait until the module is ready to read the character */
	while (!spi_is_ready_to_read(module)) {
   14bf4:	46c0      	nop			; (mov r8, r8)
   14bf6:	68fb      	ldr	r3, [r7, #12]
   14bf8:	0018      	movs	r0, r3
   14bfa:	4b0f      	ldr	r3, [pc, #60]	; (14c38 <spi_transceive_wait+0xa8>)
   14bfc:	4798      	blx	r3
   14bfe:	0003      	movs	r3, r0
   14c00:	001a      	movs	r2, r3
   14c02:	2301      	movs	r3, #1
   14c04:	4053      	eors	r3, r2
   14c06:	b2db      	uxtb	r3, r3
   14c08:	2b00      	cmp	r3, #0
   14c0a:	d1f4      	bne.n	14bf6 <spi_transceive_wait+0x66>
	}

	/* Read data */
	retval = spi_read(module, rx_data);
   14c0c:	2317      	movs	r3, #23
   14c0e:	18fc      	adds	r4, r7, r3
   14c10:	687a      	ldr	r2, [r7, #4]
   14c12:	68fb      	ldr	r3, [r7, #12]
   14c14:	0011      	movs	r1, r2
   14c16:	0018      	movs	r0, r3
   14c18:	4b08      	ldr	r3, [pc, #32]	; (14c3c <spi_transceive_wait+0xac>)
   14c1a:	4798      	blx	r3
   14c1c:	0003      	movs	r3, r0
   14c1e:	7023      	strb	r3, [r4, #0]

	return retval;
   14c20:	2317      	movs	r3, #23
   14c22:	18fb      	adds	r3, r7, r3
   14c24:	781b      	ldrb	r3, [r3, #0]
}
   14c26:	0018      	movs	r0, r3
   14c28:	46bd      	mov	sp, r7
   14c2a:	b007      	add	sp, #28
   14c2c:	bd90      	pop	{r4, r7, pc}
   14c2e:	46c0      	nop			; (mov r8, r8)
   14c30:	000144cd 	.word	0x000144cd
   14c34:	0001451d 	.word	0x0001451d
   14c38:	000144f5 	.word	0x000144f5
   14c3c:	00014565 	.word	0x00014565

00014c40 <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
   14c40:	b580      	push	{r7, lr}
   14c42:	b086      	sub	sp, #24
   14c44:	af00      	add	r7, sp, #0
   14c46:	60f8      	str	r0, [r7, #12]
   14c48:	60b9      	str	r1, [r7, #8]
   14c4a:	1dfb      	adds	r3, r7, #7
   14c4c:	701a      	strb	r2, [r3, #0]
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
   14c4e:	68fb      	ldr	r3, [r7, #12]
   14c50:	795b      	ldrb	r3, [r3, #5]
   14c52:	2b01      	cmp	r3, #1
   14c54:	d001      	beq.n	14c5a <spi_select_slave+0x1a>
		return STATUS_ERR_UNSUPPORTED_DEV;
   14c56:	2315      	movs	r3, #21
   14c58:	e05c      	b.n	14d14 <spi_select_slave+0xd4>
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
   14c5a:	68fb      	ldr	r3, [r7, #12]
   14c5c:	7a1b      	ldrb	r3, [r3, #8]
   14c5e:	2201      	movs	r2, #1
   14c60:	4053      	eors	r3, r2
   14c62:	b2db      	uxtb	r3, r3
   14c64:	2b00      	cmp	r3, #0
   14c66:	d054      	beq.n	14d12 <spi_select_slave+0xd2>
#  endif
	{
		if (select) {
   14c68:	1dfb      	adds	r3, r7, #7
   14c6a:	781b      	ldrb	r3, [r3, #0]
   14c6c:	2b00      	cmp	r3, #0
   14c6e:	d04a      	beq.n	14d06 <spi_select_slave+0xc6>
			/* Check if address recognition is enabled */
			if (slave->address_enabled) {
   14c70:	68bb      	ldr	r3, [r7, #8]
   14c72:	785b      	ldrb	r3, [r3, #1]
   14c74:	2b00      	cmp	r3, #0
   14c76:	d03f      	beq.n	14cf8 <spi_select_slave+0xb8>
				/* Check if the module is ready to write the address */
				if (!spi_is_ready_to_write(module)) {
   14c78:	68fb      	ldr	r3, [r7, #12]
   14c7a:	0018      	movs	r0, r3
   14c7c:	4b27      	ldr	r3, [pc, #156]	; (14d1c <spi_select_slave+0xdc>)
   14c7e:	4798      	blx	r3
   14c80:	0003      	movs	r3, r0
   14c82:	001a      	movs	r2, r3
   14c84:	2301      	movs	r3, #1
   14c86:	4053      	eors	r3, r2
   14c88:	b2db      	uxtb	r3, r3
   14c8a:	2b00      	cmp	r3, #0
   14c8c:	d007      	beq.n	14c9e <spi_select_slave+0x5e>
					/* Not ready, do not select slave and return */
					port_pin_set_output_level(slave->ss_pin, true);
   14c8e:	68bb      	ldr	r3, [r7, #8]
   14c90:	781b      	ldrb	r3, [r3, #0]
   14c92:	2101      	movs	r1, #1
   14c94:	0018      	movs	r0, r3
   14c96:	4b22      	ldr	r3, [pc, #136]	; (14d20 <spi_select_slave+0xe0>)
   14c98:	4798      	blx	r3
					return STATUS_BUSY;
   14c9a:	2305      	movs	r3, #5
   14c9c:	e03a      	b.n	14d14 <spi_select_slave+0xd4>
				}

				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
   14c9e:	68bb      	ldr	r3, [r7, #8]
   14ca0:	781b      	ldrb	r3, [r3, #0]
   14ca2:	2100      	movs	r1, #0
   14ca4:	0018      	movs	r0, r3
   14ca6:	4b1e      	ldr	r3, [pc, #120]	; (14d20 <spi_select_slave+0xe0>)
   14ca8:	4798      	blx	r3

				/* Write address to slave */
				spi_write(module, slave->address);
   14caa:	68bb      	ldr	r3, [r7, #8]
   14cac:	789b      	ldrb	r3, [r3, #2]
   14cae:	b29a      	uxth	r2, r3
   14cb0:	68fb      	ldr	r3, [r7, #12]
   14cb2:	0011      	movs	r1, r2
   14cb4:	0018      	movs	r0, r3
   14cb6:	4b1b      	ldr	r3, [pc, #108]	; (14d24 <spi_select_slave+0xe4>)
   14cb8:	4798      	blx	r3

				if (!(module->receiver_enabled)) {
   14cba:	68fb      	ldr	r3, [r7, #12]
   14cbc:	79db      	ldrb	r3, [r3, #7]
   14cbe:	2201      	movs	r2, #1
   14cc0:	4053      	eors	r3, r2
   14cc2:	b2db      	uxtb	r3, r3
   14cc4:	2b00      	cmp	r3, #0
   14cc6:	d024      	beq.n	14d12 <spi_select_slave+0xd2>
					/* Flush contents of shift register shifted back from slave */
					while (!spi_is_ready_to_read(module)) {
   14cc8:	46c0      	nop			; (mov r8, r8)
   14cca:	68fb      	ldr	r3, [r7, #12]
   14ccc:	0018      	movs	r0, r3
   14cce:	4b16      	ldr	r3, [pc, #88]	; (14d28 <spi_select_slave+0xe8>)
   14cd0:	4798      	blx	r3
   14cd2:	0003      	movs	r3, r0
   14cd4:	001a      	movs	r2, r3
   14cd6:	2301      	movs	r3, #1
   14cd8:	4053      	eors	r3, r2
   14cda:	b2db      	uxtb	r3, r3
   14cdc:	2b00      	cmp	r3, #0
   14cde:	d1f4      	bne.n	14cca <spi_select_slave+0x8a>
					}
					uint16_t flush = 0;
   14ce0:	2316      	movs	r3, #22
   14ce2:	18fb      	adds	r3, r7, r3
   14ce4:	2200      	movs	r2, #0
   14ce6:	801a      	strh	r2, [r3, #0]
					spi_read(module, &flush);
   14ce8:	2316      	movs	r3, #22
   14cea:	18fa      	adds	r2, r7, r3
   14cec:	68fb      	ldr	r3, [r7, #12]
   14cee:	0011      	movs	r1, r2
   14cf0:	0018      	movs	r0, r3
   14cf2:	4b0e      	ldr	r3, [pc, #56]	; (14d2c <spi_select_slave+0xec>)
   14cf4:	4798      	blx	r3
   14cf6:	e00c      	b.n	14d12 <spi_select_slave+0xd2>
				}
			} else {
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
   14cf8:	68bb      	ldr	r3, [r7, #8]
   14cfa:	781b      	ldrb	r3, [r3, #0]
   14cfc:	2100      	movs	r1, #0
   14cfe:	0018      	movs	r0, r3
   14d00:	4b07      	ldr	r3, [pc, #28]	; (14d20 <spi_select_slave+0xe0>)
   14d02:	4798      	blx	r3
   14d04:	e005      	b.n	14d12 <spi_select_slave+0xd2>
			}
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
   14d06:	68bb      	ldr	r3, [r7, #8]
   14d08:	781b      	ldrb	r3, [r3, #0]
   14d0a:	2101      	movs	r1, #1
   14d0c:	0018      	movs	r0, r3
   14d0e:	4b04      	ldr	r3, [pc, #16]	; (14d20 <spi_select_slave+0xe0>)
   14d10:	4798      	blx	r3
		}
	}
	return STATUS_OK;
   14d12:	2300      	movs	r3, #0
}
   14d14:	0018      	movs	r0, r3
   14d16:	46bd      	mov	sp, r7
   14d18:	b006      	add	sp, #24
   14d1a:	bd80      	pop	{r7, pc}
   14d1c:	000144cd 	.word	0x000144cd
   14d20:	000142a1 	.word	0x000142a1
   14d24:	0001451d 	.word	0x0001451d
   14d28:	000144f5 	.word	0x000144f5
   14d2c:	00014565 	.word	0x00014565

00014d30 <spi_write_buffer_wait>:
 */
enum status_code spi_write_buffer_wait(
		struct spi_module *const module,
		const uint8_t *tx_data,
		uint16_t length)
{
   14d30:	b580      	push	{r7, lr}
   14d32:	b086      	sub	sp, #24
   14d34:	af00      	add	r7, sp, #0
   14d36:	60f8      	str	r0, [r7, #12]
   14d38:	60b9      	str	r1, [r7, #8]
   14d3a:	1dbb      	adds	r3, r7, #6
   14d3c:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
   14d3e:	68fb      	ldr	r3, [r7, #12]
   14d40:	2238      	movs	r2, #56	; 0x38
   14d42:	5c9b      	ldrb	r3, [r3, r2]
   14d44:	b2db      	uxtb	r3, r3
   14d46:	2b05      	cmp	r3, #5
   14d48:	d101      	bne.n	14d4e <spi_write_buffer_wait+0x1e>
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
   14d4a:	2305      	movs	r3, #5
   14d4c:	e087      	b.n	14e5e <spi_write_buffer_wait+0x12e>
	}
#  endif

	if (length == 0) {
   14d4e:	1dbb      	adds	r3, r7, #6
   14d50:	881b      	ldrh	r3, [r3, #0]
   14d52:	2b00      	cmp	r3, #0
   14d54:	d101      	bne.n	14d5a <spi_write_buffer_wait+0x2a>
		return STATUS_ERR_INVALID_ARG;
   14d56:	2317      	movs	r3, #23
   14d58:	e081      	b.n	14e5e <spi_write_buffer_wait+0x12e>
		/* Clear TX complete flag */
		_spi_clear_tx_complete_flag(module);
	}
#  endif

	uint16_t tx_pos = 0;
   14d5a:	2316      	movs	r3, #22
   14d5c:	18fb      	adds	r3, r7, r3
   14d5e:	2200      	movs	r2, #0
   14d60:	801a      	strh	r2, [r3, #0]
	uint16_t flush_length = length;
   14d62:	2314      	movs	r3, #20
   14d64:	18fb      	adds	r3, r7, r3
   14d66:	1dba      	adds	r2, r7, #6
   14d68:	8812      	ldrh	r2, [r2, #0]
   14d6a:	801a      	strh	r2, [r3, #0]

	/* Write block */
	while (length--) {
   14d6c:	e05f      	b.n	14e2e <spi_write_buffer_wait+0xfe>
			}
		}
#  endif

		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
   14d6e:	46c0      	nop			; (mov r8, r8)
   14d70:	68fb      	ldr	r3, [r7, #12]
   14d72:	0018      	movs	r0, r3
   14d74:	4b3c      	ldr	r3, [pc, #240]	; (14e68 <spi_write_buffer_wait+0x138>)
   14d76:	4798      	blx	r3
   14d78:	0003      	movs	r3, r0
   14d7a:	001a      	movs	r2, r3
   14d7c:	2301      	movs	r3, #1
   14d7e:	4053      	eors	r3, r2
   14d80:	b2db      	uxtb	r3, r3
   14d82:	2b00      	cmp	r3, #0
   14d84:	d1f4      	bne.n	14d70 <spi_write_buffer_wait+0x40>
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
   14d86:	2316      	movs	r3, #22
   14d88:	18fb      	adds	r3, r7, r3
   14d8a:	881b      	ldrh	r3, [r3, #0]
   14d8c:	2216      	movs	r2, #22
   14d8e:	18ba      	adds	r2, r7, r2
   14d90:	1c59      	adds	r1, r3, #1
   14d92:	8011      	strh	r1, [r2, #0]
   14d94:	001a      	movs	r2, r3
   14d96:	68bb      	ldr	r3, [r7, #8]
   14d98:	189b      	adds	r3, r3, r2
   14d9a:	781a      	ldrb	r2, [r3, #0]
   14d9c:	2312      	movs	r3, #18
   14d9e:	18fb      	adds	r3, r7, r3
   14da0:	801a      	strh	r2, [r3, #0]

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   14da2:	68fb      	ldr	r3, [r7, #12]
   14da4:	799b      	ldrb	r3, [r3, #6]
   14da6:	2b01      	cmp	r3, #1
   14da8:	d115      	bne.n	14dd6 <spi_write_buffer_wait+0xa6>
			data_to_send |= (tx_data[tx_pos++] << 8);
   14daa:	2316      	movs	r3, #22
   14dac:	18fb      	adds	r3, r7, r3
   14dae:	881b      	ldrh	r3, [r3, #0]
   14db0:	2216      	movs	r2, #22
   14db2:	18ba      	adds	r2, r7, r2
   14db4:	1c59      	adds	r1, r3, #1
   14db6:	8011      	strh	r1, [r2, #0]
   14db8:	001a      	movs	r2, r3
   14dba:	68bb      	ldr	r3, [r7, #8]
   14dbc:	189b      	adds	r3, r3, r2
   14dbe:	781b      	ldrb	r3, [r3, #0]
   14dc0:	021b      	lsls	r3, r3, #8
   14dc2:	b21a      	sxth	r2, r3
   14dc4:	2312      	movs	r3, #18
   14dc6:	18fb      	adds	r3, r7, r3
   14dc8:	2100      	movs	r1, #0
   14dca:	5e5b      	ldrsh	r3, [r3, r1]
   14dcc:	4313      	orrs	r3, r2
   14dce:	b21a      	sxth	r2, r3
   14dd0:	2312      	movs	r3, #18
   14dd2:	18fb      	adds	r3, r7, r3
   14dd4:	801a      	strh	r2, [r3, #0]
		}

		/* Write the data to send */
		spi_write(module, data_to_send);
   14dd6:	2312      	movs	r3, #18
   14dd8:	18fb      	adds	r3, r7, r3
   14dda:	881a      	ldrh	r2, [r3, #0]
   14ddc:	68fb      	ldr	r3, [r7, #12]
   14dde:	0011      	movs	r1, r2
   14de0:	0018      	movs	r0, r3
   14de2:	4b22      	ldr	r3, [pc, #136]	; (14e6c <spi_write_buffer_wait+0x13c>)
   14de4:	4798      	blx	r3

		if (module->receiver_enabled) {
   14de6:	68fb      	ldr	r3, [r7, #12]
   14de8:	79db      	ldrb	r3, [r3, #7]
   14dea:	2214      	movs	r2, #20
   14dec:	18ba      	adds	r2, r7, r2
   14dee:	2114      	movs	r1, #20
   14df0:	1879      	adds	r1, r7, r1
   14df2:	8809      	ldrh	r1, [r1, #0]
   14df4:	8011      	strh	r1, [r2, #0]
   14df6:	2b00      	cmp	r3, #0
   14df8:	d019      	beq.n	14e2e <spi_write_buffer_wait+0xfe>
					return STATUS_ERR_TIMEOUT;
				}
			}
#  endif

			while (!spi_is_ready_to_read(module)) {
   14dfa:	46c0      	nop			; (mov r8, r8)
   14dfc:	68fb      	ldr	r3, [r7, #12]
   14dfe:	0018      	movs	r0, r3
   14e00:	4b1b      	ldr	r3, [pc, #108]	; (14e70 <spi_write_buffer_wait+0x140>)
   14e02:	4798      	blx	r3
   14e04:	0003      	movs	r3, r0
   14e06:	001a      	movs	r2, r3
   14e08:	2301      	movs	r3, #1
   14e0a:	4053      	eors	r3, r2
   14e0c:	b2db      	uxtb	r3, r3
   14e0e:	2b00      	cmp	r3, #0
   14e10:	d1f4      	bne.n	14dfc <spi_write_buffer_wait+0xcc>
			}

			/* Flush read buffer */
			uint16_t flush;
			spi_read(module, &flush);
   14e12:	2310      	movs	r3, #16
   14e14:	18fa      	adds	r2, r7, r3
   14e16:	68fb      	ldr	r3, [r7, #12]
   14e18:	0011      	movs	r1, r2
   14e1a:	0018      	movs	r0, r3
   14e1c:	4b15      	ldr	r3, [pc, #84]	; (14e74 <spi_write_buffer_wait+0x144>)
   14e1e:	4798      	blx	r3
			flush_length--;
   14e20:	2314      	movs	r3, #20
   14e22:	18fb      	adds	r3, r7, r3
   14e24:	881a      	ldrh	r2, [r3, #0]
   14e26:	2314      	movs	r3, #20
   14e28:	18fb      	adds	r3, r7, r3
   14e2a:	3a01      	subs	r2, #1
   14e2c:	801a      	strh	r2, [r3, #0]

	uint16_t tx_pos = 0;
	uint16_t flush_length = length;

	/* Write block */
	while (length--) {
   14e2e:	1dbb      	adds	r3, r7, #6
   14e30:	881b      	ldrh	r3, [r3, #0]
   14e32:	1dba      	adds	r2, r7, #6
   14e34:	1e59      	subs	r1, r3, #1
   14e36:	8011      	strh	r1, [r2, #0]
   14e38:	2b00      	cmp	r3, #0
   14e3a:	d198      	bne.n	14d6e <spi_write_buffer_wait+0x3e>
			flush_length--;
		}
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
   14e3c:	68fb      	ldr	r3, [r7, #12]
   14e3e:	795b      	ldrb	r3, [r3, #5]
   14e40:	2b01      	cmp	r3, #1
   14e42:	d10b      	bne.n	14e5c <spi_write_buffer_wait+0x12c>
		/* Wait for last byte to be transferred */
		while (!spi_is_write_complete(module)) {
   14e44:	46c0      	nop			; (mov r8, r8)
   14e46:	68fb      	ldr	r3, [r7, #12]
   14e48:	0018      	movs	r0, r3
   14e4a:	4b0b      	ldr	r3, [pc, #44]	; (14e78 <spi_write_buffer_wait+0x148>)
   14e4c:	4798      	blx	r3
   14e4e:	0003      	movs	r3, r0
   14e50:	001a      	movs	r2, r3
   14e52:	2301      	movs	r3, #1
   14e54:	4053      	eors	r3, r2
   14e56:	b2db      	uxtb	r3, r3
   14e58:	2b00      	cmp	r3, #0
   14e5a:	d1f4      	bne.n	14e46 <spi_write_buffer_wait+0x116>
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
   14e5c:	2300      	movs	r3, #0
}
   14e5e:	0018      	movs	r0, r3
   14e60:	46bd      	mov	sp, r7
   14e62:	b006      	add	sp, #24
   14e64:	bd80      	pop	{r7, pc}
   14e66:	46c0      	nop			; (mov r8, r8)
   14e68:	000144cd 	.word	0x000144cd
   14e6c:	0001451d 	.word	0x0001451d
   14e70:	000144f5 	.word	0x000144f5
   14e74:	00014565 	.word	0x00014565
   14e78:	000144a5 	.word	0x000144a5

00014e7c <_spi_write>:
 *
 * \param[in,out]  module  Pointer to SPI software instance struct
 */
static void _spi_write(
		struct spi_module *const module)
{
   14e7c:	b580      	push	{r7, lr}
   14e7e:	b084      	sub	sp, #16
   14e80:	af00      	add	r7, sp, #0
   14e82:	6078      	str	r0, [r7, #4]
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
   14e84:	687b      	ldr	r3, [r7, #4]
   14e86:	681b      	ldr	r3, [r3, #0]
   14e88:	60bb      	str	r3, [r7, #8]

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
   14e8a:	687b      	ldr	r3, [r7, #4]
   14e8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14e8e:	781b      	ldrb	r3, [r3, #0]
   14e90:	b2da      	uxtb	r2, r3
   14e92:	230e      	movs	r3, #14
   14e94:	18fb      	adds	r3, r7, r3
   14e96:	801a      	strh	r2, [r3, #0]
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;
   14e98:	687b      	ldr	r3, [r7, #4]
   14e9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14e9c:	1c5a      	adds	r2, r3, #1
   14e9e:	687b      	ldr	r3, [r7, #4]
   14ea0:	62da      	str	r2, [r3, #44]	; 0x2c

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   14ea2:	687b      	ldr	r3, [r7, #4]
   14ea4:	799b      	ldrb	r3, [r3, #6]
   14ea6:	2b01      	cmp	r3, #1
   14ea8:	d113      	bne.n	14ed2 <_spi_write+0x56>
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
   14eaa:	687b      	ldr	r3, [r7, #4]
   14eac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14eae:	781b      	ldrb	r3, [r3, #0]
   14eb0:	b2db      	uxtb	r3, r3
   14eb2:	021b      	lsls	r3, r3, #8
   14eb4:	b21a      	sxth	r2, r3
   14eb6:	230e      	movs	r3, #14
   14eb8:	18fb      	adds	r3, r7, r3
   14eba:	2100      	movs	r1, #0
   14ebc:	5e5b      	ldrsh	r3, [r3, r1]
   14ebe:	4313      	orrs	r3, r2
   14ec0:	b21a      	sxth	r2, r3
   14ec2:	230e      	movs	r3, #14
   14ec4:	18fb      	adds	r3, r7, r3
   14ec6:	801a      	strh	r2, [r3, #0]
		/* Increment 8-bit pointer */
		(module->tx_buffer_ptr)++;
   14ec8:	687b      	ldr	r3, [r7, #4]
   14eca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14ecc:	1c5a      	adds	r2, r3, #1
   14ece:	687b      	ldr	r3, [r7, #4]
   14ed0:	62da      	str	r2, [r3, #44]	; 0x2c
	}

	/* Write the data to send*/
	spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
   14ed2:	230e      	movs	r3, #14
   14ed4:	18fb      	adds	r3, r7, r3
   14ed6:	881b      	ldrh	r3, [r3, #0]
   14ed8:	05db      	lsls	r3, r3, #23
   14eda:	0dda      	lsrs	r2, r3, #23
   14edc:	68bb      	ldr	r3, [r7, #8]
   14ede:	629a      	str	r2, [r3, #40]	; 0x28

	/* Decrement remaining buffer length */
	(module->remaining_tx_buffer_length)--;
   14ee0:	687b      	ldr	r3, [r7, #4]
   14ee2:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
   14ee4:	b29b      	uxth	r3, r3
   14ee6:	3b01      	subs	r3, #1
   14ee8:	b29a      	uxth	r2, r3
   14eea:	687b      	ldr	r3, [r7, #4]
   14eec:	869a      	strh	r2, [r3, #52]	; 0x34
}
   14eee:	46c0      	nop			; (mov r8, r8)
   14ef0:	46bd      	mov	sp, r7
   14ef2:	b004      	add	sp, #16
   14ef4:	bd80      	pop	{r7, pc}
   14ef6:	46c0      	nop			; (mov r8, r8)

00014ef8 <_spi_write_dummy>:
 *
 * \param[in,out]  module  Pointer to SPI software instance struct
 */
static void _spi_write_dummy(
		struct spi_module *const module)
{
   14ef8:	b580      	push	{r7, lr}
   14efa:	b084      	sub	sp, #16
   14efc:	af00      	add	r7, sp, #0
   14efe:	6078      	str	r0, [r7, #4]
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
   14f00:	687b      	ldr	r3, [r7, #4]
   14f02:	681b      	ldr	r3, [r3, #0]
   14f04:	60fb      	str	r3, [r7, #12]

	/* Write dummy byte */
	spi_hw->DATA.reg = dummy_write;
   14f06:	4b08      	ldr	r3, [pc, #32]	; (14f28 <_spi_write_dummy+0x30>)
   14f08:	881b      	ldrh	r3, [r3, #0]
   14f0a:	001a      	movs	r2, r3
   14f0c:	68fb      	ldr	r3, [r7, #12]
   14f0e:	629a      	str	r2, [r3, #40]	; 0x28

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
   14f10:	687b      	ldr	r3, [r7, #4]
   14f12:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
   14f14:	b29b      	uxth	r3, r3
   14f16:	3b01      	subs	r3, #1
   14f18:	b29a      	uxth	r2, r3
   14f1a:	687b      	ldr	r3, [r7, #4]
   14f1c:	865a      	strh	r2, [r3, #50]	; 0x32
}
   14f1e:	46c0      	nop			; (mov r8, r8)
   14f20:	46bd      	mov	sp, r7
   14f22:	b004      	add	sp, #16
   14f24:	bd80      	pop	{r7, pc}
   14f26:	46c0      	nop			; (mov r8, r8)
   14f28:	20004bc4 	.word	0x20004bc4

00014f2c <_spi_read_dummy>:
 *
 * \param[in,out]  module  Pointer to SPI software instance struct
 */
static void _spi_read_dummy(
		struct spi_module *const module)
{
   14f2c:	b580      	push	{r7, lr}
   14f2e:	b084      	sub	sp, #16
   14f30:	af00      	add	r7, sp, #0
   14f32:	6078      	str	r0, [r7, #4]
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
   14f34:	687b      	ldr	r3, [r7, #4]
   14f36:	681b      	ldr	r3, [r3, #0]
   14f38:	60fb      	str	r3, [r7, #12]
	uint16_t flush = 0;
   14f3a:	230a      	movs	r3, #10
   14f3c:	18fb      	adds	r3, r7, r3
   14f3e:	2200      	movs	r2, #0
   14f40:	801a      	strh	r2, [r3, #0]

	/* Read dummy byte */
	flush = spi_hw->DATA.reg;
   14f42:	68fb      	ldr	r3, [r7, #12]
   14f44:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   14f46:	230a      	movs	r3, #10
   14f48:	18fb      	adds	r3, r7, r3
   14f4a:	801a      	strh	r2, [r3, #0]
	UNUSED(flush);

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
   14f4c:	687b      	ldr	r3, [r7, #4]
   14f4e:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
   14f50:	b29b      	uxth	r3, r3
   14f52:	3b01      	subs	r3, #1
   14f54:	b29a      	uxth	r2, r3
   14f56:	687b      	ldr	r3, [r7, #4]
   14f58:	865a      	strh	r2, [r3, #50]	; 0x32
}
   14f5a:	46c0      	nop			; (mov r8, r8)
   14f5c:	46bd      	mov	sp, r7
   14f5e:	b004      	add	sp, #16
   14f60:	bd80      	pop	{r7, pc}
   14f62:	46c0      	nop			; (mov r8, r8)

00014f64 <_spi_read>:
 *
 * \param[in,out]  module  Pointer to SPI software instance struct
 */
static void _spi_read(
		struct spi_module *const module)
{
   14f64:	b580      	push	{r7, lr}
   14f66:	b084      	sub	sp, #16
   14f68:	af00      	add	r7, sp, #0
   14f6a:	6078      	str	r0, [r7, #4]
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
   14f6c:	687b      	ldr	r3, [r7, #4]
   14f6e:	681b      	ldr	r3, [r3, #0]
   14f70:	60fb      	str	r3, [r7, #12]

	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
   14f72:	68fb      	ldr	r3, [r7, #12]
   14f74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   14f76:	b29a      	uxth	r2, r3
   14f78:	230a      	movs	r3, #10
   14f7a:	18fb      	adds	r3, r7, r3
   14f7c:	05d2      	lsls	r2, r2, #23
   14f7e:	0dd2      	lsrs	r2, r2, #23
   14f80:	801a      	strh	r2, [r3, #0]

	/* Read value will be at least 8-bits long */
	*(module->rx_buffer_ptr) = received_data;
   14f82:	687b      	ldr	r3, [r7, #4]
   14f84:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   14f86:	220a      	movs	r2, #10
   14f88:	18ba      	adds	r2, r7, r2
   14f8a:	8812      	ldrh	r2, [r2, #0]
   14f8c:	b2d2      	uxtb	r2, r2
   14f8e:	701a      	strb	r2, [r3, #0]
	/* Increment 8-bit pointer */
	module->rx_buffer_ptr += 1;
   14f90:	687b      	ldr	r3, [r7, #4]
   14f92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   14f94:	1c5a      	adds	r2, r3, #1
   14f96:	687b      	ldr	r3, [r7, #4]
   14f98:	629a      	str	r2, [r3, #40]	; 0x28

	if(module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   14f9a:	687b      	ldr	r3, [r7, #4]
   14f9c:	799b      	ldrb	r3, [r3, #6]
   14f9e:	2b01      	cmp	r3, #1
   14fa0:	d10d      	bne.n	14fbe <_spi_read+0x5a>
		/* 9-bit data, write next received byte to the buffer */
		*(module->rx_buffer_ptr) = (received_data >> 8);
   14fa2:	687b      	ldr	r3, [r7, #4]
   14fa4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   14fa6:	220a      	movs	r2, #10
   14fa8:	18ba      	adds	r2, r7, r2
   14faa:	8812      	ldrh	r2, [r2, #0]
   14fac:	0a12      	lsrs	r2, r2, #8
   14fae:	b292      	uxth	r2, r2
   14fb0:	b2d2      	uxtb	r2, r2
   14fb2:	701a      	strb	r2, [r3, #0]
		/* Increment 8-bit pointer */
		module->rx_buffer_ptr += 1;
   14fb4:	687b      	ldr	r3, [r7, #4]
   14fb6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   14fb8:	1c5a      	adds	r2, r3, #1
   14fba:	687b      	ldr	r3, [r7, #4]
   14fbc:	629a      	str	r2, [r3, #40]	; 0x28
	}

	/* Decrement length of the remaining buffer */
	module->remaining_rx_buffer_length--;
   14fbe:	687b      	ldr	r3, [r7, #4]
   14fc0:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
   14fc2:	b29b      	uxth	r3, r3
   14fc4:	3b01      	subs	r3, #1
   14fc6:	b29a      	uxth	r2, r3
   14fc8:	687b      	ldr	r3, [r7, #4]
   14fca:	861a      	strh	r2, [r3, #48]	; 0x30
}
   14fcc:	46c0      	nop			; (mov r8, r8)
   14fce:	46bd      	mov	sp, r7
   14fd0:	b004      	add	sp, #16
   14fd2:	bd80      	pop	{r7, pc}

00014fd4 <_spi_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
   14fd4:	b580      	push	{r7, lr}
   14fd6:	b086      	sub	sp, #24
   14fd8:	af00      	add	r7, sp, #0
   14fda:	0002      	movs	r2, r0
   14fdc:	1dfb      	adds	r3, r7, #7
   14fde:	701a      	strb	r2, [r3, #0]
	/* Get device instance from the look-up table */
	struct spi_module *module
		= (struct spi_module *)_sercom_instances[instance];
   14fe0:	1dfb      	adds	r3, r7, #7
   14fe2:	781a      	ldrb	r2, [r3, #0]
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
	/* Get device instance from the look-up table */
	struct spi_module *module
   14fe4:	4b98      	ldr	r3, [pc, #608]	; (15248 <_spi_interrupt_handler+0x274>)
   14fe6:	0092      	lsls	r2, r2, #2
   14fe8:	58d3      	ldr	r3, [r2, r3]
   14fea:	617b      	str	r3, [r7, #20]
		= (struct spi_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
   14fec:	697b      	ldr	r3, [r7, #20]
   14fee:	681b      	ldr	r3, [r3, #0]
   14ff0:	613b      	str	r3, [r7, #16]

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
			module->enabled_callback & module->registered_callback;
   14ff2:	697b      	ldr	r3, [r7, #20]
   14ff4:	2237      	movs	r2, #55	; 0x37
   14ff6:	5c9a      	ldrb	r2, [r3, r2]
   14ff8:	697b      	ldr	r3, [r7, #20]
   14ffa:	2136      	movs	r1, #54	; 0x36
   14ffc:	5c59      	ldrb	r1, [r3, r1]

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
   14ffe:	230f      	movs	r3, #15
   15000:	18fb      	adds	r3, r7, r3
   15002:	400a      	ands	r2, r1
   15004:	701a      	strb	r2, [r3, #0]
			module->enabled_callback & module->registered_callback;

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
   15006:	693b      	ldr	r3, [r7, #16]
   15008:	7e1b      	ldrb	r3, [r3, #24]
   1500a:	b2da      	uxtb	r2, r3
   1500c:	230c      	movs	r3, #12
   1500e:	18fb      	adds	r3, r7, r3
   15010:	801a      	strh	r2, [r3, #0]
	interrupt_status &= spi_hw->INTENSET.reg;
   15012:	693b      	ldr	r3, [r7, #16]
   15014:	7d9b      	ldrb	r3, [r3, #22]
   15016:	b2db      	uxtb	r3, r3
   15018:	b29a      	uxth	r2, r3
   1501a:	230c      	movs	r3, #12
   1501c:	18fb      	adds	r3, r7, r3
   1501e:	210c      	movs	r1, #12
   15020:	1879      	adds	r1, r7, r1
   15022:	8809      	ldrh	r1, [r1, #0]
   15024:	400a      	ands	r2, r1
   15026:	801a      	strh	r2, [r3, #0]

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
   15028:	230c      	movs	r3, #12
   1502a:	18fb      	adds	r3, r7, r3
   1502c:	881b      	ldrh	r3, [r3, #0]
   1502e:	2201      	movs	r2, #1
   15030:	4013      	ands	r3, r2
   15032:	d038      	beq.n	150a6 <_spi_interrupt_handler+0xd2>
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   15034:	697b      	ldr	r3, [r7, #20]
   15036:	795b      	ldrb	r3, [r3, #5]
   15038:	2b01      	cmp	r3, #1
   1503a:	d110      	bne.n	1505e <_spi_interrupt_handler+0x8a>
			(module->dir == SPI_DIRECTION_READ)) {
   1503c:	697b      	ldr	r3, [r7, #20]
   1503e:	7a5b      	ldrb	r3, [r3, #9]
   15040:	b2db      	uxtb	r3, r3
	interrupt_status &= spi_hw->INTENSET.reg;

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   15042:	2b00      	cmp	r3, #0
   15044:	d10b      	bne.n	1505e <_spi_interrupt_handler+0x8a>
			(module->dir == SPI_DIRECTION_READ)) {
			/* Send dummy byte when reading in master mode */
			_spi_write_dummy(module);
   15046:	697b      	ldr	r3, [r7, #20]
   15048:	0018      	movs	r0, r3
   1504a:	4b80      	ldr	r3, [pc, #512]	; (1524c <_spi_interrupt_handler+0x278>)
   1504c:	4798      	blx	r3
			if (module->remaining_dummy_buffer_length == 0) {
   1504e:	697b      	ldr	r3, [r7, #20]
   15050:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
   15052:	b29b      	uxth	r3, r3
   15054:	2b00      	cmp	r3, #0
   15056:	d102      	bne.n	1505e <_spi_interrupt_handler+0x8a>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
   15058:	693b      	ldr	r3, [r7, #16]
   1505a:	2201      	movs	r2, #1
   1505c:	751a      	strb	r2, [r3, #20]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
   1505e:	697b      	ldr	r3, [r7, #20]
   15060:	795b      	ldrb	r3, [r3, #5]
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
			}
		}
#  endif

		if (0
   15062:	2b01      	cmp	r3, #1
   15064:	d11f      	bne.n	150a6 <_spi_interrupt_handler+0xd2>
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
   15066:	697b      	ldr	r3, [r7, #20]
   15068:	7a5b      	ldrb	r3, [r3, #9]
   1506a:	b2db      	uxtb	r3, r3
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
   1506c:	2b00      	cmp	r3, #0
   1506e:	d01a      	beq.n	150a6 <_spi_interrupt_handler+0xd2>
		|| ((module->mode == SPI_MODE_SLAVE) &&
			(module->dir != SPI_DIRECTION_READ))
#  endif
		) {
			/* Write next byte from buffer */
			_spi_write(module);
   15070:	697b      	ldr	r3, [r7, #20]
   15072:	0018      	movs	r0, r3
   15074:	4b76      	ldr	r3, [pc, #472]	; (15250 <_spi_interrupt_handler+0x27c>)
   15076:	4798      	blx	r3
			if (module->remaining_tx_buffer_length == 0) {
   15078:	697b      	ldr	r3, [r7, #20]
   1507a:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
   1507c:	b29b      	uxth	r3, r3
   1507e:	2b00      	cmp	r3, #0
   15080:	d111      	bne.n	150a6 <_spi_interrupt_handler+0xd2>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
   15082:	693b      	ldr	r3, [r7, #16]
   15084:	2201      	movs	r2, #1
   15086:	751a      	strb	r2, [r3, #20]

				if (module->dir == SPI_DIRECTION_WRITE &&
   15088:	697b      	ldr	r3, [r7, #20]
   1508a:	7a5b      	ldrb	r3, [r3, #9]
   1508c:	b2db      	uxtb	r3, r3
   1508e:	2b01      	cmp	r3, #1
   15090:	d109      	bne.n	150a6 <_spi_interrupt_handler+0xd2>
						!(module->receiver_enabled)) {
   15092:	697b      	ldr	r3, [r7, #20]
   15094:	79db      	ldrb	r3, [r3, #7]
   15096:	2201      	movs	r2, #1
   15098:	4053      	eors	r3, r2
   1509a:	b2db      	uxtb	r3, r3
			if (module->remaining_tx_buffer_length == 0) {
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;

				if (module->dir == SPI_DIRECTION_WRITE &&
   1509c:	2b00      	cmp	r3, #0
   1509e:	d002      	beq.n	150a6 <_spi_interrupt_handler+0xd2>
						!(module->receiver_enabled)) {
					/* Enable the Data Register transmit complete Interrupt */
					spi_hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
   150a0:	693b      	ldr	r3, [r7, #16]
   150a2:	2202      	movs	r2, #2
   150a4:	759a      	strb	r2, [r3, #22]
			}
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
   150a6:	230c      	movs	r3, #12
   150a8:	18fb      	adds	r3, r7, r3
   150aa:	881b      	ldrh	r3, [r3, #0]
   150ac:	2204      	movs	r2, #4
   150ae:	4013      	ands	r3, r2
   150b0:	d100      	bne.n	150b4 <_spi_interrupt_handler+0xe0>
   150b2:	e083      	b.n	151bc <_spi_interrupt_handler+0x1e8>
		/* Check for overflow */
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   150b4:	693b      	ldr	r3, [r7, #16]
   150b6:	8b5b      	ldrh	r3, [r3, #26]
   150b8:	b29b      	uxth	r3, r3
   150ba:	001a      	movs	r2, r3
   150bc:	2304      	movs	r3, #4
   150be:	4013      	ands	r3, r2
   150c0:	d027      	beq.n	15112 <_spi_interrupt_handler+0x13e>
			if (module->dir != SPI_DIRECTION_WRITE) {
   150c2:	697b      	ldr	r3, [r7, #20]
   150c4:	7a5b      	ldrb	r3, [r3, #9]
   150c6:	b2db      	uxtb	r3, r3
   150c8:	2b01      	cmp	r3, #1
   150ca:	d014      	beq.n	150f6 <_spi_interrupt_handler+0x122>
				/* Store the error code */
				module->status = STATUS_ERR_OVERFLOW;
   150cc:	697b      	ldr	r3, [r7, #20]
   150ce:	2238      	movs	r2, #56	; 0x38
   150d0:	211e      	movs	r1, #30
   150d2:	5499      	strb	r1, [r3, r2]

				/* End transaction */
				module->dir = SPI_DIRECTION_IDLE;
   150d4:	697b      	ldr	r3, [r7, #20]
   150d6:	2203      	movs	r2, #3
   150d8:	725a      	strb	r2, [r3, #9]

				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE |
   150da:	693b      	ldr	r3, [r7, #16]
   150dc:	2205      	movs	r2, #5
   150de:	751a      	strb	r2, [r3, #20]
						SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
				/* Run callback if registered and enabled */
				if (callback_mask & (1 << SPI_CALLBACK_ERROR)) {
   150e0:	230f      	movs	r3, #15
   150e2:	18fb      	adds	r3, r7, r3
   150e4:	781b      	ldrb	r3, [r3, #0]
   150e6:	2208      	movs	r2, #8
   150e8:	4013      	ands	r3, r2
   150ea:	d004      	beq.n	150f6 <_spi_interrupt_handler+0x122>
					(module->callback[SPI_CALLBACK_ERROR])(module);
   150ec:	697b      	ldr	r3, [r7, #20]
   150ee:	699b      	ldr	r3, [r3, #24]
   150f0:	697a      	ldr	r2, [r7, #20]
   150f2:	0010      	movs	r0, r2
   150f4:	4798      	blx	r3
				}
			}
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
   150f6:	693b      	ldr	r3, [r7, #16]
   150f8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   150fa:	230a      	movs	r3, #10
   150fc:	18fb      	adds	r3, r7, r3
   150fe:	801a      	strh	r2, [r3, #0]
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
   15100:	693b      	ldr	r3, [r7, #16]
   15102:	8b5b      	ldrh	r3, [r3, #26]
   15104:	b29b      	uxth	r3, r3
   15106:	2204      	movs	r2, #4
   15108:	4313      	orrs	r3, r2
   1510a:	b29a      	uxth	r2, r3
   1510c:	693b      	ldr	r3, [r7, #16]
   1510e:	835a      	strh	r2, [r3, #26]
   15110:	e054      	b.n	151bc <_spi_interrupt_handler+0x1e8>
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
   15112:	697b      	ldr	r3, [r7, #20]
   15114:	7a5b      	ldrb	r3, [r3, #9]
   15116:	b2db      	uxtb	r3, r3
   15118:	2b01      	cmp	r3, #1
   1511a:	d11e      	bne.n	1515a <_spi_interrupt_handler+0x186>
				/* Flush receive buffer when writing */
				_spi_read_dummy(module);
   1511c:	697b      	ldr	r3, [r7, #20]
   1511e:	0018      	movs	r0, r3
   15120:	4b4c      	ldr	r3, [pc, #304]	; (15254 <_spi_interrupt_handler+0x280>)
   15122:	4798      	blx	r3
				if (module->remaining_dummy_buffer_length == 0) {
   15124:	697b      	ldr	r3, [r7, #20]
   15126:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
   15128:	b29b      	uxth	r3, r3
   1512a:	2b00      	cmp	r3, #0
   1512c:	d146      	bne.n	151bc <_spi_interrupt_handler+0x1e8>
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
   1512e:	693b      	ldr	r3, [r7, #16]
   15130:	2204      	movs	r2, #4
   15132:	751a      	strb	r2, [r3, #20]
					module->status = STATUS_OK;
   15134:	697b      	ldr	r3, [r7, #20]
   15136:	2238      	movs	r2, #56	; 0x38
   15138:	2100      	movs	r1, #0
   1513a:	5499      	strb	r1, [r3, r2]
					module->dir = SPI_DIRECTION_IDLE;
   1513c:	697b      	ldr	r3, [r7, #20]
   1513e:	2203      	movs	r2, #3
   15140:	725a      	strb	r2, [r3, #9]
					/* Run callback if registered and enabled */
					if (callback_mask &
   15142:	230f      	movs	r3, #15
   15144:	18fb      	adds	r3, r7, r3
   15146:	781b      	ldrb	r3, [r3, #0]
   15148:	2201      	movs	r2, #1
   1514a:	4013      	ands	r3, r2
   1514c:	d036      	beq.n	151bc <_spi_interrupt_handler+0x1e8>
							(1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
						(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])(module);
   1514e:	697b      	ldr	r3, [r7, #20]
   15150:	68db      	ldr	r3, [r3, #12]
   15152:	697a      	ldr	r2, [r7, #20]
   15154:	0010      	movs	r0, r2
   15156:	4798      	blx	r3
   15158:	e030      	b.n	151bc <_spi_interrupt_handler+0x1e8>
					}
				}
			} else {
				/* Read data register */
				_spi_read(module);
   1515a:	697b      	ldr	r3, [r7, #20]
   1515c:	0018      	movs	r0, r3
   1515e:	4b3e      	ldr	r3, [pc, #248]	; (15258 <_spi_interrupt_handler+0x284>)
   15160:	4798      	blx	r3

				/* Check if the last character have been received */
				if (module->remaining_rx_buffer_length == 0) {
   15162:	697b      	ldr	r3, [r7, #20]
   15164:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
   15166:	b29b      	uxth	r3, r3
   15168:	2b00      	cmp	r3, #0
   1516a:	d127      	bne.n	151bc <_spi_interrupt_handler+0x1e8>
					module->status = STATUS_OK;
   1516c:	697b      	ldr	r3, [r7, #20]
   1516e:	2238      	movs	r2, #56	; 0x38
   15170:	2100      	movs	r1, #0
   15172:	5499      	strb	r1, [r3, r2]
					/* Disable RX Complete Interrupt and set status */
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
   15174:	693b      	ldr	r3, [r7, #16]
   15176:	2204      	movs	r2, #4
   15178:	751a      	strb	r2, [r3, #20]
					if(module->dir == SPI_DIRECTION_BOTH) {
   1517a:	697b      	ldr	r3, [r7, #20]
   1517c:	7a5b      	ldrb	r3, [r3, #9]
   1517e:	b2db      	uxtb	r3, r3
   15180:	2b02      	cmp	r3, #2
   15182:	d10b      	bne.n	1519c <_spi_interrupt_handler+0x1c8>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
   15184:	230f      	movs	r3, #15
   15186:	18fb      	adds	r3, r7, r3
   15188:	781b      	ldrb	r3, [r3, #0]
   1518a:	2204      	movs	r2, #4
   1518c:	4013      	ands	r3, r2
   1518e:	d015      	beq.n	151bc <_spi_interrupt_handler+0x1e8>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
   15190:	697b      	ldr	r3, [r7, #20]
   15192:	695b      	ldr	r3, [r3, #20]
   15194:	697a      	ldr	r2, [r7, #20]
   15196:	0010      	movs	r0, r2
   15198:	4798      	blx	r3
   1519a:	e00f      	b.n	151bc <_spi_interrupt_handler+0x1e8>
						}
					} else if (module->dir == SPI_DIRECTION_READ) {
   1519c:	697b      	ldr	r3, [r7, #20]
   1519e:	7a5b      	ldrb	r3, [r3, #9]
   151a0:	b2db      	uxtb	r3, r3
   151a2:	2b00      	cmp	r3, #0
   151a4:	d10a      	bne.n	151bc <_spi_interrupt_handler+0x1e8>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
   151a6:	230f      	movs	r3, #15
   151a8:	18fb      	adds	r3, r7, r3
   151aa:	781b      	ldrb	r3, [r3, #0]
   151ac:	2202      	movs	r2, #2
   151ae:	4013      	ands	r3, r2
   151b0:	d004      	beq.n	151bc <_spi_interrupt_handler+0x1e8>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
   151b2:	697b      	ldr	r3, [r7, #20]
   151b4:	691b      	ldr	r3, [r3, #16]
   151b6:	697a      	ldr	r2, [r7, #20]
   151b8:	0010      	movs	r0, r2
   151ba:	4798      	blx	r3
			}
		}
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
   151bc:	230c      	movs	r3, #12
   151be:	18fb      	adds	r3, r7, r3
   151c0:	881b      	ldrh	r3, [r3, #0]
   151c2:	2202      	movs	r2, #2
   151c4:	4013      	ands	r3, r2
   151c6:	d024      	beq.n	15212 <_spi_interrupt_handler+0x23e>
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   151c8:	697b      	ldr	r3, [r7, #20]
   151ca:	795b      	ldrb	r3, [r3, #5]
   151cc:	2b01      	cmp	r3, #1
   151ce:	d120      	bne.n	15212 <_spi_interrupt_handler+0x23e>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
   151d0:	697b      	ldr	r3, [r7, #20]
   151d2:	7a5b      	ldrb	r3, [r3, #9]
   151d4:	b2db      	uxtb	r3, r3
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   151d6:	2b01      	cmp	r3, #1
   151d8:	d11b      	bne.n	15212 <_spi_interrupt_handler+0x23e>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
   151da:	697b      	ldr	r3, [r7, #20]
   151dc:	79db      	ldrb	r3, [r3, #7]
   151de:	2201      	movs	r2, #1
   151e0:	4053      	eors	r3, r2
   151e2:	b2db      	uxtb	r3, r3
   151e4:	2b00      	cmp	r3, #0
   151e6:	d014      	beq.n	15212 <_spi_interrupt_handler+0x23e>
		  	/* Clear interrupt flag */
		 	spi_hw->INTENCLR.reg
					= SPI_INTERRUPT_FLAG_TX_COMPLETE;
   151e8:	693b      	ldr	r3, [r7, #16]
   151ea:	2202      	movs	r2, #2
   151ec:	751a      	strb	r2, [r3, #20]
			/* Buffer sent with receiver disabled */
			module->dir = SPI_DIRECTION_IDLE;
   151ee:	697b      	ldr	r3, [r7, #20]
   151f0:	2203      	movs	r2, #3
   151f2:	725a      	strb	r2, [r3, #9]
			module->status = STATUS_OK;
   151f4:	697b      	ldr	r3, [r7, #20]
   151f6:	2238      	movs	r2, #56	; 0x38
   151f8:	2100      	movs	r1, #0
   151fa:	5499      	strb	r1, [r3, r2]
			/* Run callback if registered and enabled */
			if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
   151fc:	230f      	movs	r3, #15
   151fe:	18fb      	adds	r3, r7, r3
   15200:	781b      	ldrb	r3, [r3, #0]
   15202:	2201      	movs	r2, #1
   15204:	4013      	ands	r3, r2
   15206:	d004      	beq.n	15212 <_spi_interrupt_handler+0x23e>
				(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])
   15208:	697b      	ldr	r3, [r7, #20]
   1520a:	68db      	ldr	r3, [r3, #12]
   1520c:	697a      	ldr	r2, [r7, #20]
   1520e:	0010      	movs	r0, r2
   15210:	4798      	blx	r3
#  endif
#  endif

#  ifdef FEATURE_SPI_ERROR_INTERRUPT
	/* When combined error happen */
	if (interrupt_status & SPI_INTERRUPT_FLAG_COMBINED_ERROR) {
   15212:	230c      	movs	r3, #12
   15214:	18fb      	adds	r3, r7, r3
   15216:	881b      	ldrh	r3, [r3, #0]
   15218:	2280      	movs	r2, #128	; 0x80
   1521a:	4013      	ands	r3, r2
   1521c:	d010      	beq.n	15240 <_spi_interrupt_handler+0x26c>
		/* Disable interrupts */
		spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
   1521e:	693b      	ldr	r3, [r7, #16]
   15220:	2280      	movs	r2, #128	; 0x80
   15222:	751a      	strb	r2, [r3, #20]
		/* Clear interrupt flag */
		spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
   15224:	693b      	ldr	r3, [r7, #16]
   15226:	2280      	movs	r2, #128	; 0x80
   15228:	761a      	strb	r2, [r3, #24]

		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
   1522a:	230f      	movs	r3, #15
   1522c:	18fb      	adds	r3, r7, r3
   1522e:	781b      	ldrb	r3, [r3, #0]
   15230:	2240      	movs	r2, #64	; 0x40
   15232:	4013      	ands	r3, r2
   15234:	d004      	beq.n	15240 <_spi_interrupt_handler+0x26c>
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
   15236:	697b      	ldr	r3, [r7, #20]
   15238:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1523a:	697a      	ldr	r2, [r7, #20]
   1523c:	0010      	movs	r0, r2
   1523e:	4798      	blx	r3
		}
	}
#  endif
}
   15240:	46c0      	nop			; (mov r8, r8)
   15242:	46bd      	mov	sp, r7
   15244:	b006      	add	sp, #24
   15246:	bd80      	pop	{r7, pc}
   15248:	20004bac 	.word	0x20004bac
   1524c:	00014ef9 	.word	0x00014ef9
   15250:	00014e7d 	.word	0x00014e7d
   15254:	00014f2d 	.word	0x00014f2d
   15258:	00014f65 	.word	0x00014f65

0001525c <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
   1525c:	b580      	push	{r7, lr}
   1525e:	b082      	sub	sp, #8
   15260:	af00      	add	r7, sp, #0
   15262:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
   15264:	687b      	ldr	r3, [r7, #4]
   15266:	2200      	movs	r2, #0
   15268:	701a      	strb	r2, [r3, #0]
}
   1526a:	46c0      	nop			; (mov r8, r8)
   1526c:	46bd      	mov	sp, r7
   1526e:	b002      	add	sp, #8
   15270:	bd80      	pop	{r7, pc}
   15272:	46c0      	nop			; (mov r8, r8)

00015274 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
   15274:	b580      	push	{r7, lr}
   15276:	b082      	sub	sp, #8
   15278:	af00      	add	r7, sp, #0
   1527a:	0002      	movs	r2, r0
   1527c:	6039      	str	r1, [r7, #0]
   1527e:	1dfb      	adds	r3, r7, #7
   15280:	701a      	strb	r2, [r3, #0]
	switch (bus) {
   15282:	1dfb      	adds	r3, r7, #7
   15284:	781b      	ldrb	r3, [r3, #0]
   15286:	2b01      	cmp	r3, #1
   15288:	d00a      	beq.n	152a0 <system_apb_clock_set_mask+0x2c>
   1528a:	2b02      	cmp	r3, #2
   1528c:	d00f      	beq.n	152ae <system_apb_clock_set_mask+0x3a>
   1528e:	2b00      	cmp	r3, #0
   15290:	d114      	bne.n	152bc <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
   15292:	4b0e      	ldr	r3, [pc, #56]	; (152cc <system_apb_clock_set_mask+0x58>)
   15294:	4a0d      	ldr	r2, [pc, #52]	; (152cc <system_apb_clock_set_mask+0x58>)
   15296:	6991      	ldr	r1, [r2, #24]
   15298:	683a      	ldr	r2, [r7, #0]
   1529a:	430a      	orrs	r2, r1
   1529c:	619a      	str	r2, [r3, #24]
			break;
   1529e:	e00f      	b.n	152c0 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
   152a0:	4b0a      	ldr	r3, [pc, #40]	; (152cc <system_apb_clock_set_mask+0x58>)
   152a2:	4a0a      	ldr	r2, [pc, #40]	; (152cc <system_apb_clock_set_mask+0x58>)
   152a4:	69d1      	ldr	r1, [r2, #28]
   152a6:	683a      	ldr	r2, [r7, #0]
   152a8:	430a      	orrs	r2, r1
   152aa:	61da      	str	r2, [r3, #28]
			break;
   152ac:	e008      	b.n	152c0 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
   152ae:	4b07      	ldr	r3, [pc, #28]	; (152cc <system_apb_clock_set_mask+0x58>)
   152b0:	4a06      	ldr	r2, [pc, #24]	; (152cc <system_apb_clock_set_mask+0x58>)
   152b2:	6a11      	ldr	r1, [r2, #32]
   152b4:	683a      	ldr	r2, [r7, #0]
   152b6:	430a      	orrs	r2, r1
   152b8:	621a      	str	r2, [r3, #32]
			break;
   152ba:	e001      	b.n	152c0 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
   152bc:	2317      	movs	r3, #23
   152be:	e000      	b.n	152c2 <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
   152c0:	2300      	movs	r3, #0
}
   152c2:	0018      	movs	r0, r3
   152c4:	46bd      	mov	sp, r7
   152c6:	b002      	add	sp, #8
   152c8:	bd80      	pop	{r7, pc}
   152ca:	46c0      	nop			; (mov r8, r8)
   152cc:	40000400 	.word	0x40000400

000152d0 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
   152d0:	b580      	push	{r7, lr}
   152d2:	b082      	sub	sp, #8
   152d4:	af00      	add	r7, sp, #0
   152d6:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
   152d8:	687b      	ldr	r3, [r7, #4]
   152da:	2280      	movs	r2, #128	; 0x80
   152dc:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
   152de:	687b      	ldr	r3, [r7, #4]
   152e0:	2200      	movs	r2, #0
   152e2:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
   152e4:	687b      	ldr	r3, [r7, #4]
   152e6:	2201      	movs	r2, #1
   152e8:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
   152ea:	687b      	ldr	r3, [r7, #4]
   152ec:	2200      	movs	r2, #0
   152ee:	70da      	strb	r2, [r3, #3]
}
   152f0:	46c0      	nop			; (mov r8, r8)
   152f2:	46bd      	mov	sp, r7
   152f4:	b002      	add	sp, #8
   152f6:	bd80      	pop	{r7, pc}

000152f8 <system_is_debugger_present>:
 * \retval true  Debugger is connected to the system
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
   152f8:	b580      	push	{r7, lr}
   152fa:	af00      	add	r7, sp, #0
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
   152fc:	4b05      	ldr	r3, [pc, #20]	; (15314 <system_is_debugger_present+0x1c>)
   152fe:	789b      	ldrb	r3, [r3, #2]
   15300:	b2db      	uxtb	r3, r3
   15302:	001a      	movs	r2, r3
   15304:	2302      	movs	r3, #2
   15306:	4013      	ands	r3, r2
   15308:	1e5a      	subs	r2, r3, #1
   1530a:	4193      	sbcs	r3, r2
   1530c:	b2db      	uxtb	r3, r3
}
   1530e:	0018      	movs	r0, r3
   15310:	46bd      	mov	sp, r7
   15312:	bd80      	pop	{r7, pc}
   15314:	41002000 	.word	0x41002000

00015318 <usart_is_syncing>:
 * \retval false  Peripheral is not busy syncing and can be read/written without
 *                stalling the bus
 */
static inline bool usart_is_syncing(
		const struct usart_module *const module)
{
   15318:	b580      	push	{r7, lr}
   1531a:	b084      	sub	sp, #16
   1531c:	af00      	add	r7, sp, #0
   1531e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
   15320:	687b      	ldr	r3, [r7, #4]
   15322:	681b      	ldr	r3, [r3, #0]
   15324:	60fb      	str	r3, [r7, #12]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
   15326:	68fb      	ldr	r3, [r7, #12]
   15328:	69db      	ldr	r3, [r3, #28]
   1532a:	1e5a      	subs	r2, r3, #1
   1532c:	4193      	sbcs	r3, r2
   1532e:	b2db      	uxtb	r3, r3
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
#endif
}
   15330:	0018      	movs	r0, r3
   15332:	46bd      	mov	sp, r7
   15334:	b004      	add	sp, #16
   15336:	bd80      	pop	{r7, pc}

00015338 <_usart_wait_for_sync>:
 * \internal
 * Waits until synchronization is complete
 */
static inline void _usart_wait_for_sync(
		const struct usart_module *const module)
{
   15338:	b580      	push	{r7, lr}
   1533a:	b082      	sub	sp, #8
   1533c:	af00      	add	r7, sp, #0
   1533e:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
   15340:	46c0      	nop			; (mov r8, r8)
   15342:	687b      	ldr	r3, [r7, #4]
   15344:	0018      	movs	r0, r3
   15346:	4b04      	ldr	r3, [pc, #16]	; (15358 <_usart_wait_for_sync+0x20>)
   15348:	4798      	blx	r3
   1534a:	1e03      	subs	r3, r0, #0
   1534c:	d1f9      	bne.n	15342 <_usart_wait_for_sync+0xa>
		/* Wait until the synchronization is complete */
	}
}
   1534e:	46c0      	nop			; (mov r8, r8)
   15350:	46bd      	mov	sp, r7
   15352:	b002      	add	sp, #8
   15354:	bd80      	pop	{r7, pc}
   15356:	46c0      	nop			; (mov r8, r8)
   15358:	00015319 	.word	0x00015319

0001535c <_usart_set_config>:
 * Set Configuration of the USART module
 */
static enum status_code _usart_set_config(
		struct usart_module *const module,
		const struct usart_config *const config)
{
   1535c:	b5b0      	push	{r4, r5, r7, lr}
   1535e:	b08c      	sub	sp, #48	; 0x30
   15360:	af02      	add	r7, sp, #8
   15362:	6078      	str	r0, [r7, #4]
   15364:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
   15366:	687b      	ldr	r3, [r7, #4]
   15368:	681b      	ldr	r3, [r3, #0]
   1536a:	61bb      	str	r3, [r7, #24]

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1536c:	687b      	ldr	r3, [r7, #4]
   1536e:	681b      	ldr	r3, [r3, #0]
   15370:	0018      	movs	r0, r3
   15372:	4ba8      	ldr	r3, [pc, #672]	; (15614 <_usart_set_config+0x2b8>)
   15374:	4798      	blx	r3
   15376:	0003      	movs	r3, r0
   15378:	617b      	str	r3, [r7, #20]
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   1537a:	697b      	ldr	r3, [r7, #20]
   1537c:	3314      	adds	r3, #20
   1537e:	613b      	str	r3, [r7, #16]

	/* Cache new register values to minimize the number of register writes */
	uint32_t ctrla = 0;
   15380:	2300      	movs	r3, #0
   15382:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t ctrlb = 0;
   15384:	2300      	movs	r3, #0
   15386:	623b      	str	r3, [r7, #32]
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
   15388:	230a      	movs	r3, #10
   1538a:	18fb      	adds	r3, r7, r3
   1538c:	2200      	movs	r2, #0
   1538e:	801a      	strh	r2, [r3, #0]
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
   15390:	231f      	movs	r3, #31
   15392:	18fb      	adds	r3, r7, r3
   15394:	2200      	movs	r2, #0
   15396:	701a      	strb	r2, [r3, #0]
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
   15398:	231e      	movs	r3, #30
   1539a:	18fb      	adds	r3, r7, r3
   1539c:	2210      	movs	r2, #16
   1539e:	701a      	strb	r2, [r3, #0]

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
   153a0:	683b      	ldr	r3, [r7, #0]
   153a2:	8a1b      	ldrh	r3, [r3, #16]
   153a4:	2280      	movs	r2, #128	; 0x80
   153a6:	01d2      	lsls	r2, r2, #7
   153a8:	4293      	cmp	r3, r2
   153aa:	d01c      	beq.n	153e6 <_usart_set_config+0x8a>
   153ac:	2280      	movs	r2, #128	; 0x80
   153ae:	01d2      	lsls	r2, r2, #7
   153b0:	4293      	cmp	r3, r2
   153b2:	dc06      	bgt.n	153c2 <_usart_set_config+0x66>
   153b4:	2b00      	cmp	r3, #0
   153b6:	d00d      	beq.n	153d4 <_usart_set_config+0x78>
   153b8:	2280      	movs	r2, #128	; 0x80
   153ba:	0192      	lsls	r2, r2, #6
   153bc:	4293      	cmp	r3, r2
   153be:	d024      	beq.n	1540a <_usart_set_config+0xae>
   153c0:	e035      	b.n	1542e <_usart_set_config+0xd2>
   153c2:	22c0      	movs	r2, #192	; 0xc0
   153c4:	01d2      	lsls	r2, r2, #7
   153c6:	4293      	cmp	r3, r2
   153c8:	d028      	beq.n	1541c <_usart_set_config+0xc0>
   153ca:	2280      	movs	r2, #128	; 0x80
   153cc:	0212      	lsls	r2, r2, #8
   153ce:	4293      	cmp	r3, r2
   153d0:	d012      	beq.n	153f8 <_usart_set_config+0x9c>
   153d2:	e02c      	b.n	1542e <_usart_set_config+0xd2>
		case USART_SAMPLE_RATE_16X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
   153d4:	231f      	movs	r3, #31
   153d6:	18fb      	adds	r3, r7, r3
   153d8:	2200      	movs	r2, #0
   153da:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
   153dc:	231e      	movs	r3, #30
   153de:	18fb      	adds	r3, r7, r3
   153e0:	2210      	movs	r2, #16
   153e2:	701a      	strb	r2, [r3, #0]
			break;
   153e4:	e023      	b.n	1542e <_usart_set_config+0xd2>
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
   153e6:	231f      	movs	r3, #31
   153e8:	18fb      	adds	r3, r7, r3
   153ea:	2200      	movs	r2, #0
   153ec:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
   153ee:	231e      	movs	r3, #30
   153f0:	18fb      	adds	r3, r7, r3
   153f2:	2208      	movs	r2, #8
   153f4:	701a      	strb	r2, [r3, #0]
			break;
   153f6:	e01a      	b.n	1542e <_usart_set_config+0xd2>
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
   153f8:	231f      	movs	r3, #31
   153fa:	18fb      	adds	r3, r7, r3
   153fc:	2200      	movs	r2, #0
   153fe:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
   15400:	231e      	movs	r3, #30
   15402:	18fb      	adds	r3, r7, r3
   15404:	2203      	movs	r2, #3
   15406:	701a      	strb	r2, [r3, #0]
			break;
   15408:	e011      	b.n	1542e <_usart_set_config+0xd2>
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
   1540a:	231f      	movs	r3, #31
   1540c:	18fb      	adds	r3, r7, r3
   1540e:	2201      	movs	r2, #1
   15410:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
   15412:	231e      	movs	r3, #30
   15414:	18fb      	adds	r3, r7, r3
   15416:	2210      	movs	r2, #16
   15418:	701a      	strb	r2, [r3, #0]
			break;
   1541a:	e008      	b.n	1542e <_usart_set_config+0xd2>
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
   1541c:	231f      	movs	r3, #31
   1541e:	18fb      	adds	r3, r7, r3
   15420:	2201      	movs	r2, #1
   15422:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
   15424:	231e      	movs	r3, #30
   15426:	18fb      	adds	r3, r7, r3
   15428:	2208      	movs	r2, #8
   1542a:	701a      	strb	r2, [r3, #0]
			break;
   1542c:	46c0      	nop			; (mov r8, r8)
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
   1542e:	683b      	ldr	r3, [r7, #0]
   15430:	681a      	ldr	r2, [r3, #0]
		(uint32_t)config->mux_setting |
   15432:	683b      	ldr	r3, [r7, #0]
   15434:	68db      	ldr	r3, [r3, #12]
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
   15436:	431a      	orrs	r2, r3
		(uint32_t)config->mux_setting |
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
   15438:	683b      	ldr	r3, [r7, #0]
   1543a:	695b      	ldr	r3, [r3, #20]
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
		(uint32_t)config->mux_setting |
   1543c:	4313      	orrs	r3, r2
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
		config->sample_rate |
   1543e:	683a      	ldr	r2, [r7, #0]
   15440:	8a12      	ldrh	r2, [r2, #16]

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
		(uint32_t)config->mux_setting |
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
   15442:	4313      	orrs	r3, r2
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
   15444:	683a      	ldr	r2, [r7, #0]
   15446:	7e12      	ldrb	r2, [r2, #24]
   15448:	0212      	lsls	r2, r2, #8
	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
		(uint32_t)config->mux_setting |
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
		config->sample_rate |
   1544a:	4313      	orrs	r3, r2
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
   1544c:	683a      	ldr	r2, [r7, #0]
   1544e:	2126      	movs	r1, #38	; 0x26
   15450:	5c52      	ldrb	r2, [r2, r1]
   15452:	0752      	lsls	r2, r2, #29
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
   15454:	4313      	orrs	r3, r2
   15456:	627b      	str	r3, [r7, #36]	; 0x24
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);

	enum status_code status_code = STATUS_OK;
   15458:	231d      	movs	r3, #29
   1545a:	18fb      	adds	r3, r7, r3
   1545c:	2200      	movs	r2, #0
   1545e:	701a      	strb	r2, [r3, #0]

	transfer_mode = (uint32_t)config->transfer_mode;
   15460:	683b      	ldr	r3, [r7, #0]
   15462:	685b      	ldr	r3, [r3, #4]
   15464:	60fb      	str	r3, [r7, #12]
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
   15466:	68fb      	ldr	r3, [r7, #12]
   15468:	2b00      	cmp	r3, #0
   1546a:	d01e      	beq.n	154aa <_usart_set_config+0x14e>
   1546c:	2280      	movs	r2, #128	; 0x80
   1546e:	0552      	lsls	r2, r2, #21
   15470:	4293      	cmp	r3, r2
   15472:	d14f      	bne.n	15514 <_usart_set_config+0x1b8>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
   15474:	683b      	ldr	r3, [r7, #0]
   15476:	2227      	movs	r2, #39	; 0x27
   15478:	5c9b      	ldrb	r3, [r3, r2]
   1547a:	2201      	movs	r2, #1
   1547c:	4053      	eors	r3, r2
   1547e:	b2db      	uxtb	r3, r3
   15480:	2b00      	cmp	r3, #0
   15482:	d046      	beq.n	15512 <_usart_set_config+0x1b6>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
   15484:	683b      	ldr	r3, [r7, #0]
   15486:	6a1d      	ldr	r5, [r3, #32]
   15488:	693b      	ldr	r3, [r7, #16]
   1548a:	b2db      	uxtb	r3, r3
   1548c:	0018      	movs	r0, r3
   1548e:	4b62      	ldr	r3, [pc, #392]	; (15618 <_usart_set_config+0x2bc>)
   15490:	4798      	blx	r3
   15492:	0001      	movs	r1, r0
   15494:	231d      	movs	r3, #29
   15496:	18fc      	adds	r4, r7, r3
   15498:	230a      	movs	r3, #10
   1549a:	18fb      	adds	r3, r7, r3
   1549c:	001a      	movs	r2, r3
   1549e:	0028      	movs	r0, r5
   154a0:	4b5e      	ldr	r3, [pc, #376]	; (1561c <_usart_set_config+0x2c0>)
   154a2:	4798      	blx	r3
   154a4:	0003      	movs	r3, r0
   154a6:	7023      	strb	r3, [r4, #0]
						system_gclk_chan_get_hz(gclk_index), &baud);
			}

			break;
   154a8:	e033      	b.n	15512 <_usart_set_config+0x1b6>

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
   154aa:	683b      	ldr	r3, [r7, #0]
   154ac:	2227      	movs	r2, #39	; 0x27
   154ae:	5c9b      	ldrb	r3, [r3, r2]
   154b0:	2b00      	cmp	r3, #0
   154b2:	d014      	beq.n	154de <_usart_set_config+0x182>
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
   154b4:	683b      	ldr	r3, [r7, #0]
   154b6:	6a18      	ldr	r0, [r3, #32]
   154b8:	683b      	ldr	r3, [r7, #0]
   154ba:	6a99      	ldr	r1, [r3, #40]	; 0x28

			break;

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
				status_code =
   154bc:	231d      	movs	r3, #29
   154be:	18fc      	adds	r4, r7, r3
   154c0:	231f      	movs	r3, #31
   154c2:	18fb      	adds	r3, r7, r3
   154c4:	781d      	ldrb	r5, [r3, #0]
   154c6:	230a      	movs	r3, #10
   154c8:	18fa      	adds	r2, r7, r3
   154ca:	231e      	movs	r3, #30
   154cc:	18fb      	adds	r3, r7, r3
   154ce:	781b      	ldrb	r3, [r3, #0]
   154d0:	9300      	str	r3, [sp, #0]
   154d2:	002b      	movs	r3, r5
   154d4:	4d52      	ldr	r5, [pc, #328]	; (15620 <_usart_set_config+0x2c4>)
   154d6:	47a8      	blx	r5
   154d8:	0003      	movs	r3, r0
   154da:	7023      	strb	r3, [r4, #0]
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							system_gclk_chan_get_hz(gclk_index), &baud, mode, sample_num);
			}

			break;
   154dc:	e01a      	b.n	15514 <_usart_set_config+0x1b8>
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
   154de:	683b      	ldr	r3, [r7, #0]
   154e0:	6a1d      	ldr	r5, [r3, #32]
   154e2:	693b      	ldr	r3, [r7, #16]
   154e4:	b2db      	uxtb	r3, r3
   154e6:	0018      	movs	r0, r3
   154e8:	4b4b      	ldr	r3, [pc, #300]	; (15618 <_usart_set_config+0x2bc>)
   154ea:	4798      	blx	r3
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
   154ec:	231d      	movs	r3, #29
   154ee:	18fc      	adds	r4, r7, r3
   154f0:	231f      	movs	r3, #31
   154f2:	18fb      	adds	r3, r7, r3
   154f4:	7819      	ldrb	r1, [r3, #0]
   154f6:	230a      	movs	r3, #10
   154f8:	18fa      	adds	r2, r7, r3
   154fa:	231e      	movs	r3, #30
   154fc:	18fb      	adds	r3, r7, r3
   154fe:	781b      	ldrb	r3, [r3, #0]
   15500:	9300      	str	r3, [sp, #0]
   15502:	000b      	movs	r3, r1
   15504:	0001      	movs	r1, r0
   15506:	0028      	movs	r0, r5
   15508:	4d45      	ldr	r5, [pc, #276]	; (15620 <_usart_set_config+0x2c4>)
   1550a:	47a8      	blx	r5
   1550c:	0003      	movs	r3, r0
   1550e:	7023      	strb	r3, [r4, #0]
						_sercom_get_async_baud_val(config->baudrate,
							system_gclk_chan_get_hz(gclk_index), &baud, mode, sample_num);
			}

			break;
   15510:	e000      	b.n	15514 <_usart_set_config+0x1b8>
			if (!config->use_external_clock) {
				status_code = _sercom_get_sync_baud_val(config->baudrate,
						system_gclk_chan_get_hz(gclk_index), &baud);
			}

			break;
   15512:	46c0      	nop			; (mov r8, r8)

			break;
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
   15514:	231d      	movs	r3, #29
   15516:	18fb      	adds	r3, r7, r3
   15518:	781b      	ldrb	r3, [r3, #0]
   1551a:	2b00      	cmp	r3, #0
   1551c:	d003      	beq.n	15526 <_usart_set_config+0x1ca>
		/* Abort */
		return status_code;
   1551e:	231d      	movs	r3, #29
   15520:	18fb      	adds	r3, r7, r3
   15522:	781b      	ldrb	r3, [r3, #0]
   15524:	e071      	b.n	1560a <_usart_set_config+0x2ae>
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_IRDA
	if(config->encoding_format_enable) {
   15526:	683b      	ldr	r3, [r7, #0]
   15528:	7e5b      	ldrb	r3, [r3, #25]
   1552a:	2b00      	cmp	r3, #0
   1552c:	d003      	beq.n	15536 <_usart_set_config+0x1da>
		usart_hw->RXPL.reg = config->receive_pulse_length;
   1552e:	683b      	ldr	r3, [r7, #0]
   15530:	7e9a      	ldrb	r2, [r3, #26]
   15532:	69bb      	ldr	r3, [r7, #24]
   15534:	739a      	strb	r2, [r3, #14]
	}
#endif

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);
   15536:	687b      	ldr	r3, [r7, #4]
   15538:	0018      	movs	r0, r3
   1553a:	4b3a      	ldr	r3, [pc, #232]	; (15624 <_usart_set_config+0x2c8>)
   1553c:	4798      	blx	r3

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
   1553e:	230a      	movs	r3, #10
   15540:	18fb      	adds	r3, r7, r3
   15542:	881a      	ldrh	r2, [r3, #0]
   15544:	69bb      	ldr	r3, [r7, #24]
   15546:	819a      	strh	r2, [r3, #12]

	/* Set sample mode */
	ctrla |= transfer_mode;
   15548:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1554a:	68fb      	ldr	r3, [r7, #12]
   1554c:	4313      	orrs	r3, r2
   1554e:	627b      	str	r3, [r7, #36]	; 0x24

	if (config->use_external_clock == false) {
   15550:	683b      	ldr	r3, [r7, #0]
   15552:	2227      	movs	r2, #39	; 0x27
   15554:	5c9b      	ldrb	r3, [r3, r2]
   15556:	2201      	movs	r2, #1
   15558:	4053      	eors	r3, r2
   1555a:	b2db      	uxtb	r3, r3
   1555c:	2b00      	cmp	r3, #0
   1555e:	d003      	beq.n	15568 <_usart_set_config+0x20c>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
   15560:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15562:	2204      	movs	r2, #4
   15564:	4313      	orrs	r3, r2
   15566:	627b      	str	r3, [r7, #36]	; 0x24
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
   15568:	683b      	ldr	r3, [r7, #0]
   1556a:	7e5b      	ldrb	r3, [r3, #25]
   1556c:	029a      	lsls	r2, r3, #10
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
   1556e:	683b      	ldr	r3, [r7, #0]
   15570:	7f1b      	ldrb	r3, [r3, #28]
   15572:	025b      	lsls	r3, r3, #9
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
   15574:	431a      	orrs	r2, r3
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
   15576:	683b      	ldr	r3, [r7, #0]
   15578:	7f5b      	ldrb	r3, [r3, #29]
   1557a:	021b      	lsls	r3, r3, #8
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
   1557c:	431a      	orrs	r2, r3
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
   1557e:	683b      	ldr	r3, [r7, #0]
   15580:	2124      	movs	r1, #36	; 0x24
   15582:	5c5b      	ldrb	r3, [r3, r1]
   15584:	045b      	lsls	r3, r3, #17
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
   15586:	431a      	orrs	r2, r3
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
   15588:	683b      	ldr	r3, [r7, #0]
   1558a:	2125      	movs	r1, #37	; 0x25
   1558c:	5c5b      	ldrb	r3, [r3, r1]
   1558e:	041b      	lsls	r3, r3, #16
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
   15590:	4313      	orrs	r3, r2
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
   15592:	623b      	str	r3, [r7, #32]
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->character_size;
   15594:	683b      	ldr	r3, [r7, #0]
   15596:	7adb      	ldrb	r3, [r3, #11]
   15598:	001a      	movs	r2, r3
   1559a:	6a3b      	ldr	r3, [r7, #32]
   1559c:	4313      	orrs	r3, r2
   1559e:	623b      	str	r3, [r7, #32]
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
   155a0:	683b      	ldr	r3, [r7, #0]
   155a2:	891b      	ldrh	r3, [r3, #8]
   155a4:	2bff      	cmp	r3, #255	; 0xff
   155a6:	d00b      	beq.n	155c0 <_usart_set_config+0x264>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
   155a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   155aa:	2280      	movs	r2, #128	; 0x80
   155ac:	0452      	lsls	r2, r2, #17
   155ae:	4313      	orrs	r3, r2
   155b0:	627b      	str	r3, [r7, #36]	; 0x24
		ctrlb |= config->parity;
   155b2:	683b      	ldr	r3, [r7, #0]
   155b4:	891b      	ldrh	r3, [r3, #8]
   155b6:	001a      	movs	r2, r3
   155b8:	6a3b      	ldr	r3, [r7, #32]
   155ba:	4313      	orrs	r3, r2
   155bc:	623b      	str	r3, [r7, #32]
   155be:	e008      	b.n	155d2 <_usart_set_config+0x276>
	} else {
#ifdef FEATURE_USART_LIN_SLAVE
		if(config->lin_slave_enable) {
   155c0:	683b      	ldr	r3, [r7, #0]
   155c2:	7edb      	ldrb	r3, [r3, #27]
   155c4:	2b00      	cmp	r3, #0
   155c6:	d004      	beq.n	155d2 <_usart_set_config+0x276>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
   155c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   155ca:	2280      	movs	r2, #128	; 0x80
   155cc:	04d2      	lsls	r2, r2, #19
   155ce:	4313      	orrs	r3, r2
   155d0:	627b      	str	r3, [r7, #36]	; 0x24
		ctrla |= config->lin_node;
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
   155d2:	683b      	ldr	r3, [r7, #0]
   155d4:	222c      	movs	r2, #44	; 0x2c
   155d6:	5c9b      	ldrb	r3, [r3, r2]
   155d8:	2b00      	cmp	r3, #0
   155da:	d103      	bne.n	155e4 <_usart_set_config+0x288>
   155dc:	4b12      	ldr	r3, [pc, #72]	; (15628 <_usart_set_config+0x2cc>)
   155de:	4798      	blx	r3
   155e0:	1e03      	subs	r3, r0, #0
   155e2:	d003      	beq.n	155ec <_usart_set_config+0x290>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
   155e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   155e6:	2280      	movs	r2, #128	; 0x80
   155e8:	4313      	orrs	r3, r2
   155ea:	627b      	str	r3, [r7, #36]	; 0x24
	}

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);
   155ec:	687b      	ldr	r3, [r7, #4]
   155ee:	0018      	movs	r0, r3
   155f0:	4b0c      	ldr	r3, [pc, #48]	; (15624 <_usart_set_config+0x2c8>)
   155f2:	4798      	blx	r3

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
   155f4:	69bb      	ldr	r3, [r7, #24]
   155f6:	6a3a      	ldr	r2, [r7, #32]
   155f8:	605a      	str	r2, [r3, #4]

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);
   155fa:	687b      	ldr	r3, [r7, #4]
   155fc:	0018      	movs	r0, r3
   155fe:	4b09      	ldr	r3, [pc, #36]	; (15624 <_usart_set_config+0x2c8>)
   15600:	4798      	blx	r3

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
   15602:	69bb      	ldr	r3, [r7, #24]
   15604:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   15606:	601a      	str	r2, [r3, #0]
		_usart_wait_for_sync(module);
		usart_hw->CTRLC.reg = ctrlc;
	}
#endif

	return STATUS_OK;
   15608:	2300      	movs	r3, #0
}
   1560a:	0018      	movs	r0, r3
   1560c:	46bd      	mov	sp, r7
   1560e:	b00a      	add	sp, #40	; 0x28
   15610:	bdb0      	pop	{r4, r5, r7, pc}
   15612:	46c0      	nop			; (mov r8, r8)
   15614:	00014049 	.word	0x00014049
   15618:	00016b4d 	.word	0x00016b4d
   1561c:	00013b99 	.word	0x00013b99
   15620:	00013c15 	.word	0x00013c15
   15624:	00015339 	.word	0x00015339
   15628:	000152f9 	.word	0x000152f9

0001562c <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
   1562c:	b590      	push	{r4, r7, lr}
   1562e:	b093      	sub	sp, #76	; 0x4c
   15630:	af00      	add	r7, sp, #0
   15632:	60f8      	str	r0, [r7, #12]
   15634:	60b9      	str	r1, [r7, #8]
   15636:	607a      	str	r2, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(hw);
	Assert(config);

	enum status_code status_code = STATUS_OK;
   15638:	233b      	movs	r3, #59	; 0x3b
   1563a:	18fb      	adds	r3, r7, r3
   1563c:	2200      	movs	r2, #0
   1563e:	701a      	strb	r2, [r3, #0]

	/* Assign module pointer to software instance struct */
	module->hw = hw;
   15640:	68fb      	ldr	r3, [r7, #12]
   15642:	68ba      	ldr	r2, [r7, #8]
   15644:	601a      	str	r2, [r3, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
   15646:	68fb      	ldr	r3, [r7, #12]
   15648:	681b      	ldr	r3, [r3, #0]
   1564a:	637b      	str	r3, [r7, #52]	; 0x34

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1564c:	68fb      	ldr	r3, [r7, #12]
   1564e:	681b      	ldr	r3, [r3, #0]
   15650:	0018      	movs	r0, r3
   15652:	4b86      	ldr	r3, [pc, #536]	; (1586c <usart_init+0x240>)
   15654:	4798      	blx	r3
   15656:	0003      	movs	r3, r0
   15658:	633b      	str	r3, [r7, #48]	; 0x30
#else
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
   1565a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1565c:	3302      	adds	r3, #2
   1565e:	62fb      	str	r3, [r7, #44]	; 0x2c
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   15660:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   15662:	3314      	adds	r3, #20
   15664:	62bb      	str	r3, [r7, #40]	; 0x28
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
   15666:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   15668:	681b      	ldr	r3, [r3, #0]
   1566a:	2201      	movs	r2, #1
   1566c:	4013      	ands	r3, r2
   1566e:	d001      	beq.n	15674 <usart_init+0x48>
		/* The module is busy resetting itself */
		return STATUS_BUSY;
   15670:	2305      	movs	r3, #5
   15672:	e0f6      	b.n	15862 <usart_init+0x236>
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
   15674:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   15676:	681b      	ldr	r3, [r3, #0]
   15678:	2202      	movs	r2, #2
   1567a:	4013      	ands	r3, r2
   1567c:	d001      	beq.n	15682 <usart_init+0x56>
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
   1567e:	231c      	movs	r3, #28
   15680:	e0ef      	b.n	15862 <usart_init+0x236>
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
   15682:	2201      	movs	r2, #1
   15684:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   15686:	409a      	lsls	r2, r3
   15688:	0013      	movs	r3, r2
   1568a:	0019      	movs	r1, r3
   1568c:	2002      	movs	r0, #2
   1568e:	4b78      	ldr	r3, [pc, #480]	; (15870 <usart_init+0x244>)
   15690:	4798      	blx	r3
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
   15692:	2324      	movs	r3, #36	; 0x24
   15694:	18fb      	adds	r3, r7, r3
   15696:	0018      	movs	r0, r3
   15698:	4b76      	ldr	r3, [pc, #472]	; (15874 <usart_init+0x248>)
   1569a:	4798      	blx	r3
	gclk_chan_conf.source_generator = config->generator_source;
   1569c:	687b      	ldr	r3, [r7, #4]
   1569e:	222d      	movs	r2, #45	; 0x2d
   156a0:	5c9a      	ldrb	r2, [r3, r2]
   156a2:	2324      	movs	r3, #36	; 0x24
   156a4:	18fb      	adds	r3, r7, r3
   156a6:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
   156a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   156aa:	b2db      	uxtb	r3, r3
   156ac:	2224      	movs	r2, #36	; 0x24
   156ae:	18ba      	adds	r2, r7, r2
   156b0:	0011      	movs	r1, r2
   156b2:	0018      	movs	r0, r3
   156b4:	4b70      	ldr	r3, [pc, #448]	; (15878 <usart_init+0x24c>)
   156b6:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
   156b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   156ba:	b2db      	uxtb	r3, r3
   156bc:	0018      	movs	r0, r3
   156be:	4b6f      	ldr	r3, [pc, #444]	; (1587c <usart_init+0x250>)
   156c0:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
   156c2:	687b      	ldr	r3, [r7, #4]
   156c4:	222d      	movs	r2, #45	; 0x2d
   156c6:	5c9b      	ldrb	r3, [r3, r2]
   156c8:	2100      	movs	r1, #0
   156ca:	0018      	movs	r0, r3
   156cc:	4b6c      	ldr	r3, [pc, #432]	; (15880 <usart_init+0x254>)
   156ce:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
   156d0:	687b      	ldr	r3, [r7, #4]
   156d2:	7ada      	ldrb	r2, [r3, #11]
   156d4:	68fb      	ldr	r3, [r7, #12]
   156d6:	715a      	strb	r2, [r3, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
   156d8:	687b      	ldr	r3, [r7, #4]
   156da:	2224      	movs	r2, #36	; 0x24
   156dc:	5c9a      	ldrb	r2, [r3, r2]
   156de:	68fb      	ldr	r3, [r7, #12]
   156e0:	719a      	strb	r2, [r3, #6]
	module->transmitter_enabled = config->transmitter_enable;
   156e2:	687b      	ldr	r3, [r7, #4]
   156e4:	2225      	movs	r2, #37	; 0x25
   156e6:	5c9a      	ldrb	r2, [r3, r2]
   156e8:	68fb      	ldr	r3, [r7, #12]
   156ea:	71da      	strb	r2, [r3, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
   156ec:	687b      	ldr	r3, [r7, #4]
   156ee:	7eda      	ldrb	r2, [r3, #27]
   156f0:	68fb      	ldr	r3, [r7, #12]
   156f2:	721a      	strb	r2, [r3, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
   156f4:	687b      	ldr	r3, [r7, #4]
   156f6:	7f1a      	ldrb	r2, [r3, #28]
   156f8:	68fb      	ldr	r3, [r7, #12]
   156fa:	725a      	strb	r2, [r3, #9]
#endif
#ifdef FEATURE_USART_ISO7816
	module->iso7816_mode_enabled = config->iso7816_config.enabled;
#endif
	/* Set configuration according to the config struct */
	status_code = _usart_set_config(module, config);
   156fc:	233b      	movs	r3, #59	; 0x3b
   156fe:	18fc      	adds	r4, r7, r3
   15700:	687a      	ldr	r2, [r7, #4]
   15702:	68fb      	ldr	r3, [r7, #12]
   15704:	0011      	movs	r1, r2
   15706:	0018      	movs	r0, r3
   15708:	4b5e      	ldr	r3, [pc, #376]	; (15884 <usart_init+0x258>)
   1570a:	4798      	blx	r3
   1570c:	0003      	movs	r3, r0
   1570e:	7023      	strb	r3, [r4, #0]
	if(status_code != STATUS_OK) {
   15710:	233b      	movs	r3, #59	; 0x3b
   15712:	18fb      	adds	r3, r7, r3
   15714:	781b      	ldrb	r3, [r3, #0]
   15716:	2b00      	cmp	r3, #0
   15718:	d003      	beq.n	15722 <usart_init+0xf6>
		return status_code;
   1571a:	233b      	movs	r3, #59	; 0x3b
   1571c:	18fb      	adds	r3, r7, r3
   1571e:	781b      	ldrb	r3, [r3, #0]
   15720:	e09f      	b.n	15862 <usart_init+0x236>
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
   15722:	2320      	movs	r3, #32
   15724:	18fb      	adds	r3, r7, r3
   15726:	0018      	movs	r0, r3
   15728:	4b57      	ldr	r3, [pc, #348]	; (15888 <usart_init+0x25c>)
   1572a:	4798      	blx	r3
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
   1572c:	2320      	movs	r3, #32
   1572e:	18fb      	adds	r3, r7, r3
   15730:	2200      	movs	r2, #0
   15732:	705a      	strb	r2, [r3, #1]
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
   15734:	2320      	movs	r3, #32
   15736:	18fb      	adds	r3, r7, r3
   15738:	2200      	movs	r2, #0
   1573a:	709a      	strb	r2, [r3, #2]

	uint32_t pad_pinmuxes[] = {
			config->pinmux_pad0, config->pinmux_pad1,
   1573c:	687b      	ldr	r3, [r7, #4]
   1573e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;

	uint32_t pad_pinmuxes[] = {
   15740:	2310      	movs	r3, #16
   15742:	18fb      	adds	r3, r7, r3
   15744:	601a      	str	r2, [r3, #0]
			config->pinmux_pad0, config->pinmux_pad1,
   15746:	687b      	ldr	r3, [r7, #4]
   15748:	6b5a      	ldr	r2, [r3, #52]	; 0x34
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;

	uint32_t pad_pinmuxes[] = {
   1574a:	2310      	movs	r3, #16
   1574c:	18fb      	adds	r3, r7, r3
   1574e:	605a      	str	r2, [r3, #4]
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
   15750:	687b      	ldr	r3, [r7, #4]
   15752:	6b9a      	ldr	r2, [r3, #56]	; 0x38
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;

	uint32_t pad_pinmuxes[] = {
   15754:	2310      	movs	r3, #16
   15756:	18fb      	adds	r3, r7, r3
   15758:	609a      	str	r2, [r3, #8]
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
   1575a:	687b      	ldr	r3, [r7, #4]
   1575c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;

	uint32_t pad_pinmuxes[] = {
   1575e:	2310      	movs	r3, #16
   15760:	18fb      	adds	r3, r7, r3
   15762:	60da      	str	r2, [r3, #12]
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
   15764:	2347      	movs	r3, #71	; 0x47
   15766:	18fb      	adds	r3, r7, r3
   15768:	2200      	movs	r2, #0
   1576a:	701a      	strb	r2, [r3, #0]
   1576c:	e02c      	b.n	157c8 <usart_init+0x19c>
		uint32_t current_pinmux = pad_pinmuxes[pad];
   1576e:	2347      	movs	r3, #71	; 0x47
   15770:	18fb      	adds	r3, r7, r3
   15772:	781a      	ldrb	r2, [r3, #0]
   15774:	2310      	movs	r3, #16
   15776:	18fb      	adds	r3, r7, r3
   15778:	0092      	lsls	r2, r2, #2
   1577a:	58d3      	ldr	r3, [r2, r3]
   1577c:	643b      	str	r3, [r7, #64]	; 0x40

		if (current_pinmux == PINMUX_DEFAULT) {
   1577e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   15780:	2b00      	cmp	r3, #0
   15782:	d109      	bne.n	15798 <usart_init+0x16c>
			current_pinmux = _sercom_get_default_pad(hw, pad);
   15784:	2347      	movs	r3, #71	; 0x47
   15786:	18fb      	adds	r3, r7, r3
   15788:	781a      	ldrb	r2, [r3, #0]
   1578a:	68bb      	ldr	r3, [r7, #8]
   1578c:	0011      	movs	r1, r2
   1578e:	0018      	movs	r0, r3
   15790:	4b3e      	ldr	r3, [pc, #248]	; (1588c <usart_init+0x260>)
   15792:	4798      	blx	r3
   15794:	0003      	movs	r3, r0
   15796:	643b      	str	r3, [r7, #64]	; 0x40
		}

		if (current_pinmux != PINMUX_UNUSED) {
   15798:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1579a:	3301      	adds	r3, #1
   1579c:	d00d      	beq.n	157ba <usart_init+0x18e>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
   1579e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   157a0:	b2da      	uxtb	r2, r3
   157a2:	2320      	movs	r3, #32
   157a4:	18fb      	adds	r3, r7, r3
   157a6:	701a      	strb	r2, [r3, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
   157a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   157aa:	0c1b      	lsrs	r3, r3, #16
   157ac:	b2db      	uxtb	r3, r3
   157ae:	2220      	movs	r2, #32
   157b0:	18ba      	adds	r2, r7, r2
   157b2:	0011      	movs	r1, r2
   157b4:	0018      	movs	r0, r3
   157b6:	4b36      	ldr	r3, [pc, #216]	; (15890 <usart_init+0x264>)
   157b8:	4798      	blx	r3
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
   157ba:	2347      	movs	r3, #71	; 0x47
   157bc:	18fb      	adds	r3, r7, r3
   157be:	781a      	ldrb	r2, [r3, #0]
   157c0:	2347      	movs	r3, #71	; 0x47
   157c2:	18fb      	adds	r3, r7, r3
   157c4:	3201      	adds	r2, #1
   157c6:	701a      	strb	r2, [r3, #0]
   157c8:	2347      	movs	r3, #71	; 0x47
   157ca:	18fb      	adds	r3, r7, r3
   157cc:	781b      	ldrb	r3, [r3, #0]
   157ce:	2b03      	cmp	r3, #3
   157d0:	d9cd      	bls.n	1576e <usart_init+0x142>
		}
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
   157d2:	2300      	movs	r3, #0
   157d4:	63fb      	str	r3, [r7, #60]	; 0x3c
   157d6:	e00a      	b.n	157ee <usart_init+0x1c2>
		module->callback[i]            = NULL;
   157d8:	68fa      	ldr	r2, [r7, #12]
   157da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   157dc:	3302      	adds	r3, #2
   157de:	009b      	lsls	r3, r3, #2
   157e0:	18d3      	adds	r3, r2, r3
   157e2:	3304      	adds	r3, #4
   157e4:	2200      	movs	r2, #0
   157e6:	601a      	str	r2, [r3, #0]
		}
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
   157e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   157ea:	3301      	adds	r3, #1
   157ec:	63fb      	str	r3, [r7, #60]	; 0x3c
   157ee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   157f0:	2b05      	cmp	r3, #5
   157f2:	d9f1      	bls.n	157d8 <usart_init+0x1ac>
		module->callback[i]            = NULL;
	}

	module->tx_buffer_ptr              = NULL;
   157f4:	68fb      	ldr	r3, [r7, #12]
   157f6:	2200      	movs	r2, #0
   157f8:	629a      	str	r2, [r3, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
   157fa:	68fb      	ldr	r3, [r7, #12]
   157fc:	2200      	movs	r2, #0
   157fe:	625a      	str	r2, [r3, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
   15800:	68fb      	ldr	r3, [r7, #12]
   15802:	2200      	movs	r2, #0
   15804:	85da      	strh	r2, [r3, #46]	; 0x2e
	module->remaining_rx_buffer_length = 0x0000;
   15806:	68fb      	ldr	r3, [r7, #12]
   15808:	2200      	movs	r2, #0
   1580a:	859a      	strh	r2, [r3, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
   1580c:	68fb      	ldr	r3, [r7, #12]
   1580e:	2230      	movs	r2, #48	; 0x30
   15810:	2100      	movs	r1, #0
   15812:	5499      	strb	r1, [r3, r2]
	module->callback_enable_mask       = 0x00;
   15814:	68fb      	ldr	r3, [r7, #12]
   15816:	2231      	movs	r2, #49	; 0x31
   15818:	2100      	movs	r1, #0
   1581a:	5499      	strb	r1, [r3, r2]
	module->rx_status                  = STATUS_OK;
   1581c:	68fb      	ldr	r3, [r7, #12]
   1581e:	2232      	movs	r2, #50	; 0x32
   15820:	2100      	movs	r1, #0
   15822:	5499      	strb	r1, [r3, r2]
	module->tx_status                  = STATUS_OK;
   15824:	68fb      	ldr	r3, [r7, #12]
   15826:	2233      	movs	r2, #51	; 0x33
   15828:	2100      	movs	r1, #0
   1582a:	5499      	strb	r1, [r3, r2]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
   1582c:	68fb      	ldr	r3, [r7, #12]
   1582e:	681b      	ldr	r3, [r3, #0]
   15830:	2227      	movs	r2, #39	; 0x27
   15832:	18bc      	adds	r4, r7, r2
   15834:	0018      	movs	r0, r3
   15836:	4b0d      	ldr	r3, [pc, #52]	; (1586c <usart_init+0x240>)
   15838:	4798      	blx	r3
   1583a:	0003      	movs	r3, r0
   1583c:	7023      	strb	r3, [r4, #0]
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
   1583e:	4a15      	ldr	r2, [pc, #84]	; (15894 <usart_init+0x268>)
   15840:	2327      	movs	r3, #39	; 0x27
   15842:	18fb      	adds	r3, r7, r3
   15844:	781b      	ldrb	r3, [r3, #0]
   15846:	0011      	movs	r1, r2
   15848:	0018      	movs	r0, r3
   1584a:	4b13      	ldr	r3, [pc, #76]	; (15898 <usart_init+0x26c>)
   1584c:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
   1584e:	2327      	movs	r3, #39	; 0x27
   15850:	18fb      	adds	r3, r7, r3
   15852:	781a      	ldrb	r2, [r3, #0]
   15854:	4b11      	ldr	r3, [pc, #68]	; (1589c <usart_init+0x270>)
   15856:	0092      	lsls	r2, r2, #2
   15858:	68f9      	ldr	r1, [r7, #12]
   1585a:	50d1      	str	r1, [r2, r3]
#endif

	return status_code;
   1585c:	233b      	movs	r3, #59	; 0x3b
   1585e:	18fb      	adds	r3, r7, r3
   15860:	781b      	ldrb	r3, [r3, #0]
}
   15862:	0018      	movs	r0, r3
   15864:	46bd      	mov	sp, r7
   15866:	b013      	add	sp, #76	; 0x4c
   15868:	bd90      	pop	{r4, r7, pc}
   1586a:	46c0      	nop			; (mov r8, r8)
   1586c:	00014049 	.word	0x00014049
   15870:	00015275 	.word	0x00015275
   15874:	0001525d 	.word	0x0001525d
   15878:	000169e1 	.word	0x000169e1
   1587c:	00016a25 	.word	0x00016a25
   15880:	00013e01 	.word	0x00013e01
   15884:	0001535d 	.word	0x0001535d
   15888:	000152d1 	.word	0x000152d1
   1588c:	00013e8d 	.word	0x00013e8d
   15890:	00016d15 	.word	0x00016d15
   15894:	000159f1 	.word	0x000159f1
   15898:	000140ad 	.word	0x000140ad
   1589c:	20004bac 	.word	0x20004bac

000158a0 <system_interrupt_enter_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
   158a0:	b580      	push	{r7, lr}
   158a2:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
   158a4:	4b02      	ldr	r3, [pc, #8]	; (158b0 <system_interrupt_enter_critical_section+0x10>)
   158a6:	4798      	blx	r3
}
   158a8:	46c0      	nop			; (mov r8, r8)
   158aa:	46bd      	mov	sp, r7
   158ac:	bd80      	pop	{r7, pc}
   158ae:	46c0      	nop			; (mov r8, r8)
   158b0:	00013345 	.word	0x00013345

000158b4 <system_interrupt_leave_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
   158b4:	b580      	push	{r7, lr}
   158b6:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
   158b8:	4b02      	ldr	r3, [pc, #8]	; (158c4 <system_interrupt_leave_critical_section+0x10>)
   158ba:	4798      	blx	r3
}
   158bc:	46c0      	nop			; (mov r8, r8)
   158be:	46bd      	mov	sp, r7
   158c0:	bd80      	pop	{r7, pc}
   158c2:	46c0      	nop			; (mov r8, r8)
   158c4:	00013399 	.word	0x00013399

000158c8 <usart_is_syncing>:
 * \retval false  Peripheral is not busy syncing and can be read/written without
 *                stalling the bus
 */
static inline bool usart_is_syncing(
		const struct usart_module *const module)
{
   158c8:	b580      	push	{r7, lr}
   158ca:	b084      	sub	sp, #16
   158cc:	af00      	add	r7, sp, #0
   158ce:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
   158d0:	687b      	ldr	r3, [r7, #4]
   158d2:	681b      	ldr	r3, [r3, #0]
   158d4:	60fb      	str	r3, [r7, #12]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
   158d6:	68fb      	ldr	r3, [r7, #12]
   158d8:	69db      	ldr	r3, [r3, #28]
   158da:	1e5a      	subs	r2, r3, #1
   158dc:	4193      	sbcs	r3, r2
   158de:	b2db      	uxtb	r3, r3
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
#endif
}
   158e0:	0018      	movs	r0, r3
   158e2:	46bd      	mov	sp, r7
   158e4:	b004      	add	sp, #16
   158e6:	bd80      	pop	{r7, pc}

000158e8 <_usart_wait_for_sync>:
 * \internal
 * Waits until synchronization is complete
 */
static inline void _usart_wait_for_sync(
		const struct usart_module *const module)
{
   158e8:	b580      	push	{r7, lr}
   158ea:	b082      	sub	sp, #8
   158ec:	af00      	add	r7, sp, #0
   158ee:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
   158f0:	46c0      	nop			; (mov r8, r8)
   158f2:	687b      	ldr	r3, [r7, #4]
   158f4:	0018      	movs	r0, r3
   158f6:	4b04      	ldr	r3, [pc, #16]	; (15908 <_usart_wait_for_sync+0x20>)
   158f8:	4798      	blx	r3
   158fa:	1e03      	subs	r3, r0, #0
   158fc:	d1f9      	bne.n	158f2 <_usart_wait_for_sync+0xa>
		/* Wait until the synchronization is complete */
	}
}
   158fe:	46c0      	nop			; (mov r8, r8)
   15900:	46bd      	mov	sp, r7
   15902:	b002      	add	sp, #8
   15904:	bd80      	pop	{r7, pc}
   15906:	46c0      	nop			; (mov r8, r8)
   15908:	000158c9 	.word	0x000158c9

0001590c <_usart_read_buffer>:
 */
enum status_code _usart_read_buffer(
		struct usart_module *const module,
		uint8_t *rx_data,
		uint16_t length)
{
   1590c:	b580      	push	{r7, lr}
   1590e:	b086      	sub	sp, #24
   15910:	af00      	add	r7, sp, #0
   15912:	60f8      	str	r0, [r7, #12]
   15914:	60b9      	str	r1, [r7, #8]
   15916:	1dbb      	adds	r3, r7, #6
   15918:	801a      	strh	r2, [r3, #0]
	Assert(module);
	Assert(module->hw);
	Assert(rx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
   1591a:	68fb      	ldr	r3, [r7, #12]
   1591c:	681b      	ldr	r3, [r3, #0]
   1591e:	617b      	str	r3, [r7, #20]

	system_interrupt_enter_critical_section();
   15920:	4b16      	ldr	r3, [pc, #88]	; (1597c <_usart_read_buffer+0x70>)
   15922:	4798      	blx	r3

	/* Check if the USART receiver is busy */
	if (module->remaining_rx_buffer_length > 0) {
   15924:	68fb      	ldr	r3, [r7, #12]
   15926:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
   15928:	b29b      	uxth	r3, r3
   1592a:	2b00      	cmp	r3, #0
   1592c:	d003      	beq.n	15936 <_usart_read_buffer+0x2a>
		system_interrupt_leave_critical_section();
   1592e:	4b14      	ldr	r3, [pc, #80]	; (15980 <_usart_read_buffer+0x74>)
   15930:	4798      	blx	r3
		return STATUS_BUSY;
   15932:	2305      	movs	r3, #5
   15934:	e01e      	b.n	15974 <_usart_read_buffer+0x68>
	}

	/* Set length for the buffer and the pointer, and let
	 * the interrupt handler do the rest */
	module->remaining_rx_buffer_length = length;
   15936:	68fb      	ldr	r3, [r7, #12]
   15938:	1dba      	adds	r2, r7, #6
   1593a:	8812      	ldrh	r2, [r2, #0]
   1593c:	859a      	strh	r2, [r3, #44]	; 0x2c

	system_interrupt_leave_critical_section();
   1593e:	4b10      	ldr	r3, [pc, #64]	; (15980 <_usart_read_buffer+0x74>)
   15940:	4798      	blx	r3

    //usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXS; //Add
    //usart_hw->CTRLB.bit.RXEN=0; //Add
	module->rx_buffer_ptr              = rx_data;
   15942:	68fb      	ldr	r3, [r7, #12]
   15944:	68ba      	ldr	r2, [r7, #8]
   15946:	625a      	str	r2, [r3, #36]	; 0x24
	module->rx_status                  = STATUS_BUSY;
   15948:	68fb      	ldr	r3, [r7, #12]
   1594a:	2232      	movs	r2, #50	; 0x32
   1594c:	2105      	movs	r1, #5
   1594e:	5499      	strb	r1, [r3, r2]
   //usart_hw->CTRLB.bit.RXEN=1;	//Add
	/* Enable the RX Complete Interrupt */
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXC;
   15950:	697b      	ldr	r3, [r7, #20]
   15952:	2204      	movs	r2, #4
   15954:	759a      	strb	r2, [r3, #22]

#ifdef FEATURE_USART_LIN_SLAVE
	/* Enable the break character is received Interrupt */
	if(module->lin_slave_enabled) {
   15956:	68fb      	ldr	r3, [r7, #12]
   15958:	7a1b      	ldrb	r3, [r3, #8]
   1595a:	2b00      	cmp	r3, #0
   1595c:	d002      	beq.n	15964 <_usart_read_buffer+0x58>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXBRK;
   1595e:	697b      	ldr	r3, [r7, #20]
   15960:	2220      	movs	r2, #32
   15962:	759a      	strb	r2, [r3, #22]
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	/* Enable a start condition is detected Interrupt */
	if(module->start_frame_detection_enabled) {
   15964:	68fb      	ldr	r3, [r7, #12]
   15966:	7a5b      	ldrb	r3, [r3, #9]
   15968:	2b00      	cmp	r3, #0
   1596a:	d002      	beq.n	15972 <_usart_read_buffer+0x66>
		//usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS; //Add
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS; 
   1596c:	697b      	ldr	r3, [r7, #20]
   1596e:	2208      	movs	r2, #8
   15970:	759a      	strb	r2, [r3, #22]
	}
#endif

    //module->rx_buffer_ptr              = rx_data;
	return STATUS_OK;
   15972:	2300      	movs	r3, #0
}
   15974:	0018      	movs	r0, r3
   15976:	46bd      	mov	sp, r7
   15978:	b006      	add	sp, #24
   1597a:	bd80      	pop	{r7, pc}
   1597c:	000158a1 	.word	0x000158a1
   15980:	000158b5 	.word	0x000158b5

00015984 <usart_register_callback>:
 */
void usart_register_callback(
		struct usart_module *const module,
		usart_callback_t callback_func,
		enum usart_callback callback_type)
{
   15984:	b580      	push	{r7, lr}
   15986:	b084      	sub	sp, #16
   15988:	af00      	add	r7, sp, #0
   1598a:	60f8      	str	r0, [r7, #12]
   1598c:	60b9      	str	r1, [r7, #8]
   1598e:	1dfb      	adds	r3, r7, #7
   15990:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
   15992:	1dfb      	adds	r3, r7, #7
   15994:	781b      	ldrb	r3, [r3, #0]
   15996:	68fa      	ldr	r2, [r7, #12]
   15998:	3302      	adds	r3, #2
   1599a:	009b      	lsls	r3, r3, #2
   1599c:	18d3      	adds	r3, r2, r3
   1599e:	3304      	adds	r3, #4
   159a0:	68ba      	ldr	r2, [r7, #8]
   159a2:	601a      	str	r2, [r3, #0]

	/* Set the bit corresponding to the callback_type */
	module->callback_reg_mask |= (1 << callback_type);
   159a4:	68fb      	ldr	r3, [r7, #12]
   159a6:	2230      	movs	r2, #48	; 0x30
   159a8:	5c9b      	ldrb	r3, [r3, r2]
   159aa:	b25a      	sxtb	r2, r3
   159ac:	1dfb      	adds	r3, r7, #7
   159ae:	781b      	ldrb	r3, [r3, #0]
   159b0:	2101      	movs	r1, #1
   159b2:	4099      	lsls	r1, r3
   159b4:	000b      	movs	r3, r1
   159b6:	b25b      	sxtb	r3, r3
   159b8:	4313      	orrs	r3, r2
   159ba:	b25b      	sxtb	r3, r3
   159bc:	b2d9      	uxtb	r1, r3
   159be:	68fb      	ldr	r3, [r7, #12]
   159c0:	2230      	movs	r2, #48	; 0x30
   159c2:	5499      	strb	r1, [r3, r2]
}
   159c4:	46c0      	nop			; (mov r8, r8)
   159c6:	46bd      	mov	sp, r7
   159c8:	b004      	add	sp, #16
   159ca:	bd80      	pop	{r7, pc}

000159cc <usart_read_job>:
 * \retval  STATUS_BUSY  If operation was not completed
 */
enum status_code usart_read_job(
		struct usart_module *const module,
		uint16_t *const rx_data)
{
   159cc:	b580      	push	{r7, lr}
   159ce:	b082      	sub	sp, #8
   159d0:	af00      	add	r7, sp, #0
   159d2:	6078      	str	r0, [r7, #4]
   159d4:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(rx_data);

	/* Call internal read buffer function with length 1 */
	return _usart_read_buffer(module, (uint8_t *)rx_data, 1);
   159d6:	6839      	ldr	r1, [r7, #0]
   159d8:	687b      	ldr	r3, [r7, #4]
   159da:	2201      	movs	r2, #1
   159dc:	0018      	movs	r0, r3
   159de:	4b03      	ldr	r3, [pc, #12]	; (159ec <usart_read_job+0x20>)
   159e0:	4798      	blx	r3
   159e2:	0003      	movs	r3, r0
}
   159e4:	0018      	movs	r0, r3
   159e6:	46bd      	mov	sp, r7
   159e8:	b002      	add	sp, #8
   159ea:	bd80      	pop	{r7, pc}
   159ec:	0001590d 	.word	0x0001590d

000159f0 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
   159f0:	b580      	push	{r7, lr}
   159f2:	b088      	sub	sp, #32
   159f4:	af00      	add	r7, sp, #0
   159f6:	0002      	movs	r2, r0
   159f8:	1dfb      	adds	r3, r7, #7
   159fa:	701a      	strb	r2, [r3, #0]
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
		= (struct usart_module *)_sercom_instances[instance];
   159fc:	1dfb      	adds	r3, r7, #7
   159fe:	781a      	ldrb	r2, [r3, #0]
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
   15a00:	4bb0      	ldr	r3, [pc, #704]	; (15cc4 <_usart_interrupt_handler+0x2d4>)
   15a02:	0092      	lsls	r2, r2, #2
   15a04:	58d3      	ldr	r3, [r2, r3]
   15a06:	61bb      	str	r3, [r7, #24]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
   15a08:	69bb      	ldr	r3, [r7, #24]
   15a0a:	681b      	ldr	r3, [r3, #0]
	/* Get device instance from the look-up table */
	struct usart_module *module
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
   15a0c:	617b      	str	r3, [r7, #20]
		= &(module->hw->USART);

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);
   15a0e:	69bb      	ldr	r3, [r7, #24]
   15a10:	0018      	movs	r0, r3
   15a12:	4bad      	ldr	r3, [pc, #692]	; (15cc8 <_usart_interrupt_handler+0x2d8>)
   15a14:	4798      	blx	r3

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
   15a16:	697b      	ldr	r3, [r7, #20]
   15a18:	7e1b      	ldrb	r3, [r3, #24]
   15a1a:	b2da      	uxtb	r2, r3
   15a1c:	2312      	movs	r3, #18
   15a1e:	18fb      	adds	r3, r7, r3
   15a20:	801a      	strh	r2, [r3, #0]
	interrupt_status &= usart_hw->INTENSET.reg;
   15a22:	697b      	ldr	r3, [r7, #20]
   15a24:	7d9b      	ldrb	r3, [r3, #22]
   15a26:	b2db      	uxtb	r3, r3
   15a28:	b29a      	uxth	r2, r3
   15a2a:	2312      	movs	r3, #18
   15a2c:	18fb      	adds	r3, r7, r3
   15a2e:	2112      	movs	r1, #18
   15a30:	1879      	adds	r1, r7, r1
   15a32:	8809      	ldrh	r1, [r1, #0]
   15a34:	400a      	ands	r2, r1
   15a36:	801a      	strh	r2, [r3, #0]
	callback_status = module->callback_reg_mask &
   15a38:	69bb      	ldr	r3, [r7, #24]
   15a3a:	2230      	movs	r2, #48	; 0x30
   15a3c:	5c9b      	ldrb	r3, [r3, r2]
			module->callback_enable_mask;
   15a3e:	69ba      	ldr	r2, [r7, #24]
   15a40:	2131      	movs	r1, #49	; 0x31
   15a42:	5c52      	ldrb	r2, [r2, r1]
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
	interrupt_status &= usart_hw->INTENSET.reg;
	callback_status = module->callback_reg_mask &
   15a44:	4013      	ands	r3, r2
   15a46:	b2da      	uxtb	r2, r3
   15a48:	2310      	movs	r3, #16
   15a4a:	18fb      	adds	r3, r7, r3
   15a4c:	801a      	strh	r2, [r3, #0]
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
   15a4e:	2312      	movs	r3, #18
   15a50:	18fb      	adds	r3, r7, r3
   15a52:	881b      	ldrh	r3, [r3, #0]
   15a54:	2201      	movs	r2, #1
   15a56:	4013      	ands	r3, r2
   15a58:	d044      	beq.n	15ae4 <_usart_interrupt_handler+0xf4>
		if (module->remaining_tx_buffer_length) {
   15a5a:	69bb      	ldr	r3, [r7, #24]
   15a5c:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
   15a5e:	b29b      	uxth	r3, r3
   15a60:	2b00      	cmp	r3, #0
   15a62:	d03c      	beq.n	15ade <_usart_interrupt_handler+0xee>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
   15a64:	69bb      	ldr	r3, [r7, #24]
   15a66:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   15a68:	781b      	ldrb	r3, [r3, #0]
   15a6a:	b2da      	uxtb	r2, r3
   15a6c:	231c      	movs	r3, #28
   15a6e:	18fb      	adds	r3, r7, r3
   15a70:	801a      	strh	r2, [r3, #0]
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
   15a72:	69bb      	ldr	r3, [r7, #24]
   15a74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   15a76:	1c5a      	adds	r2, r3, #1
   15a78:	69bb      	ldr	r3, [r7, #24]
   15a7a:	629a      	str	r2, [r3, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
   15a7c:	69bb      	ldr	r3, [r7, #24]
   15a7e:	795b      	ldrb	r3, [r3, #5]
   15a80:	2b01      	cmp	r3, #1
   15a82:	d113      	bne.n	15aac <_usart_interrupt_handler+0xbc>
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
   15a84:	69bb      	ldr	r3, [r7, #24]
   15a86:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   15a88:	781b      	ldrb	r3, [r3, #0]
   15a8a:	b2db      	uxtb	r3, r3
   15a8c:	021b      	lsls	r3, r3, #8
   15a8e:	b21a      	sxth	r2, r3
   15a90:	231c      	movs	r3, #28
   15a92:	18fb      	adds	r3, r7, r3
   15a94:	2100      	movs	r1, #0
   15a96:	5e5b      	ldrsh	r3, [r3, r1]
   15a98:	4313      	orrs	r3, r2
   15a9a:	b21a      	sxth	r2, r3
   15a9c:	231c      	movs	r3, #28
   15a9e:	18fb      	adds	r3, r7, r3
   15aa0:	801a      	strh	r2, [r3, #0]
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
   15aa2:	69bb      	ldr	r3, [r7, #24]
   15aa4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   15aa6:	1c5a      	adds	r2, r3, #1
   15aa8:	69bb      	ldr	r3, [r7, #24]
   15aaa:	629a      	str	r2, [r3, #40]	; 0x28
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
   15aac:	231c      	movs	r3, #28
   15aae:	18fb      	adds	r3, r7, r3
   15ab0:	881b      	ldrh	r3, [r3, #0]
   15ab2:	05db      	lsls	r3, r3, #23
   15ab4:	0ddb      	lsrs	r3, r3, #23
   15ab6:	b29a      	uxth	r2, r3
   15ab8:	697b      	ldr	r3, [r7, #20]
   15aba:	851a      	strh	r2, [r3, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
   15abc:	69bb      	ldr	r3, [r7, #24]
   15abe:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
   15ac0:	b29b      	uxth	r3, r3
   15ac2:	3b01      	subs	r3, #1
   15ac4:	b29b      	uxth	r3, r3
   15ac6:	69ba      	ldr	r2, [r7, #24]
   15ac8:	1c19      	adds	r1, r3, #0
   15aca:	85d1      	strh	r1, [r2, #46]	; 0x2e
   15acc:	2b00      	cmp	r3, #0
   15ace:	d109      	bne.n	15ae4 <_usart_interrupt_handler+0xf4>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
   15ad0:	697b      	ldr	r3, [r7, #20]
   15ad2:	2201      	movs	r2, #1
   15ad4:	751a      	strb	r2, [r3, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
   15ad6:	697b      	ldr	r3, [r7, #20]
   15ad8:	2202      	movs	r2, #2
   15ada:	759a      	strb	r2, [r3, #22]
   15adc:	e002      	b.n	15ae4 <_usart_interrupt_handler+0xf4>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
   15ade:	697b      	ldr	r3, [r7, #20]
   15ae0:	2201      	movs	r2, #1
   15ae2:	751a      	strb	r2, [r3, #20]

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
   15ae4:	2312      	movs	r3, #18
   15ae6:	18fb      	adds	r3, r7, r3
   15ae8:	881b      	ldrh	r3, [r3, #0]
   15aea:	2202      	movs	r2, #2
   15aec:	4013      	ands	r3, r2
   15aee:	d011      	beq.n	15b14 <_usart_interrupt_handler+0x124>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
   15af0:	697b      	ldr	r3, [r7, #20]
   15af2:	2202      	movs	r2, #2
   15af4:	751a      	strb	r2, [r3, #20]
		module->tx_status = STATUS_OK;
   15af6:	69bb      	ldr	r3, [r7, #24]
   15af8:	2233      	movs	r2, #51	; 0x33
   15afa:	2100      	movs	r1, #0
   15afc:	5499      	strb	r1, [r3, r2]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
   15afe:	2310      	movs	r3, #16
   15b00:	18fb      	adds	r3, r7, r3
   15b02:	881b      	ldrh	r3, [r3, #0]
   15b04:	2201      	movs	r2, #1
   15b06:	4013      	ands	r3, r2
   15b08:	d004      	beq.n	15b14 <_usart_interrupt_handler+0x124>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
   15b0a:	69bb      	ldr	r3, [r7, #24]
   15b0c:	68db      	ldr	r3, [r3, #12]
   15b0e:	69ba      	ldr	r2, [r7, #24]
   15b10:	0010      	movs	r0, r2
   15b12:	4798      	blx	r3

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
   15b14:	2312      	movs	r3, #18
   15b16:	18fb      	adds	r3, r7, r3
   15b18:	881b      	ldrh	r3, [r3, #0]
   15b1a:	2204      	movs	r2, #4
   15b1c:	4013      	ands	r3, r2
   15b1e:	d100      	bne.n	15b22 <_usart_interrupt_handler+0x132>
   15b20:	e0d7      	b.n	15cd2 <_usart_interrupt_handler+0x2e2>

		if (module->remaining_rx_buffer_length) {
   15b22:	69bb      	ldr	r3, [r7, #24]
   15b24:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
   15b26:	b29b      	uxth	r3, r3
   15b28:	2b00      	cmp	r3, #0
   15b2a:	d100      	bne.n	15b2e <_usart_interrupt_handler+0x13e>
   15b2c:	e0ce      	b.n	15ccc <_usart_interrupt_handler+0x2dc>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
   15b2e:	697b      	ldr	r3, [r7, #20]
   15b30:	8b5b      	ldrh	r3, [r3, #26]
   15b32:	b29b      	uxth	r3, r3
   15b34:	b2da      	uxtb	r2, r3
   15b36:	231f      	movs	r3, #31
   15b38:	18fb      	adds	r3, r7, r3
   15b3a:	213f      	movs	r1, #63	; 0x3f
   15b3c:	400a      	ands	r2, r1
   15b3e:	701a      	strb	r2, [r3, #0]
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
   15b40:	231f      	movs	r3, #31
   15b42:	18fb      	adds	r3, r7, r3
   15b44:	781b      	ldrb	r3, [r3, #0]
   15b46:	2208      	movs	r2, #8
   15b48:	4013      	ands	r3, r2
   15b4a:	d007      	beq.n	15b5c <_usart_interrupt_handler+0x16c>
				error_code &= ~SERCOM_USART_STATUS_CTS;
   15b4c:	231f      	movs	r3, #31
   15b4e:	18fb      	adds	r3, r7, r3
   15b50:	221f      	movs	r2, #31
   15b52:	18ba      	adds	r2, r7, r2
   15b54:	7812      	ldrb	r2, [r2, #0]
   15b56:	2108      	movs	r1, #8
   15b58:	438a      	bics	r2, r1
   15b5a:	701a      	strb	r2, [r3, #0]
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
   15b5c:	231f      	movs	r3, #31
   15b5e:	18fb      	adds	r3, r7, r3
   15b60:	781b      	ldrb	r3, [r3, #0]
   15b62:	2b00      	cmp	r3, #0
   15b64:	d100      	bne.n	15b68 <_usart_interrupt_handler+0x178>
   15b66:	e069      	b.n	15c3c <_usart_interrupt_handler+0x24c>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
   15b68:	231f      	movs	r3, #31
   15b6a:	18fb      	adds	r3, r7, r3
   15b6c:	781b      	ldrb	r3, [r3, #0]
   15b6e:	2202      	movs	r2, #2
   15b70:	4013      	ands	r3, r2
   15b72:	d00c      	beq.n	15b8e <_usart_interrupt_handler+0x19e>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
   15b74:	69bb      	ldr	r3, [r7, #24]
   15b76:	2232      	movs	r2, #50	; 0x32
   15b78:	211a      	movs	r1, #26
   15b7a:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_FERR;
   15b7c:	697b      	ldr	r3, [r7, #20]
   15b7e:	8b5b      	ldrh	r3, [r3, #26]
   15b80:	b29b      	uxth	r3, r3
   15b82:	2202      	movs	r2, #2
   15b84:	4313      	orrs	r3, r2
   15b86:	b29a      	uxth	r2, r3
   15b88:	697b      	ldr	r3, [r7, #20]
   15b8a:	835a      	strh	r2, [r3, #26]
   15b8c:	e04a      	b.n	15c24 <_usart_interrupt_handler+0x234>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
   15b8e:	231f      	movs	r3, #31
   15b90:	18fb      	adds	r3, r7, r3
   15b92:	781b      	ldrb	r3, [r3, #0]
   15b94:	2204      	movs	r2, #4
   15b96:	4013      	ands	r3, r2
   15b98:	d00c      	beq.n	15bb4 <_usart_interrupt_handler+0x1c4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
   15b9a:	69bb      	ldr	r3, [r7, #24]
   15b9c:	2232      	movs	r2, #50	; 0x32
   15b9e:	211e      	movs	r1, #30
   15ba0:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_BUFOVF;
   15ba2:	697b      	ldr	r3, [r7, #20]
   15ba4:	8b5b      	ldrh	r3, [r3, #26]
   15ba6:	b29b      	uxth	r3, r3
   15ba8:	2204      	movs	r2, #4
   15baa:	4313      	orrs	r3, r2
   15bac:	b29a      	uxth	r2, r3
   15bae:	697b      	ldr	r3, [r7, #20]
   15bb0:	835a      	strh	r2, [r3, #26]
   15bb2:	e037      	b.n	15c24 <_usart_interrupt_handler+0x234>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
   15bb4:	231f      	movs	r3, #31
   15bb6:	18fb      	adds	r3, r7, r3
   15bb8:	781b      	ldrb	r3, [r3, #0]
   15bba:	2201      	movs	r2, #1
   15bbc:	4013      	ands	r3, r2
   15bbe:	d00c      	beq.n	15bda <_usart_interrupt_handler+0x1ea>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
   15bc0:	69bb      	ldr	r3, [r7, #24]
   15bc2:	2232      	movs	r2, #50	; 0x32
   15bc4:	2113      	movs	r1, #19
   15bc6:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_PERR;
   15bc8:	697b      	ldr	r3, [r7, #20]
   15bca:	8b5b      	ldrh	r3, [r3, #26]
   15bcc:	b29b      	uxth	r3, r3
   15bce:	2201      	movs	r2, #1
   15bd0:	4313      	orrs	r3, r2
   15bd2:	b29a      	uxth	r2, r3
   15bd4:	697b      	ldr	r3, [r7, #20]
   15bd6:	835a      	strh	r2, [r3, #26]
   15bd8:	e024      	b.n	15c24 <_usart_interrupt_handler+0x234>
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
   15bda:	231f      	movs	r3, #31
   15bdc:	18fb      	adds	r3, r7, r3
   15bde:	781b      	ldrb	r3, [r3, #0]
   15be0:	2210      	movs	r2, #16
   15be2:	4013      	ands	r3, r2
   15be4:	d00c      	beq.n	15c00 <_usart_interrupt_handler+0x210>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
   15be6:	69bb      	ldr	r3, [r7, #24]
   15be8:	2232      	movs	r2, #50	; 0x32
   15bea:	2142      	movs	r1, #66	; 0x42
   15bec:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
   15bee:	697b      	ldr	r3, [r7, #20]
   15bf0:	8b5b      	ldrh	r3, [r3, #26]
   15bf2:	b29b      	uxth	r3, r3
   15bf4:	2210      	movs	r2, #16
   15bf6:	4313      	orrs	r3, r2
   15bf8:	b29a      	uxth	r2, r3
   15bfa:	697b      	ldr	r3, [r7, #20]
   15bfc:	835a      	strh	r2, [r3, #26]
   15bfe:	e011      	b.n	15c24 <_usart_interrupt_handler+0x234>
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
   15c00:	231f      	movs	r3, #31
   15c02:	18fb      	adds	r3, r7, r3
   15c04:	781b      	ldrb	r3, [r3, #0]
   15c06:	2220      	movs	r2, #32
   15c08:	4013      	ands	r3, r2
   15c0a:	d00b      	beq.n	15c24 <_usart_interrupt_handler+0x234>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
   15c0c:	69bb      	ldr	r3, [r7, #24]
   15c0e:	2232      	movs	r2, #50	; 0x32
   15c10:	2141      	movs	r1, #65	; 0x41
   15c12:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
   15c14:	697b      	ldr	r3, [r7, #20]
   15c16:	8b5b      	ldrh	r3, [r3, #26]
   15c18:	b29b      	uxth	r3, r3
   15c1a:	2220      	movs	r2, #32
   15c1c:	4313      	orrs	r3, r2
   15c1e:	b29a      	uxth	r2, r3
   15c20:	697b      	ldr	r3, [r7, #20]
   15c22:	835a      	strh	r2, [r3, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
						& (1 << USART_CALLBACK_ERROR)) {
   15c24:	2310      	movs	r3, #16
   15c26:	18fb      	adds	r3, r7, r3
   15c28:	881b      	ldrh	r3, [r3, #0]
   15c2a:	2204      	movs	r2, #4
   15c2c:	4013      	ands	r3, r2
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
   15c2e:	d050      	beq.n	15cd2 <_usart_interrupt_handler+0x2e2>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
   15c30:	69bb      	ldr	r3, [r7, #24]
   15c32:	695b      	ldr	r3, [r3, #20]
   15c34:	69ba      	ldr	r2, [r7, #24]
   15c36:	0010      	movs	r0, r2
   15c38:	4798      	blx	r3
   15c3a:	e04a      	b.n	15cd2 <_usart_interrupt_handler+0x2e2>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
   15c3c:	697b      	ldr	r3, [r7, #20]
   15c3e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
   15c40:	b29a      	uxth	r2, r3
   15c42:	230e      	movs	r3, #14
   15c44:	18fb      	adds	r3, r7, r3
   15c46:	05d2      	lsls	r2, r2, #23
   15c48:	0dd2      	lsrs	r2, r2, #23
   15c4a:	801a      	strh	r2, [r3, #0]

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
   15c4c:	69bb      	ldr	r3, [r7, #24]
   15c4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   15c50:	220e      	movs	r2, #14
   15c52:	18ba      	adds	r2, r7, r2
   15c54:	8812      	ldrh	r2, [r2, #0]
   15c56:	b2d2      	uxtb	r2, r2
   15c58:	701a      	strb	r2, [r3, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
   15c5a:	69bb      	ldr	r3, [r7, #24]
   15c5c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   15c5e:	1c5a      	adds	r2, r3, #1
   15c60:	69bb      	ldr	r3, [r7, #24]
   15c62:	625a      	str	r2, [r3, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
   15c64:	69bb      	ldr	r3, [r7, #24]
   15c66:	795b      	ldrb	r3, [r3, #5]
   15c68:	2b01      	cmp	r3, #1
   15c6a:	d10d      	bne.n	15c88 <_usart_interrupt_handler+0x298>
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
   15c6c:	69bb      	ldr	r3, [r7, #24]
   15c6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   15c70:	220e      	movs	r2, #14
   15c72:	18ba      	adds	r2, r7, r2
   15c74:	8812      	ldrh	r2, [r2, #0]
   15c76:	0a12      	lsrs	r2, r2, #8
   15c78:	b292      	uxth	r2, r2
   15c7a:	b2d2      	uxtb	r2, r2
   15c7c:	701a      	strb	r2, [r3, #0]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
   15c7e:	69bb      	ldr	r3, [r7, #24]
   15c80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   15c82:	1c5a      	adds	r2, r3, #1
   15c84:	69bb      	ldr	r3, [r7, #24]
   15c86:	625a      	str	r2, [r3, #36]	; 0x24
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
   15c88:	69bb      	ldr	r3, [r7, #24]
   15c8a:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
   15c8c:	b29b      	uxth	r3, r3
   15c8e:	3b01      	subs	r3, #1
   15c90:	b29b      	uxth	r3, r3
   15c92:	69ba      	ldr	r2, [r7, #24]
   15c94:	1c19      	adds	r1, r3, #0
   15c96:	8591      	strh	r1, [r2, #44]	; 0x2c
   15c98:	2b00      	cmp	r3, #0
   15c9a:	d11a      	bne.n	15cd2 <_usart_interrupt_handler+0x2e2>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
   15c9c:	697b      	ldr	r3, [r7, #20]
   15c9e:	2204      	movs	r2, #4
   15ca0:	751a      	strb	r2, [r3, #20]
					module->rx_status = STATUS_OK;
   15ca2:	69bb      	ldr	r3, [r7, #24]
   15ca4:	2232      	movs	r2, #50	; 0x32
   15ca6:	2100      	movs	r1, #0
   15ca8:	5499      	strb	r1, [r3, r2]

					/* Run callback if registered and enabled */
					if (callback_status
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
   15caa:	2310      	movs	r3, #16
   15cac:	18fb      	adds	r3, r7, r3
   15cae:	881b      	ldrh	r3, [r3, #0]
   15cb0:	2202      	movs	r2, #2
   15cb2:	4013      	ands	r3, r2
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
					module->rx_status = STATUS_OK;

					/* Run callback if registered and enabled */
					if (callback_status
   15cb4:	d00d      	beq.n	15cd2 <_usart_interrupt_handler+0x2e2>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
   15cb6:	69bb      	ldr	r3, [r7, #24]
   15cb8:	691b      	ldr	r3, [r3, #16]
   15cba:	69ba      	ldr	r2, [r7, #24]
   15cbc:	0010      	movs	r0, r2
   15cbe:	4798      	blx	r3
   15cc0:	e007      	b.n	15cd2 <_usart_interrupt_handler+0x2e2>
   15cc2:	46c0      	nop			; (mov r8, r8)
   15cc4:	20004bac 	.word	0x20004bac
   15cc8:	000158e9 	.word	0x000158e9
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
   15ccc:	697b      	ldr	r3, [r7, #20]
   15cce:	2204      	movs	r2, #4
   15cd0:	751a      	strb	r2, [r3, #20]
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
   15cd2:	2312      	movs	r3, #18
   15cd4:	18fb      	adds	r3, r7, r3
   15cd6:	881b      	ldrh	r3, [r3, #0]
   15cd8:	2210      	movs	r2, #16
   15cda:	4013      	ands	r3, r2
   15cdc:	d010      	beq.n	15d00 <_usart_interrupt_handler+0x310>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
   15cde:	697b      	ldr	r3, [r7, #20]
   15ce0:	2210      	movs	r2, #16
   15ce2:	751a      	strb	r2, [r3, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
   15ce4:	697b      	ldr	r3, [r7, #20]
   15ce6:	2210      	movs	r2, #16
   15ce8:	761a      	strb	r2, [r3, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
   15cea:	2310      	movs	r3, #16
   15cec:	18fb      	adds	r3, r7, r3
   15cee:	881b      	ldrh	r3, [r3, #0]
   15cf0:	2210      	movs	r2, #16
   15cf2:	4013      	ands	r3, r2
   15cf4:	d004      	beq.n	15d00 <_usart_interrupt_handler+0x310>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
   15cf6:	69bb      	ldr	r3, [r7, #24]
   15cf8:	69db      	ldr	r3, [r3, #28]
   15cfa:	69ba      	ldr	r2, [r7, #24]
   15cfc:	0010      	movs	r0, r2
   15cfe:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
   15d00:	2312      	movs	r3, #18
   15d02:	18fb      	adds	r3, r7, r3
   15d04:	881b      	ldrh	r3, [r3, #0]
   15d06:	2220      	movs	r2, #32
   15d08:	4013      	ands	r3, r2
   15d0a:	d010      	beq.n	15d2e <_usart_interrupt_handler+0x33e>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
   15d0c:	697b      	ldr	r3, [r7, #20]
   15d0e:	2220      	movs	r2, #32
   15d10:	751a      	strb	r2, [r3, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
   15d12:	697b      	ldr	r3, [r7, #20]
   15d14:	2220      	movs	r2, #32
   15d16:	761a      	strb	r2, [r3, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
   15d18:	2310      	movs	r3, #16
   15d1a:	18fb      	adds	r3, r7, r3
   15d1c:	881b      	ldrh	r3, [r3, #0]
   15d1e:	2208      	movs	r2, #8
   15d20:	4013      	ands	r3, r2
   15d22:	d004      	beq.n	15d2e <_usart_interrupt_handler+0x33e>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
   15d24:	69bb      	ldr	r3, [r7, #24]
   15d26:	699b      	ldr	r3, [r3, #24]
   15d28:	69ba      	ldr	r2, [r7, #24]
   15d2a:	0010      	movs	r0, r2
   15d2c:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
   15d2e:	2312      	movs	r3, #18
   15d30:	18fb      	adds	r3, r7, r3
   15d32:	881b      	ldrh	r3, [r3, #0]
   15d34:	2208      	movs	r2, #8
   15d36:	4013      	ands	r3, r2
   15d38:	d00d      	beq.n	15d56 <_usart_interrupt_handler+0x366>
		/* Disable interrupts */
		//usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
   15d3a:	697b      	ldr	r3, [r7, #20]
   15d3c:	2208      	movs	r2, #8
   15d3e:	761a      	strb	r2, [r3, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
   15d40:	2310      	movs	r3, #16
   15d42:	18fb      	adds	r3, r7, r3
   15d44:	881b      	ldrh	r3, [r3, #0]
   15d46:	2220      	movs	r2, #32
   15d48:	4013      	ands	r3, r2
   15d4a:	d004      	beq.n	15d56 <_usart_interrupt_handler+0x366>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
   15d4c:	69bb      	ldr	r3, [r7, #24]
   15d4e:	6a1b      	ldr	r3, [r3, #32]
   15d50:	69ba      	ldr	r2, [r7, #24]
   15d52:	0010      	movs	r0, r2
   15d54:	4798      	blx	r3
		}
	}
#endif
}
   15d56:	46c0      	nop			; (mov r8, r8)
   15d58:	46bd      	mov	sp, r7
   15d5a:	b008      	add	sp, #32
   15d5c:	bd80      	pop	{r7, pc}
   15d5e:	46c0      	nop			; (mov r8, r8)

00015d60 <system_gclk_gen_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_gen_get_config_defaults(
		struct system_gclk_gen_config *const config)
{
   15d60:	b580      	push	{r7, lr}
   15d62:	b082      	sub	sp, #8
   15d64:	af00      	add	r7, sp, #0
   15d66:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
   15d68:	687b      	ldr	r3, [r7, #4]
   15d6a:	2201      	movs	r2, #1
   15d6c:	605a      	str	r2, [r3, #4]
	config->high_when_disabled = false;
   15d6e:	687b      	ldr	r3, [r7, #4]
   15d70:	2200      	movs	r2, #0
   15d72:	705a      	strb	r2, [r3, #1]
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
   15d74:	687b      	ldr	r3, [r7, #4]
   15d76:	2206      	movs	r2, #6
   15d78:	701a      	strb	r2, [r3, #0]
#endif
	config->run_in_standby     = false;
   15d7a:	687b      	ldr	r3, [r7, #4]
   15d7c:	2200      	movs	r2, #0
   15d7e:	721a      	strb	r2, [r3, #8]
	config->output_enable      = false;
   15d80:	687b      	ldr	r3, [r7, #4]
   15d82:	2200      	movs	r2, #0
   15d84:	725a      	strb	r2, [r3, #9]
}
   15d86:	46c0      	nop			; (mov r8, r8)
   15d88:	46bd      	mov	sp, r7
   15d8a:	b002      	add	sp, #8
   15d8c:	bd80      	pop	{r7, pc}
   15d8e:	46c0      	nop			; (mov r8, r8)

00015d90 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
   15d90:	b580      	push	{r7, lr}
   15d92:	b082      	sub	sp, #8
   15d94:	af00      	add	r7, sp, #0
   15d96:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
   15d98:	687b      	ldr	r3, [r7, #4]
   15d9a:	2200      	movs	r2, #0
   15d9c:	701a      	strb	r2, [r3, #0]
}
   15d9e:	46c0      	nop			; (mov r8, r8)
   15da0:	46bd      	mov	sp, r7
   15da2:	b002      	add	sp, #8
   15da4:	bd80      	pop	{r7, pc}
   15da6:	46c0      	nop			; (mov r8, r8)

00015da8 <system_clock_source_xosc32k_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to fill with default values
 */
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
   15da8:	b580      	push	{r7, lr}
   15daa:	b082      	sub	sp, #8
   15dac:	af00      	add	r7, sp, #0
   15dae:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
   15db0:	687b      	ldr	r3, [r7, #4]
   15db2:	2200      	movs	r2, #0
   15db4:	701a      	strb	r2, [r3, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
   15db6:	687b      	ldr	r3, [r7, #4]
   15db8:	2204      	movs	r2, #4
   15dba:	705a      	strb	r2, [r3, #1]
	config->auto_gain_control   = false;
   15dbc:	687b      	ldr	r3, [r7, #4]
   15dbe:	2200      	movs	r2, #0
   15dc0:	709a      	strb	r2, [r3, #2]
	config->frequency           = 32768UL;
   15dc2:	687b      	ldr	r3, [r7, #4]
   15dc4:	2280      	movs	r2, #128	; 0x80
   15dc6:	0212      	lsls	r2, r2, #8
   15dc8:	609a      	str	r2, [r3, #8]
	config->enable_1khz_output  = false;
   15dca:	687b      	ldr	r3, [r7, #4]
   15dcc:	2200      	movs	r2, #0
   15dce:	70da      	strb	r2, [r3, #3]
	config->enable_32khz_output = true;
   15dd0:	687b      	ldr	r3, [r7, #4]
   15dd2:	2201      	movs	r2, #1
   15dd4:	711a      	strb	r2, [r3, #4]
	config->run_in_standby      = false;
   15dd6:	687b      	ldr	r3, [r7, #4]
   15dd8:	2200      	movs	r2, #0
   15dda:	731a      	strb	r2, [r3, #12]
	config->on_demand           = true;
   15ddc:	687b      	ldr	r3, [r7, #4]
   15dde:	2201      	movs	r2, #1
   15de0:	735a      	strb	r2, [r3, #13]
	config->write_once          = false;
   15de2:	687b      	ldr	r3, [r7, #4]
   15de4:	2200      	movs	r2, #0
   15de6:	739a      	strb	r2, [r3, #14]
}
   15de8:	46c0      	nop			; (mov r8, r8)
   15dea:	46bd      	mov	sp, r7
   15dec:	b002      	add	sp, #8
   15dee:	bd80      	pop	{r7, pc}

00015df0 <system_clock_source_osc8m_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to fill with default values
 */
static inline void system_clock_source_osc8m_get_config_defaults(
		struct system_clock_source_osc8m_config *const config)
{
   15df0:	b580      	push	{r7, lr}
   15df2:	b082      	sub	sp, #8
   15df4:	af00      	add	r7, sp, #0
   15df6:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
   15df8:	687b      	ldr	r3, [r7, #4]
   15dfa:	2203      	movs	r2, #3
   15dfc:	701a      	strb	r2, [r3, #0]
	config->run_in_standby  = false;
   15dfe:	687b      	ldr	r3, [r7, #4]
   15e00:	2200      	movs	r2, #0
   15e02:	705a      	strb	r2, [r3, #1]
	config->on_demand       = true;
   15e04:	687b      	ldr	r3, [r7, #4]
   15e06:	2201      	movs	r2, #1
   15e08:	709a      	strb	r2, [r3, #2]
}
   15e0a:	46c0      	nop			; (mov r8, r8)
   15e0c:	46bd      	mov	sp, r7
   15e0e:	b002      	add	sp, #8
   15e10:	bd80      	pop	{r7, pc}
   15e12:	46c0      	nop			; (mov r8, r8)

00015e14 <system_clock_source_dfll_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to fill with default values
 */
static inline void system_clock_source_dfll_get_config_defaults(
		struct system_clock_source_dfll_config *const config)
{
   15e14:	b580      	push	{r7, lr}
   15e16:	b082      	sub	sp, #8
   15e18:	af00      	add	r7, sp, #0
   15e1a:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
   15e1c:	687b      	ldr	r3, [r7, #4]
   15e1e:	2200      	movs	r2, #0
   15e20:	701a      	strb	r2, [r3, #0]
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
   15e22:	687b      	ldr	r3, [r7, #4]
   15e24:	2200      	movs	r2, #0
   15e26:	805a      	strh	r2, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
   15e28:	687b      	ldr	r3, [r7, #4]
   15e2a:	2200      	movs	r2, #0
   15e2c:	809a      	strh	r2, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
   15e2e:	687b      	ldr	r3, [r7, #4]
   15e30:	2200      	movs	r2, #0
   15e32:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
   15e34:	687b      	ldr	r3, [r7, #4]
   15e36:	2200      	movs	r2, #0
   15e38:	71da      	strb	r2, [r3, #7]
	config->on_demand       = true;
   15e3a:	687b      	ldr	r3, [r7, #4]
   15e3c:	2201      	movs	r2, #1
   15e3e:	705a      	strb	r2, [r3, #1]

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
   15e40:	687b      	ldr	r3, [r7, #4]
   15e42:	2207      	movs	r2, #7
   15e44:	721a      	strb	r2, [r3, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */
   15e46:	687b      	ldr	r3, [r7, #4]
   15e48:	223f      	movs	r2, #63	; 0x3f
   15e4a:	815a      	strh	r2, [r3, #10]

	/* Closed loop mode */
	config->coarse_max_step = 1;
   15e4c:	687b      	ldr	r3, [r7, #4]
   15e4e:	2201      	movs	r2, #1
   15e50:	731a      	strb	r2, [r3, #12]
	config->fine_max_step   = 1;
   15e52:	687b      	ldr	r3, [r7, #4]
   15e54:	2201      	movs	r2, #1
   15e56:	81da      	strh	r2, [r3, #14]
	config->multiply_factor = 6; /* Multiply 8MHz by 6 to get 48MHz */
   15e58:	687b      	ldr	r3, [r7, #4]
   15e5a:	2206      	movs	r2, #6
   15e5c:	821a      	strh	r2, [r3, #16]
}
   15e5e:	46c0      	nop			; (mov r8, r8)
   15e60:	46bd      	mov	sp, r7
   15e62:	b002      	add	sp, #8
   15e64:	bd80      	pop	{r7, pc}
   15e66:	46c0      	nop			; (mov r8, r8)

00015e68 <system_cpu_clock_set_divider>:
 *
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
   15e68:	b580      	push	{r7, lr}
   15e6a:	b082      	sub	sp, #8
   15e6c:	af00      	add	r7, sp, #0
   15e6e:	0002      	movs	r2, r0
   15e70:	1dfb      	adds	r3, r7, #7
   15e72:	701a      	strb	r2, [r3, #0]
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
   15e74:	4a03      	ldr	r2, [pc, #12]	; (15e84 <system_cpu_clock_set_divider+0x1c>)
   15e76:	1dfb      	adds	r3, r7, #7
   15e78:	781b      	ldrb	r3, [r3, #0]
   15e7a:	7213      	strb	r3, [r2, #8]
}
   15e7c:	46c0      	nop			; (mov r8, r8)
   15e7e:	46bd      	mov	sp, r7
   15e80:	b002      	add	sp, #8
   15e82:	bd80      	pop	{r7, pc}
   15e84:	40000400 	.word	0x40000400

00015e88 <system_apb_clock_set_divider>:
 * \retval STATUS_OK               The APBx clock was set successfully
 */
static inline enum status_code system_apb_clock_set_divider(
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
   15e88:	b580      	push	{r7, lr}
   15e8a:	b082      	sub	sp, #8
   15e8c:	af00      	add	r7, sp, #0
   15e8e:	0002      	movs	r2, r0
   15e90:	1dfb      	adds	r3, r7, #7
   15e92:	701a      	strb	r2, [r3, #0]
   15e94:	1dbb      	adds	r3, r7, #6
   15e96:	1c0a      	adds	r2, r1, #0
   15e98:	701a      	strb	r2, [r3, #0]
	switch (bus) {
   15e9a:	1dfb      	adds	r3, r7, #7
   15e9c:	781b      	ldrb	r3, [r3, #0]
   15e9e:	2b01      	cmp	r3, #1
   15ea0:	d008      	beq.n	15eb4 <system_apb_clock_set_divider+0x2c>
   15ea2:	2b02      	cmp	r3, #2
   15ea4:	d00b      	beq.n	15ebe <system_apb_clock_set_divider+0x36>
   15ea6:	2b00      	cmp	r3, #0
   15ea8:	d10e      	bne.n	15ec8 <system_apb_clock_set_divider+0x40>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
   15eaa:	4a0b      	ldr	r2, [pc, #44]	; (15ed8 <system_apb_clock_set_divider+0x50>)
   15eac:	1dbb      	adds	r3, r7, #6
   15eae:	781b      	ldrb	r3, [r3, #0]
   15eb0:	7253      	strb	r3, [r2, #9]
			break;
   15eb2:	e00b      	b.n	15ecc <system_apb_clock_set_divider+0x44>
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
   15eb4:	4a08      	ldr	r2, [pc, #32]	; (15ed8 <system_apb_clock_set_divider+0x50>)
   15eb6:	1dbb      	adds	r3, r7, #6
   15eb8:	781b      	ldrb	r3, [r3, #0]
   15eba:	7293      	strb	r3, [r2, #10]
			break;
   15ebc:	e006      	b.n	15ecc <system_apb_clock_set_divider+0x44>
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
   15ebe:	4a06      	ldr	r2, [pc, #24]	; (15ed8 <system_apb_clock_set_divider+0x50>)
   15ec0:	1dbb      	adds	r3, r7, #6
   15ec2:	781b      	ldrb	r3, [r3, #0]
   15ec4:	72d3      	strb	r3, [r2, #11]
			break;
   15ec6:	e001      	b.n	15ecc <system_apb_clock_set_divider+0x44>
		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
   15ec8:	2317      	movs	r3, #23
   15eca:	e000      	b.n	15ece <system_apb_clock_set_divider+0x46>
	}

	return STATUS_OK;
   15ecc:	2300      	movs	r3, #0
}
   15ece:	0018      	movs	r0, r3
   15ed0:	46bd      	mov	sp, r7
   15ed2:	b002      	add	sp, #8
   15ed4:	bd80      	pop	{r7, pc}
   15ed6:	46c0      	nop			; (mov r8, r8)
   15ed8:	40000400 	.word	0x40000400

00015edc <system_flash_set_waitstates>:
 * can be found in the electrical characteristics of the device.
 *
 * \param[in] wait_states Number of wait states to use for internal flash
 */
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
   15edc:	b580      	push	{r7, lr}
   15ede:	b082      	sub	sp, #8
   15ee0:	af00      	add	r7, sp, #0
   15ee2:	0002      	movs	r2, r0
   15ee4:	1dfb      	adds	r3, r7, #7
   15ee6:	701a      	strb	r2, [r3, #0]
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
   15ee8:	4a08      	ldr	r2, [pc, #32]	; (15f0c <system_flash_set_waitstates+0x30>)
   15eea:	1dfb      	adds	r3, r7, #7
   15eec:	781b      	ldrb	r3, [r3, #0]
   15eee:	210f      	movs	r1, #15
   15ef0:	400b      	ands	r3, r1
   15ef2:	b2d9      	uxtb	r1, r3
   15ef4:	6853      	ldr	r3, [r2, #4]
   15ef6:	200f      	movs	r0, #15
   15ef8:	4001      	ands	r1, r0
   15efa:	0049      	lsls	r1, r1, #1
   15efc:	201e      	movs	r0, #30
   15efe:	4383      	bics	r3, r0
   15f00:	430b      	orrs	r3, r1
   15f02:	6053      	str	r3, [r2, #4]
}
   15f04:	46c0      	nop			; (mov r8, r8)
   15f06:	46bd      	mov	sp, r7
   15f08:	b002      	add	sp, #8
   15f0a:	bd80      	pop	{r7, pc}
   15f0c:	41004000 	.word	0x41004000

00015f10 <_system_dfll_wait_for_sync>:
/**
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
   15f10:	b580      	push	{r7, lr}
   15f12:	af00      	add	r7, sp, #0
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
   15f14:	46c0      	nop			; (mov r8, r8)
   15f16:	4b04      	ldr	r3, [pc, #16]	; (15f28 <_system_dfll_wait_for_sync+0x18>)
   15f18:	68db      	ldr	r3, [r3, #12]
   15f1a:	2210      	movs	r2, #16
   15f1c:	4013      	ands	r3, r2
   15f1e:	d0fa      	beq.n	15f16 <_system_dfll_wait_for_sync+0x6>
		/* Wait for DFLL sync */
	}
}
   15f20:	46c0      	nop			; (mov r8, r8)
   15f22:	46bd      	mov	sp, r7
   15f24:	bd80      	pop	{r7, pc}
   15f26:	46c0      	nop			; (mov r8, r8)
   15f28:	40000800 	.word	0x40000800

00015f2c <_system_clock_source_dfll_set_config_errata_9905>:
		/* Wait for OSC32K sync */
	}
}

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{
   15f2c:	b580      	push	{r7, lr}
   15f2e:	af00      	add	r7, sp, #0

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
   15f30:	4b0c      	ldr	r3, [pc, #48]	; (15f64 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
   15f32:	2202      	movs	r2, #2
   15f34:	849a      	strh	r2, [r3, #36]	; 0x24
	_system_dfll_wait_for_sync();
   15f36:	4b0c      	ldr	r3, [pc, #48]	; (15f68 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
   15f38:	4798      	blx	r3

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
   15f3a:	4a0a      	ldr	r2, [pc, #40]	; (15f64 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
   15f3c:	4b0b      	ldr	r3, [pc, #44]	; (15f6c <_system_clock_source_dfll_set_config_errata_9905+0x40>)
   15f3e:	689b      	ldr	r3, [r3, #8]
   15f40:	62d3      	str	r3, [r2, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
   15f42:	4a08      	ldr	r2, [pc, #32]	; (15f64 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
   15f44:	4b09      	ldr	r3, [pc, #36]	; (15f6c <_system_clock_source_dfll_set_config_errata_9905+0x40>)
   15f46:	685b      	ldr	r3, [r3, #4]
   15f48:	6293      	str	r3, [r2, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
   15f4a:	4b06      	ldr	r3, [pc, #24]	; (15f64 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
   15f4c:	2200      	movs	r2, #0
   15f4e:	849a      	strh	r2, [r3, #36]	; 0x24
	_system_dfll_wait_for_sync();
   15f50:	4b05      	ldr	r3, [pc, #20]	; (15f68 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
   15f52:	4798      	blx	r3
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
   15f54:	4a03      	ldr	r2, [pc, #12]	; (15f64 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
   15f56:	4b05      	ldr	r3, [pc, #20]	; (15f6c <_system_clock_source_dfll_set_config_errata_9905+0x40>)
   15f58:	681b      	ldr	r3, [r3, #0]
   15f5a:	b29b      	uxth	r3, r3
   15f5c:	8493      	strh	r3, [r2, #36]	; 0x24
}
   15f5e:	46c0      	nop			; (mov r8, r8)
   15f60:	46bd      	mov	sp, r7
   15f62:	bd80      	pop	{r7, pc}
   15f64:	40000800 	.word	0x40000800
   15f68:	00015f11 	.word	0x00015f11
   15f6c:	20002e50 	.word	0x20002e50

00015f70 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
   15f70:	b580      	push	{r7, lr}
   15f72:	b082      	sub	sp, #8
   15f74:	af00      	add	r7, sp, #0
   15f76:	0002      	movs	r2, r0
   15f78:	1dfb      	adds	r3, r7, #7
   15f7a:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
   15f7c:	1dfb      	adds	r3, r7, #7
   15f7e:	781b      	ldrb	r3, [r3, #0]
   15f80:	2b08      	cmp	r3, #8
   15f82:	d840      	bhi.n	16006 <system_clock_source_get_hz+0x96>
   15f84:	009a      	lsls	r2, r3, #2
   15f86:	4b22      	ldr	r3, [pc, #136]	; (16010 <system_clock_source_get_hz+0xa0>)
   15f88:	18d3      	adds	r3, r2, r3
   15f8a:	681b      	ldr	r3, [r3, #0]
   15f8c:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
   15f8e:	4b21      	ldr	r3, [pc, #132]	; (16014 <system_clock_source_get_hz+0xa4>)
   15f90:	691b      	ldr	r3, [r3, #16]
   15f92:	e039      	b.n	16008 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
   15f94:	4b20      	ldr	r3, [pc, #128]	; (16018 <system_clock_source_get_hz+0xa8>)
   15f96:	6a1b      	ldr	r3, [r3, #32]
   15f98:	059b      	lsls	r3, r3, #22
   15f9a:	0f9b      	lsrs	r3, r3, #30
   15f9c:	b2db      	uxtb	r3, r3
   15f9e:	001a      	movs	r2, r3
   15fa0:	4b1e      	ldr	r3, [pc, #120]	; (1601c <system_clock_source_get_hz+0xac>)
   15fa2:	40d3      	lsrs	r3, r2
   15fa4:	e030      	b.n	16008 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
   15fa6:	2380      	movs	r3, #128	; 0x80
   15fa8:	021b      	lsls	r3, r3, #8
   15faa:	e02d      	b.n	16008 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;
   15fac:	2380      	movs	r3, #128	; 0x80
   15fae:	021b      	lsls	r3, r3, #8
   15fb0:	e02a      	b.n	16008 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
   15fb2:	4b18      	ldr	r3, [pc, #96]	; (16014 <system_clock_source_get_hz+0xa4>)
   15fb4:	695b      	ldr	r3, [r3, #20]
   15fb6:	e027      	b.n	16008 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
   15fb8:	4b16      	ldr	r3, [pc, #88]	; (16014 <system_clock_source_get_hz+0xa4>)
   15fba:	681b      	ldr	r3, [r3, #0]
   15fbc:	2202      	movs	r2, #2
   15fbe:	4013      	ands	r3, r2
   15fc0:	d101      	bne.n	15fc6 <system_clock_source_get_hz+0x56>
			return 0;
   15fc2:	2300      	movs	r3, #0
   15fc4:	e020      	b.n	16008 <system_clock_source_get_hz+0x98>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();
   15fc6:	4b16      	ldr	r3, [pc, #88]	; (16020 <system_clock_source_get_hz+0xb0>)
   15fc8:	4798      	blx	r3

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
   15fca:	4b12      	ldr	r3, [pc, #72]	; (16014 <system_clock_source_get_hz+0xa4>)
   15fcc:	681b      	ldr	r3, [r3, #0]
   15fce:	2204      	movs	r2, #4
   15fd0:	4013      	ands	r3, r2
   15fd2:	d009      	beq.n	15fe8 <system_clock_source_get_hz+0x78>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
   15fd4:	2000      	movs	r0, #0
   15fd6:	4b13      	ldr	r3, [pc, #76]	; (16024 <system_clock_source_get_hz+0xb4>)
   15fd8:	4798      	blx	r3
   15fda:	0002      	movs	r2, r0
					(_system_clock_inst.dfll.mul & 0xffff);
   15fdc:	4b0d      	ldr	r3, [pc, #52]	; (16014 <system_clock_source_get_hz+0xa4>)
   15fde:	689b      	ldr	r3, [r3, #8]
   15fe0:	041b      	lsls	r3, r3, #16
   15fe2:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
   15fe4:	4353      	muls	r3, r2
   15fe6:	e00f      	b.n	16008 <system_clock_source_get_hz+0x98>
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
   15fe8:	4b0f      	ldr	r3, [pc, #60]	; (16028 <system_clock_source_get_hz+0xb8>)
   15fea:	e00d      	b.n	16008 <system_clock_source_get_hz+0x98>

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
   15fec:	4a0a      	ldr	r2, [pc, #40]	; (16018 <system_clock_source_get_hz+0xa8>)
   15fee:	2350      	movs	r3, #80	; 0x50
   15ff0:	5cd3      	ldrb	r3, [r2, r3]
   15ff2:	b2db      	uxtb	r3, r3
   15ff4:	001a      	movs	r2, r3
   15ff6:	2304      	movs	r3, #4
   15ff8:	4013      	ands	r3, r2
   15ffa:	d101      	bne.n	16000 <system_clock_source_get_hz+0x90>
			return 0;
   15ffc:	2300      	movs	r3, #0
   15ffe:	e003      	b.n	16008 <system_clock_source_get_hz+0x98>
		}

		return _system_clock_inst.dpll.frequency;
   16000:	4b04      	ldr	r3, [pc, #16]	; (16014 <system_clock_source_get_hz+0xa4>)
   16002:	68db      	ldr	r3, [r3, #12]
   16004:	e000      	b.n	16008 <system_clock_source_get_hz+0x98>
#endif

	default:
		return 0;
   16006:	2300      	movs	r3, #0
	}
}
   16008:	0018      	movs	r0, r3
   1600a:	46bd      	mov	sp, r7
   1600c:	b002      	add	sp, #8
   1600e:	bd80      	pop	{r7, pc}
   16010:	000210f8 	.word	0x000210f8
   16014:	20002e50 	.word	0x20002e50
   16018:	40000800 	.word	0x40000800
   1601c:	007a1200 	.word	0x007a1200
   16020:	00015f11 	.word	0x00015f11
   16024:	00016b4d 	.word	0x00016b4d
   16028:	02dc6c00 	.word	0x02dc6c00

0001602c <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
   1602c:	b580      	push	{r7, lr}
   1602e:	b084      	sub	sp, #16
   16030:	af00      	add	r7, sp, #0
   16032:	6078      	str	r0, [r7, #4]
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
   16034:	4b1a      	ldr	r3, [pc, #104]	; (160a0 <system_clock_source_osc8m_set_config+0x74>)
   16036:	6a1b      	ldr	r3, [r3, #32]
   16038:	60fb      	str	r3, [r7, #12]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
   1603a:	687b      	ldr	r3, [r7, #4]
   1603c:	781b      	ldrb	r3, [r3, #0]
   1603e:	1c1a      	adds	r2, r3, #0
   16040:	2303      	movs	r3, #3
   16042:	4013      	ands	r3, r2
   16044:	b2da      	uxtb	r2, r3
   16046:	230d      	movs	r3, #13
   16048:	18fb      	adds	r3, r7, r3
   1604a:	2103      	movs	r1, #3
   1604c:	400a      	ands	r2, r1
   1604e:	0010      	movs	r0, r2
   16050:	781a      	ldrb	r2, [r3, #0]
   16052:	2103      	movs	r1, #3
   16054:	438a      	bics	r2, r1
   16056:	1c11      	adds	r1, r2, #0
   16058:	1c02      	adds	r2, r0, #0
   1605a:	430a      	orrs	r2, r1
   1605c:	701a      	strb	r2, [r3, #0]
	temp.bit.ONDEMAND = config->on_demand;
   1605e:	687b      	ldr	r3, [r7, #4]
   16060:	789a      	ldrb	r2, [r3, #2]
   16062:	230c      	movs	r3, #12
   16064:	18fb      	adds	r3, r7, r3
   16066:	01d0      	lsls	r0, r2, #7
   16068:	781a      	ldrb	r2, [r3, #0]
   1606a:	217f      	movs	r1, #127	; 0x7f
   1606c:	400a      	ands	r2, r1
   1606e:	1c11      	adds	r1, r2, #0
   16070:	1c02      	adds	r2, r0, #0
   16072:	430a      	orrs	r2, r1
   16074:	701a      	strb	r2, [r3, #0]
	temp.bit.RUNSTDBY = config->run_in_standby;
   16076:	687b      	ldr	r3, [r7, #4]
   16078:	785a      	ldrb	r2, [r3, #1]
   1607a:	230c      	movs	r3, #12
   1607c:	18fb      	adds	r3, r7, r3
   1607e:	2101      	movs	r1, #1
   16080:	400a      	ands	r2, r1
   16082:	0190      	lsls	r0, r2, #6
   16084:	781a      	ldrb	r2, [r3, #0]
   16086:	2140      	movs	r1, #64	; 0x40
   16088:	438a      	bics	r2, r1
   1608a:	1c11      	adds	r1, r2, #0
   1608c:	1c02      	adds	r2, r0, #0
   1608e:	430a      	orrs	r2, r1
   16090:	701a      	strb	r2, [r3, #0]

	SYSCTRL->OSC8M = temp;
   16092:	4b03      	ldr	r3, [pc, #12]	; (160a0 <system_clock_source_osc8m_set_config+0x74>)
   16094:	68fa      	ldr	r2, [r7, #12]
   16096:	621a      	str	r2, [r3, #32]
}
   16098:	46c0      	nop			; (mov r8, r8)
   1609a:	46bd      	mov	sp, r7
   1609c:	b004      	add	sp, #16
   1609e:	bd80      	pop	{r7, pc}
   160a0:	40000800 	.word	0x40000800

000160a4 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
   160a4:	b580      	push	{r7, lr}
   160a6:	b084      	sub	sp, #16
   160a8:	af00      	add	r7, sp, #0
   160aa:	6078      	str	r0, [r7, #4]
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
   160ac:	4a43      	ldr	r2, [pc, #268]	; (161bc <system_clock_source_xosc32k_set_config+0x118>)
   160ae:	230c      	movs	r3, #12
   160b0:	18fb      	adds	r3, r7, r3
   160b2:	8a92      	ldrh	r2, [r2, #20]
   160b4:	801a      	strh	r2, [r3, #0]

	temp.bit.STARTUP = config->startup_time;
   160b6:	687b      	ldr	r3, [r7, #4]
   160b8:	785b      	ldrb	r3, [r3, #1]
   160ba:	1c1a      	adds	r2, r3, #0
   160bc:	2307      	movs	r3, #7
   160be:	4013      	ands	r3, r2
   160c0:	b2da      	uxtb	r2, r3
   160c2:	230c      	movs	r3, #12
   160c4:	18fb      	adds	r3, r7, r3
   160c6:	2107      	movs	r1, #7
   160c8:	400a      	ands	r2, r1
   160ca:	0010      	movs	r0, r2
   160cc:	785a      	ldrb	r2, [r3, #1]
   160ce:	2107      	movs	r1, #7
   160d0:	438a      	bics	r2, r1
   160d2:	1c11      	adds	r1, r2, #0
   160d4:	1c02      	adds	r2, r0, #0
   160d6:	430a      	orrs	r2, r1
   160d8:	705a      	strb	r2, [r3, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
   160da:	687b      	ldr	r3, [r7, #4]
   160dc:	781b      	ldrb	r3, [r3, #0]
   160de:	2b00      	cmp	r3, #0
   160e0:	d106      	bne.n	160f0 <system_clock_source_xosc32k_set_config+0x4c>
		temp.bit.XTALEN = 1;
   160e2:	230c      	movs	r3, #12
   160e4:	18fb      	adds	r3, r7, r3
   160e6:	781a      	ldrb	r2, [r3, #0]
   160e8:	2104      	movs	r1, #4
   160ea:	430a      	orrs	r2, r1
   160ec:	701a      	strb	r2, [r3, #0]
   160ee:	e005      	b.n	160fc <system_clock_source_xosc32k_set_config+0x58>
	} else {
		temp.bit.XTALEN = 0;
   160f0:	230c      	movs	r3, #12
   160f2:	18fb      	adds	r3, r7, r3
   160f4:	781a      	ldrb	r2, [r3, #0]
   160f6:	2104      	movs	r1, #4
   160f8:	438a      	bics	r2, r1
   160fa:	701a      	strb	r2, [r3, #0]
	}

	temp.bit.AAMPEN = config->auto_gain_control;
   160fc:	687b      	ldr	r3, [r7, #4]
   160fe:	789a      	ldrb	r2, [r3, #2]
   16100:	230c      	movs	r3, #12
   16102:	18fb      	adds	r3, r7, r3
   16104:	2101      	movs	r1, #1
   16106:	400a      	ands	r2, r1
   16108:	0150      	lsls	r0, r2, #5
   1610a:	781a      	ldrb	r2, [r3, #0]
   1610c:	2120      	movs	r1, #32
   1610e:	438a      	bics	r2, r1
   16110:	1c11      	adds	r1, r2, #0
   16112:	1c02      	adds	r2, r0, #0
   16114:	430a      	orrs	r2, r1
   16116:	701a      	strb	r2, [r3, #0]
	temp.bit.EN1K = config->enable_1khz_output;
   16118:	687b      	ldr	r3, [r7, #4]
   1611a:	78da      	ldrb	r2, [r3, #3]
   1611c:	230c      	movs	r3, #12
   1611e:	18fb      	adds	r3, r7, r3
   16120:	2101      	movs	r1, #1
   16122:	400a      	ands	r2, r1
   16124:	0110      	lsls	r0, r2, #4
   16126:	781a      	ldrb	r2, [r3, #0]
   16128:	2110      	movs	r1, #16
   1612a:	438a      	bics	r2, r1
   1612c:	1c11      	adds	r1, r2, #0
   1612e:	1c02      	adds	r2, r0, #0
   16130:	430a      	orrs	r2, r1
   16132:	701a      	strb	r2, [r3, #0]
	temp.bit.EN32K = config->enable_32khz_output;
   16134:	687b      	ldr	r3, [r7, #4]
   16136:	791a      	ldrb	r2, [r3, #4]
   16138:	230c      	movs	r3, #12
   1613a:	18fb      	adds	r3, r7, r3
   1613c:	2101      	movs	r1, #1
   1613e:	400a      	ands	r2, r1
   16140:	00d0      	lsls	r0, r2, #3
   16142:	781a      	ldrb	r2, [r3, #0]
   16144:	2108      	movs	r1, #8
   16146:	438a      	bics	r2, r1
   16148:	1c11      	adds	r1, r2, #0
   1614a:	1c02      	adds	r2, r0, #0
   1614c:	430a      	orrs	r2, r1
   1614e:	701a      	strb	r2, [r3, #0]

	temp.bit.ONDEMAND = config->on_demand;
   16150:	687b      	ldr	r3, [r7, #4]
   16152:	7b5a      	ldrb	r2, [r3, #13]
   16154:	230c      	movs	r3, #12
   16156:	18fb      	adds	r3, r7, r3
   16158:	01d0      	lsls	r0, r2, #7
   1615a:	781a      	ldrb	r2, [r3, #0]
   1615c:	217f      	movs	r1, #127	; 0x7f
   1615e:	400a      	ands	r2, r1
   16160:	1c11      	adds	r1, r2, #0
   16162:	1c02      	adds	r2, r0, #0
   16164:	430a      	orrs	r2, r1
   16166:	701a      	strb	r2, [r3, #0]
	temp.bit.RUNSTDBY = config->run_in_standby;
   16168:	687b      	ldr	r3, [r7, #4]
   1616a:	7b1a      	ldrb	r2, [r3, #12]
   1616c:	230c      	movs	r3, #12
   1616e:	18fb      	adds	r3, r7, r3
   16170:	2101      	movs	r1, #1
   16172:	400a      	ands	r2, r1
   16174:	0190      	lsls	r0, r2, #6
   16176:	781a      	ldrb	r2, [r3, #0]
   16178:	2140      	movs	r1, #64	; 0x40
   1617a:	438a      	bics	r2, r1
   1617c:	1c11      	adds	r1, r2, #0
   1617e:	1c02      	adds	r2, r0, #0
   16180:	430a      	orrs	r2, r1
   16182:	701a      	strb	r2, [r3, #0]
	temp.bit.WRTLOCK  = config->write_once;
   16184:	687b      	ldr	r3, [r7, #4]
   16186:	7b9a      	ldrb	r2, [r3, #14]
   16188:	230c      	movs	r3, #12
   1618a:	18fb      	adds	r3, r7, r3
   1618c:	2101      	movs	r1, #1
   1618e:	400a      	ands	r2, r1
   16190:	0110      	lsls	r0, r2, #4
   16192:	785a      	ldrb	r2, [r3, #1]
   16194:	2110      	movs	r1, #16
   16196:	438a      	bics	r2, r1
   16198:	1c11      	adds	r1, r2, #0
   1619a:	1c02      	adds	r2, r0, #0
   1619c:	430a      	orrs	r2, r1
   1619e:	705a      	strb	r2, [r3, #1]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
   161a0:	687b      	ldr	r3, [r7, #4]
   161a2:	689a      	ldr	r2, [r3, #8]
   161a4:	4b06      	ldr	r3, [pc, #24]	; (161c0 <system_clock_source_xosc32k_set_config+0x11c>)
   161a6:	615a      	str	r2, [r3, #20]

	SYSCTRL->XOSC32K = temp;
   161a8:	4a04      	ldr	r2, [pc, #16]	; (161bc <system_clock_source_xosc32k_set_config+0x118>)
   161aa:	230c      	movs	r3, #12
   161ac:	18fb      	adds	r3, r7, r3
   161ae:	881b      	ldrh	r3, [r3, #0]
   161b0:	8293      	strh	r3, [r2, #20]
}
   161b2:	46c0      	nop			; (mov r8, r8)
   161b4:	46bd      	mov	sp, r7
   161b6:	b004      	add	sp, #16
   161b8:	bd80      	pop	{r7, pc}
   161ba:	46c0      	nop			; (mov r8, r8)
   161bc:	40000800 	.word	0x40000800
   161c0:	20002e50 	.word	0x20002e50

000161c4 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
   161c4:	b580      	push	{r7, lr}
   161c6:	b082      	sub	sp, #8
   161c8:	af00      	add	r7, sp, #0
   161ca:	6078      	str	r0, [r7, #4]
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
   161cc:	687b      	ldr	r3, [r7, #4]
   161ce:	7a1b      	ldrb	r3, [r3, #8]
   161d0:	029b      	lsls	r3, r3, #10
   161d2:	041b      	lsls	r3, r3, #16
   161d4:	0c1a      	lsrs	r2, r3, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
   161d6:	687b      	ldr	r3, [r7, #4]
   161d8:	895b      	ldrh	r3, [r3, #10]
   161da:	059b      	lsls	r3, r3, #22
   161dc:	0d9b      	lsrs	r3, r3, #22
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
   161de:	431a      	orrs	r2, r3
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
   161e0:	4b2a      	ldr	r3, [pc, #168]	; (1628c <system_clock_source_dfll_set_config+0xc8>)
   161e2:	605a      	str	r2, [r3, #4]
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
   161e4:	687b      	ldr	r3, [r7, #4]
   161e6:	799a      	ldrb	r2, [r3, #6]
			(uint32_t)config->stable_tracking |
   161e8:	687b      	ldr	r3, [r7, #4]
   161ea:	79db      	ldrb	r3, [r3, #7]
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
   161ec:	4313      	orrs	r3, r2
   161ee:	b2db      	uxtb	r3, r3
   161f0:	001a      	movs	r2, r3
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
   161f2:	687b      	ldr	r3, [r7, #4]
   161f4:	885b      	ldrh	r3, [r3, #2]
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
   161f6:	4313      	orrs	r3, r2
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
   161f8:	687a      	ldr	r2, [r7, #4]
   161fa:	8892      	ldrh	r2, [r2, #4]
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
   161fc:	431a      	orrs	r2, r3
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
   161fe:	687b      	ldr	r3, [r7, #4]
   16200:	785b      	ldrb	r3, [r3, #1]
   16202:	01db      	lsls	r3, r3, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
   16204:	431a      	orrs	r2, r3
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
   16206:	4b21      	ldr	r3, [pc, #132]	; (1628c <system_clock_source_dfll_set_config+0xc8>)
   16208:	601a      	str	r2, [r3, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
   1620a:	687b      	ldr	r3, [r7, #4]
   1620c:	781b      	ldrb	r3, [r3, #0]
   1620e:	2b04      	cmp	r3, #4
   16210:	d116      	bne.n	16240 <system_clock_source_dfll_set_config+0x7c>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
   16212:	687b      	ldr	r3, [r7, #4]
   16214:	7b1b      	ldrb	r3, [r3, #12]
   16216:	069b      	lsls	r3, r3, #26
   16218:	001a      	movs	r2, r3
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
   1621a:	687b      	ldr	r3, [r7, #4]
   1621c:	89db      	ldrh	r3, [r3, #14]
   1621e:	041b      	lsls	r3, r3, #16
   16220:	0019      	movs	r1, r3
   16222:	4b1b      	ldr	r3, [pc, #108]	; (16290 <system_clock_source_dfll_set_config+0xcc>)
   16224:	400b      	ands	r3, r1
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
   16226:	4313      	orrs	r3, r2
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
   16228:	687a      	ldr	r2, [r7, #4]
   1622a:	8a12      	ldrh	r2, [r2, #16]

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
   1622c:	431a      	orrs	r2, r3
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
   1622e:	4b17      	ldr	r3, [pc, #92]	; (1628c <system_clock_source_dfll_set_config+0xc8>)
   16230:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
   16232:	4b16      	ldr	r3, [pc, #88]	; (1628c <system_clock_source_dfll_set_config+0xc8>)
   16234:	681b      	ldr	r3, [r3, #0]
   16236:	687a      	ldr	r2, [r7, #4]
   16238:	7812      	ldrb	r2, [r2, #0]
   1623a:	431a      	orrs	r2, r3
   1623c:	4b13      	ldr	r3, [pc, #76]	; (1628c <system_clock_source_dfll_set_config+0xc8>)
   1623e:	601a      	str	r2, [r3, #0]
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
   16240:	687b      	ldr	r3, [r7, #4]
   16242:	781b      	ldrb	r3, [r3, #0]
   16244:	2b20      	cmp	r3, #32
   16246:	d11c      	bne.n	16282 <system_clock_source_dfll_set_config+0xbe>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
   16248:	687b      	ldr	r3, [r7, #4]
   1624a:	7b1b      	ldrb	r3, [r3, #12]
   1624c:	069b      	lsls	r3, r3, #26
   1624e:	001a      	movs	r2, r3
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
   16250:	687b      	ldr	r3, [r7, #4]
   16252:	89db      	ldrh	r3, [r3, #14]
   16254:	041b      	lsls	r3, r3, #16
   16256:	0019      	movs	r1, r3
   16258:	4b0d      	ldr	r3, [pc, #52]	; (16290 <system_clock_source_dfll_set_config+0xcc>)
   1625a:	400b      	ands	r3, r1
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
   1625c:	4313      	orrs	r3, r2
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
   1625e:	687a      	ldr	r2, [r7, #4]
   16260:	8a12      	ldrh	r2, [r2, #16]
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
   16262:	431a      	orrs	r2, r3
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
   16264:	4b09      	ldr	r3, [pc, #36]	; (1628c <system_clock_source_dfll_set_config+0xc8>)
   16266:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
   16268:	4b08      	ldr	r3, [pc, #32]	; (1628c <system_clock_source_dfll_set_config+0xc8>)
   1626a:	681b      	ldr	r3, [r3, #0]
   1626c:	687a      	ldr	r2, [r7, #4]
   1626e:	7812      	ldrb	r2, [r2, #0]
   16270:	2104      	movs	r1, #4
   16272:	430a      	orrs	r2, r1
   16274:	b2d2      	uxtb	r2, r2
   16276:	4313      	orrs	r3, r2
   16278:	2280      	movs	r2, #128	; 0x80
   1627a:	00d2      	lsls	r2, r2, #3
   1627c:	431a      	orrs	r2, r3
   1627e:	4b03      	ldr	r3, [pc, #12]	; (1628c <system_clock_source_dfll_set_config+0xc8>)
   16280:	601a      	str	r2, [r3, #0]
				SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
   16282:	46c0      	nop			; (mov r8, r8)
   16284:	46bd      	mov	sp, r7
   16286:	b002      	add	sp, #8
   16288:	bd80      	pop	{r7, pc}
   1628a:	46c0      	nop			; (mov r8, r8)
   1628c:	20002e50 	.word	0x20002e50
   16290:	03ff0000 	.word	0x03ff0000

00016294 <system_clock_source_enable>:
 * \retval STATUS_ERR_INVALID_ARG  The clock source is not available on this
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
   16294:	b580      	push	{r7, lr}
   16296:	b082      	sub	sp, #8
   16298:	af00      	add	r7, sp, #0
   1629a:	0002      	movs	r2, r0
   1629c:	1dfb      	adds	r3, r7, #7
   1629e:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
   162a0:	1dfb      	adds	r3, r7, #7
   162a2:	781b      	ldrb	r3, [r3, #0]
   162a4:	2b08      	cmp	r3, #8
   162a6:	d83b      	bhi.n	16320 <system_clock_source_enable+0x8c>
   162a8:	009a      	lsls	r2, r3, #2
   162aa:	4b21      	ldr	r3, [pc, #132]	; (16330 <system_clock_source_enable+0x9c>)
   162ac:	18d3      	adds	r3, r2, r3
   162ae:	681b      	ldr	r3, [r3, #0]
   162b0:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
   162b2:	4b20      	ldr	r3, [pc, #128]	; (16334 <system_clock_source_enable+0xa0>)
   162b4:	4a1f      	ldr	r2, [pc, #124]	; (16334 <system_clock_source_enable+0xa0>)
   162b6:	6a12      	ldr	r2, [r2, #32]
   162b8:	2102      	movs	r1, #2
   162ba:	430a      	orrs	r2, r1
   162bc:	621a      	str	r2, [r3, #32]
		return STATUS_OK;
   162be:	2300      	movs	r3, #0
   162c0:	e031      	b.n	16326 <system_clock_source_enable+0x92>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
   162c2:	4b1c      	ldr	r3, [pc, #112]	; (16334 <system_clock_source_enable+0xa0>)
   162c4:	4a1b      	ldr	r2, [pc, #108]	; (16334 <system_clock_source_enable+0xa0>)
   162c6:	6992      	ldr	r2, [r2, #24]
   162c8:	2102      	movs	r1, #2
   162ca:	430a      	orrs	r2, r1
   162cc:	619a      	str	r2, [r3, #24]
		break;
   162ce:	e029      	b.n	16324 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
   162d0:	4a18      	ldr	r2, [pc, #96]	; (16334 <system_clock_source_enable+0xa0>)
   162d2:	4b18      	ldr	r3, [pc, #96]	; (16334 <system_clock_source_enable+0xa0>)
   162d4:	8a1b      	ldrh	r3, [r3, #16]
   162d6:	b29b      	uxth	r3, r3
   162d8:	2102      	movs	r1, #2
   162da:	430b      	orrs	r3, r1
   162dc:	b29b      	uxth	r3, r3
   162de:	8213      	strh	r3, [r2, #16]
		break;
   162e0:	e020      	b.n	16324 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
   162e2:	4a14      	ldr	r2, [pc, #80]	; (16334 <system_clock_source_enable+0xa0>)
   162e4:	4b13      	ldr	r3, [pc, #76]	; (16334 <system_clock_source_enable+0xa0>)
   162e6:	8a9b      	ldrh	r3, [r3, #20]
   162e8:	b29b      	uxth	r3, r3
   162ea:	2102      	movs	r1, #2
   162ec:	430b      	orrs	r3, r1
   162ee:	b29b      	uxth	r3, r3
   162f0:	8293      	strh	r3, [r2, #20]
		break;
   162f2:	e017      	b.n	16324 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
   162f4:	4b10      	ldr	r3, [pc, #64]	; (16338 <system_clock_source_enable+0xa4>)
   162f6:	681b      	ldr	r3, [r3, #0]
   162f8:	2202      	movs	r2, #2
   162fa:	431a      	orrs	r2, r3
   162fc:	4b0e      	ldr	r3, [pc, #56]	; (16338 <system_clock_source_enable+0xa4>)
   162fe:	601a      	str	r2, [r3, #0]
		_system_clock_source_dfll_set_config_errata_9905();
   16300:	4b0e      	ldr	r3, [pc, #56]	; (1633c <system_clock_source_enable+0xa8>)
   16302:	4798      	blx	r3
		break;
   16304:	e00e      	b.n	16324 <system_clock_source_enable+0x90>

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
   16306:	4a0b      	ldr	r2, [pc, #44]	; (16334 <system_clock_source_enable+0xa0>)
   16308:	490a      	ldr	r1, [pc, #40]	; (16334 <system_clock_source_enable+0xa0>)
   1630a:	2344      	movs	r3, #68	; 0x44
   1630c:	5ccb      	ldrb	r3, [r1, r3]
   1630e:	b2db      	uxtb	r3, r3
   16310:	2102      	movs	r1, #2
   16312:	430b      	orrs	r3, r1
   16314:	b2d9      	uxtb	r1, r3
   16316:	2344      	movs	r3, #68	; 0x44
   16318:	54d1      	strb	r1, [r2, r3]
		break;
   1631a:	e003      	b.n	16324 <system_clock_source_enable+0x90>
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
   1631c:	2300      	movs	r3, #0
   1631e:	e002      	b.n	16326 <system_clock_source_enable+0x92>

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   16320:	2317      	movs	r3, #23
   16322:	e000      	b.n	16326 <system_clock_source_enable+0x92>
	}

	return STATUS_OK;
   16324:	2300      	movs	r3, #0
}
   16326:	0018      	movs	r0, r3
   16328:	46bd      	mov	sp, r7
   1632a:	b002      	add	sp, #8
   1632c:	bd80      	pop	{r7, pc}
   1632e:	46c0      	nop			; (mov r8, r8)
   16330:	0002111c 	.word	0x0002111c
   16334:	40000800 	.word	0x40000800
   16338:	20002e50 	.word	0x20002e50
   1633c:	00015f2d 	.word	0x00015f2d

00016340 <system_clock_source_is_ready>:
 * \retval true   Clock source is enabled and ready
 * \retval false  Clock source is disabled or not yet ready
 */
bool system_clock_source_is_ready(
		const enum system_clock_source clock_source)
{
   16340:	b580      	push	{r7, lr}
   16342:	b084      	sub	sp, #16
   16344:	af00      	add	r7, sp, #0
   16346:	0002      	movs	r2, r0
   16348:	1dfb      	adds	r3, r7, #7
   1634a:	701a      	strb	r2, [r3, #0]
	uint32_t mask = 0;
   1634c:	2300      	movs	r3, #0
   1634e:	60fb      	str	r3, [r7, #12]

	switch (clock_source) {
   16350:	1dfb      	adds	r3, r7, #7
   16352:	781b      	ldrb	r3, [r3, #0]
   16354:	2b08      	cmp	r3, #8
   16356:	d821      	bhi.n	1639c <system_clock_source_is_ready+0x5c>
   16358:	009a      	lsls	r2, r3, #2
   1635a:	4b18      	ldr	r3, [pc, #96]	; (163bc <system_clock_source_is_ready+0x7c>)
   1635c:	18d3      	adds	r3, r2, r3
   1635e:	681b      	ldr	r3, [r3, #0]
   16360:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		mask = SYSCTRL_PCLKSR_OSC8MRDY;
   16362:	2308      	movs	r3, #8
   16364:	60fb      	str	r3, [r7, #12]
		break;
   16366:	e01b      	b.n	163a0 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		mask = SYSCTRL_PCLKSR_OSC32KRDY;
   16368:	2304      	movs	r3, #4
   1636a:	60fb      	str	r3, [r7, #12]
		break;
   1636c:	e018      	b.n	163a0 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		mask = SYSCTRL_PCLKSR_XOSCRDY;
   1636e:	2301      	movs	r3, #1
   16370:	60fb      	str	r3, [r7, #12]
		break;
   16372:	e015      	b.n	163a0 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		mask = SYSCTRL_PCLKSR_XOSC32KRDY;
   16374:	2302      	movs	r3, #2
   16376:	60fb      	str	r3, [r7, #12]
		break;
   16378:	e012      	b.n	163a0 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
			mask = (SYSCTRL_PCLKSR_DFLLRDY |
   1637a:	23d0      	movs	r3, #208	; 0xd0
   1637c:	60fb      	str	r3, [r7, #12]
			        SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC);
		} else {
			mask = SYSCTRL_PCLKSR_DFLLRDY;
		}
		break;
   1637e:	e00f      	b.n	163a0 <system_clock_source_is_ready+0x60>

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		return ((SYSCTRL->DPLLSTATUS.reg &
   16380:	4a0f      	ldr	r2, [pc, #60]	; (163c0 <system_clock_source_is_ready+0x80>)
   16382:	2350      	movs	r3, #80	; 0x50
   16384:	5cd3      	ldrb	r3, [r2, r3]
   16386:	b2db      	uxtb	r3, r3
   16388:	001a      	movs	r2, r3
   1638a:	2303      	movs	r3, #3
   1638c:	4013      	ands	r3, r2
   1638e:	3b03      	subs	r3, #3
   16390:	425a      	negs	r2, r3
   16392:	4153      	adcs	r3, r2
   16394:	b2db      	uxtb	r3, r3
   16396:	e00c      	b.n	163b2 <system_clock_source_is_ready+0x72>
				(SYSCTRL_DPLLSTATUS_CLKRDY | SYSCTRL_DPLLSTATUS_LOCK));
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Not possible to disable */
		return true;
   16398:	2301      	movs	r3, #1
   1639a:	e00a      	b.n	163b2 <system_clock_source_is_ready+0x72>

	default:
		return false;
   1639c:	2300      	movs	r3, #0
   1639e:	e008      	b.n	163b2 <system_clock_source_is_ready+0x72>
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
   163a0:	4b07      	ldr	r3, [pc, #28]	; (163c0 <system_clock_source_is_ready+0x80>)
   163a2:	68db      	ldr	r3, [r3, #12]
   163a4:	68fa      	ldr	r2, [r7, #12]
   163a6:	401a      	ands	r2, r3
   163a8:	68fb      	ldr	r3, [r7, #12]
   163aa:	1ad3      	subs	r3, r2, r3
   163ac:	425a      	negs	r2, r3
   163ae:	4153      	adcs	r3, r2
   163b0:	b2db      	uxtb	r3, r3
}
   163b2:	0018      	movs	r0, r3
   163b4:	46bd      	mov	sp, r7
   163b6:	b004      	add	sp, #16
   163b8:	bd80      	pop	{r7, pc}
   163ba:	46c0      	nop			; (mov r8, r8)
   163bc:	00021140 	.word	0x00021140
   163c0:	40000800 	.word	0x40000800

000163c4 <_switch_peripheral_gclk>:
 *
 * Switch all peripheral clock to a not enabled general clock
 * to save power.
 */
static void _switch_peripheral_gclk(void)
{
   163c4:	b580      	push	{r7, lr}
   163c6:	b082      	sub	sp, #8
   163c8:	af00      	add	r7, sp, #0
#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
#elif CONF_CLOCK_GCLK_3_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_3;
   163ca:	003b      	movs	r3, r7
   163cc:	2203      	movs	r2, #3
   163ce:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
   163d0:	2300      	movs	r3, #0
   163d2:	607b      	str	r3, [r7, #4]
   163d4:	e009      	b.n	163ea <_switch_peripheral_gclk+0x26>
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
   163d6:	687b      	ldr	r3, [r7, #4]
   163d8:	b2db      	uxtb	r3, r3
   163da:	003a      	movs	r2, r7
   163dc:	0011      	movs	r1, r2
   163de:	0018      	movs	r0, r3
   163e0:	4b05      	ldr	r3, [pc, #20]	; (163f8 <_switch_peripheral_gclk+0x34>)
   163e2:	4798      	blx	r3
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
   163e4:	687b      	ldr	r3, [r7, #4]
   163e6:	3301      	adds	r3, #1
   163e8:	607b      	str	r3, [r7, #4]
   163ea:	687b      	ldr	r3, [r7, #4]
   163ec:	2b24      	cmp	r3, #36	; 0x24
   163ee:	d9f2      	bls.n	163d6 <_switch_peripheral_gclk+0x12>
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
	}
}
   163f0:	46c0      	nop			; (mov r8, r8)
   163f2:	46bd      	mov	sp, r7
   163f4:	b002      	add	sp, #8
   163f6:	bd80      	pop	{r7, pc}
   163f8:	000169e1 	.word	0x000169e1

000163fc <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
   163fc:	b580      	push	{r7, lr}
   163fe:	b0aa      	sub	sp, #168	; 0xa8
   16400:	af00      	add	r7, sp, #0
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
   16402:	4b96      	ldr	r3, [pc, #600]	; (1665c <system_clock_init+0x260>)
   16404:	22c2      	movs	r2, #194	; 0xc2
   16406:	00d2      	lsls	r2, r2, #3
   16408:	609a      	str	r2, [r3, #8]
			SYSCTRL_INTFLAG_DFLLRDY;

	system_flash_set_waitstates(CONF_CLOCK_FLASH_WAIT_STATES);
   1640a:	2001      	movs	r0, #1
   1640c:	4b94      	ldr	r3, [pc, #592]	; (16660 <system_clock_init+0x264>)
   1640e:	4798      	blx	r3

	/* Switch all peripheral clock to a not enabled general clock to save power. */
	_switch_peripheral_gclk();
   16410:	4b94      	ldr	r3, [pc, #592]	; (16664 <system_clock_init+0x268>)
   16412:	4798      	blx	r3


	/* XOSC32K */
#if CONF_CLOCK_XOSC32K_ENABLE == true
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);
   16414:	2394      	movs	r3, #148	; 0x94
   16416:	18fb      	adds	r3, r7, r3
   16418:	0018      	movs	r0, r3
   1641a:	4b93      	ldr	r3, [pc, #588]	; (16668 <system_clock_init+0x26c>)
   1641c:	4798      	blx	r3

	xosc32k_conf.frequency           = 32768UL;
   1641e:	2394      	movs	r3, #148	; 0x94
   16420:	18fb      	adds	r3, r7, r3
   16422:	2280      	movs	r2, #128	; 0x80
   16424:	0212      	lsls	r2, r2, #8
   16426:	609a      	str	r2, [r3, #8]
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
   16428:	2394      	movs	r3, #148	; 0x94
   1642a:	18fb      	adds	r3, r7, r3
   1642c:	2200      	movs	r2, #0
   1642e:	701a      	strb	r2, [r3, #0]
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
   16430:	2394      	movs	r3, #148	; 0x94
   16432:	18fb      	adds	r3, r7, r3
   16434:	2203      	movs	r2, #3
   16436:	705a      	strb	r2, [r3, #1]
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
   16438:	2394      	movs	r3, #148	; 0x94
   1643a:	18fb      	adds	r3, r7, r3
   1643c:	2200      	movs	r2, #0
   1643e:	709a      	strb	r2, [r3, #2]
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
   16440:	2394      	movs	r3, #148	; 0x94
   16442:	18fb      	adds	r3, r7, r3
   16444:	2200      	movs	r2, #0
   16446:	70da      	strb	r2, [r3, #3]
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
   16448:	2394      	movs	r3, #148	; 0x94
   1644a:	18fb      	adds	r3, r7, r3
   1644c:	2201      	movs	r2, #1
   1644e:	711a      	strb	r2, [r3, #4]
	xosc32k_conf.on_demand           = false;
   16450:	2394      	movs	r3, #148	; 0x94
   16452:	18fb      	adds	r3, r7, r3
   16454:	2200      	movs	r2, #0
   16456:	735a      	strb	r2, [r3, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
   16458:	2394      	movs	r3, #148	; 0x94
   1645a:	18fb      	adds	r3, r7, r3
   1645c:	2200      	movs	r2, #0
   1645e:	731a      	strb	r2, [r3, #12]

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
   16460:	2394      	movs	r3, #148	; 0x94
   16462:	18fb      	adds	r3, r7, r3
   16464:	0018      	movs	r0, r3
   16466:	4b81      	ldr	r3, [pc, #516]	; (1666c <system_clock_init+0x270>)
   16468:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
   1646a:	2005      	movs	r0, #5
   1646c:	4b80      	ldr	r3, [pc, #512]	; (16670 <system_clock_init+0x274>)
   1646e:	4798      	blx	r3
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
   16470:	46c0      	nop			; (mov r8, r8)
   16472:	2005      	movs	r0, #5
   16474:	4b7f      	ldr	r3, [pc, #508]	; (16674 <system_clock_init+0x278>)
   16476:	4798      	blx	r3
   16478:	0003      	movs	r3, r0
   1647a:	001a      	movs	r2, r3
   1647c:	2301      	movs	r3, #1
   1647e:	4053      	eors	r3, r2
   16480:	b2db      	uxtb	r3, r3
   16482:	2b00      	cmp	r3, #0
   16484:	d1f5      	bne.n	16472 <system_clock_init+0x76>
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
   16486:	4a75      	ldr	r2, [pc, #468]	; (1665c <system_clock_init+0x260>)
   16488:	8a93      	ldrh	r3, [r2, #20]
   1648a:	2180      	movs	r1, #128	; 0x80
   1648c:	430b      	orrs	r3, r1
   1648e:	8293      	strh	r3, [r2, #20]


	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);
   16490:	2380      	movs	r3, #128	; 0x80
   16492:	18fb      	adds	r3, r7, r3
   16494:	0018      	movs	r0, r3
   16496:	4b78      	ldr	r3, [pc, #480]	; (16678 <system_clock_init+0x27c>)
   16498:	4798      	blx	r3

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
   1649a:	2380      	movs	r3, #128	; 0x80
   1649c:	18fb      	adds	r3, r7, r3
   1649e:	2204      	movs	r2, #4
   164a0:	701a      	strb	r2, [r3, #0]
	dfll_conf.on_demand      = false;
   164a2:	2380      	movs	r3, #128	; 0x80
   164a4:	18fb      	adds	r3, r7, r3
   164a6:	2200      	movs	r2, #0
   164a8:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping 
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
   164aa:	4b74      	ldr	r3, [pc, #464]	; (1667c <system_clock_init+0x280>)
   164ac:	681b      	ldr	r3, [r3, #0]
   164ae:	0e9b      	lsrs	r3, r3, #26
   164b0:	22a4      	movs	r2, #164	; 0xa4
   164b2:	18ba      	adds	r2, r7, r2
   164b4:	6013      	str	r3, [r2, #0]
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the coarse calibration value is not correct. */
	if (coarse == 0x3f) {
   164b6:	23a4      	movs	r3, #164	; 0xa4
   164b8:	18fb      	adds	r3, r7, r3
   164ba:	681b      	ldr	r3, [r3, #0]
   164bc:	2b3f      	cmp	r3, #63	; 0x3f
   164be:	d103      	bne.n	164c8 <system_clock_init+0xcc>
		coarse = 0x1f;
   164c0:	231f      	movs	r3, #31
   164c2:	22a4      	movs	r2, #164	; 0xa4
   164c4:	18ba      	adds	r2, r7, r2
   164c6:	6013      	str	r3, [r2, #0]
	}
	dfll_conf.coarse_value = coarse;
   164c8:	23a4      	movs	r3, #164	; 0xa4
   164ca:	18fb      	adds	r3, r7, r3
   164cc:	681b      	ldr	r3, [r3, #0]
   164ce:	b2da      	uxtb	r2, r3
   164d0:	2380      	movs	r3, #128	; 0x80
   164d2:	18fb      	adds	r3, r7, r3
   164d4:	721a      	strb	r2, [r3, #8]
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN) {
		dfll_conf.fine_value   = CONF_CLOCK_DFLL_FINE_VALUE;
	}

#  if CONF_CLOCK_DFLL_QUICK_LOCK == true
	dfll_conf.quick_lock = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
   164d6:	2380      	movs	r3, #128	; 0x80
   164d8:	18fb      	adds	r3, r7, r3
   164da:	2200      	movs	r2, #0
   164dc:	805a      	strh	r2, [r3, #2]
#  else
	dfll_conf.quick_lock = SYSTEM_CLOCK_DFLL_QUICK_LOCK_DISABLE;
#  endif

#  if CONF_CLOCK_DFLL_TRACK_AFTER_FINE_LOCK == true
	dfll_conf.stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
   164de:	2380      	movs	r3, #128	; 0x80
   164e0:	18fb      	adds	r3, r7, r3
   164e2:	2200      	movs	r2, #0
   164e4:	71da      	strb	r2, [r3, #7]
#  else
	dfll_conf.stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_FIX_AFTER_LOCK;
#  endif

#  if CONF_CLOCK_DFLL_KEEP_LOCK_ON_WAKEUP == true
	dfll_conf.wakeup_lock = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
   164e6:	2380      	movs	r3, #128	; 0x80
   164e8:	18fb      	adds	r3, r7, r3
   164ea:	2200      	movs	r2, #0
   164ec:	719a      	strb	r2, [r3, #6]
#  else
	dfll_conf.wakeup_lock = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_LOSE;
#  endif

#  if CONF_CLOCK_DFLL_ENABLE_CHILL_CYCLE == true
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
   164ee:	2380      	movs	r3, #128	; 0x80
   164f0:	18fb      	adds	r3, r7, r3
   164f2:	2200      	movs	r2, #0
   164f4:	809a      	strh	r2, [r3, #4]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
   164f6:	2380      	movs	r3, #128	; 0x80
   164f8:	18fb      	adds	r3, r7, r3
   164fa:	4a61      	ldr	r2, [pc, #388]	; (16680 <system_clock_init+0x284>)
   164fc:	821a      	strh	r2, [r3, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
   164fe:	2380      	movs	r3, #128	; 0x80
   16500:	18fb      	adds	r3, r7, r3
   16502:	2207      	movs	r2, #7
   16504:	731a      	strb	r2, [r3, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
   16506:	2380      	movs	r3, #128	; 0x80
   16508:	18fb      	adds	r3, r7, r3
   1650a:	223f      	movs	r2, #63	; 0x3f
   1650c:	81da      	strh	r2, [r3, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
   1650e:	2380      	movs	r3, #128	; 0x80
   16510:	18fb      	adds	r3, r7, r3
   16512:	0018      	movs	r0, r3
   16514:	4b5b      	ldr	r3, [pc, #364]	; (16684 <system_clock_init+0x288>)
   16516:	4798      	blx	r3
#endif


	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);
   16518:	237c      	movs	r3, #124	; 0x7c
   1651a:	18fb      	adds	r3, r7, r3
   1651c:	0018      	movs	r0, r3
   1651e:	4b5a      	ldr	r3, [pc, #360]	; (16688 <system_clock_init+0x28c>)
   16520:	4798      	blx	r3

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
   16522:	237c      	movs	r3, #124	; 0x7c
   16524:	18fb      	adds	r3, r7, r3
   16526:	2200      	movs	r2, #0
   16528:	701a      	strb	r2, [r3, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
   1652a:	237c      	movs	r3, #124	; 0x7c
   1652c:	18fb      	adds	r3, r7, r3
   1652e:	2201      	movs	r2, #1
   16530:	709a      	strb	r2, [r3, #2]
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;
   16532:	237c      	movs	r3, #124	; 0x7c
   16534:	18fb      	adds	r3, r7, r3
   16536:	2200      	movs	r2, #0
   16538:	705a      	strb	r2, [r3, #1]

	system_clock_source_osc8m_set_config(&osc8m_conf);
   1653a:	237c      	movs	r3, #124	; 0x7c
   1653c:	18fb      	adds	r3, r7, r3
   1653e:	0018      	movs	r0, r3
   16540:	4b52      	ldr	r3, [pc, #328]	; (1668c <system_clock_init+0x290>)
   16542:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
   16544:	2006      	movs	r0, #6
   16546:	4b4a      	ldr	r3, [pc, #296]	; (16670 <system_clock_init+0x274>)
   16548:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
   1654a:	4b51      	ldr	r3, [pc, #324]	; (16690 <system_clock_init+0x294>)
   1654c:	4798      	blx	r3

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
   1654e:	2364      	movs	r3, #100	; 0x64
   16550:	18fb      	adds	r3, r7, r3
   16552:	0018      	movs	r0, r3
   16554:	4b4f      	ldr	r3, [pc, #316]	; (16694 <system_clock_init+0x298>)
   16556:	4798      	blx	r3
   16558:	2364      	movs	r3, #100	; 0x64
   1655a:	18fb      	adds	r3, r7, r3
   1655c:	2205      	movs	r2, #5
   1655e:	701a      	strb	r2, [r3, #0]
   16560:	2364      	movs	r3, #100	; 0x64
   16562:	18fb      	adds	r3, r7, r3
   16564:	2201      	movs	r2, #1
   16566:	605a      	str	r2, [r3, #4]
   16568:	2364      	movs	r3, #100	; 0x64
   1656a:	18fb      	adds	r3, r7, r3
   1656c:	2200      	movs	r2, #0
   1656e:	721a      	strb	r2, [r3, #8]
   16570:	2364      	movs	r3, #100	; 0x64
   16572:	18fb      	adds	r3, r7, r3
   16574:	2200      	movs	r2, #0
   16576:	725a      	strb	r2, [r3, #9]
   16578:	2364      	movs	r3, #100	; 0x64
   1657a:	18fb      	adds	r3, r7, r3
   1657c:	0019      	movs	r1, r3
   1657e:	2001      	movs	r0, #1
   16580:	4b45      	ldr	r3, [pc, #276]	; (16698 <system_clock_init+0x29c>)
   16582:	4798      	blx	r3
   16584:	2001      	movs	r0, #1
   16586:	4b45      	ldr	r3, [pc, #276]	; (1669c <system_clock_init+0x2a0>)
   16588:	4798      	blx	r3
   1658a:	2358      	movs	r3, #88	; 0x58
   1658c:	18fb      	adds	r3, r7, r3
   1658e:	0018      	movs	r0, r3
   16590:	4b40      	ldr	r3, [pc, #256]	; (16694 <system_clock_init+0x298>)
   16592:	4798      	blx	r3
   16594:	2358      	movs	r3, #88	; 0x58
   16596:	18fb      	adds	r3, r7, r3
   16598:	2205      	movs	r2, #5
   1659a:	701a      	strb	r2, [r3, #0]
   1659c:	2358      	movs	r3, #88	; 0x58
   1659e:	18fb      	adds	r3, r7, r3
   165a0:	2220      	movs	r2, #32
   165a2:	605a      	str	r2, [r3, #4]
   165a4:	2358      	movs	r3, #88	; 0x58
   165a6:	18fb      	adds	r3, r7, r3
   165a8:	2200      	movs	r2, #0
   165aa:	721a      	strb	r2, [r3, #8]
   165ac:	2358      	movs	r3, #88	; 0x58
   165ae:	18fb      	adds	r3, r7, r3
   165b0:	2200      	movs	r2, #0
   165b2:	725a      	strb	r2, [r3, #9]
   165b4:	2358      	movs	r3, #88	; 0x58
   165b6:	18fb      	adds	r3, r7, r3
   165b8:	0019      	movs	r1, r3
   165ba:	2002      	movs	r0, #2
   165bc:	4b36      	ldr	r3, [pc, #216]	; (16698 <system_clock_init+0x29c>)
   165be:	4798      	blx	r3
   165c0:	2002      	movs	r0, #2
   165c2:	4b36      	ldr	r3, [pc, #216]	; (1669c <system_clock_init+0x2a0>)
   165c4:	4798      	blx	r3
#  if CONF_CLOCK_DFLL_ENABLE == true
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
   165c6:	230c      	movs	r3, #12
   165c8:	18fb      	adds	r3, r7, r3
   165ca:	0018      	movs	r0, r3
   165cc:	4b34      	ldr	r3, [pc, #208]	; (166a0 <system_clock_init+0x2a4>)
   165ce:	4798      	blx	r3
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
   165d0:	230c      	movs	r3, #12
   165d2:	18fb      	adds	r3, r7, r3
   165d4:	2201      	movs	r2, #1
   165d6:	701a      	strb	r2, [r3, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
   165d8:	230c      	movs	r3, #12
   165da:	18fb      	adds	r3, r7, r3
   165dc:	0019      	movs	r1, r3
   165de:	2000      	movs	r0, #0
   165e0:	4b30      	ldr	r3, [pc, #192]	; (166a4 <system_clock_init+0x2a8>)
   165e2:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
   165e4:	2000      	movs	r0, #0
   165e6:	4b30      	ldr	r3, [pc, #192]	; (166a8 <system_clock_init+0x2ac>)
   165e8:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
   165ea:	2007      	movs	r0, #7
   165ec:	4b20      	ldr	r3, [pc, #128]	; (16670 <system_clock_init+0x274>)
   165ee:	4798      	blx	r3
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
   165f0:	46c0      	nop			; (mov r8, r8)
   165f2:	2007      	movs	r0, #7
   165f4:	4b1f      	ldr	r3, [pc, #124]	; (16674 <system_clock_init+0x278>)
   165f6:	4798      	blx	r3
   165f8:	0003      	movs	r3, r0
   165fa:	001a      	movs	r2, r3
   165fc:	2301      	movs	r3, #1
   165fe:	4053      	eors	r3, r2
   16600:	b2db      	uxtb	r3, r3
   16602:	2b00      	cmp	r3, #0
   16604:	d1f5      	bne.n	165f2 <system_clock_init+0x1f6>

#  endif
#endif

	/* CPU and BUS clocks */
	system_cpu_clock_set_divider(CONF_CLOCK_CPU_DIVIDER);
   16606:	2000      	movs	r0, #0
   16608:	4b28      	ldr	r3, [pc, #160]	; (166ac <system_clock_init+0x2b0>)
   1660a:	4798      	blx	r3

	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBA, CONF_CLOCK_APBA_DIVIDER);
   1660c:	2100      	movs	r1, #0
   1660e:	2000      	movs	r0, #0
   16610:	4b27      	ldr	r3, [pc, #156]	; (166b0 <system_clock_init+0x2b4>)
   16612:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBB, CONF_CLOCK_APBB_DIVIDER);
   16614:	2100      	movs	r1, #0
   16616:	2001      	movs	r0, #1
   16618:	4b25      	ldr	r3, [pc, #148]	; (166b0 <system_clock_init+0x2b4>)
   1661a:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);
   1661c:	2100      	movs	r1, #0
   1661e:	2002      	movs	r0, #2
   16620:	4b23      	ldr	r3, [pc, #140]	; (166b0 <system_clock_init+0x2b4>)
   16622:	4798      	blx	r3

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
   16624:	003b      	movs	r3, r7
   16626:	0018      	movs	r0, r3
   16628:	4b1a      	ldr	r3, [pc, #104]	; (16694 <system_clock_init+0x298>)
   1662a:	4798      	blx	r3
   1662c:	003b      	movs	r3, r7
   1662e:	2207      	movs	r2, #7
   16630:	701a      	strb	r2, [r3, #0]
   16632:	003b      	movs	r3, r7
   16634:	2201      	movs	r2, #1
   16636:	605a      	str	r2, [r3, #4]
   16638:	003b      	movs	r3, r7
   1663a:	2200      	movs	r2, #0
   1663c:	721a      	strb	r2, [r3, #8]
   1663e:	003b      	movs	r3, r7
   16640:	2200      	movs	r2, #0
   16642:	725a      	strb	r2, [r3, #9]
   16644:	003b      	movs	r3, r7
   16646:	0019      	movs	r1, r3
   16648:	2000      	movs	r0, #0
   1664a:	4b13      	ldr	r3, [pc, #76]	; (16698 <system_clock_init+0x29c>)
   1664c:	4798      	blx	r3
   1664e:	2000      	movs	r0, #0
   16650:	4b12      	ldr	r3, [pc, #72]	; (1669c <system_clock_init+0x2a0>)
   16652:	4798      	blx	r3
#endif
}
   16654:	46c0      	nop			; (mov r8, r8)
   16656:	46bd      	mov	sp, r7
   16658:	b02a      	add	sp, #168	; 0xa8
   1665a:	bd80      	pop	{r7, pc}
   1665c:	40000800 	.word	0x40000800
   16660:	00015edd 	.word	0x00015edd
   16664:	000163c5 	.word	0x000163c5
   16668:	00015da9 	.word	0x00015da9
   1666c:	000160a5 	.word	0x000160a5
   16670:	00016295 	.word	0x00016295
   16674:	00016341 	.word	0x00016341
   16678:	00015e15 	.word	0x00015e15
   1667c:	00806024 	.word	0x00806024
   16680:	000005b9 	.word	0x000005b9
   16684:	000161c5 	.word	0x000161c5
   16688:	00015df1 	.word	0x00015df1
   1668c:	0001602d 	.word	0x0001602d
   16690:	00016759 	.word	0x00016759
   16694:	00015d61 	.word	0x00015d61
   16698:	00016789 	.word	0x00016789
   1669c:	000168ad 	.word	0x000168ad
   166a0:	00015d91 	.word	0x00015d91
   166a4:	000169e1 	.word	0x000169e1
   166a8:	00016a25 	.word	0x00016a25
   166ac:	00015e69 	.word	0x00015e69
   166b0:	00015e89 	.word	0x00015e89

000166b4 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
   166b4:	b580      	push	{r7, lr}
   166b6:	b082      	sub	sp, #8
   166b8:	af00      	add	r7, sp, #0
   166ba:	0002      	movs	r2, r0
   166bc:	6039      	str	r1, [r7, #0]
   166be:	1dfb      	adds	r3, r7, #7
   166c0:	701a      	strb	r2, [r3, #0]
	switch (bus) {
   166c2:	1dfb      	adds	r3, r7, #7
   166c4:	781b      	ldrb	r3, [r3, #0]
   166c6:	2b01      	cmp	r3, #1
   166c8:	d00a      	beq.n	166e0 <system_apb_clock_set_mask+0x2c>
   166ca:	2b02      	cmp	r3, #2
   166cc:	d00f      	beq.n	166ee <system_apb_clock_set_mask+0x3a>
   166ce:	2b00      	cmp	r3, #0
   166d0:	d114      	bne.n	166fc <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
   166d2:	4b0e      	ldr	r3, [pc, #56]	; (1670c <system_apb_clock_set_mask+0x58>)
   166d4:	4a0d      	ldr	r2, [pc, #52]	; (1670c <system_apb_clock_set_mask+0x58>)
   166d6:	6991      	ldr	r1, [r2, #24]
   166d8:	683a      	ldr	r2, [r7, #0]
   166da:	430a      	orrs	r2, r1
   166dc:	619a      	str	r2, [r3, #24]
			break;
   166de:	e00f      	b.n	16700 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
   166e0:	4b0a      	ldr	r3, [pc, #40]	; (1670c <system_apb_clock_set_mask+0x58>)
   166e2:	4a0a      	ldr	r2, [pc, #40]	; (1670c <system_apb_clock_set_mask+0x58>)
   166e4:	69d1      	ldr	r1, [r2, #28]
   166e6:	683a      	ldr	r2, [r7, #0]
   166e8:	430a      	orrs	r2, r1
   166ea:	61da      	str	r2, [r3, #28]
			break;
   166ec:	e008      	b.n	16700 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
   166ee:	4b07      	ldr	r3, [pc, #28]	; (1670c <system_apb_clock_set_mask+0x58>)
   166f0:	4a06      	ldr	r2, [pc, #24]	; (1670c <system_apb_clock_set_mask+0x58>)
   166f2:	6a11      	ldr	r1, [r2, #32]
   166f4:	683a      	ldr	r2, [r7, #0]
   166f6:	430a      	orrs	r2, r1
   166f8:	621a      	str	r2, [r3, #32]
			break;
   166fa:	e001      	b.n	16700 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
   166fc:	2317      	movs	r3, #23
   166fe:	e000      	b.n	16702 <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
   16700:	2300      	movs	r3, #0
}
   16702:	0018      	movs	r0, r3
   16704:	46bd      	mov	sp, r7
   16706:	b002      	add	sp, #8
   16708:	bd80      	pop	{r7, pc}
   1670a:	46c0      	nop			; (mov r8, r8)
   1670c:	40000400 	.word	0x40000400

00016710 <system_interrupt_enter_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
   16710:	b580      	push	{r7, lr}
   16712:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
   16714:	4b02      	ldr	r3, [pc, #8]	; (16720 <system_interrupt_enter_critical_section+0x10>)
   16716:	4798      	blx	r3
}
   16718:	46c0      	nop			; (mov r8, r8)
   1671a:	46bd      	mov	sp, r7
   1671c:	bd80      	pop	{r7, pc}
   1671e:	46c0      	nop			; (mov r8, r8)
   16720:	00013345 	.word	0x00013345

00016724 <system_interrupt_leave_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
   16724:	b580      	push	{r7, lr}
   16726:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
   16728:	4b02      	ldr	r3, [pc, #8]	; (16734 <system_interrupt_leave_critical_section+0x10>)
   1672a:	4798      	blx	r3
}
   1672c:	46c0      	nop			; (mov r8, r8)
   1672e:	46bd      	mov	sp, r7
   16730:	bd80      	pop	{r7, pc}
   16732:	46c0      	nop			; (mov r8, r8)
   16734:	00013399 	.word	0x00013399

00016738 <system_gclk_is_syncing>:
 *
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
   16738:	b580      	push	{r7, lr}
   1673a:	af00      	add	r7, sp, #0
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   1673c:	4b05      	ldr	r3, [pc, #20]	; (16754 <system_gclk_is_syncing+0x1c>)
   1673e:	785b      	ldrb	r3, [r3, #1]
   16740:	b2db      	uxtb	r3, r3
   16742:	b25b      	sxtb	r3, r3
   16744:	2b00      	cmp	r3, #0
   16746:	da01      	bge.n	1674c <system_gclk_is_syncing+0x14>
		return true;
   16748:	2301      	movs	r3, #1
   1674a:	e000      	b.n	1674e <system_gclk_is_syncing+0x16>
	}

	return false;
   1674c:	2300      	movs	r3, #0
}
   1674e:	0018      	movs	r0, r3
   16750:	46bd      	mov	sp, r7
   16752:	bd80      	pop	{r7, pc}
   16754:	40000c00 	.word	0x40000c00

00016758 <system_gclk_init>:
 *
 * Initializes the Generic Clock module, disabling and resetting all active
 * Generic Clock Generators and Channels to their power-on default values.
 */
void system_gclk_init(void)
{
   16758:	b580      	push	{r7, lr}
   1675a:	af00      	add	r7, sp, #0
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);
   1675c:	2108      	movs	r1, #8
   1675e:	2000      	movs	r0, #0
   16760:	4b07      	ldr	r3, [pc, #28]	; (16780 <system_gclk_init+0x28>)
   16762:	4798      	blx	r3

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
   16764:	4b07      	ldr	r3, [pc, #28]	; (16784 <system_gclk_init+0x2c>)
   16766:	2201      	movs	r2, #1
   16768:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
   1676a:	46c0      	nop			; (mov r8, r8)
   1676c:	4b05      	ldr	r3, [pc, #20]	; (16784 <system_gclk_init+0x2c>)
   1676e:	781b      	ldrb	r3, [r3, #0]
   16770:	b2db      	uxtb	r3, r3
   16772:	001a      	movs	r2, r3
   16774:	2301      	movs	r3, #1
   16776:	4013      	ands	r3, r2
   16778:	d1f8      	bne.n	1676c <system_gclk_init+0x14>
		/* Wait for reset to complete */
	}
}
   1677a:	46c0      	nop			; (mov r8, r8)
   1677c:	46bd      	mov	sp, r7
   1677e:	bd80      	pop	{r7, pc}
   16780:	000166b5 	.word	0x000166b5
   16784:	40000c00 	.word	0x40000c00

00016788 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
   16788:	b580      	push	{r7, lr}
   1678a:	b086      	sub	sp, #24
   1678c:	af00      	add	r7, sp, #0
   1678e:	0002      	movs	r2, r0
   16790:	6039      	str	r1, [r7, #0]
   16792:	1dfb      	adds	r3, r7, #7
   16794:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
   16796:	1dfb      	adds	r3, r7, #7
   16798:	781b      	ldrb	r3, [r3, #0]
   1679a:	617b      	str	r3, [r7, #20]
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);
   1679c:	1dfb      	adds	r3, r7, #7
   1679e:	781b      	ldrb	r3, [r3, #0]
   167a0:	613b      	str	r3, [r7, #16]

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
   167a2:	683b      	ldr	r3, [r7, #0]
   167a4:	781b      	ldrb	r3, [r3, #0]
   167a6:	021b      	lsls	r3, r3, #8
   167a8:	001a      	movs	r2, r3
   167aa:	697b      	ldr	r3, [r7, #20]
   167ac:	4313      	orrs	r3, r2
   167ae:	617b      	str	r3, [r7, #20]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
   167b0:	683b      	ldr	r3, [r7, #0]
   167b2:	785b      	ldrb	r3, [r3, #1]
   167b4:	2b00      	cmp	r3, #0
   167b6:	d004      	beq.n	167c2 <system_gclk_gen_set_config+0x3a>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
   167b8:	697b      	ldr	r3, [r7, #20]
   167ba:	2280      	movs	r2, #128	; 0x80
   167bc:	02d2      	lsls	r2, r2, #11
   167be:	4313      	orrs	r3, r2
   167c0:	617b      	str	r3, [r7, #20]
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
   167c2:	683b      	ldr	r3, [r7, #0]
   167c4:	7a5b      	ldrb	r3, [r3, #9]
   167c6:	2b00      	cmp	r3, #0
   167c8:	d004      	beq.n	167d4 <system_gclk_gen_set_config+0x4c>
		new_genctrl_config |= GCLK_GENCTRL_OE;
   167ca:	697b      	ldr	r3, [r7, #20]
   167cc:	2280      	movs	r2, #128	; 0x80
   167ce:	0312      	lsls	r2, r2, #12
   167d0:	4313      	orrs	r3, r2
   167d2:	617b      	str	r3, [r7, #20]
	}

	/* Set division factor */
	if (config->division_factor > 1) {
   167d4:	683b      	ldr	r3, [r7, #0]
   167d6:	685b      	ldr	r3, [r3, #4]
   167d8:	2b01      	cmp	r3, #1
   167da:	d92c      	bls.n	16836 <system_gclk_gen_set_config+0xae>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
   167dc:	683b      	ldr	r3, [r7, #0]
   167de:	685a      	ldr	r2, [r3, #4]
   167e0:	683b      	ldr	r3, [r7, #0]
   167e2:	685b      	ldr	r3, [r3, #4]
   167e4:	3b01      	subs	r3, #1
   167e6:	4013      	ands	r3, r2
   167e8:	d11a      	bne.n	16820 <system_gclk_gen_set_config+0x98>
			/* Determine the index of the highest bit set to get the
			 * division factor that must be loaded into the division
			 * register */

			uint32_t div2_count = 0;
   167ea:	2300      	movs	r3, #0
   167ec:	60fb      	str	r3, [r7, #12]

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
   167ee:	2302      	movs	r3, #2
   167f0:	60bb      	str	r3, [r7, #8]
   167f2:	e005      	b.n	16800 <system_gclk_gen_set_config+0x78>
						mask <<= 1) {
				div2_count++;
   167f4:	68fb      	ldr	r3, [r7, #12]
   167f6:	3301      	adds	r3, #1
   167f8:	60fb      	str	r3, [r7, #12]

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
   167fa:	68bb      	ldr	r3, [r7, #8]
   167fc:	005b      	lsls	r3, r3, #1
   167fe:	60bb      	str	r3, [r7, #8]
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
   16800:	683b      	ldr	r3, [r7, #0]
   16802:	685a      	ldr	r2, [r3, #4]
   16804:	68bb      	ldr	r3, [r7, #8]
   16806:	429a      	cmp	r2, r3
   16808:	d8f4      	bhi.n	167f4 <system_gclk_gen_set_config+0x6c>
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
   1680a:	68fb      	ldr	r3, [r7, #12]
   1680c:	021b      	lsls	r3, r3, #8
   1680e:	693a      	ldr	r2, [r7, #16]
   16810:	4313      	orrs	r3, r2
   16812:	613b      	str	r3, [r7, #16]
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
   16814:	697b      	ldr	r3, [r7, #20]
   16816:	2280      	movs	r2, #128	; 0x80
   16818:	0352      	lsls	r2, r2, #13
   1681a:	4313      	orrs	r3, r2
   1681c:	617b      	str	r3, [r7, #20]
   1681e:	e00a      	b.n	16836 <system_gclk_gen_set_config+0xae>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
   16820:	683b      	ldr	r3, [r7, #0]
   16822:	685b      	ldr	r3, [r3, #4]
   16824:	021b      	lsls	r3, r3, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
   16826:	693a      	ldr	r2, [r7, #16]
   16828:	4313      	orrs	r3, r2
   1682a:	613b      	str	r3, [r7, #16]
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
   1682c:	697b      	ldr	r3, [r7, #20]
   1682e:	2280      	movs	r2, #128	; 0x80
   16830:	0292      	lsls	r2, r2, #10
   16832:	4313      	orrs	r3, r2
   16834:	617b      	str	r3, [r7, #20]
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
   16836:	683b      	ldr	r3, [r7, #0]
   16838:	7a1b      	ldrb	r3, [r3, #8]
   1683a:	2b00      	cmp	r3, #0
   1683c:	d004      	beq.n	16848 <system_gclk_gen_set_config+0xc0>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
   1683e:	697b      	ldr	r3, [r7, #20]
   16840:	2280      	movs	r2, #128	; 0x80
   16842:	0392      	lsls	r2, r2, #14
   16844:	4313      	orrs	r3, r2
   16846:	617b      	str	r3, [r7, #20]
	}

	while (system_gclk_is_syncing()) {
   16848:	46c0      	nop			; (mov r8, r8)
   1684a:	4b13      	ldr	r3, [pc, #76]	; (16898 <system_gclk_gen_set_config+0x110>)
   1684c:	4798      	blx	r3
   1684e:	1e03      	subs	r3, r0, #0
   16850:	d1fb      	bne.n	1684a <system_gclk_gen_set_config+0xc2>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
   16852:	4b12      	ldr	r3, [pc, #72]	; (1689c <system_gclk_gen_set_config+0x114>)
   16854:	4798      	blx	r3

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
   16856:	4a12      	ldr	r2, [pc, #72]	; (168a0 <system_gclk_gen_set_config+0x118>)
   16858:	1dfb      	adds	r3, r7, #7
   1685a:	781b      	ldrb	r3, [r3, #0]
   1685c:	7013      	strb	r3, [r2, #0]

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
   1685e:	46c0      	nop			; (mov r8, r8)
   16860:	4b0d      	ldr	r3, [pc, #52]	; (16898 <system_gclk_gen_set_config+0x110>)
   16862:	4798      	blx	r3
   16864:	1e03      	subs	r3, r0, #0
   16866:	d1fb      	bne.n	16860 <system_gclk_gen_set_config+0xd8>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
   16868:	4b0e      	ldr	r3, [pc, #56]	; (168a4 <system_gclk_gen_set_config+0x11c>)
   1686a:	693a      	ldr	r2, [r7, #16]
   1686c:	609a      	str	r2, [r3, #8]

	while (system_gclk_is_syncing()) {
   1686e:	46c0      	nop			; (mov r8, r8)
   16870:	4b09      	ldr	r3, [pc, #36]	; (16898 <system_gclk_gen_set_config+0x110>)
   16872:	4798      	blx	r3
   16874:	1e03      	subs	r3, r0, #0
   16876:	d1fb      	bne.n	16870 <system_gclk_gen_set_config+0xe8>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
   16878:	4b0a      	ldr	r3, [pc, #40]	; (168a4 <system_gclk_gen_set_config+0x11c>)
   1687a:	4a0a      	ldr	r2, [pc, #40]	; (168a4 <system_gclk_gen_set_config+0x11c>)
   1687c:	6851      	ldr	r1, [r2, #4]
   1687e:	2280      	movs	r2, #128	; 0x80
   16880:	0252      	lsls	r2, r2, #9
   16882:	4011      	ands	r1, r2
   16884:	697a      	ldr	r2, [r7, #20]
   16886:	430a      	orrs	r2, r1
   16888:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
   1688a:	4b07      	ldr	r3, [pc, #28]	; (168a8 <system_gclk_gen_set_config+0x120>)
   1688c:	4798      	blx	r3
}
   1688e:	46c0      	nop			; (mov r8, r8)
   16890:	46bd      	mov	sp, r7
   16892:	b006      	add	sp, #24
   16894:	bd80      	pop	{r7, pc}
   16896:	46c0      	nop			; (mov r8, r8)
   16898:	00016739 	.word	0x00016739
   1689c:	00016711 	.word	0x00016711
   168a0:	40000c08 	.word	0x40000c08
   168a4:	40000c00 	.word	0x40000c00
   168a8:	00016725 	.word	0x00016725

000168ac <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
   168ac:	b580      	push	{r7, lr}
   168ae:	b082      	sub	sp, #8
   168b0:	af00      	add	r7, sp, #0
   168b2:	0002      	movs	r2, r0
   168b4:	1dfb      	adds	r3, r7, #7
   168b6:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing()) {
   168b8:	46c0      	nop			; (mov r8, r8)
   168ba:	4b0e      	ldr	r3, [pc, #56]	; (168f4 <system_gclk_gen_enable+0x48>)
   168bc:	4798      	blx	r3
   168be:	1e03      	subs	r3, r0, #0
   168c0:	d1fb      	bne.n	168ba <system_gclk_gen_enable+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
   168c2:	4b0d      	ldr	r3, [pc, #52]	; (168f8 <system_gclk_gen_enable+0x4c>)
   168c4:	4798      	blx	r3

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   168c6:	4a0d      	ldr	r2, [pc, #52]	; (168fc <system_gclk_gen_enable+0x50>)
   168c8:	1dfb      	adds	r3, r7, #7
   168ca:	781b      	ldrb	r3, [r3, #0]
   168cc:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
   168ce:	46c0      	nop			; (mov r8, r8)
   168d0:	4b08      	ldr	r3, [pc, #32]	; (168f4 <system_gclk_gen_enable+0x48>)
   168d2:	4798      	blx	r3
   168d4:	1e03      	subs	r3, r0, #0
   168d6:	d1fb      	bne.n	168d0 <system_gclk_gen_enable+0x24>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
   168d8:	4b09      	ldr	r3, [pc, #36]	; (16900 <system_gclk_gen_enable+0x54>)
   168da:	4a09      	ldr	r2, [pc, #36]	; (16900 <system_gclk_gen_enable+0x54>)
   168dc:	6852      	ldr	r2, [r2, #4]
   168de:	2180      	movs	r1, #128	; 0x80
   168e0:	0249      	lsls	r1, r1, #9
   168e2:	430a      	orrs	r2, r1
   168e4:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
   168e6:	4b07      	ldr	r3, [pc, #28]	; (16904 <system_gclk_gen_enable+0x58>)
   168e8:	4798      	blx	r3
}
   168ea:	46c0      	nop			; (mov r8, r8)
   168ec:	46bd      	mov	sp, r7
   168ee:	b002      	add	sp, #8
   168f0:	bd80      	pop	{r7, pc}
   168f2:	46c0      	nop			; (mov r8, r8)
   168f4:	00016739 	.word	0x00016739
   168f8:	00016711 	.word	0x00016711
   168fc:	40000c04 	.word	0x40000c04
   16900:	40000c00 	.word	0x40000c00
   16904:	00016725 	.word	0x00016725

00016908 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
   16908:	b580      	push	{r7, lr}
   1690a:	b086      	sub	sp, #24
   1690c:	af00      	add	r7, sp, #0
   1690e:	0002      	movs	r2, r0
   16910:	1dfb      	adds	r3, r7, #7
   16912:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing()) {
   16914:	46c0      	nop			; (mov r8, r8)
   16916:	4b2a      	ldr	r3, [pc, #168]	; (169c0 <system_gclk_gen_get_hz+0xb8>)
   16918:	4798      	blx	r3
   1691a:	1e03      	subs	r3, r0, #0
   1691c:	d1fb      	bne.n	16916 <system_gclk_gen_get_hz+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
   1691e:	4b29      	ldr	r3, [pc, #164]	; (169c4 <system_gclk_gen_get_hz+0xbc>)
   16920:	4798      	blx	r3

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   16922:	4a29      	ldr	r2, [pc, #164]	; (169c8 <system_gclk_gen_get_hz+0xc0>)
   16924:	1dfb      	adds	r3, r7, #7
   16926:	781b      	ldrb	r3, [r3, #0]
   16928:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
   1692a:	46c0      	nop			; (mov r8, r8)
   1692c:	4b24      	ldr	r3, [pc, #144]	; (169c0 <system_gclk_gen_get_hz+0xb8>)
   1692e:	4798      	blx	r3
   16930:	1e03      	subs	r3, r0, #0
   16932:	d1fb      	bne.n	1692c <system_gclk_gen_get_hz+0x24>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
   16934:	4b25      	ldr	r3, [pc, #148]	; (169cc <system_gclk_gen_get_hz+0xc4>)
   16936:	685b      	ldr	r3, [r3, #4]
   16938:	04db      	lsls	r3, r3, #19
   1693a:	0edb      	lsrs	r3, r3, #27
   1693c:	b2db      	uxtb	r3, r3
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
   1693e:	0018      	movs	r0, r3
   16940:	4b23      	ldr	r3, [pc, #140]	; (169d0 <system_gclk_gen_get_hz+0xc8>)
   16942:	4798      	blx	r3
   16944:	0003      	movs	r3, r0
   16946:	617b      	str	r3, [r7, #20]
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   16948:	4a1f      	ldr	r2, [pc, #124]	; (169c8 <system_gclk_gen_get_hz+0xc0>)
   1694a:	1dfb      	adds	r3, r7, #7
   1694c:	781b      	ldrb	r3, [r3, #0]
   1694e:	7013      	strb	r3, [r2, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
   16950:	4b1e      	ldr	r3, [pc, #120]	; (169cc <system_gclk_gen_get_hz+0xc4>)
   16952:	685b      	ldr	r3, [r3, #4]
   16954:	02db      	lsls	r3, r3, #11
   16956:	0fdb      	lsrs	r3, r3, #31
   16958:	b2da      	uxtb	r2, r3
   1695a:	2313      	movs	r3, #19
   1695c:	18fb      	adds	r3, r7, r3
   1695e:	701a      	strb	r2, [r3, #0]

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
   16960:	4a1c      	ldr	r2, [pc, #112]	; (169d4 <system_gclk_gen_get_hz+0xcc>)
   16962:	1dfb      	adds	r3, r7, #7
   16964:	781b      	ldrb	r3, [r3, #0]
   16966:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
   16968:	46c0      	nop			; (mov r8, r8)
   1696a:	4b15      	ldr	r3, [pc, #84]	; (169c0 <system_gclk_gen_get_hz+0xb8>)
   1696c:	4798      	blx	r3
   1696e:	1e03      	subs	r3, r0, #0
   16970:	d1fb      	bne.n	1696a <system_gclk_gen_get_hz+0x62>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
   16972:	4b16      	ldr	r3, [pc, #88]	; (169cc <system_gclk_gen_get_hz+0xc4>)
   16974:	689b      	ldr	r3, [r3, #8]
   16976:	021b      	lsls	r3, r3, #8
   16978:	0c1b      	lsrs	r3, r3, #16
   1697a:	b29b      	uxth	r3, r3
   1697c:	60fb      	str	r3, [r7, #12]

	system_interrupt_leave_critical_section();
   1697e:	4b16      	ldr	r3, [pc, #88]	; (169d8 <system_gclk_gen_get_hz+0xd0>)
   16980:	4798      	blx	r3

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
   16982:	2313      	movs	r3, #19
   16984:	18fb      	adds	r3, r7, r3
   16986:	781b      	ldrb	r3, [r3, #0]
   16988:	2b00      	cmp	r3, #0
   1698a:	d109      	bne.n	169a0 <system_gclk_gen_get_hz+0x98>
   1698c:	68fb      	ldr	r3, [r7, #12]
   1698e:	2b01      	cmp	r3, #1
   16990:	d906      	bls.n	169a0 <system_gclk_gen_get_hz+0x98>
		gen_input_hz /= divider;
   16992:	4b12      	ldr	r3, [pc, #72]	; (169dc <system_gclk_gen_get_hz+0xd4>)
   16994:	68f9      	ldr	r1, [r7, #12]
   16996:	6978      	ldr	r0, [r7, #20]
   16998:	4798      	blx	r3
   1699a:	0003      	movs	r3, r0
   1699c:	617b      	str	r3, [r7, #20]
   1699e:	e00a      	b.n	169b6 <system_gclk_gen_get_hz+0xae>
	} else if (divsel) {
   169a0:	2313      	movs	r3, #19
   169a2:	18fb      	adds	r3, r7, r3
   169a4:	781b      	ldrb	r3, [r3, #0]
   169a6:	2b00      	cmp	r3, #0
   169a8:	d005      	beq.n	169b6 <system_gclk_gen_get_hz+0xae>
		gen_input_hz >>= (divider+1);
   169aa:	68fb      	ldr	r3, [r7, #12]
   169ac:	3301      	adds	r3, #1
   169ae:	697a      	ldr	r2, [r7, #20]
   169b0:	40da      	lsrs	r2, r3
   169b2:	0013      	movs	r3, r2
   169b4:	617b      	str	r3, [r7, #20]
	}

	return gen_input_hz;
   169b6:	697b      	ldr	r3, [r7, #20]
}
   169b8:	0018      	movs	r0, r3
   169ba:	46bd      	mov	sp, r7
   169bc:	b006      	add	sp, #24
   169be:	bd80      	pop	{r7, pc}
   169c0:	00016739 	.word	0x00016739
   169c4:	00016711 	.word	0x00016711
   169c8:	40000c04 	.word	0x40000c04
   169cc:	40000c00 	.word	0x40000c00
   169d0:	00015f71 	.word	0x00015f71
   169d4:	40000c08 	.word	0x40000c08
   169d8:	00016725 	.word	0x00016725
   169dc:	0001d485 	.word	0x0001d485

000169e0 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
   169e0:	b580      	push	{r7, lr}
   169e2:	b084      	sub	sp, #16
   169e4:	af00      	add	r7, sp, #0
   169e6:	0002      	movs	r2, r0
   169e8:	6039      	str	r1, [r7, #0]
   169ea:	1dfb      	adds	r3, r7, #7
   169ec:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);
   169ee:	1dfb      	adds	r3, r7, #7
   169f0:	781b      	ldrb	r3, [r3, #0]
   169f2:	60fb      	str	r3, [r7, #12]

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
   169f4:	683b      	ldr	r3, [r7, #0]
   169f6:	781b      	ldrb	r3, [r3, #0]
   169f8:	021b      	lsls	r3, r3, #8
   169fa:	001a      	movs	r2, r3
   169fc:	68fb      	ldr	r3, [r7, #12]
   169fe:	4313      	orrs	r3, r2
   16a00:	60fb      	str	r3, [r7, #12]

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
   16a02:	1dfb      	adds	r3, r7, #7
   16a04:	781b      	ldrb	r3, [r3, #0]
   16a06:	0018      	movs	r0, r3
   16a08:	4b04      	ldr	r3, [pc, #16]	; (16a1c <system_gclk_chan_set_config+0x3c>)
   16a0a:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
   16a0c:	4b04      	ldr	r3, [pc, #16]	; (16a20 <system_gclk_chan_set_config+0x40>)
   16a0e:	68fa      	ldr	r2, [r7, #12]
   16a10:	b292      	uxth	r2, r2
   16a12:	805a      	strh	r2, [r3, #2]
}
   16a14:	46c0      	nop			; (mov r8, r8)
   16a16:	46bd      	mov	sp, r7
   16a18:	b004      	add	sp, #16
   16a1a:	bd80      	pop	{r7, pc}
   16a1c:	00016a6d 	.word	0x00016a6d
   16a20:	40000c00 	.word	0x40000c00

00016a24 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
   16a24:	b580      	push	{r7, lr}
   16a26:	b082      	sub	sp, #8
   16a28:	af00      	add	r7, sp, #0
   16a2a:	0002      	movs	r2, r0
   16a2c:	1dfb      	adds	r3, r7, #7
   16a2e:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
   16a30:	4b0a      	ldr	r3, [pc, #40]	; (16a5c <system_gclk_chan_enable+0x38>)
   16a32:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   16a34:	4a0a      	ldr	r2, [pc, #40]	; (16a60 <system_gclk_chan_enable+0x3c>)
   16a36:	1dfb      	adds	r3, r7, #7
   16a38:	781b      	ldrb	r3, [r3, #0]
   16a3a:	7013      	strb	r3, [r2, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
   16a3c:	4909      	ldr	r1, [pc, #36]	; (16a64 <system_gclk_chan_enable+0x40>)
   16a3e:	4b09      	ldr	r3, [pc, #36]	; (16a64 <system_gclk_chan_enable+0x40>)
   16a40:	885b      	ldrh	r3, [r3, #2]
   16a42:	b29b      	uxth	r3, r3
   16a44:	2280      	movs	r2, #128	; 0x80
   16a46:	01d2      	lsls	r2, r2, #7
   16a48:	4313      	orrs	r3, r2
   16a4a:	b29b      	uxth	r3, r3
   16a4c:	804b      	strh	r3, [r1, #2]

	system_interrupt_leave_critical_section();
   16a4e:	4b06      	ldr	r3, [pc, #24]	; (16a68 <system_gclk_chan_enable+0x44>)
   16a50:	4798      	blx	r3
}
   16a52:	46c0      	nop			; (mov r8, r8)
   16a54:	46bd      	mov	sp, r7
   16a56:	b002      	add	sp, #8
   16a58:	bd80      	pop	{r7, pc}
   16a5a:	46c0      	nop			; (mov r8, r8)
   16a5c:	00016711 	.word	0x00016711
   16a60:	40000c02 	.word	0x40000c02
   16a64:	40000c00 	.word	0x40000c00
   16a68:	00016725 	.word	0x00016725

00016a6c <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
   16a6c:	b580      	push	{r7, lr}
   16a6e:	b084      	sub	sp, #16
   16a70:	af00      	add	r7, sp, #0
   16a72:	0002      	movs	r2, r0
   16a74:	1dfb      	adds	r3, r7, #7
   16a76:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
   16a78:	4b1c      	ldr	r3, [pc, #112]	; (16aec <system_gclk_chan_disable+0x80>)
   16a7a:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   16a7c:	4a1c      	ldr	r2, [pc, #112]	; (16af0 <system_gclk_chan_disable+0x84>)
   16a7e:	1dfb      	adds	r3, r7, #7
   16a80:	781b      	ldrb	r3, [r3, #0]
   16a82:	7013      	strb	r3, [r2, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
   16a84:	4b1b      	ldr	r3, [pc, #108]	; (16af4 <system_gclk_chan_disable+0x88>)
   16a86:	885b      	ldrh	r3, [r3, #2]
   16a88:	051b      	lsls	r3, r3, #20
   16a8a:	0f1b      	lsrs	r3, r3, #28
   16a8c:	b2db      	uxtb	r3, r3
   16a8e:	60fb      	str	r3, [r7, #12]
	GCLK->CLKCTRL.bit.GEN = 0;
   16a90:	4a18      	ldr	r2, [pc, #96]	; (16af4 <system_gclk_chan_disable+0x88>)
   16a92:	8853      	ldrh	r3, [r2, #2]
   16a94:	4918      	ldr	r1, [pc, #96]	; (16af8 <system_gclk_chan_disable+0x8c>)
   16a96:	400b      	ands	r3, r1
   16a98:	8053      	strh	r3, [r2, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
   16a9a:	4a16      	ldr	r2, [pc, #88]	; (16af4 <system_gclk_chan_disable+0x88>)
   16a9c:	4b15      	ldr	r3, [pc, #84]	; (16af4 <system_gclk_chan_disable+0x88>)
   16a9e:	885b      	ldrh	r3, [r3, #2]
   16aa0:	b29b      	uxth	r3, r3
   16aa2:	4916      	ldr	r1, [pc, #88]	; (16afc <system_gclk_chan_disable+0x90>)
   16aa4:	400b      	ands	r3, r1
   16aa6:	b29b      	uxth	r3, r3
   16aa8:	8053      	strh	r3, [r2, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
   16aaa:	46c0      	nop			; (mov r8, r8)
   16aac:	4b11      	ldr	r3, [pc, #68]	; (16af4 <system_gclk_chan_disable+0x88>)
   16aae:	885b      	ldrh	r3, [r3, #2]
   16ab0:	b29b      	uxth	r3, r3
   16ab2:	001a      	movs	r2, r3
   16ab4:	2380      	movs	r3, #128	; 0x80
   16ab6:	01db      	lsls	r3, r3, #7
   16ab8:	4013      	ands	r3, r2
   16aba:	d1f7      	bne.n	16aac <system_gclk_chan_disable+0x40>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
   16abc:	4a0d      	ldr	r2, [pc, #52]	; (16af4 <system_gclk_chan_disable+0x88>)
   16abe:	68fb      	ldr	r3, [r7, #12]
   16ac0:	b2db      	uxtb	r3, r3
   16ac2:	1c19      	adds	r1, r3, #0
   16ac4:	230f      	movs	r3, #15
   16ac6:	400b      	ands	r3, r1
   16ac8:	b2d9      	uxtb	r1, r3
   16aca:	8853      	ldrh	r3, [r2, #2]
   16acc:	1c08      	adds	r0, r1, #0
   16ace:	210f      	movs	r1, #15
   16ad0:	4001      	ands	r1, r0
   16ad2:	0208      	lsls	r0, r1, #8
   16ad4:	4908      	ldr	r1, [pc, #32]	; (16af8 <system_gclk_chan_disable+0x8c>)
   16ad6:	400b      	ands	r3, r1
   16ad8:	1c19      	adds	r1, r3, #0
   16ada:	1c03      	adds	r3, r0, #0
   16adc:	430b      	orrs	r3, r1
   16ade:	8053      	strh	r3, [r2, #2]

	system_interrupt_leave_critical_section();
   16ae0:	4b07      	ldr	r3, [pc, #28]	; (16b00 <system_gclk_chan_disable+0x94>)
   16ae2:	4798      	blx	r3
}
   16ae4:	46c0      	nop			; (mov r8, r8)
   16ae6:	46bd      	mov	sp, r7
   16ae8:	b004      	add	sp, #16
   16aea:	bd80      	pop	{r7, pc}
   16aec:	00016711 	.word	0x00016711
   16af0:	40000c02 	.word	0x40000c02
   16af4:	40000c00 	.word	0x40000c00
   16af8:	fffff0ff 	.word	0xfffff0ff
   16afc:	ffffbfff 	.word	0xffffbfff
   16b00:	00016725 	.word	0x00016725

00016b04 <system_gclk_chan_lock>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_lock(
		const uint8_t channel)
{
   16b04:	b580      	push	{r7, lr}
   16b06:	b082      	sub	sp, #8
   16b08:	af00      	add	r7, sp, #0
   16b0a:	0002      	movs	r2, r0
   16b0c:	1dfb      	adds	r3, r7, #7
   16b0e:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
   16b10:	4b09      	ldr	r3, [pc, #36]	; (16b38 <system_gclk_chan_lock+0x34>)
   16b12:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   16b14:	4a09      	ldr	r2, [pc, #36]	; (16b3c <system_gclk_chan_lock+0x38>)
   16b16:	1dfb      	adds	r3, r7, #7
   16b18:	781b      	ldrb	r3, [r3, #0]
   16b1a:	7013      	strb	r3, [r2, #0]

	/* Lock the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_WRTLOCK;
   16b1c:	4a08      	ldr	r2, [pc, #32]	; (16b40 <system_gclk_chan_lock+0x3c>)
   16b1e:	4b08      	ldr	r3, [pc, #32]	; (16b40 <system_gclk_chan_lock+0x3c>)
   16b20:	885b      	ldrh	r3, [r3, #2]
   16b22:	b29b      	uxth	r3, r3
   16b24:	4907      	ldr	r1, [pc, #28]	; (16b44 <system_gclk_chan_lock+0x40>)
   16b26:	430b      	orrs	r3, r1
   16b28:	b29b      	uxth	r3, r3
   16b2a:	8053      	strh	r3, [r2, #2]

	system_interrupt_leave_critical_section();
   16b2c:	4b06      	ldr	r3, [pc, #24]	; (16b48 <system_gclk_chan_lock+0x44>)
   16b2e:	4798      	blx	r3
}
   16b30:	46c0      	nop			; (mov r8, r8)
   16b32:	46bd      	mov	sp, r7
   16b34:	b002      	add	sp, #8
   16b36:	bd80      	pop	{r7, pc}
   16b38:	00016711 	.word	0x00016711
   16b3c:	40000c02 	.word	0x40000c02
   16b40:	40000c00 	.word	0x40000c00
   16b44:	ffff8000 	.word	0xffff8000
   16b48:	00016725 	.word	0x00016725

00016b4c <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
   16b4c:	b580      	push	{r7, lr}
   16b4e:	b084      	sub	sp, #16
   16b50:	af00      	add	r7, sp, #0
   16b52:	0002      	movs	r2, r0
   16b54:	1dfb      	adds	r3, r7, #7
   16b56:	701a      	strb	r2, [r3, #0]
	uint8_t gen_id;

	system_interrupt_enter_critical_section();
   16b58:	4b0d      	ldr	r3, [pc, #52]	; (16b90 <system_gclk_chan_get_hz+0x44>)
   16b5a:	4798      	blx	r3

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   16b5c:	4a0d      	ldr	r2, [pc, #52]	; (16b94 <system_gclk_chan_get_hz+0x48>)
   16b5e:	1dfb      	adds	r3, r7, #7
   16b60:	781b      	ldrb	r3, [r3, #0]
   16b62:	7013      	strb	r3, [r2, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
   16b64:	4b0c      	ldr	r3, [pc, #48]	; (16b98 <system_gclk_chan_get_hz+0x4c>)
   16b66:	885b      	ldrh	r3, [r3, #2]
   16b68:	051b      	lsls	r3, r3, #20
   16b6a:	0f1b      	lsrs	r3, r3, #28
   16b6c:	b2da      	uxtb	r2, r3
   16b6e:	230f      	movs	r3, #15
   16b70:	18fb      	adds	r3, r7, r3
   16b72:	701a      	strb	r2, [r3, #0]

	system_interrupt_leave_critical_section();
   16b74:	4b09      	ldr	r3, [pc, #36]	; (16b9c <system_gclk_chan_get_hz+0x50>)
   16b76:	4798      	blx	r3

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
   16b78:	230f      	movs	r3, #15
   16b7a:	18fb      	adds	r3, r7, r3
   16b7c:	781b      	ldrb	r3, [r3, #0]
   16b7e:	0018      	movs	r0, r3
   16b80:	4b07      	ldr	r3, [pc, #28]	; (16ba0 <system_gclk_chan_get_hz+0x54>)
   16b82:	4798      	blx	r3
   16b84:	0003      	movs	r3, r0
}
   16b86:	0018      	movs	r0, r3
   16b88:	46bd      	mov	sp, r7
   16b8a:	b004      	add	sp, #16
   16b8c:	bd80      	pop	{r7, pc}
   16b8e:	46c0      	nop			; (mov r8, r8)
   16b90:	00016711 	.word	0x00016711
   16b94:	40000c02 	.word	0x40000c02
   16b98:	40000c00 	.word	0x40000c00
   16b9c:	00016725 	.word	0x00016725
   16ba0:	00016909 	.word	0x00016909

00016ba4 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   16ba4:	b580      	push	{r7, lr}
   16ba6:	b084      	sub	sp, #16
   16ba8:	af00      	add	r7, sp, #0
   16baa:	0002      	movs	r2, r0
   16bac:	1dfb      	adds	r3, r7, #7
   16bae:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
   16bb0:	230f      	movs	r3, #15
   16bb2:	18fb      	adds	r3, r7, r3
   16bb4:	1dfa      	adds	r2, r7, #7
   16bb6:	7812      	ldrb	r2, [r2, #0]
   16bb8:	09d2      	lsrs	r2, r2, #7
   16bba:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
   16bbc:	230e      	movs	r3, #14
   16bbe:	18fb      	adds	r3, r7, r3
   16bc0:	1dfa      	adds	r2, r7, #7
   16bc2:	7812      	ldrb	r2, [r2, #0]
   16bc4:	0952      	lsrs	r2, r2, #5
   16bc6:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
   16bc8:	4b0d      	ldr	r3, [pc, #52]	; (16c00 <system_pinmux_get_group_from_gpio_pin+0x5c>)
   16bca:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
   16bcc:	230f      	movs	r3, #15
   16bce:	18fb      	adds	r3, r7, r3
   16bd0:	781b      	ldrb	r3, [r3, #0]
   16bd2:	2b00      	cmp	r3, #0
   16bd4:	d10f      	bne.n	16bf6 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
   16bd6:	230f      	movs	r3, #15
   16bd8:	18fb      	adds	r3, r7, r3
   16bda:	781b      	ldrb	r3, [r3, #0]
   16bdc:	009b      	lsls	r3, r3, #2
   16bde:	2210      	movs	r2, #16
   16be0:	4694      	mov	ip, r2
   16be2:	44bc      	add	ip, r7
   16be4:	4463      	add	r3, ip
   16be6:	3b08      	subs	r3, #8
   16be8:	681a      	ldr	r2, [r3, #0]
   16bea:	230e      	movs	r3, #14
   16bec:	18fb      	adds	r3, r7, r3
   16bee:	781b      	ldrb	r3, [r3, #0]
   16bf0:	01db      	lsls	r3, r3, #7
   16bf2:	18d3      	adds	r3, r2, r3
   16bf4:	e000      	b.n	16bf8 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
   16bf6:	2300      	movs	r3, #0
	}
}
   16bf8:	0018      	movs	r0, r3
   16bfa:	46bd      	mov	sp, r7
   16bfc:	b004      	add	sp, #16
   16bfe:	bd80      	pop	{r7, pc}
   16c00:	41004400 	.word	0x41004400

00016c04 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
   16c04:	b580      	push	{r7, lr}
   16c06:	b088      	sub	sp, #32
   16c08:	af00      	add	r7, sp, #0
   16c0a:	60f8      	str	r0, [r7, #12]
   16c0c:	60b9      	str	r1, [r7, #8]
   16c0e:	607a      	str	r2, [r7, #4]
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
   16c10:	2300      	movs	r3, #0
   16c12:	61fb      	str	r3, [r7, #28]

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
   16c14:	687b      	ldr	r3, [r7, #4]
   16c16:	78db      	ldrb	r3, [r3, #3]
   16c18:	2201      	movs	r2, #1
   16c1a:	4053      	eors	r3, r2
   16c1c:	b2db      	uxtb	r3, r3
   16c1e:	2b00      	cmp	r3, #0
   16c20:	d035      	beq.n	16c8e <_system_pinmux_config+0x8a>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
   16c22:	687b      	ldr	r3, [r7, #4]
   16c24:	781b      	ldrb	r3, [r3, #0]
   16c26:	2b80      	cmp	r3, #128	; 0x80
   16c28:	d00b      	beq.n	16c42 <_system_pinmux_config+0x3e>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
   16c2a:	69fb      	ldr	r3, [r7, #28]
   16c2c:	2280      	movs	r2, #128	; 0x80
   16c2e:	0252      	lsls	r2, r2, #9
   16c30:	4313      	orrs	r3, r2
   16c32:	61fb      	str	r3, [r7, #28]
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
   16c34:	687b      	ldr	r3, [r7, #4]
   16c36:	781b      	ldrb	r3, [r3, #0]
   16c38:	061b      	lsls	r3, r3, #24
   16c3a:	001a      	movs	r2, r3
   16c3c:	69fb      	ldr	r3, [r7, #28]
   16c3e:	4313      	orrs	r3, r2
   16c40:	61fb      	str	r3, [r7, #28]
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
   16c42:	687b      	ldr	r3, [r7, #4]
   16c44:	785b      	ldrb	r3, [r3, #1]
   16c46:	2b00      	cmp	r3, #0
   16c48:	d003      	beq.n	16c52 <_system_pinmux_config+0x4e>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
   16c4a:	687b      	ldr	r3, [r7, #4]
   16c4c:	785b      	ldrb	r3, [r3, #1]
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
   16c4e:	2b02      	cmp	r3, #2
   16c50:	d110      	bne.n	16c74 <_system_pinmux_config+0x70>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
   16c52:	69fb      	ldr	r3, [r7, #28]
   16c54:	2280      	movs	r2, #128	; 0x80
   16c56:	0292      	lsls	r2, r2, #10
   16c58:	4313      	orrs	r3, r2
   16c5a:	61fb      	str	r3, [r7, #28]

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
   16c5c:	687b      	ldr	r3, [r7, #4]
   16c5e:	789b      	ldrb	r3, [r3, #2]
   16c60:	2b00      	cmp	r3, #0
   16c62:	d004      	beq.n	16c6e <_system_pinmux_config+0x6a>
				pin_cfg |= PORT_WRCONFIG_PULLEN;
   16c64:	69fb      	ldr	r3, [r7, #28]
   16c66:	2280      	movs	r2, #128	; 0x80
   16c68:	02d2      	lsls	r2, r2, #11
   16c6a:	4313      	orrs	r3, r2
   16c6c:	61fb      	str	r3, [r7, #28]
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
   16c6e:	68fb      	ldr	r3, [r7, #12]
   16c70:	68ba      	ldr	r2, [r7, #8]
   16c72:	605a      	str	r2, [r3, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   16c74:	687b      	ldr	r3, [r7, #4]
   16c76:	785b      	ldrb	r3, [r3, #1]
   16c78:	2b01      	cmp	r3, #1
   16c7a:	d003      	beq.n	16c84 <_system_pinmux_config+0x80>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
   16c7c:	687b      	ldr	r3, [r7, #4]
   16c7e:	785b      	ldrb	r3, [r3, #1]
			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   16c80:	2b02      	cmp	r3, #2
   16c82:	d107      	bne.n	16c94 <_system_pinmux_config+0x90>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
   16c84:	69fb      	ldr	r3, [r7, #28]
   16c86:	4a22      	ldr	r2, [pc, #136]	; (16d10 <_system_pinmux_config+0x10c>)
   16c88:	4013      	ands	r3, r2
   16c8a:	61fb      	str	r3, [r7, #28]
   16c8c:	e002      	b.n	16c94 <_system_pinmux_config+0x90>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
   16c8e:	68fb      	ldr	r3, [r7, #12]
   16c90:	68ba      	ldr	r2, [r7, #8]
   16c92:	605a      	str	r2, [r3, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
   16c94:	68bb      	ldr	r3, [r7, #8]
   16c96:	041b      	lsls	r3, r3, #16
   16c98:	0c1b      	lsrs	r3, r3, #16
   16c9a:	61bb      	str	r3, [r7, #24]
	uint32_t upper_pin_mask = (pin_mask >> 16);
   16c9c:	68bb      	ldr	r3, [r7, #8]
   16c9e:	0c1b      	lsrs	r3, r3, #16
   16ca0:	617b      	str	r3, [r7, #20]

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   16ca2:	69ba      	ldr	r2, [r7, #24]
   16ca4:	69fb      	ldr	r3, [r7, #28]
   16ca6:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
   16ca8:	22a0      	movs	r2, #160	; 0xa0
   16caa:	05d2      	lsls	r2, r2, #23
   16cac:	431a      	orrs	r2, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   16cae:	68fb      	ldr	r3, [r7, #12]
   16cb0:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   16cb2:	697a      	ldr	r2, [r7, #20]
   16cb4:	69fb      	ldr	r3, [r7, #28]
   16cb6:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
   16cb8:	22d0      	movs	r2, #208	; 0xd0
   16cba:	0612      	lsls	r2, r2, #24
   16cbc:	431a      	orrs	r2, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   16cbe:	68fb      	ldr	r3, [r7, #12]
   16cc0:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
   16cc2:	687b      	ldr	r3, [r7, #4]
   16cc4:	78db      	ldrb	r3, [r3, #3]
   16cc6:	2201      	movs	r2, #1
   16cc8:	4053      	eors	r3, r2
   16cca:	b2db      	uxtb	r3, r3
   16ccc:	2b00      	cmp	r3, #0
   16cce:	d01a      	beq.n	16d06 <_system_pinmux_config+0x102>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
   16cd0:	69fa      	ldr	r2, [r7, #28]
   16cd2:	2380      	movs	r3, #128	; 0x80
   16cd4:	02db      	lsls	r3, r3, #11
   16cd6:	4013      	ands	r3, r2
   16cd8:	d00a      	beq.n	16cf0 <_system_pinmux_config+0xec>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
   16cda:	687b      	ldr	r3, [r7, #4]
   16cdc:	789b      	ldrb	r3, [r3, #2]
   16cde:	2b01      	cmp	r3, #1
   16ce0:	d103      	bne.n	16cea <_system_pinmux_config+0xe6>
				port->OUTSET.reg = pin_mask;
   16ce2:	68fb      	ldr	r3, [r7, #12]
   16ce4:	68ba      	ldr	r2, [r7, #8]
   16ce6:	619a      	str	r2, [r3, #24]
   16ce8:	e002      	b.n	16cf0 <_system_pinmux_config+0xec>
			} else {
				port->OUTCLR.reg = pin_mask;
   16cea:	68fb      	ldr	r3, [r7, #12]
   16cec:	68ba      	ldr	r2, [r7, #8]
   16cee:	615a      	str	r2, [r3, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   16cf0:	687b      	ldr	r3, [r7, #4]
   16cf2:	785b      	ldrb	r3, [r3, #1]
   16cf4:	2b01      	cmp	r3, #1
   16cf6:	d003      	beq.n	16d00 <_system_pinmux_config+0xfc>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
   16cf8:	687b      	ldr	r3, [r7, #4]
   16cfa:	785b      	ldrb	r3, [r3, #1]
				port->OUTCLR.reg = pin_mask;
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   16cfc:	2b02      	cmp	r3, #2
   16cfe:	d102      	bne.n	16d06 <_system_pinmux_config+0x102>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
   16d00:	68fb      	ldr	r3, [r7, #12]
   16d02:	68ba      	ldr	r2, [r7, #8]
   16d04:	609a      	str	r2, [r3, #8]
		}
	}
}
   16d06:	46c0      	nop			; (mov r8, r8)
   16d08:	46bd      	mov	sp, r7
   16d0a:	b008      	add	sp, #32
   16d0c:	bd80      	pop	{r7, pc}
   16d0e:	46c0      	nop			; (mov r8, r8)
   16d10:	fffbffff 	.word	0xfffbffff

00016d14 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
   16d14:	b580      	push	{r7, lr}
   16d16:	b084      	sub	sp, #16
   16d18:	af00      	add	r7, sp, #0
   16d1a:	0002      	movs	r2, r0
   16d1c:	6039      	str	r1, [r7, #0]
   16d1e:	1dfb      	adds	r3, r7, #7
   16d20:	701a      	strb	r2, [r3, #0]
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
   16d22:	1dfb      	adds	r3, r7, #7
   16d24:	781b      	ldrb	r3, [r3, #0]
   16d26:	0018      	movs	r0, r3
   16d28:	4b0a      	ldr	r3, [pc, #40]	; (16d54 <system_pinmux_pin_set_config+0x40>)
   16d2a:	4798      	blx	r3
   16d2c:	0003      	movs	r3, r0
   16d2e:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
   16d30:	1dfb      	adds	r3, r7, #7
   16d32:	781b      	ldrb	r3, [r3, #0]
   16d34:	221f      	movs	r2, #31
   16d36:	4013      	ands	r3, r2
   16d38:	2201      	movs	r2, #1
   16d3a:	409a      	lsls	r2, r3
   16d3c:	0013      	movs	r3, r2
   16d3e:	60bb      	str	r3, [r7, #8]

	_system_pinmux_config(port, pin_mask, config);
   16d40:	683a      	ldr	r2, [r7, #0]
   16d42:	68b9      	ldr	r1, [r7, #8]
   16d44:	68fb      	ldr	r3, [r7, #12]
   16d46:	0018      	movs	r0, r3
   16d48:	4b03      	ldr	r3, [pc, #12]	; (16d58 <system_pinmux_pin_set_config+0x44>)
   16d4a:	4798      	blx	r3
}
   16d4c:	46c0      	nop			; (mov r8, r8)
   16d4e:	46bd      	mov	sp, r7
   16d50:	b004      	add	sp, #16
   16d52:	bd80      	pop	{r7, pc}
   16d54:	00016ba5 	.word	0x00016ba5
   16d58:	00016c05 	.word	0x00016c05

00016d5c <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
   16d5c:	b580      	push	{r7, lr}
   16d5e:	af00      	add	r7, sp, #0
	/* Configure GCLK and clock sources according to conf_clocks.h */
    system_clock_init();
   16d60:	4b04      	ldr	r3, [pc, #16]	; (16d74 <system_init+0x18>)
   16d62:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
   16d64:	4b04      	ldr	r3, [pc, #16]	; (16d78 <system_init+0x1c>)
   16d66:	4798      	blx	r3
	
	/* Initialize EVSYS hardware */
	//_system_events_init();

	/* Initialize External hardware */
	_system_extint_init();
   16d68:	4b04      	ldr	r3, [pc, #16]	; (16d7c <system_init+0x20>)
   16d6a:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	//_system_divas_init();
}
   16d6c:	46c0      	nop			; (mov r8, r8)
   16d6e:	46bd      	mov	sp, r7
   16d70:	bd80      	pop	{r7, pc}
   16d72:	46c0      	nop			; (mov r8, r8)
   16d74:	000163fd 	.word	0x000163fd
   16d78:	000134d5 	.word	0x000134d5
   16d7c:	0000e9d9 	.word	0x0000e9d9

00016d80 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   16d80:	b580      	push	{r7, lr}
   16d82:	b082      	sub	sp, #8
   16d84:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
   16d86:	4b2f      	ldr	r3, [pc, #188]	; (16e44 <Reset_Handler+0xc4>)
   16d88:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
   16d8a:	4b2f      	ldr	r3, [pc, #188]	; (16e48 <Reset_Handler+0xc8>)
   16d8c:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
   16d8e:	687a      	ldr	r2, [r7, #4]
   16d90:	683b      	ldr	r3, [r7, #0]
   16d92:	429a      	cmp	r2, r3
   16d94:	d00c      	beq.n	16db0 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
   16d96:	e007      	b.n	16da8 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
   16d98:	683b      	ldr	r3, [r7, #0]
   16d9a:	1d1a      	adds	r2, r3, #4
   16d9c:	603a      	str	r2, [r7, #0]
   16d9e:	687a      	ldr	r2, [r7, #4]
   16da0:	1d11      	adds	r1, r2, #4
   16da2:	6079      	str	r1, [r7, #4]
   16da4:	6812      	ldr	r2, [r2, #0]
   16da6:	601a      	str	r2, [r3, #0]
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
   16da8:	683a      	ldr	r2, [r7, #0]
   16daa:	4b28      	ldr	r3, [pc, #160]	; (16e4c <Reset_Handler+0xcc>)
   16dac:	429a      	cmp	r2, r3
   16dae:	d3f3      	bcc.n	16d98 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   16db0:	4b27      	ldr	r3, [pc, #156]	; (16e50 <Reset_Handler+0xd0>)
   16db2:	603b      	str	r3, [r7, #0]
   16db4:	e004      	b.n	16dc0 <Reset_Handler+0x40>
                *pDest++ = 0;
   16db6:	683b      	ldr	r3, [r7, #0]
   16db8:	1d1a      	adds	r2, r3, #4
   16dba:	603a      	str	r2, [r7, #0]
   16dbc:	2200      	movs	r2, #0
   16dbe:	601a      	str	r2, [r3, #0]
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   16dc0:	683a      	ldr	r2, [r7, #0]
   16dc2:	4b24      	ldr	r3, [pc, #144]	; (16e54 <Reset_Handler+0xd4>)
   16dc4:	429a      	cmp	r2, r3
   16dc6:	d3f6      	bcc.n	16db6 <Reset_Handler+0x36>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
   16dc8:	4b23      	ldr	r3, [pc, #140]	; (16e58 <Reset_Handler+0xd8>)
   16dca:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   16dcc:	4b23      	ldr	r3, [pc, #140]	; (16e5c <Reset_Handler+0xdc>)
   16dce:	687a      	ldr	r2, [r7, #4]
   16dd0:	21ff      	movs	r1, #255	; 0xff
   16dd2:	438a      	bics	r2, r1
   16dd4:	609a      	str	r2, [r3, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
   16dd6:	4a22      	ldr	r2, [pc, #136]	; (16e60 <Reset_Handler+0xe0>)
   16dd8:	2390      	movs	r3, #144	; 0x90
   16dda:	005b      	lsls	r3, r3, #1
   16ddc:	2102      	movs	r1, #2
   16dde:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
   16de0:	4a20      	ldr	r2, [pc, #128]	; (16e64 <Reset_Handler+0xe4>)
   16de2:	78d3      	ldrb	r3, [r2, #3]
   16de4:	2103      	movs	r1, #3
   16de6:	438b      	bics	r3, r1
   16de8:	1c19      	adds	r1, r3, #0
   16dea:	2302      	movs	r3, #2
   16dec:	430b      	orrs	r3, r1
   16dee:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
   16df0:	4a1c      	ldr	r2, [pc, #112]	; (16e64 <Reset_Handler+0xe4>)
   16df2:	78d3      	ldrb	r3, [r2, #3]
   16df4:	210c      	movs	r1, #12
   16df6:	438b      	bics	r3, r1
   16df8:	1c19      	adds	r1, r3, #0
   16dfa:	2308      	movs	r3, #8
   16dfc:	430b      	orrs	r3, r1
   16dfe:	70d3      	strb	r3, [r2, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
   16e00:	4a19      	ldr	r2, [pc, #100]	; (16e68 <Reset_Handler+0xe8>)
   16e02:	7b93      	ldrb	r3, [r2, #14]
   16e04:	2130      	movs	r1, #48	; 0x30
   16e06:	438b      	bics	r3, r1
   16e08:	1c19      	adds	r1, r3, #0
   16e0a:	2320      	movs	r3, #32
   16e0c:	430b      	orrs	r3, r1
   16e0e:	7393      	strb	r3, [r2, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
   16e10:	4a15      	ldr	r2, [pc, #84]	; (16e68 <Reset_Handler+0xe8>)
   16e12:	7b93      	ldrb	r3, [r2, #14]
   16e14:	210c      	movs	r1, #12
   16e16:	438b      	bics	r3, r1
   16e18:	1c19      	adds	r1, r3, #0
   16e1a:	2308      	movs	r3, #8
   16e1c:	430b      	orrs	r3, r1
   16e1e:	7393      	strb	r3, [r2, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
   16e20:	4a11      	ldr	r2, [pc, #68]	; (16e68 <Reset_Handler+0xe8>)
   16e22:	7b93      	ldrb	r3, [r2, #14]
   16e24:	2103      	movs	r1, #3
   16e26:	438b      	bics	r3, r1
   16e28:	1c19      	adds	r1, r3, #0
   16e2a:	2302      	movs	r3, #2
   16e2c:	430b      	orrs	r3, r1
   16e2e:	7393      	strb	r3, [r2, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
   16e30:	4a0e      	ldr	r2, [pc, #56]	; (16e6c <Reset_Handler+0xec>)
   16e32:	6853      	ldr	r3, [r2, #4]
   16e34:	2180      	movs	r1, #128	; 0x80
   16e36:	430b      	orrs	r3, r1
   16e38:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
   16e3a:	4b0d      	ldr	r3, [pc, #52]	; (16e70 <Reset_Handler+0xf0>)
   16e3c:	4798      	blx	r3

        /* Branch to main function */
        main();
   16e3e:	4b0d      	ldr	r3, [pc, #52]	; (16e74 <Reset_Handler+0xf4>)
   16e40:	4798      	blx	r3

        /* Infinite loop */
        while (1);
   16e42:	e7fe      	b.n	16e42 <Reset_Handler+0xc2>
   16e44:	00022160 	.word	0x00022160
   16e48:	20000000 	.word	0x20000000
   16e4c:	200004c8 	.word	0x200004c8
   16e50:	200004e0 	.word	0x200004e0
   16e54:	20004df0 	.word	0x20004df0
   16e58:	00008000 	.word	0x00008000
   16e5c:	e000ed00 	.word	0xe000ed00
   16e60:	41007000 	.word	0x41007000
   16e64:	41005000 	.word	0x41005000
   16e68:	41004800 	.word	0x41004800
   16e6c:	41004000 	.word	0x41004000
   16e70:	0001ec05 	.word	0x0001ec05
   16e74:	0001d3f1 	.word	0x0001d3f1

00016e78 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
   16e78:	b580      	push	{r7, lr}
   16e7a:	af00      	add	r7, sp, #0
        while (1) {
        }
   16e7c:	e7fe      	b.n	16e7c <Dummy_Handler+0x4>
   16e7e:	46c0      	nop			; (mov r8, r8)

00016e80 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
   16e80:	b580      	push	{r7, lr}
   16e82:	b084      	sub	sp, #16
   16e84:	af00      	add	r7, sp, #0
   16e86:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
   16e88:	4b0a      	ldr	r3, [pc, #40]	; (16eb4 <_sbrk+0x34>)
   16e8a:	681b      	ldr	r3, [r3, #0]
   16e8c:	2b00      	cmp	r3, #0
   16e8e:	d102      	bne.n	16e96 <_sbrk+0x16>
		heap = (unsigned char *)&_end;
   16e90:	4b08      	ldr	r3, [pc, #32]	; (16eb4 <_sbrk+0x34>)
   16e92:	4a09      	ldr	r2, [pc, #36]	; (16eb8 <_sbrk+0x38>)
   16e94:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
   16e96:	4b07      	ldr	r3, [pc, #28]	; (16eb4 <_sbrk+0x34>)
   16e98:	681b      	ldr	r3, [r3, #0]
   16e9a:	60fb      	str	r3, [r7, #12]

	heap += incr;
   16e9c:	4b05      	ldr	r3, [pc, #20]	; (16eb4 <_sbrk+0x34>)
   16e9e:	681a      	ldr	r2, [r3, #0]
   16ea0:	687b      	ldr	r3, [r7, #4]
   16ea2:	18d2      	adds	r2, r2, r3
   16ea4:	4b03      	ldr	r3, [pc, #12]	; (16eb4 <_sbrk+0x34>)
   16ea6:	601a      	str	r2, [r3, #0]

	return (caddr_t) prev_heap;
   16ea8:	68fb      	ldr	r3, [r7, #12]
}
   16eaa:	0018      	movs	r0, r3
   16eac:	46bd      	mov	sp, r7
   16eae:	b004      	add	sp, #16
   16eb0:	bd80      	pop	{r7, pc}
   16eb2:	46c0      	nop			; (mov r8, r8)
   16eb4:	20002e68 	.word	0x20002e68
   16eb8:	200055f0 	.word	0x200055f0

00016ebc <rtc_calendar_get_time_defaults>:
 *
 * \param[out] time  Time structure to initialize
 */
static inline void rtc_calendar_get_time_defaults(
		struct rtc_calendar_time *const time)
{
   16ebc:	b580      	push	{r7, lr}
   16ebe:	b082      	sub	sp, #8
   16ec0:	af00      	add	r7, sp, #0
   16ec2:	6078      	str	r0, [r7, #4]
	time->second = 0;
   16ec4:	687b      	ldr	r3, [r7, #4]
   16ec6:	2200      	movs	r2, #0
   16ec8:	701a      	strb	r2, [r3, #0]
	time->minute = 0;
   16eca:	687b      	ldr	r3, [r7, #4]
   16ecc:	2200      	movs	r2, #0
   16ece:	705a      	strb	r2, [r3, #1]
	time->hour   = 0;
   16ed0:	687b      	ldr	r3, [r7, #4]
   16ed2:	2200      	movs	r2, #0
   16ed4:	709a      	strb	r2, [r3, #2]
	time->pm     = 0;
   16ed6:	687b      	ldr	r3, [r7, #4]
   16ed8:	2200      	movs	r2, #0
   16eda:	70da      	strb	r2, [r3, #3]
	time->day    = 1;
   16edc:	687b      	ldr	r3, [r7, #4]
   16ede:	2201      	movs	r2, #1
   16ee0:	711a      	strb	r2, [r3, #4]
	time->month  = 1;
   16ee2:	687b      	ldr	r3, [r7, #4]
   16ee4:	2201      	movs	r2, #1
   16ee6:	715a      	strb	r2, [r3, #5]
	time->year   = 2000;
   16ee8:	687b      	ldr	r3, [r7, #4]
   16eea:	22fa      	movs	r2, #250	; 0xfa
   16eec:	00d2      	lsls	r2, r2, #3
   16eee:	80da      	strh	r2, [r3, #6]
}
   16ef0:	46c0      	nop			; (mov r8, r8)
   16ef2:	46bd      	mov	sp, r7
   16ef4:	b002      	add	sp, #8
   16ef6:	bd80      	pop	{r7, pc}

00016ef8 <rtc_calendar_get_config_defaults>:
 *  \param[out] config  Configuration structure to be initialized to default
 *                      values
 */
static inline void rtc_calendar_get_config_defaults(
		struct rtc_calendar_config *const config)
{
   16ef8:	b580      	push	{r7, lr}
   16efa:	b086      	sub	sp, #24
   16efc:	af00      	add	r7, sp, #0
   16efe:	6078      	str	r0, [r7, #4]
	/* Sanity check argument */
	Assert(config);

	/* Initialize and set time structure to default */
	struct rtc_calendar_time time;
	rtc_calendar_get_time_defaults(&time);
   16f00:	230c      	movs	r3, #12
   16f02:	18fb      	adds	r3, r7, r3
   16f04:	0018      	movs	r0, r3
   16f06:	4b23      	ldr	r3, [pc, #140]	; (16f94 <rtc_calendar_get_config_defaults+0x9c>)
   16f08:	4798      	blx	r3

	/* Set defaults into configuration structure */
	config->prescaler           = RTC_CALENDAR_PRESCALER_DIV_1024;
   16f0a:	687b      	ldr	r3, [r7, #4]
   16f0c:	22a0      	movs	r2, #160	; 0xa0
   16f0e:	0112      	lsls	r2, r2, #4
   16f10:	801a      	strh	r2, [r3, #0]
	config->clear_on_match      = false;
   16f12:	687b      	ldr	r3, [r7, #4]
   16f14:	2200      	movs	r2, #0
   16f16:	709a      	strb	r2, [r3, #2]
#ifdef FEATURE_RTC_CONTINUOUSLY_UPDATED
	config->continuously_update = false;
   16f18:	687b      	ldr	r3, [r7, #4]
   16f1a:	2200      	movs	r2, #0
   16f1c:	70da      	strb	r2, [r3, #3]
#endif
	config->clock_24h           = false;
   16f1e:	687b      	ldr	r3, [r7, #4]
   16f20:	2200      	movs	r2, #0
   16f22:	711a      	strb	r2, [r3, #4]
	config->year_init_value     = 2000;
   16f24:	687b      	ldr	r3, [r7, #4]
   16f26:	22fa      	movs	r2, #250	; 0xfa
   16f28:	00d2      	lsls	r2, r2, #3
   16f2a:	80da      	strh	r2, [r3, #6]
#if (SAML22)
	config->enable_read_sync    = true;
#endif
	for (uint8_t i = 0; i < RTC_NUM_OF_ALARMS; i++) {
   16f2c:	2317      	movs	r3, #23
   16f2e:	18fb      	adds	r3, r7, r3
   16f30:	2200      	movs	r2, #0
   16f32:	701a      	strb	r2, [r3, #0]
   16f34:	e025      	b.n	16f82 <rtc_calendar_get_config_defaults+0x8a>
		config->alarm[i].time = time;
   16f36:	2317      	movs	r3, #23
   16f38:	18fb      	adds	r3, r7, r3
   16f3a:	781a      	ldrb	r2, [r3, #0]
   16f3c:	6879      	ldr	r1, [r7, #4]
   16f3e:	2008      	movs	r0, #8
   16f40:	0013      	movs	r3, r2
   16f42:	005b      	lsls	r3, r3, #1
   16f44:	189b      	adds	r3, r3, r2
   16f46:	009b      	lsls	r3, r3, #2
   16f48:	18cb      	adds	r3, r1, r3
   16f4a:	181a      	adds	r2, r3, r0
   16f4c:	230c      	movs	r3, #12
   16f4e:	18fb      	adds	r3, r7, r3
   16f50:	0010      	movs	r0, r2
   16f52:	0019      	movs	r1, r3
   16f54:	230a      	movs	r3, #10
   16f56:	001a      	movs	r2, r3
   16f58:	4b0f      	ldr	r3, [pc, #60]	; (16f98 <rtc_calendar_get_config_defaults+0xa0>)
   16f5a:	4798      	blx	r3
		config->alarm[i].mask = RTC_CALENDAR_ALARM_MASK_YEAR;
   16f5c:	2317      	movs	r3, #23
   16f5e:	18fb      	adds	r3, r7, r3
   16f60:	781a      	ldrb	r2, [r3, #0]
   16f62:	6879      	ldr	r1, [r7, #4]
   16f64:	0013      	movs	r3, r2
   16f66:	005b      	lsls	r3, r3, #1
   16f68:	189b      	adds	r3, r3, r2
   16f6a:	009b      	lsls	r3, r3, #2
   16f6c:	18cb      	adds	r3, r1, r3
   16f6e:	3312      	adds	r3, #18
   16f70:	2206      	movs	r2, #6
   16f72:	701a      	strb	r2, [r3, #0]
	config->clock_24h           = false;
	config->year_init_value     = 2000;
#if (SAML22)
	config->enable_read_sync    = true;
#endif
	for (uint8_t i = 0; i < RTC_NUM_OF_ALARMS; i++) {
   16f74:	2317      	movs	r3, #23
   16f76:	18fb      	adds	r3, r7, r3
   16f78:	781a      	ldrb	r2, [r3, #0]
   16f7a:	2317      	movs	r3, #23
   16f7c:	18fb      	adds	r3, r7, r3
   16f7e:	3201      	adds	r2, #1
   16f80:	701a      	strb	r2, [r3, #0]
   16f82:	2317      	movs	r3, #23
   16f84:	18fb      	adds	r3, r7, r3
   16f86:	781b      	ldrb	r3, [r3, #0]
   16f88:	2b00      	cmp	r3, #0
   16f8a:	d0d4      	beq.n	16f36 <rtc_calendar_get_config_defaults+0x3e>
		config->alarm[i].time = time;
		config->alarm[i].mask = RTC_CALENDAR_ALARM_MASK_YEAR;
	}
}
   16f8c:	46c0      	nop			; (mov r8, r8)
   16f8e:	46bd      	mov	sp, r7
   16f90:	b006      	add	sp, #24
   16f92:	bd80      	pop	{r7, pc}
   16f94:	00016ebd 	.word	0x00016ebd
   16f98:	0001ee9b 	.word	0x0001ee9b

00016f9c <configure_rtc_calendar>:
#if (SAM0)
# include <rtc_calendar.h>
struct rtc_module rtc_instance;

static void configure_rtc_calendar(void)
{
   16f9c:	b580      	push	{r7, lr}
   16f9e:	b088      	sub	sp, #32
   16fa0:	af00      	add	r7, sp, #0
	/* Initialize RTC in calendar mode. */
	struct rtc_calendar_config config_rtc_calendar;

	rtc_calendar_get_config_defaults(&config_rtc_calendar);
   16fa2:	230c      	movs	r3, #12
   16fa4:	18fb      	adds	r3, r7, r3
   16fa6:	0018      	movs	r0, r3
   16fa8:	4b1b      	ldr	r3, [pc, #108]	; (17018 <configure_rtc_calendar+0x7c>)
   16faa:	4798      	blx	r3

	struct rtc_calendar_time init_time;
	rtc_calendar_get_time_defaults(&init_time);
   16fac:	003b      	movs	r3, r7
   16fae:	0018      	movs	r0, r3
   16fb0:	4b1a      	ldr	r3, [pc, #104]	; (1701c <configure_rtc_calendar+0x80>)
   16fb2:	4798      	blx	r3
	init_time.year   = 2014;
   16fb4:	003b      	movs	r3, r7
   16fb6:	4a1a      	ldr	r2, [pc, #104]	; (17020 <configure_rtc_calendar+0x84>)
   16fb8:	80da      	strh	r2, [r3, #6]
	init_time.month  = 1;
   16fba:	003b      	movs	r3, r7
   16fbc:	2201      	movs	r2, #1
   16fbe:	715a      	strb	r2, [r3, #5]
	init_time.day    = 1;
   16fc0:	003b      	movs	r3, r7
   16fc2:	2201      	movs	r2, #1
   16fc4:	711a      	strb	r2, [r3, #4]
	init_time.hour   = 0;
   16fc6:	003b      	movs	r3, r7
   16fc8:	2200      	movs	r2, #0
   16fca:	709a      	strb	r2, [r3, #2]
	init_time.minute = 0;
   16fcc:	003b      	movs	r3, r7
   16fce:	2200      	movs	r2, #0
   16fd0:	705a      	strb	r2, [r3, #1]
	init_time.second = 4;
   16fd2:	003b      	movs	r3, r7
   16fd4:	2204      	movs	r2, #4
   16fd6:	701a      	strb	r2, [r3, #0]

	config_rtc_calendar.clock_24h     = true;
   16fd8:	230c      	movs	r3, #12
   16fda:	18fb      	adds	r3, r7, r3
   16fdc:	2201      	movs	r2, #1
   16fde:	711a      	strb	r2, [r3, #4]
	config_rtc_calendar.alarm[0].time = init_time;
   16fe0:	230c      	movs	r3, #12
   16fe2:	18fb      	adds	r3, r7, r3
   16fe4:	003a      	movs	r2, r7
   16fe6:	3308      	adds	r3, #8
   16fe8:	ca03      	ldmia	r2!, {r0, r1}
   16fea:	c303      	stmia	r3!, {r0, r1}
   16fec:	8812      	ldrh	r2, [r2, #0]
   16fee:	801a      	strh	r2, [r3, #0]
	config_rtc_calendar.alarm[0].mask = RTC_CALENDAR_ALARM_MASK_YEAR;
   16ff0:	230c      	movs	r3, #12
   16ff2:	18fb      	adds	r3, r7, r3
   16ff4:	2206      	movs	r2, #6
   16ff6:	749a      	strb	r2, [r3, #18]

	rtc_calendar_init(&rtc_instance, RTC, &config_rtc_calendar);
   16ff8:	230c      	movs	r3, #12
   16ffa:	18fa      	adds	r2, r7, r3
   16ffc:	4909      	ldr	r1, [pc, #36]	; (17024 <configure_rtc_calendar+0x88>)
   16ffe:	4b0a      	ldr	r3, [pc, #40]	; (17028 <configure_rtc_calendar+0x8c>)
   17000:	0018      	movs	r0, r3
   17002:	4b0a      	ldr	r3, [pc, #40]	; (1702c <configure_rtc_calendar+0x90>)
   17004:	4798      	blx	r3

	rtc_calendar_enable(&rtc_instance);
   17006:	4b08      	ldr	r3, [pc, #32]	; (17028 <configure_rtc_calendar+0x8c>)
   17008:	0018      	movs	r0, r3
   1700a:	4b09      	ldr	r3, [pc, #36]	; (17030 <configure_rtc_calendar+0x94>)
   1700c:	4798      	blx	r3
}
   1700e:	46c0      	nop			; (mov r8, r8)
   17010:	46bd      	mov	sp, r7
   17012:	b008      	add	sp, #32
   17014:	bd80      	pop	{r7, pc}
   17016:	46c0      	nop			; (mov r8, r8)
   17018:	00016ef9 	.word	0x00016ef9
   1701c:	00016ebd 	.word	0x00016ebd
   17020:	000007de 	.word	0x000007de
   17024:	40001400 	.word	0x40001400
   17028:	20004bc8 	.word	0x20004bc8
   1702c:	000138fd 	.word	0x000138fd
   17030:	00013659 	.word	0x00013659

00017034 <disk_initialize>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
   17034:	b590      	push	{r4, r7, lr}
   17036:	b085      	sub	sp, #20
   17038:	af00      	add	r7, sp, #0
   1703a:	0002      	movs	r2, r0
   1703c:	1dfb      	adds	r3, r7, #7
   1703e:	701a      	strb	r2, [r3, #0]
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
#endif

#if (SAMD20 || SAMD21 || SAMR21)
	configure_rtc_calendar();
   17040:	4b1a      	ldr	r3, [pc, #104]	; (170ac <disk_initialize+0x78>)
   17042:	4798      	blx	r3
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
   17044:	1dfb      	adds	r3, r7, #7
   17046:	781b      	ldrb	r3, [r3, #0]
   17048:	2b01      	cmp	r3, #1
   1704a:	d901      	bls.n	17050 <disk_initialize+0x1c>
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
   1704c:	2301      	movs	r3, #1
   1704e:	e029      	b.n	170a4 <disk_initialize+0x70>
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
   17050:	2300      	movs	r3, #0
   17052:	60fb      	str	r3, [r7, #12]
   17054:	e010      	b.n	17078 <disk_initialize+0x44>
		mem_status = mem_test_unit_ready(drv);
   17056:	230b      	movs	r3, #11
   17058:	18fc      	adds	r4, r7, r3
   1705a:	1dfb      	adds	r3, r7, #7
   1705c:	781b      	ldrb	r3, [r3, #0]
   1705e:	0018      	movs	r0, r3
   17060:	4b13      	ldr	r3, [pc, #76]	; (170b0 <disk_initialize+0x7c>)
   17062:	4798      	blx	r3
   17064:	0003      	movs	r3, r0
   17066:	7023      	strb	r3, [r4, #0]
		if (CTRL_BUSY != mem_status) {
   17068:	230b      	movs	r3, #11
   1706a:	18fb      	adds	r3, r7, r3
   1706c:	781b      	ldrb	r3, [r3, #0]
   1706e:	2b03      	cmp	r3, #3
   17070:	d106      	bne.n	17080 <disk_initialize+0x4c>
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
   17072:	68fb      	ldr	r3, [r7, #12]
   17074:	3301      	adds	r3, #1
   17076:	60fb      	str	r3, [r7, #12]
   17078:	68fb      	ldr	r3, [r7, #12]
   1707a:	2b01      	cmp	r3, #1
   1707c:	ddeb      	ble.n	17056 <disk_initialize+0x22>
   1707e:	e000      	b.n	17082 <disk_initialize+0x4e>
		mem_status = mem_test_unit_ready(drv);
		if (CTRL_BUSY != mem_status) {
			break;
   17080:	46c0      	nop			; (mov r8, r8)
		}
	}
	if (mem_status != CTRL_GOOD) {
   17082:	230b      	movs	r3, #11
   17084:	18fb      	adds	r3, r7, r3
   17086:	781b      	ldrb	r3, [r3, #0]
   17088:	2b00      	cmp	r3, #0
   1708a:	d001      	beq.n	17090 <disk_initialize+0x5c>
		return STA_NOINIT;
   1708c:	2301      	movs	r3, #1
   1708e:	e009      	b.n	170a4 <disk_initialize+0x70>
	}

	/* Check Write Protection Status */
	if (mem_wr_protect(drv)) {
   17090:	1dfb      	adds	r3, r7, #7
   17092:	781b      	ldrb	r3, [r3, #0]
   17094:	0018      	movs	r0, r3
   17096:	4b07      	ldr	r3, [pc, #28]	; (170b4 <disk_initialize+0x80>)
   17098:	4798      	blx	r3
   1709a:	1e03      	subs	r3, r0, #0
   1709c:	d001      	beq.n	170a2 <disk_initialize+0x6e>
		return STA_PROTECT;
   1709e:	2304      	movs	r3, #4
   170a0:	e000      	b.n	170a4 <disk_initialize+0x70>
	}

	/* The memory should already be initialized */
	return 0;
   170a2:	2300      	movs	r3, #0
}
   170a4:	0018      	movs	r0, r3
   170a6:	46bd      	mov	sp, r7
   170a8:	b005      	add	sp, #20
   170aa:	bd90      	pop	{r4, r7, pc}
   170ac:	00016f9d 	.word	0x00016f9d
   170b0:	0001319d 	.word	0x0001319d
   170b4:	00013255 	.word	0x00013255

000170b8 <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
   170b8:	b580      	push	{r7, lr}
   170ba:	b082      	sub	sp, #8
   170bc:	af00      	add	r7, sp, #0
   170be:	0002      	movs	r2, r0
   170c0:	1dfb      	adds	r3, r7, #7
   170c2:	701a      	strb	r2, [r3, #0]
	switch (mem_test_unit_ready(drv)) {
   170c4:	1dfb      	adds	r3, r7, #7
   170c6:	781b      	ldrb	r3, [r3, #0]
   170c8:	0018      	movs	r0, r3
   170ca:	4b08      	ldr	r3, [pc, #32]	; (170ec <disk_status+0x34>)
   170cc:	4798      	blx	r3
   170ce:	1e03      	subs	r3, r0, #0
   170d0:	d002      	beq.n	170d8 <disk_status+0x20>
   170d2:	2b02      	cmp	r3, #2
   170d4:	d002      	beq.n	170dc <disk_status+0x24>
   170d6:	e003      	b.n	170e0 <disk_status+0x28>
	case CTRL_GOOD:
		return 0;
   170d8:	2300      	movs	r3, #0
   170da:	e002      	b.n	170e2 <disk_status+0x2a>
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
   170dc:	2303      	movs	r3, #3
   170de:	e000      	b.n	170e2 <disk_status+0x2a>
	default:
		return STA_NOINIT;
   170e0:	2301      	movs	r3, #1
	}
}
   170e2:	0018      	movs	r0, r3
   170e4:	46bd      	mov	sp, r7
   170e6:	b002      	add	sp, #8
   170e8:	bd80      	pop	{r7, pc}
   170ea:	46c0      	nop			; (mov r8, r8)
   170ec:	0001319d 	.word	0x0001319d

000170f0 <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, UINT count)
{
   170f0:	b590      	push	{r4, r7, lr}
   170f2:	b089      	sub	sp, #36	; 0x24
   170f4:	af00      	add	r7, sp, #0
   170f6:	60b9      	str	r1, [r7, #8]
   170f8:	607a      	str	r2, [r7, #4]
   170fa:	603b      	str	r3, [r7, #0]
   170fc:	230f      	movs	r3, #15
   170fe:	18fb      	adds	r3, r7, r3
   17100:	1c02      	adds	r2, r0, #0
   17102:	701a      	strb	r2, [r3, #0]
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
   17104:	231b      	movs	r3, #27
   17106:	18fc      	adds	r4, r7, r3
   17108:	230f      	movs	r3, #15
   1710a:	18fb      	adds	r3, r7, r3
   1710c:	781b      	ldrb	r3, [r3, #0]
   1710e:	0018      	movs	r0, r3
   17110:	4b26      	ldr	r3, [pc, #152]	; (171ac <disk_read+0xbc>)
   17112:	4798      	blx	r3
   17114:	0003      	movs	r3, r0
   17116:	7023      	strb	r3, [r4, #0]
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
   17118:	231b      	movs	r3, #27
   1711a:	18fb      	adds	r3, r7, r3
   1711c:	781b      	ldrb	r3, [r3, #0]
   1711e:	2b00      	cmp	r3, #0
   17120:	d101      	bne.n	17126 <disk_read+0x36>
		return RES_ERROR;
   17122:	2301      	movs	r3, #1
   17124:	e03d      	b.n	171a2 <disk_read+0xb2>
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
   17126:	2314      	movs	r3, #20
   17128:	18fa      	adds	r2, r7, r3
   1712a:	230f      	movs	r3, #15
   1712c:	18fb      	adds	r3, r7, r3
   1712e:	781b      	ldrb	r3, [r3, #0]
   17130:	0011      	movs	r1, r2
   17132:	0018      	movs	r0, r3
   17134:	4b1e      	ldr	r3, [pc, #120]	; (171b0 <disk_read+0xc0>)
   17136:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
   17138:	231b      	movs	r3, #27
   1713a:	18fb      	adds	r3, r7, r3
   1713c:	781b      	ldrb	r3, [r3, #0]
   1713e:	683a      	ldr	r2, [r7, #0]
   17140:	435a      	muls	r2, r3
   17142:	687b      	ldr	r3, [r7, #4]
   17144:	18d2      	adds	r2, r2, r3
			(ul_last_sector_num + 1) * uc_sector_size) {
   17146:	697b      	ldr	r3, [r7, #20]
   17148:	3301      	adds	r3, #1
   1714a:	211b      	movs	r1, #27
   1714c:	1879      	adds	r1, r7, r1
   1714e:	7809      	ldrb	r1, [r1, #0]
   17150:	434b      	muls	r3, r1
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
   17152:	429a      	cmp	r2, r3
   17154:	d901      	bls.n	1715a <disk_read+0x6a>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
   17156:	2304      	movs	r3, #4
   17158:	e023      	b.n	171a2 <disk_read+0xb2>
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
   1715a:	2300      	movs	r3, #0
   1715c:	61fb      	str	r3, [r7, #28]
   1715e:	e01b      	b.n	17198 <disk_read+0xa8>
		if (memory_2_ram(drv, sector + uc_sector_size * i,
   17160:	231b      	movs	r3, #27
   17162:	18fb      	adds	r3, r7, r3
   17164:	781b      	ldrb	r3, [r3, #0]
   17166:	69fa      	ldr	r2, [r7, #28]
   17168:	435a      	muls	r2, r3
   1716a:	687b      	ldr	r3, [r7, #4]
   1716c:	18d1      	adds	r1, r2, r3
				buff + uc_sector_size * SECTOR_SIZE_DEFAULT * i) !=
   1716e:	231b      	movs	r3, #27
   17170:	18fb      	adds	r3, r7, r3
   17172:	781b      	ldrb	r3, [r3, #0]
   17174:	69fa      	ldr	r2, [r7, #28]
   17176:	4353      	muls	r3, r2
   17178:	025b      	lsls	r3, r3, #9
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
		if (memory_2_ram(drv, sector + uc_sector_size * i,
   1717a:	68ba      	ldr	r2, [r7, #8]
   1717c:	18d2      	adds	r2, r2, r3
   1717e:	230f      	movs	r3, #15
   17180:	18fb      	adds	r3, r7, r3
   17182:	781b      	ldrb	r3, [r3, #0]
   17184:	0018      	movs	r0, r3
   17186:	4b0b      	ldr	r3, [pc, #44]	; (171b4 <disk_read+0xc4>)
   17188:	4798      	blx	r3
   1718a:	1e03      	subs	r3, r0, #0
   1718c:	d001      	beq.n	17192 <disk_read+0xa2>
				buff + uc_sector_size * SECTOR_SIZE_DEFAULT * i) !=
				CTRL_GOOD) {
			return RES_ERROR;
   1718e:	2301      	movs	r3, #1
   17190:	e007      	b.n	171a2 <disk_read+0xb2>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
   17192:	69fb      	ldr	r3, [r7, #28]
   17194:	3301      	adds	r3, #1
   17196:	61fb      	str	r3, [r7, #28]
   17198:	69fa      	ldr	r2, [r7, #28]
   1719a:	683b      	ldr	r3, [r7, #0]
   1719c:	429a      	cmp	r2, r3
   1719e:	d3df      	bcc.n	17160 <disk_read+0x70>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
   171a0:	2300      	movs	r3, #0

#else
	return RES_ERROR;
#endif
}
   171a2:	0018      	movs	r0, r3
   171a4:	46bd      	mov	sp, r7
   171a6:	b009      	add	sp, #36	; 0x24
   171a8:	bd90      	pop	{r4, r7, pc}
   171aa:	46c0      	nop			; (mov r8, r8)
   171ac:	00013229 	.word	0x00013229
   171b0:	000131dd 	.word	0x000131dd
   171b4:	0001329d 	.word	0x0001329d

000171b8 <disk_write>:
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _FS_READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, UINT count)
{
   171b8:	b590      	push	{r4, r7, lr}
   171ba:	b089      	sub	sp, #36	; 0x24
   171bc:	af00      	add	r7, sp, #0
   171be:	60b9      	str	r1, [r7, #8]
   171c0:	607a      	str	r2, [r7, #4]
   171c2:	603b      	str	r3, [r7, #0]
   171c4:	230f      	movs	r3, #15
   171c6:	18fb      	adds	r3, r7, r3
   171c8:	1c02      	adds	r2, r0, #0
   171ca:	701a      	strb	r2, [r3, #0]
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
   171cc:	231b      	movs	r3, #27
   171ce:	18fc      	adds	r4, r7, r3
   171d0:	230f      	movs	r3, #15
   171d2:	18fb      	adds	r3, r7, r3
   171d4:	781b      	ldrb	r3, [r3, #0]
   171d6:	0018      	movs	r0, r3
   171d8:	4b26      	ldr	r3, [pc, #152]	; (17274 <disk_write+0xbc>)
   171da:	4798      	blx	r3
   171dc:	0003      	movs	r3, r0
   171de:	7023      	strb	r3, [r4, #0]
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
   171e0:	231b      	movs	r3, #27
   171e2:	18fb      	adds	r3, r7, r3
   171e4:	781b      	ldrb	r3, [r3, #0]
   171e6:	2b00      	cmp	r3, #0
   171e8:	d101      	bne.n	171ee <disk_write+0x36>
		return RES_ERROR;
   171ea:	2301      	movs	r3, #1
   171ec:	e03d      	b.n	1726a <disk_write+0xb2>
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
   171ee:	2314      	movs	r3, #20
   171f0:	18fa      	adds	r2, r7, r3
   171f2:	230f      	movs	r3, #15
   171f4:	18fb      	adds	r3, r7, r3
   171f6:	781b      	ldrb	r3, [r3, #0]
   171f8:	0011      	movs	r1, r2
   171fa:	0018      	movs	r0, r3
   171fc:	4b1e      	ldr	r3, [pc, #120]	; (17278 <disk_write+0xc0>)
   171fe:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
   17200:	231b      	movs	r3, #27
   17202:	18fb      	adds	r3, r7, r3
   17204:	781b      	ldrb	r3, [r3, #0]
   17206:	683a      	ldr	r2, [r7, #0]
   17208:	435a      	muls	r2, r3
   1720a:	687b      	ldr	r3, [r7, #4]
   1720c:	18d2      	adds	r2, r2, r3
			(ul_last_sector_num + 1) * uc_sector_size) {
   1720e:	697b      	ldr	r3, [r7, #20]
   17210:	3301      	adds	r3, #1
   17212:	211b      	movs	r1, #27
   17214:	1879      	adds	r1, r7, r1
   17216:	7809      	ldrb	r1, [r1, #0]
   17218:	434b      	muls	r3, r1
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
   1721a:	429a      	cmp	r2, r3
   1721c:	d901      	bls.n	17222 <disk_write+0x6a>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
   1721e:	2304      	movs	r3, #4
   17220:	e023      	b.n	1726a <disk_write+0xb2>
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
   17222:	2300      	movs	r3, #0
   17224:	61fb      	str	r3, [r7, #28]
   17226:	e01b      	b.n	17260 <disk_write+0xa8>
		if (ram_2_memory(drv, sector + uc_sector_size * i,
   17228:	231b      	movs	r3, #27
   1722a:	18fb      	adds	r3, r7, r3
   1722c:	781b      	ldrb	r3, [r3, #0]
   1722e:	69fa      	ldr	r2, [r7, #28]
   17230:	435a      	muls	r2, r3
   17232:	687b      	ldr	r3, [r7, #4]
   17234:	18d1      	adds	r1, r2, r3
				buff + uc_sector_size * SECTOR_SIZE_DEFAULT * i) !=
   17236:	231b      	movs	r3, #27
   17238:	18fb      	adds	r3, r7, r3
   1723a:	781b      	ldrb	r3, [r3, #0]
   1723c:	69fa      	ldr	r2, [r7, #28]
   1723e:	4353      	muls	r3, r2
   17240:	025b      	lsls	r3, r3, #9
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
		if (ram_2_memory(drv, sector + uc_sector_size * i,
   17242:	68ba      	ldr	r2, [r7, #8]
   17244:	18d2      	adds	r2, r2, r3
   17246:	230f      	movs	r3, #15
   17248:	18fb      	adds	r3, r7, r3
   1724a:	781b      	ldrb	r3, [r3, #0]
   1724c:	0018      	movs	r0, r3
   1724e:	4b0b      	ldr	r3, [pc, #44]	; (1727c <disk_write+0xc4>)
   17250:	4798      	blx	r3
   17252:	1e03      	subs	r3, r0, #0
   17254:	d001      	beq.n	1725a <disk_write+0xa2>
				buff + uc_sector_size * SECTOR_SIZE_DEFAULT * i) !=
				CTRL_GOOD) {
			return RES_ERROR;
   17256:	2301      	movs	r3, #1
   17258:	e007      	b.n	1726a <disk_write+0xb2>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
   1725a:	69fb      	ldr	r3, [r7, #28]
   1725c:	3301      	adds	r3, #1
   1725e:	61fb      	str	r3, [r7, #28]
   17260:	69fa      	ldr	r2, [r7, #28]
   17262:	683b      	ldr	r3, [r7, #0]
   17264:	429a      	cmp	r2, r3
   17266:	d3df      	bcc.n	17228 <disk_write+0x70>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
   17268:	2300      	movs	r3, #0

#else
	return RES_ERROR;
#endif
}
   1726a:	0018      	movs	r0, r3
   1726c:	46bd      	mov	sp, r7
   1726e:	b009      	add	sp, #36	; 0x24
   17270:	bd90      	pop	{r4, r7, pc}
   17272:	46c0      	nop			; (mov r8, r8)
   17274:	00013229 	.word	0x00013229
   17278:	000131dd 	.word	0x000131dd
   1727c:	000132f1 	.word	0x000132f1

00017280 <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
   17280:	b590      	push	{r4, r7, lr}
   17282:	b085      	sub	sp, #20
   17284:	af00      	add	r7, sp, #0
   17286:	603a      	str	r2, [r7, #0]
   17288:	1dfb      	adds	r3, r7, #7
   1728a:	1c02      	adds	r2, r0, #0
   1728c:	701a      	strb	r2, [r3, #0]
   1728e:	1dbb      	adds	r3, r7, #6
   17290:	1c0a      	adds	r2, r1, #0
   17292:	701a      	strb	r2, [r3, #0]
	DRESULT res = RES_PARERR;
   17294:	230f      	movs	r3, #15
   17296:	18fb      	adds	r3, r7, r3
   17298:	2204      	movs	r2, #4
   1729a:	701a      	strb	r2, [r3, #0]

	switch (ctrl) {
   1729c:	1dbb      	adds	r3, r7, #6
   1729e:	781b      	ldrb	r3, [r3, #0]
   172a0:	2b01      	cmp	r3, #1
   172a2:	d00f      	beq.n	172c4 <disk_ioctl+0x44>
   172a4:	dc02      	bgt.n	172ac <disk_ioctl+0x2c>
   172a6:	2b00      	cmp	r3, #0
   172a8:	d044      	beq.n	17334 <disk_ioctl+0xb4>
   172aa:	e054      	b.n	17356 <disk_ioctl+0xd6>
   172ac:	2b02      	cmp	r3, #2
   172ae:	d01a      	beq.n	172e6 <disk_ioctl+0x66>
   172b0:	2b03      	cmp	r3, #3
   172b2:	d150      	bne.n	17356 <disk_ioctl+0xd6>
	case GET_BLOCK_SIZE:
		*(DWORD *)buff = 1;
   172b4:	683b      	ldr	r3, [r7, #0]
   172b6:	2201      	movs	r2, #1
   172b8:	601a      	str	r2, [r3, #0]
		res = RES_OK;
   172ba:	230f      	movs	r3, #15
   172bc:	18fb      	adds	r3, r7, r3
   172be:	2200      	movs	r2, #0
   172c0:	701a      	strb	r2, [r3, #0]
		break;
   172c2:	e04c      	b.n	1735e <disk_ioctl+0xde>
	case GET_SECTOR_COUNT:
	{
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);
   172c4:	2308      	movs	r3, #8
   172c6:	18fa      	adds	r2, r7, r3
   172c8:	1dfb      	adds	r3, r7, #7
   172ca:	781b      	ldrb	r3, [r3, #0]
   172cc:	0011      	movs	r1, r2
   172ce:	0018      	movs	r0, r3
   172d0:	4b26      	ldr	r3, [pc, #152]	; (1736c <disk_ioctl+0xec>)
   172d2:	4798      	blx	r3

		*(DWORD *)buff = ul_last_sector_num + 1;
   172d4:	68bb      	ldr	r3, [r7, #8]
   172d6:	1c5a      	adds	r2, r3, #1
   172d8:	683b      	ldr	r3, [r7, #0]
   172da:	601a      	str	r2, [r3, #0]

		res = RES_OK;
   172dc:	230f      	movs	r3, #15
   172de:	18fb      	adds	r3, r7, r3
   172e0:	2200      	movs	r2, #0
   172e2:	701a      	strb	r2, [r3, #0]
	}
	break;
   172e4:	e03b      	b.n	1735e <disk_ioctl+0xde>

	/* Get sectors on the disk (WORD) */
	case GET_SECTOR_SIZE:
	{
		uint8_t uc_sector_size = mem_sector_size(drv);
   172e6:	230e      	movs	r3, #14
   172e8:	18fc      	adds	r4, r7, r3
   172ea:	1dfb      	adds	r3, r7, #7
   172ec:	781b      	ldrb	r3, [r3, #0]
   172ee:	0018      	movs	r0, r3
   172f0:	4b1f      	ldr	r3, [pc, #124]	; (17370 <disk_ioctl+0xf0>)
   172f2:	4798      	blx	r3
   172f4:	0003      	movs	r3, r0
   172f6:	7023      	strb	r3, [r4, #0]

		if ((uc_sector_size != SECTOR_SIZE_512) &&
   172f8:	230e      	movs	r3, #14
   172fa:	18fb      	adds	r3, r7, r3
   172fc:	781b      	ldrb	r3, [r3, #0]
   172fe:	2b01      	cmp	r3, #1
   17300:	d010      	beq.n	17324 <disk_ioctl+0xa4>
   17302:	230e      	movs	r3, #14
   17304:	18fb      	adds	r3, r7, r3
   17306:	781b      	ldrb	r3, [r3, #0]
   17308:	2b02      	cmp	r3, #2
   1730a:	d00b      	beq.n	17324 <disk_ioctl+0xa4>
				(uc_sector_size != SECTOR_SIZE_1024) &&
   1730c:	230e      	movs	r3, #14
   1730e:	18fb      	adds	r3, r7, r3
   17310:	781b      	ldrb	r3, [r3, #0]
   17312:	2b04      	cmp	r3, #4
   17314:	d006      	beq.n	17324 <disk_ioctl+0xa4>
				(uc_sector_size != SECTOR_SIZE_2048) &&
   17316:	230e      	movs	r3, #14
   17318:	18fb      	adds	r3, r7, r3
   1731a:	781b      	ldrb	r3, [r3, #0]
   1731c:	2b08      	cmp	r3, #8
   1731e:	d001      	beq.n	17324 <disk_ioctl+0xa4>
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
   17320:	2301      	movs	r3, #1
   17322:	e01f      	b.n	17364 <disk_ioctl+0xe4>
		}

		*(U8 *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
   17324:	683b      	ldr	r3, [r7, #0]
   17326:	2200      	movs	r2, #0
   17328:	701a      	strb	r2, [r3, #0]

		res = RES_OK;
   1732a:	230f      	movs	r3, #15
   1732c:	18fb      	adds	r3, r7, r3
   1732e:	2200      	movs	r2, #0
   17330:	701a      	strb	r2, [r3, #0]
	}
	break;
   17332:	e014      	b.n	1735e <disk_ioctl+0xde>

	/* Make sure that data has been written */
	case CTRL_SYNC:
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
   17334:	1dfb      	adds	r3, r7, #7
   17336:	781b      	ldrb	r3, [r3, #0]
   17338:	0018      	movs	r0, r3
   1733a:	4b0e      	ldr	r3, [pc, #56]	; (17374 <disk_ioctl+0xf4>)
   1733c:	4798      	blx	r3
   1733e:	1e03      	subs	r3, r0, #0
   17340:	d104      	bne.n	1734c <disk_ioctl+0xcc>
			res = RES_OK;
   17342:	230f      	movs	r3, #15
   17344:	18fb      	adds	r3, r7, r3
   17346:	2200      	movs	r2, #0
   17348:	701a      	strb	r2, [r3, #0]
		} else {
			res = RES_NOTRDY;
		}
		break;
   1734a:	e008      	b.n	1735e <disk_ioctl+0xde>
	/* Make sure that data has been written */
	case CTRL_SYNC:
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
			res = RES_OK;
		} else {
			res = RES_NOTRDY;
   1734c:	230f      	movs	r3, #15
   1734e:	18fb      	adds	r3, r7, r3
   17350:	2203      	movs	r2, #3
   17352:	701a      	strb	r2, [r3, #0]
		}
		break;
   17354:	e003      	b.n	1735e <disk_ioctl+0xde>

	default:
		res = RES_PARERR;
   17356:	230f      	movs	r3, #15
   17358:	18fb      	adds	r3, r7, r3
   1735a:	2204      	movs	r2, #4
   1735c:	701a      	strb	r2, [r3, #0]
	}

	return res;
   1735e:	230f      	movs	r3, #15
   17360:	18fb      	adds	r3, r7, r3
   17362:	781b      	ldrb	r3, [r3, #0]
}
   17364:	0018      	movs	r0, r3
   17366:	46bd      	mov	sp, r7
   17368:	b005      	add	sp, #20
   1736a:	bd90      	pop	{r4, r7, pc}
   1736c:	000131dd 	.word	0x000131dd
   17370:	00013229 	.word	0x00013229
   17374:	0001319d 	.word	0x0001319d

00017378 <get_fattime>:
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
   17378:	b580      	push	{r7, lr}
   1737a:	b084      	sub	sp, #16
   1737c:	af00      	add	r7, sp, #0
	uint32_t ul_time;
	struct rtc_calendar_time current_time;

	/* Retrieve date and time */
	rtc_calendar_get_time(&rtc_instance, &current_time);
   1737e:	003a      	movs	r2, r7
   17380:	4b11      	ldr	r3, [pc, #68]	; (173c8 <get_fattime+0x50>)
   17382:	0011      	movs	r1, r2
   17384:	0018      	movs	r0, r3
   17386:	4b11      	ldr	r3, [pc, #68]	; (173cc <get_fattime+0x54>)
   17388:	4798      	blx	r3

	ul_time = ((current_time.year - 1980) << 25)
   1738a:	003b      	movs	r3, r7
   1738c:	88db      	ldrh	r3, [r3, #6]
   1738e:	4a10      	ldr	r2, [pc, #64]	; (173d0 <get_fattime+0x58>)
   17390:	4694      	mov	ip, r2
   17392:	4463      	add	r3, ip
   17394:	065a      	lsls	r2, r3, #25
			| (current_time.month << 21)
   17396:	003b      	movs	r3, r7
   17398:	795b      	ldrb	r3, [r3, #5]
   1739a:	055b      	lsls	r3, r3, #21
   1739c:	431a      	orrs	r2, r3
			| (current_time.day << 16)
   1739e:	003b      	movs	r3, r7
   173a0:	791b      	ldrb	r3, [r3, #4]
   173a2:	041b      	lsls	r3, r3, #16
   173a4:	431a      	orrs	r2, r3
			| (current_time.hour << 11)
   173a6:	003b      	movs	r3, r7
   173a8:	789b      	ldrb	r3, [r3, #2]
   173aa:	02db      	lsls	r3, r3, #11
   173ac:	431a      	orrs	r2, r3
			| (current_time.minute << 5)
   173ae:	003b      	movs	r3, r7
   173b0:	785b      	ldrb	r3, [r3, #1]
   173b2:	015b      	lsls	r3, r3, #5
   173b4:	4313      	orrs	r3, r2
			| (current_time.second << 0);
   173b6:	003a      	movs	r2, r7
   173b8:	7812      	ldrb	r2, [r2, #0]
   173ba:	4313      	orrs	r3, r2
	struct rtc_calendar_time current_time;

	/* Retrieve date and time */
	rtc_calendar_get_time(&rtc_instance, &current_time);

	ul_time = ((current_time.year - 1980) << 25)
   173bc:	60fb      	str	r3, [r7, #12]
			| (current_time.day << 16)
			| (current_time.hour << 11)
			| (current_time.minute << 5)
			| (current_time.second << 0);

	return ul_time;
   173be:	68fb      	ldr	r3, [r7, #12]
}
   173c0:	0018      	movs	r0, r3
   173c2:	46bd      	mov	sp, r7
   173c4:	b004      	add	sp, #16
   173c6:	bd80      	pop	{r7, pc}
   173c8:	20004bc8 	.word	0x20004bc8
   173cc:	000139d5 	.word	0x000139d5
   173d0:	fffff844 	.word	0xfffff844

000173d4 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
   173d4:	b580      	push	{r7, lr}
   173d6:	b086      	sub	sp, #24
   173d8:	af00      	add	r7, sp, #0
   173da:	60f8      	str	r0, [r7, #12]
   173dc:	60b9      	str	r1, [r7, #8]
   173de:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
   173e0:	68fb      	ldr	r3, [r7, #12]
   173e2:	617b      	str	r3, [r7, #20]
	const BYTE *s = (const BYTE*)src;
   173e4:	68bb      	ldr	r3, [r7, #8]
   173e6:	613b      	str	r3, [r7, #16]
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
   173e8:	e007      	b.n	173fa <mem_cpy+0x26>
		*d++ = *s++;
   173ea:	697b      	ldr	r3, [r7, #20]
   173ec:	1c5a      	adds	r2, r3, #1
   173ee:	617a      	str	r2, [r7, #20]
   173f0:	693a      	ldr	r2, [r7, #16]
   173f2:	1c51      	adds	r1, r2, #1
   173f4:	6139      	str	r1, [r7, #16]
   173f6:	7812      	ldrb	r2, [r2, #0]
   173f8:	701a      	strb	r2, [r3, #0]
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
   173fa:	687b      	ldr	r3, [r7, #4]
   173fc:	1e5a      	subs	r2, r3, #1
   173fe:	607a      	str	r2, [r7, #4]
   17400:	2b00      	cmp	r3, #0
   17402:	d1f2      	bne.n	173ea <mem_cpy+0x16>
		*d++ = *s++;
}
   17404:	46c0      	nop			; (mov r8, r8)
   17406:	46bd      	mov	sp, r7
   17408:	b006      	add	sp, #24
   1740a:	bd80      	pop	{r7, pc}

0001740c <mem_set>:

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
   1740c:	b580      	push	{r7, lr}
   1740e:	b086      	sub	sp, #24
   17410:	af00      	add	r7, sp, #0
   17412:	60f8      	str	r0, [r7, #12]
   17414:	60b9      	str	r1, [r7, #8]
   17416:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
   17418:	68fb      	ldr	r3, [r7, #12]
   1741a:	617b      	str	r3, [r7, #20]

	while (cnt--)
   1741c:	e005      	b.n	1742a <mem_set+0x1e>
		*d++ = (BYTE)val;
   1741e:	697b      	ldr	r3, [r7, #20]
   17420:	1c5a      	adds	r2, r3, #1
   17422:	617a      	str	r2, [r7, #20]
   17424:	68ba      	ldr	r2, [r7, #8]
   17426:	b2d2      	uxtb	r2, r2
   17428:	701a      	strb	r2, [r3, #0]
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
   1742a:	687b      	ldr	r3, [r7, #4]
   1742c:	1e5a      	subs	r2, r3, #1
   1742e:	607a      	str	r2, [r7, #4]
   17430:	2b00      	cmp	r3, #0
   17432:	d1f4      	bne.n	1741e <mem_set+0x12>
		*d++ = (BYTE)val;
}
   17434:	46c0      	nop			; (mov r8, r8)
   17436:	46bd      	mov	sp, r7
   17438:	b006      	add	sp, #24
   1743a:	bd80      	pop	{r7, pc}

0001743c <mem_cmp>:

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
   1743c:	b580      	push	{r7, lr}
   1743e:	b088      	sub	sp, #32
   17440:	af00      	add	r7, sp, #0
   17442:	60f8      	str	r0, [r7, #12]
   17444:	60b9      	str	r1, [r7, #8]
   17446:	607a      	str	r2, [r7, #4]
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
   17448:	68fb      	ldr	r3, [r7, #12]
   1744a:	61fb      	str	r3, [r7, #28]
   1744c:	68bb      	ldr	r3, [r7, #8]
   1744e:	61bb      	str	r3, [r7, #24]
	int r = 0;
   17450:	2300      	movs	r3, #0
   17452:	617b      	str	r3, [r7, #20]

	while (cnt-- && (r = *d++ - *s++) == 0) ;
   17454:	46c0      	nop			; (mov r8, r8)
   17456:	687b      	ldr	r3, [r7, #4]
   17458:	1e5a      	subs	r2, r3, #1
   1745a:	607a      	str	r2, [r7, #4]
   1745c:	2b00      	cmp	r3, #0
   1745e:	d00d      	beq.n	1747c <mem_cmp+0x40>
   17460:	69fb      	ldr	r3, [r7, #28]
   17462:	1c5a      	adds	r2, r3, #1
   17464:	61fa      	str	r2, [r7, #28]
   17466:	781b      	ldrb	r3, [r3, #0]
   17468:	0019      	movs	r1, r3
   1746a:	69bb      	ldr	r3, [r7, #24]
   1746c:	1c5a      	adds	r2, r3, #1
   1746e:	61ba      	str	r2, [r7, #24]
   17470:	781b      	ldrb	r3, [r3, #0]
   17472:	1acb      	subs	r3, r1, r3
   17474:	617b      	str	r3, [r7, #20]
   17476:	697b      	ldr	r3, [r7, #20]
   17478:	2b00      	cmp	r3, #0
   1747a:	d0ec      	beq.n	17456 <mem_cmp+0x1a>
	return r;
   1747c:	697b      	ldr	r3, [r7, #20]
}
   1747e:	0018      	movs	r0, r3
   17480:	46bd      	mov	sp, r7
   17482:	b008      	add	sp, #32
   17484:	bd80      	pop	{r7, pc}
   17486:	46c0      	nop			; (mov r8, r8)

00017488 <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
   17488:	b580      	push	{r7, lr}
   1748a:	b082      	sub	sp, #8
   1748c:	af00      	add	r7, sp, #0
   1748e:	6078      	str	r0, [r7, #4]
   17490:	6039      	str	r1, [r7, #0]
	while (*str && *str != chr) str++;
   17492:	e002      	b.n	1749a <chk_chr+0x12>
   17494:	687b      	ldr	r3, [r7, #4]
   17496:	3301      	adds	r3, #1
   17498:	607b      	str	r3, [r7, #4]
   1749a:	687b      	ldr	r3, [r7, #4]
   1749c:	781b      	ldrb	r3, [r3, #0]
   1749e:	2b00      	cmp	r3, #0
   174a0:	d005      	beq.n	174ae <chk_chr+0x26>
   174a2:	687b      	ldr	r3, [r7, #4]
   174a4:	781b      	ldrb	r3, [r3, #0]
   174a6:	1e1a      	subs	r2, r3, #0
   174a8:	683b      	ldr	r3, [r7, #0]
   174aa:	429a      	cmp	r2, r3
   174ac:	d1f2      	bne.n	17494 <chk_chr+0xc>
	return *str;
   174ae:	687b      	ldr	r3, [r7, #4]
   174b0:	781b      	ldrb	r3, [r3, #0]
}
   174b2:	0018      	movs	r0, r3
   174b4:	46bd      	mov	sp, r7
   174b6:	b002      	add	sp, #8
   174b8:	bd80      	pop	{r7, pc}
   174ba:	46c0      	nop			; (mov r8, r8)

000174bc <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
   174bc:	b590      	push	{r4, r7, lr}
   174be:	b087      	sub	sp, #28
   174c0:	af00      	add	r7, sp, #0
   174c2:	6078      	str	r0, [r7, #4]
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
   174c4:	230f      	movs	r3, #15
   174c6:	18fb      	adds	r3, r7, r3
   174c8:	2200      	movs	r2, #0
   174ca:	701a      	strb	r2, [r3, #0]


	if (fs->wflag) {	/* Write back the sector if it is dirty */
   174cc:	687b      	ldr	r3, [r7, #4]
   174ce:	791b      	ldrb	r3, [r3, #4]
   174d0:	2b00      	cmp	r3, #0
   174d2:	d035      	beq.n	17540 <sync_window+0x84>
		wsect = fs->winsect;	/* Current sector number */
   174d4:	687b      	ldr	r3, [r7, #4]
   174d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   174d8:	617b      	str	r3, [r7, #20]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
   174da:	687b      	ldr	r3, [r7, #4]
   174dc:	7858      	ldrb	r0, [r3, #1]
   174de:	687b      	ldr	r3, [r7, #4]
   174e0:	3330      	adds	r3, #48	; 0x30
   174e2:	0019      	movs	r1, r3
   174e4:	697a      	ldr	r2, [r7, #20]
   174e6:	2301      	movs	r3, #1
   174e8:	4c19      	ldr	r4, [pc, #100]	; (17550 <sync_window+0x94>)
   174ea:	47a0      	blx	r4
   174ec:	1e03      	subs	r3, r0, #0
   174ee:	d004      	beq.n	174fa <sync_window+0x3e>
			res = FR_DISK_ERR;
   174f0:	230f      	movs	r3, #15
   174f2:	18fb      	adds	r3, r7, r3
   174f4:	2201      	movs	r2, #1
   174f6:	701a      	strb	r2, [r3, #0]
   174f8:	e022      	b.n	17540 <sync_window+0x84>
		} else {
			fs->wflag = 0;
   174fa:	687b      	ldr	r3, [r7, #4]
   174fc:	2200      	movs	r2, #0
   174fe:	711a      	strb	r2, [r3, #4]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
   17500:	687b      	ldr	r3, [r7, #4]
   17502:	6a1b      	ldr	r3, [r3, #32]
   17504:	697a      	ldr	r2, [r7, #20]
   17506:	1ad2      	subs	r2, r2, r3
   17508:	687b      	ldr	r3, [r7, #4]
   1750a:	699b      	ldr	r3, [r3, #24]
   1750c:	429a      	cmp	r2, r3
   1750e:	d217      	bcs.n	17540 <sync_window+0x84>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
   17510:	687b      	ldr	r3, [r7, #4]
   17512:	78db      	ldrb	r3, [r3, #3]
   17514:	613b      	str	r3, [r7, #16]
   17516:	e010      	b.n	1753a <sync_window+0x7e>
					wsect += fs->fsize;
   17518:	687b      	ldr	r3, [r7, #4]
   1751a:	699b      	ldr	r3, [r3, #24]
   1751c:	697a      	ldr	r2, [r7, #20]
   1751e:	18d3      	adds	r3, r2, r3
   17520:	617b      	str	r3, [r7, #20]
					disk_write(fs->drv, fs->win, wsect, 1);
   17522:	687b      	ldr	r3, [r7, #4]
   17524:	7858      	ldrb	r0, [r3, #1]
   17526:	687b      	ldr	r3, [r7, #4]
   17528:	3330      	adds	r3, #48	; 0x30
   1752a:	0019      	movs	r1, r3
   1752c:	697a      	ldr	r2, [r7, #20]
   1752e:	2301      	movs	r3, #1
   17530:	4c07      	ldr	r4, [pc, #28]	; (17550 <sync_window+0x94>)
   17532:	47a0      	blx	r4
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
   17534:	693b      	ldr	r3, [r7, #16]
   17536:	3b01      	subs	r3, #1
   17538:	613b      	str	r3, [r7, #16]
   1753a:	693b      	ldr	r3, [r7, #16]
   1753c:	2b01      	cmp	r3, #1
   1753e:	d8eb      	bhi.n	17518 <sync_window+0x5c>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
	}
	return res;
   17540:	230f      	movs	r3, #15
   17542:	18fb      	adds	r3, r7, r3
   17544:	781b      	ldrb	r3, [r3, #0]
}
   17546:	0018      	movs	r0, r3
   17548:	46bd      	mov	sp, r7
   1754a:	b007      	add	sp, #28
   1754c:	bd90      	pop	{r4, r7, pc}
   1754e:	46c0      	nop			; (mov r8, r8)
   17550:	000171b9 	.word	0x000171b9

00017554 <move_window>:
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
   17554:	b590      	push	{r4, r7, lr}
   17556:	b085      	sub	sp, #20
   17558:	af00      	add	r7, sp, #0
   1755a:	6078      	str	r0, [r7, #4]
   1755c:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_OK;
   1755e:	230f      	movs	r3, #15
   17560:	18fb      	adds	r3, r7, r3
   17562:	2200      	movs	r2, #0
   17564:	701a      	strb	r2, [r3, #0]


	if (sector != fs->winsect) {	/* Window offset changed? */
   17566:	687b      	ldr	r3, [r7, #4]
   17568:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1756a:	683b      	ldr	r3, [r7, #0]
   1756c:	429a      	cmp	r2, r3
   1756e:	d021      	beq.n	175b4 <move_window+0x60>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
   17570:	230f      	movs	r3, #15
   17572:	18fc      	adds	r4, r7, r3
   17574:	687b      	ldr	r3, [r7, #4]
   17576:	0018      	movs	r0, r3
   17578:	4b12      	ldr	r3, [pc, #72]	; (175c4 <move_window+0x70>)
   1757a:	4798      	blx	r3
   1757c:	0003      	movs	r3, r0
   1757e:	7023      	strb	r3, [r4, #0]
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
   17580:	230f      	movs	r3, #15
   17582:	18fb      	adds	r3, r7, r3
   17584:	781b      	ldrb	r3, [r3, #0]
   17586:	2b00      	cmp	r3, #0
   17588:	d114      	bne.n	175b4 <move_window+0x60>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
   1758a:	687b      	ldr	r3, [r7, #4]
   1758c:	7858      	ldrb	r0, [r3, #1]
   1758e:	687b      	ldr	r3, [r7, #4]
   17590:	3330      	adds	r3, #48	; 0x30
   17592:	0019      	movs	r1, r3
   17594:	683a      	ldr	r2, [r7, #0]
   17596:	2301      	movs	r3, #1
   17598:	4c0b      	ldr	r4, [pc, #44]	; (175c8 <move_window+0x74>)
   1759a:	47a0      	blx	r4
   1759c:	1e03      	subs	r3, r0, #0
   1759e:	d006      	beq.n	175ae <move_window+0x5a>
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
   175a0:	2301      	movs	r3, #1
   175a2:	425b      	negs	r3, r3
   175a4:	603b      	str	r3, [r7, #0]
				res = FR_DISK_ERR;
   175a6:	230f      	movs	r3, #15
   175a8:	18fb      	adds	r3, r7, r3
   175aa:	2201      	movs	r2, #1
   175ac:	701a      	strb	r2, [r3, #0]
			}
			fs->winsect = sector;
   175ae:	687b      	ldr	r3, [r7, #4]
   175b0:	683a      	ldr	r2, [r7, #0]
   175b2:	62da      	str	r2, [r3, #44]	; 0x2c
		}
	}
	return res;
   175b4:	230f      	movs	r3, #15
   175b6:	18fb      	adds	r3, r7, r3
   175b8:	781b      	ldrb	r3, [r3, #0]
}
   175ba:	0018      	movs	r0, r3
   175bc:	46bd      	mov	sp, r7
   175be:	b005      	add	sp, #20
   175c0:	bd90      	pop	{r4, r7, pc}
   175c2:	46c0      	nop			; (mov r8, r8)
   175c4:	000174bd 	.word	0x000174bd
   175c8:	000170f1 	.word	0x000170f1

000175cc <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
   175cc:	b590      	push	{r4, r7, lr}
   175ce:	b085      	sub	sp, #20
   175d0:	af00      	add	r7, sp, #0
   175d2:	6078      	str	r0, [r7, #4]
	FRESULT res;


	res = sync_window(fs);
   175d4:	230f      	movs	r3, #15
   175d6:	18fc      	adds	r4, r7, r3
   175d8:	687b      	ldr	r3, [r7, #4]
   175da:	0018      	movs	r0, r3
   175dc:	4b51      	ldr	r3, [pc, #324]	; (17724 <sync_fs+0x158>)
   175de:	4798      	blx	r3
   175e0:	0003      	movs	r3, r0
   175e2:	7023      	strb	r3, [r4, #0]
	if (res == FR_OK) {
   175e4:	230f      	movs	r3, #15
   175e6:	18fb      	adds	r3, r7, r3
   175e8:	781b      	ldrb	r3, [r3, #0]
   175ea:	2b00      	cmp	r3, #0
   175ec:	d000      	beq.n	175f0 <sync_fs+0x24>
   175ee:	e091      	b.n	17714 <sync_fs+0x148>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
   175f0:	687b      	ldr	r3, [r7, #4]
   175f2:	781b      	ldrb	r3, [r3, #0]
   175f4:	2b03      	cmp	r3, #3
   175f6:	d000      	beq.n	175fa <sync_fs+0x2e>
   175f8:	e07f      	b.n	176fa <sync_fs+0x12e>
   175fa:	687b      	ldr	r3, [r7, #4]
   175fc:	795b      	ldrb	r3, [r3, #5]
   175fe:	2b01      	cmp	r3, #1
   17600:	d17b      	bne.n	176fa <sync_fs+0x12e>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
   17602:	687b      	ldr	r3, [r7, #4]
   17604:	3330      	adds	r3, #48	; 0x30
   17606:	0018      	movs	r0, r3
   17608:	2380      	movs	r3, #128	; 0x80
   1760a:	009b      	lsls	r3, r3, #2
   1760c:	001a      	movs	r2, r3
   1760e:	2100      	movs	r1, #0
   17610:	4b45      	ldr	r3, [pc, #276]	; (17728 <sync_fs+0x15c>)
   17612:	4798      	blx	r3
			ST_WORD(fs->win + BS_55AA, 0xAA55);
   17614:	687b      	ldr	r3, [r7, #4]
   17616:	4a45      	ldr	r2, [pc, #276]	; (1772c <sync_fs+0x160>)
   17618:	2155      	movs	r1, #85	; 0x55
   1761a:	5499      	strb	r1, [r3, r2]
   1761c:	687b      	ldr	r3, [r7, #4]
   1761e:	4a44      	ldr	r2, [pc, #272]	; (17730 <sync_fs+0x164>)
   17620:	21aa      	movs	r1, #170	; 0xaa
   17622:	5499      	strb	r1, [r3, r2]
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
   17624:	687b      	ldr	r3, [r7, #4]
   17626:	2230      	movs	r2, #48	; 0x30
   17628:	2152      	movs	r1, #82	; 0x52
   1762a:	5499      	strb	r1, [r3, r2]
   1762c:	687b      	ldr	r3, [r7, #4]
   1762e:	2231      	movs	r2, #49	; 0x31
   17630:	2152      	movs	r1, #82	; 0x52
   17632:	5499      	strb	r1, [r3, r2]
   17634:	687b      	ldr	r3, [r7, #4]
   17636:	2232      	movs	r2, #50	; 0x32
   17638:	2161      	movs	r1, #97	; 0x61
   1763a:	5499      	strb	r1, [r3, r2]
   1763c:	687b      	ldr	r3, [r7, #4]
   1763e:	2233      	movs	r2, #51	; 0x33
   17640:	2141      	movs	r1, #65	; 0x41
   17642:	5499      	strb	r1, [r3, r2]
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
   17644:	687a      	ldr	r2, [r7, #4]
   17646:	2385      	movs	r3, #133	; 0x85
   17648:	009b      	lsls	r3, r3, #2
   1764a:	2172      	movs	r1, #114	; 0x72
   1764c:	54d1      	strb	r1, [r2, r3]
   1764e:	687b      	ldr	r3, [r7, #4]
   17650:	4a38      	ldr	r2, [pc, #224]	; (17734 <sync_fs+0x168>)
   17652:	2172      	movs	r1, #114	; 0x72
   17654:	5499      	strb	r1, [r3, r2]
   17656:	687b      	ldr	r3, [r7, #4]
   17658:	4a37      	ldr	r2, [pc, #220]	; (17738 <sync_fs+0x16c>)
   1765a:	2141      	movs	r1, #65	; 0x41
   1765c:	5499      	strb	r1, [r3, r2]
   1765e:	687b      	ldr	r3, [r7, #4]
   17660:	4a36      	ldr	r2, [pc, #216]	; (1773c <sync_fs+0x170>)
   17662:	2161      	movs	r1, #97	; 0x61
   17664:	5499      	strb	r1, [r3, r2]
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
   17666:	687b      	ldr	r3, [r7, #4]
   17668:	691b      	ldr	r3, [r3, #16]
   1766a:	b2d9      	uxtb	r1, r3
   1766c:	687a      	ldr	r2, [r7, #4]
   1766e:	2386      	movs	r3, #134	; 0x86
   17670:	009b      	lsls	r3, r3, #2
   17672:	54d1      	strb	r1, [r2, r3]
   17674:	687b      	ldr	r3, [r7, #4]
   17676:	691b      	ldr	r3, [r3, #16]
   17678:	121b      	asrs	r3, r3, #8
   1767a:	b2d9      	uxtb	r1, r3
   1767c:	687b      	ldr	r3, [r7, #4]
   1767e:	4a30      	ldr	r2, [pc, #192]	; (17740 <sync_fs+0x174>)
   17680:	5499      	strb	r1, [r3, r2]
   17682:	687b      	ldr	r3, [r7, #4]
   17684:	691b      	ldr	r3, [r3, #16]
   17686:	0c1b      	lsrs	r3, r3, #16
   17688:	b2d9      	uxtb	r1, r3
   1768a:	687b      	ldr	r3, [r7, #4]
   1768c:	4a2d      	ldr	r2, [pc, #180]	; (17744 <sync_fs+0x178>)
   1768e:	5499      	strb	r1, [r3, r2]
   17690:	687b      	ldr	r3, [r7, #4]
   17692:	691b      	ldr	r3, [r3, #16]
   17694:	0e1b      	lsrs	r3, r3, #24
   17696:	b2d9      	uxtb	r1, r3
   17698:	687b      	ldr	r3, [r7, #4]
   1769a:	4a2b      	ldr	r2, [pc, #172]	; (17748 <sync_fs+0x17c>)
   1769c:	5499      	strb	r1, [r3, r2]
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
   1769e:	687b      	ldr	r3, [r7, #4]
   176a0:	68db      	ldr	r3, [r3, #12]
   176a2:	b2d9      	uxtb	r1, r3
   176a4:	687a      	ldr	r2, [r7, #4]
   176a6:	2387      	movs	r3, #135	; 0x87
   176a8:	009b      	lsls	r3, r3, #2
   176aa:	54d1      	strb	r1, [r2, r3]
   176ac:	687b      	ldr	r3, [r7, #4]
   176ae:	68db      	ldr	r3, [r3, #12]
   176b0:	121b      	asrs	r3, r3, #8
   176b2:	b2d9      	uxtb	r1, r3
   176b4:	687b      	ldr	r3, [r7, #4]
   176b6:	4a25      	ldr	r2, [pc, #148]	; (1774c <sync_fs+0x180>)
   176b8:	5499      	strb	r1, [r3, r2]
   176ba:	687b      	ldr	r3, [r7, #4]
   176bc:	68db      	ldr	r3, [r3, #12]
   176be:	0c1b      	lsrs	r3, r3, #16
   176c0:	b2d9      	uxtb	r1, r3
   176c2:	687b      	ldr	r3, [r7, #4]
   176c4:	4a22      	ldr	r2, [pc, #136]	; (17750 <sync_fs+0x184>)
   176c6:	5499      	strb	r1, [r3, r2]
   176c8:	687b      	ldr	r3, [r7, #4]
   176ca:	68db      	ldr	r3, [r3, #12]
   176cc:	0e1b      	lsrs	r3, r3, #24
   176ce:	b2d9      	uxtb	r1, r3
   176d0:	687b      	ldr	r3, [r7, #4]
   176d2:	4a20      	ldr	r2, [pc, #128]	; (17754 <sync_fs+0x188>)
   176d4:	5499      	strb	r1, [r3, r2]
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
   176d6:	687b      	ldr	r3, [r7, #4]
   176d8:	69db      	ldr	r3, [r3, #28]
   176da:	1c5a      	adds	r2, r3, #1
   176dc:	687b      	ldr	r3, [r7, #4]
   176de:	62da      	str	r2, [r3, #44]	; 0x2c
			disk_write(fs->drv, fs->win, fs->winsect, 1);
   176e0:	687b      	ldr	r3, [r7, #4]
   176e2:	7858      	ldrb	r0, [r3, #1]
   176e4:	687b      	ldr	r3, [r7, #4]
   176e6:	3330      	adds	r3, #48	; 0x30
   176e8:	0019      	movs	r1, r3
   176ea:	687b      	ldr	r3, [r7, #4]
   176ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   176ee:	2301      	movs	r3, #1
   176f0:	4c19      	ldr	r4, [pc, #100]	; (17758 <sync_fs+0x18c>)
   176f2:	47a0      	blx	r4
			fs->fsi_flag = 0;
   176f4:	687b      	ldr	r3, [r7, #4]
   176f6:	2200      	movs	r2, #0
   176f8:	715a      	strb	r2, [r3, #5]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   176fa:	687b      	ldr	r3, [r7, #4]
   176fc:	785b      	ldrb	r3, [r3, #1]
   176fe:	2200      	movs	r2, #0
   17700:	2100      	movs	r1, #0
   17702:	0018      	movs	r0, r3
   17704:	4b15      	ldr	r3, [pc, #84]	; (1775c <sync_fs+0x190>)
   17706:	4798      	blx	r3
   17708:	1e03      	subs	r3, r0, #0
   1770a:	d003      	beq.n	17714 <sync_fs+0x148>
			res = FR_DISK_ERR;
   1770c:	230f      	movs	r3, #15
   1770e:	18fb      	adds	r3, r7, r3
   17710:	2201      	movs	r2, #1
   17712:	701a      	strb	r2, [r3, #0]
	}

	return res;
   17714:	230f      	movs	r3, #15
   17716:	18fb      	adds	r3, r7, r3
   17718:	781b      	ldrb	r3, [r3, #0]
}
   1771a:	0018      	movs	r0, r3
   1771c:	46bd      	mov	sp, r7
   1771e:	b005      	add	sp, #20
   17720:	bd90      	pop	{r4, r7, pc}
   17722:	46c0      	nop			; (mov r8, r8)
   17724:	000174bd 	.word	0x000174bd
   17728:	0001740d 	.word	0x0001740d
   1772c:	0000022e 	.word	0x0000022e
   17730:	0000022f 	.word	0x0000022f
   17734:	00000215 	.word	0x00000215
   17738:	00000216 	.word	0x00000216
   1773c:	00000217 	.word	0x00000217
   17740:	00000219 	.word	0x00000219
   17744:	0000021a 	.word	0x0000021a
   17748:	0000021b 	.word	0x0000021b
   1774c:	0000021d 	.word	0x0000021d
   17750:	0000021e 	.word	0x0000021e
   17754:	0000021f 	.word	0x0000021f
   17758:	000171b9 	.word	0x000171b9
   1775c:	00017281 	.word	0x00017281

00017760 <clust2sect>:

DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
   17760:	b580      	push	{r7, lr}
   17762:	b082      	sub	sp, #8
   17764:	af00      	add	r7, sp, #0
   17766:	6078      	str	r0, [r7, #4]
   17768:	6039      	str	r1, [r7, #0]
	clst -= 2;
   1776a:	683b      	ldr	r3, [r7, #0]
   1776c:	3b02      	subs	r3, #2
   1776e:	603b      	str	r3, [r7, #0]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
   17770:	687b      	ldr	r3, [r7, #4]
   17772:	695b      	ldr	r3, [r3, #20]
   17774:	1e9a      	subs	r2, r3, #2
   17776:	683b      	ldr	r3, [r7, #0]
   17778:	429a      	cmp	r2, r3
   1777a:	d801      	bhi.n	17780 <clust2sect+0x20>
   1777c:	2300      	movs	r3, #0
   1777e:	e007      	b.n	17790 <clust2sect+0x30>
	return clst * fs->csize + fs->database;
   17780:	687b      	ldr	r3, [r7, #4]
   17782:	789b      	ldrb	r3, [r3, #2]
   17784:	001a      	movs	r2, r3
   17786:	683b      	ldr	r3, [r7, #0]
   17788:	435a      	muls	r2, r3
   1778a:	687b      	ldr	r3, [r7, #4]
   1778c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1778e:	18d3      	adds	r3, r2, r3
}
   17790:	0018      	movs	r0, r3
   17792:	46bd      	mov	sp, r7
   17794:	b002      	add	sp, #8
   17796:	bd80      	pop	{r7, pc}

00017798 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
   17798:	b580      	push	{r7, lr}
   1779a:	b086      	sub	sp, #24
   1779c:	af00      	add	r7, sp, #0
   1779e:	6078      	str	r0, [r7, #4]
   177a0:	6039      	str	r1, [r7, #0]
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
   177a2:	683b      	ldr	r3, [r7, #0]
   177a4:	2b01      	cmp	r3, #1
   177a6:	d904      	bls.n	177b2 <get_fat+0x1a>
   177a8:	687b      	ldr	r3, [r7, #4]
   177aa:	695a      	ldr	r2, [r3, #20]
   177ac:	683b      	ldr	r3, [r7, #0]
   177ae:	429a      	cmp	r2, r3
   177b0:	d802      	bhi.n	177b8 <get_fat+0x20>
		val = 1;	/* Internal error */
   177b2:	2301      	movs	r3, #1
   177b4:	617b      	str	r3, [r7, #20]
   177b6:	e0a5      	b.n	17904 <get_fat+0x16c>

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
   177b8:	2301      	movs	r3, #1
   177ba:	425b      	negs	r3, r3
   177bc:	617b      	str	r3, [r7, #20]

		switch (fs->fs_type) {
   177be:	687b      	ldr	r3, [r7, #4]
   177c0:	781b      	ldrb	r3, [r3, #0]
   177c2:	2b02      	cmp	r3, #2
   177c4:	d048      	beq.n	17858 <get_fat+0xc0>
   177c6:	2b03      	cmp	r3, #3
   177c8:	d068      	beq.n	1789c <get_fat+0x104>
   177ca:	2b01      	cmp	r3, #1
   177cc:	d000      	beq.n	177d0 <get_fat+0x38>
   177ce:	e08f      	b.n	178f0 <get_fat+0x158>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
   177d0:	683b      	ldr	r3, [r7, #0]
   177d2:	613b      	str	r3, [r7, #16]
   177d4:	693b      	ldr	r3, [r7, #16]
   177d6:	085b      	lsrs	r3, r3, #1
   177d8:	693a      	ldr	r2, [r7, #16]
   177da:	18d3      	adds	r3, r2, r3
   177dc:	613b      	str	r3, [r7, #16]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   177de:	687b      	ldr	r3, [r7, #4]
   177e0:	6a1a      	ldr	r2, [r3, #32]
   177e2:	693b      	ldr	r3, [r7, #16]
   177e4:	0a5b      	lsrs	r3, r3, #9
   177e6:	18d2      	adds	r2, r2, r3
   177e8:	687b      	ldr	r3, [r7, #4]
   177ea:	0011      	movs	r1, r2
   177ec:	0018      	movs	r0, r3
   177ee:	4b48      	ldr	r3, [pc, #288]	; (17910 <get_fat+0x178>)
   177f0:	4798      	blx	r3
   177f2:	1e03      	subs	r3, r0, #0
   177f4:	d000      	beq.n	177f8 <get_fat+0x60>
   177f6:	e07e      	b.n	178f6 <get_fat+0x15e>
			wc = fs->win[bc++ % SS(fs)];
   177f8:	693b      	ldr	r3, [r7, #16]
   177fa:	1c5a      	adds	r2, r3, #1
   177fc:	613a      	str	r2, [r7, #16]
   177fe:	05db      	lsls	r3, r3, #23
   17800:	0ddb      	lsrs	r3, r3, #23
   17802:	687a      	ldr	r2, [r7, #4]
   17804:	2130      	movs	r1, #48	; 0x30
   17806:	18d3      	adds	r3, r2, r3
   17808:	185b      	adds	r3, r3, r1
   1780a:	781b      	ldrb	r3, [r3, #0]
   1780c:	60fb      	str	r3, [r7, #12]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   1780e:	687b      	ldr	r3, [r7, #4]
   17810:	6a1a      	ldr	r2, [r3, #32]
   17812:	693b      	ldr	r3, [r7, #16]
   17814:	0a5b      	lsrs	r3, r3, #9
   17816:	18d2      	adds	r2, r2, r3
   17818:	687b      	ldr	r3, [r7, #4]
   1781a:	0011      	movs	r1, r2
   1781c:	0018      	movs	r0, r3
   1781e:	4b3c      	ldr	r3, [pc, #240]	; (17910 <get_fat+0x178>)
   17820:	4798      	blx	r3
   17822:	1e03      	subs	r3, r0, #0
   17824:	d169      	bne.n	178fa <get_fat+0x162>
			wc |= fs->win[bc % SS(fs)] << 8;
   17826:	693b      	ldr	r3, [r7, #16]
   17828:	05db      	lsls	r3, r3, #23
   1782a:	0ddb      	lsrs	r3, r3, #23
   1782c:	687a      	ldr	r2, [r7, #4]
   1782e:	2130      	movs	r1, #48	; 0x30
   17830:	18d3      	adds	r3, r2, r3
   17832:	185b      	adds	r3, r3, r1
   17834:	781b      	ldrb	r3, [r3, #0]
   17836:	021b      	lsls	r3, r3, #8
   17838:	001a      	movs	r2, r3
   1783a:	68fb      	ldr	r3, [r7, #12]
   1783c:	4313      	orrs	r3, r2
   1783e:	60fb      	str	r3, [r7, #12]
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
   17840:	683b      	ldr	r3, [r7, #0]
   17842:	2201      	movs	r2, #1
   17844:	4013      	ands	r3, r2
   17846:	d002      	beq.n	1784e <get_fat+0xb6>
   17848:	68fb      	ldr	r3, [r7, #12]
   1784a:	091b      	lsrs	r3, r3, #4
   1784c:	e002      	b.n	17854 <get_fat+0xbc>
   1784e:	68fb      	ldr	r3, [r7, #12]
   17850:	051b      	lsls	r3, r3, #20
   17852:	0d1b      	lsrs	r3, r3, #20
   17854:	617b      	str	r3, [r7, #20]
			break;
   17856:	e055      	b.n	17904 <get_fat+0x16c>

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
   17858:	687b      	ldr	r3, [r7, #4]
   1785a:	6a1a      	ldr	r2, [r3, #32]
   1785c:	683b      	ldr	r3, [r7, #0]
   1785e:	0a1b      	lsrs	r3, r3, #8
   17860:	18d2      	adds	r2, r2, r3
   17862:	687b      	ldr	r3, [r7, #4]
   17864:	0011      	movs	r1, r2
   17866:	0018      	movs	r0, r3
   17868:	4b29      	ldr	r3, [pc, #164]	; (17910 <get_fat+0x178>)
   1786a:	4798      	blx	r3
   1786c:	1e03      	subs	r3, r0, #0
   1786e:	d146      	bne.n	178fe <get_fat+0x166>
			p = &fs->win[clst * 2 % SS(fs)];
   17870:	683b      	ldr	r3, [r7, #0]
   17872:	005a      	lsls	r2, r3, #1
   17874:	23ff      	movs	r3, #255	; 0xff
   17876:	005b      	lsls	r3, r3, #1
   17878:	4013      	ands	r3, r2
   1787a:	3330      	adds	r3, #48	; 0x30
   1787c:	687a      	ldr	r2, [r7, #4]
   1787e:	18d3      	adds	r3, r2, r3
   17880:	60bb      	str	r3, [r7, #8]
			val = LD_WORD(p);
   17882:	68bb      	ldr	r3, [r7, #8]
   17884:	3301      	adds	r3, #1
   17886:	781b      	ldrb	r3, [r3, #0]
   17888:	021b      	lsls	r3, r3, #8
   1788a:	b21a      	sxth	r2, r3
   1788c:	68bb      	ldr	r3, [r7, #8]
   1788e:	781b      	ldrb	r3, [r3, #0]
   17890:	b21b      	sxth	r3, r3
   17892:	4313      	orrs	r3, r2
   17894:	b21b      	sxth	r3, r3
   17896:	b29b      	uxth	r3, r3
   17898:	617b      	str	r3, [r7, #20]
			break;
   1789a:	e033      	b.n	17904 <get_fat+0x16c>

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
   1789c:	687b      	ldr	r3, [r7, #4]
   1789e:	6a1a      	ldr	r2, [r3, #32]
   178a0:	683b      	ldr	r3, [r7, #0]
   178a2:	09db      	lsrs	r3, r3, #7
   178a4:	18d2      	adds	r2, r2, r3
   178a6:	687b      	ldr	r3, [r7, #4]
   178a8:	0011      	movs	r1, r2
   178aa:	0018      	movs	r0, r3
   178ac:	4b18      	ldr	r3, [pc, #96]	; (17910 <get_fat+0x178>)
   178ae:	4798      	blx	r3
   178b0:	1e03      	subs	r3, r0, #0
   178b2:	d126      	bne.n	17902 <get_fat+0x16a>
			p = &fs->win[clst * 4 % SS(fs)];
   178b4:	683b      	ldr	r3, [r7, #0]
   178b6:	009a      	lsls	r2, r3, #2
   178b8:	23fe      	movs	r3, #254	; 0xfe
   178ba:	005b      	lsls	r3, r3, #1
   178bc:	4013      	ands	r3, r2
   178be:	3330      	adds	r3, #48	; 0x30
   178c0:	687a      	ldr	r2, [r7, #4]
   178c2:	18d3      	adds	r3, r2, r3
   178c4:	60bb      	str	r3, [r7, #8]
			val = LD_DWORD(p) & 0x0FFFFFFF;
   178c6:	68bb      	ldr	r3, [r7, #8]
   178c8:	3303      	adds	r3, #3
   178ca:	781b      	ldrb	r3, [r3, #0]
   178cc:	061a      	lsls	r2, r3, #24
   178ce:	68bb      	ldr	r3, [r7, #8]
   178d0:	3302      	adds	r3, #2
   178d2:	781b      	ldrb	r3, [r3, #0]
   178d4:	041b      	lsls	r3, r3, #16
   178d6:	4313      	orrs	r3, r2
   178d8:	68ba      	ldr	r2, [r7, #8]
   178da:	3201      	adds	r2, #1
   178dc:	7812      	ldrb	r2, [r2, #0]
   178de:	0212      	lsls	r2, r2, #8
   178e0:	4313      	orrs	r3, r2
   178e2:	68ba      	ldr	r2, [r7, #8]
   178e4:	7812      	ldrb	r2, [r2, #0]
   178e6:	4313      	orrs	r3, r2
   178e8:	011b      	lsls	r3, r3, #4
   178ea:	091b      	lsrs	r3, r3, #4
   178ec:	617b      	str	r3, [r7, #20]
			break;
   178ee:	e009      	b.n	17904 <get_fat+0x16c>

		default:
			val = 1;	/* Internal error */
   178f0:	2301      	movs	r3, #1
   178f2:	617b      	str	r3, [r7, #20]
   178f4:	e006      	b.n	17904 <get_fat+0x16c>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   178f6:	46c0      	nop			; (mov r8, r8)
   178f8:	e004      	b.n	17904 <get_fat+0x16c>
			wc = fs->win[bc++ % SS(fs)];
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   178fa:	46c0      	nop			; (mov r8, r8)
   178fc:	e002      	b.n	17904 <get_fat+0x16c>
			wc |= fs->win[bc % SS(fs)] << 8;
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
   178fe:	46c0      	nop			; (mov r8, r8)
   17900:	e000      	b.n	17904 <get_fat+0x16c>
			p = &fs->win[clst * 2 % SS(fs)];
			val = LD_WORD(p);
			break;

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
   17902:	46c0      	nop			; (mov r8, r8)
		default:
			val = 1;	/* Internal error */
		}
	}

	return val;
   17904:	697b      	ldr	r3, [r7, #20]
}
   17906:	0018      	movs	r0, r3
   17908:	46bd      	mov	sp, r7
   1790a:	b006      	add	sp, #24
   1790c:	bd80      	pop	{r7, pc}
   1790e:	46c0      	nop			; (mov r8, r8)
   17910:	00017555 	.word	0x00017555

00017914 <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
   17914:	b590      	push	{r4, r7, lr}
   17916:	b089      	sub	sp, #36	; 0x24
   17918:	af00      	add	r7, sp, #0
   1791a:	60f8      	str	r0, [r7, #12]
   1791c:	60b9      	str	r1, [r7, #8]
   1791e:	607a      	str	r2, [r7, #4]
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
   17920:	68bb      	ldr	r3, [r7, #8]
   17922:	2b01      	cmp	r3, #1
   17924:	d904      	bls.n	17930 <put_fat+0x1c>
   17926:	68fb      	ldr	r3, [r7, #12]
   17928:	695a      	ldr	r2, [r3, #20]
   1792a:	68bb      	ldr	r3, [r7, #8]
   1792c:	429a      	cmp	r2, r3
   1792e:	d804      	bhi.n	1793a <put_fat+0x26>
		res = FR_INT_ERR;
   17930:	231f      	movs	r3, #31
   17932:	18fb      	adds	r3, r7, r3
   17934:	2202      	movs	r2, #2
   17936:	701a      	strb	r2, [r3, #0]
   17938:	e103      	b.n	17b42 <put_fat+0x22e>

	} else {
		switch (fs->fs_type) {
   1793a:	68fb      	ldr	r3, [r7, #12]
   1793c:	781b      	ldrb	r3, [r3, #0]
   1793e:	2b02      	cmp	r3, #2
   17940:	d100      	bne.n	17944 <put_fat+0x30>
   17942:	e07c      	b.n	17a3e <put_fat+0x12a>
   17944:	2b03      	cmp	r3, #3
   17946:	d100      	bne.n	1794a <put_fat+0x36>
   17948:	e0a3      	b.n	17a92 <put_fat+0x17e>
   1794a:	2b01      	cmp	r3, #1
   1794c:	d000      	beq.n	17950 <put_fat+0x3c>
   1794e:	e0ec      	b.n	17b2a <put_fat+0x216>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
   17950:	68bb      	ldr	r3, [r7, #8]
   17952:	61bb      	str	r3, [r7, #24]
   17954:	69bb      	ldr	r3, [r7, #24]
   17956:	085b      	lsrs	r3, r3, #1
   17958:	69ba      	ldr	r2, [r7, #24]
   1795a:	18d3      	adds	r3, r2, r3
   1795c:	61bb      	str	r3, [r7, #24]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   1795e:	68fb      	ldr	r3, [r7, #12]
   17960:	6a1a      	ldr	r2, [r3, #32]
   17962:	69bb      	ldr	r3, [r7, #24]
   17964:	0a5b      	lsrs	r3, r3, #9
   17966:	18d2      	adds	r2, r2, r3
   17968:	231f      	movs	r3, #31
   1796a:	18fc      	adds	r4, r7, r3
   1796c:	68fb      	ldr	r3, [r7, #12]
   1796e:	0011      	movs	r1, r2
   17970:	0018      	movs	r0, r3
   17972:	4b77      	ldr	r3, [pc, #476]	; (17b50 <put_fat+0x23c>)
   17974:	4798      	blx	r3
   17976:	0003      	movs	r3, r0
   17978:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) break;
   1797a:	231f      	movs	r3, #31
   1797c:	18fb      	adds	r3, r7, r3
   1797e:	781b      	ldrb	r3, [r3, #0]
   17980:	2b00      	cmp	r3, #0
   17982:	d000      	beq.n	17986 <put_fat+0x72>
   17984:	e0d6      	b.n	17b34 <put_fat+0x220>
			p = &fs->win[bc++ % SS(fs)];
   17986:	69bb      	ldr	r3, [r7, #24]
   17988:	1c5a      	adds	r2, r3, #1
   1798a:	61ba      	str	r2, [r7, #24]
   1798c:	05db      	lsls	r3, r3, #23
   1798e:	0ddb      	lsrs	r3, r3, #23
   17990:	3330      	adds	r3, #48	; 0x30
   17992:	68fa      	ldr	r2, [r7, #12]
   17994:	18d3      	adds	r3, r2, r3
   17996:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   17998:	68bb      	ldr	r3, [r7, #8]
   1799a:	2201      	movs	r2, #1
   1799c:	4013      	ands	r3, r2
   1799e:	d00f      	beq.n	179c0 <put_fat+0xac>
   179a0:	697b      	ldr	r3, [r7, #20]
   179a2:	781b      	ldrb	r3, [r3, #0]
   179a4:	b25b      	sxtb	r3, r3
   179a6:	220f      	movs	r2, #15
   179a8:	4013      	ands	r3, r2
   179aa:	b25a      	sxtb	r2, r3
   179ac:	687b      	ldr	r3, [r7, #4]
   179ae:	011b      	lsls	r3, r3, #4
   179b0:	b25b      	sxtb	r3, r3
   179b2:	210f      	movs	r1, #15
   179b4:	438b      	bics	r3, r1
   179b6:	b25b      	sxtb	r3, r3
   179b8:	4313      	orrs	r3, r2
   179ba:	b25b      	sxtb	r3, r3
   179bc:	b2db      	uxtb	r3, r3
   179be:	e001      	b.n	179c4 <put_fat+0xb0>
   179c0:	687b      	ldr	r3, [r7, #4]
   179c2:	b2db      	uxtb	r3, r3
   179c4:	697a      	ldr	r2, [r7, #20]
   179c6:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
   179c8:	68fb      	ldr	r3, [r7, #12]
   179ca:	2201      	movs	r2, #1
   179cc:	711a      	strb	r2, [r3, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   179ce:	68fb      	ldr	r3, [r7, #12]
   179d0:	6a1a      	ldr	r2, [r3, #32]
   179d2:	69bb      	ldr	r3, [r7, #24]
   179d4:	0a5b      	lsrs	r3, r3, #9
   179d6:	18d2      	adds	r2, r2, r3
   179d8:	231f      	movs	r3, #31
   179da:	18fc      	adds	r4, r7, r3
   179dc:	68fb      	ldr	r3, [r7, #12]
   179de:	0011      	movs	r1, r2
   179e0:	0018      	movs	r0, r3
   179e2:	4b5b      	ldr	r3, [pc, #364]	; (17b50 <put_fat+0x23c>)
   179e4:	4798      	blx	r3
   179e6:	0003      	movs	r3, r0
   179e8:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) break;
   179ea:	231f      	movs	r3, #31
   179ec:	18fb      	adds	r3, r7, r3
   179ee:	781b      	ldrb	r3, [r3, #0]
   179f0:	2b00      	cmp	r3, #0
   179f2:	d000      	beq.n	179f6 <put_fat+0xe2>
   179f4:	e0a0      	b.n	17b38 <put_fat+0x224>
			p = &fs->win[bc % SS(fs)];
   179f6:	69bb      	ldr	r3, [r7, #24]
   179f8:	05db      	lsls	r3, r3, #23
   179fa:	0ddb      	lsrs	r3, r3, #23
   179fc:	3330      	adds	r3, #48	; 0x30
   179fe:	68fa      	ldr	r2, [r7, #12]
   17a00:	18d3      	adds	r3, r2, r3
   17a02:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   17a04:	68bb      	ldr	r3, [r7, #8]
   17a06:	2201      	movs	r2, #1
   17a08:	4013      	ands	r3, r2
   17a0a:	d003      	beq.n	17a14 <put_fat+0x100>
   17a0c:	687b      	ldr	r3, [r7, #4]
   17a0e:	091b      	lsrs	r3, r3, #4
   17a10:	b2db      	uxtb	r3, r3
   17a12:	e00e      	b.n	17a32 <put_fat+0x11e>
   17a14:	697b      	ldr	r3, [r7, #20]
   17a16:	781b      	ldrb	r3, [r3, #0]
   17a18:	b25b      	sxtb	r3, r3
   17a1a:	220f      	movs	r2, #15
   17a1c:	4393      	bics	r3, r2
   17a1e:	b25a      	sxtb	r2, r3
   17a20:	687b      	ldr	r3, [r7, #4]
   17a22:	0a1b      	lsrs	r3, r3, #8
   17a24:	b25b      	sxtb	r3, r3
   17a26:	210f      	movs	r1, #15
   17a28:	400b      	ands	r3, r1
   17a2a:	b25b      	sxtb	r3, r3
   17a2c:	4313      	orrs	r3, r2
   17a2e:	b25b      	sxtb	r3, r3
   17a30:	b2db      	uxtb	r3, r3
   17a32:	697a      	ldr	r2, [r7, #20]
   17a34:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
   17a36:	68fb      	ldr	r3, [r7, #12]
   17a38:	2201      	movs	r2, #1
   17a3a:	711a      	strb	r2, [r3, #4]
			break;
   17a3c:	e081      	b.n	17b42 <put_fat+0x22e>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   17a3e:	68fb      	ldr	r3, [r7, #12]
   17a40:	6a1a      	ldr	r2, [r3, #32]
   17a42:	68bb      	ldr	r3, [r7, #8]
   17a44:	0a1b      	lsrs	r3, r3, #8
   17a46:	18d2      	adds	r2, r2, r3
   17a48:	231f      	movs	r3, #31
   17a4a:	18fc      	adds	r4, r7, r3
   17a4c:	68fb      	ldr	r3, [r7, #12]
   17a4e:	0011      	movs	r1, r2
   17a50:	0018      	movs	r0, r3
   17a52:	4b3f      	ldr	r3, [pc, #252]	; (17b50 <put_fat+0x23c>)
   17a54:	4798      	blx	r3
   17a56:	0003      	movs	r3, r0
   17a58:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) break;
   17a5a:	231f      	movs	r3, #31
   17a5c:	18fb      	adds	r3, r7, r3
   17a5e:	781b      	ldrb	r3, [r3, #0]
   17a60:	2b00      	cmp	r3, #0
   17a62:	d16b      	bne.n	17b3c <put_fat+0x228>
			p = &fs->win[clst * 2 % SS(fs)];
   17a64:	68bb      	ldr	r3, [r7, #8]
   17a66:	005a      	lsls	r2, r3, #1
   17a68:	23ff      	movs	r3, #255	; 0xff
   17a6a:	005b      	lsls	r3, r3, #1
   17a6c:	4013      	ands	r3, r2
   17a6e:	3330      	adds	r3, #48	; 0x30
   17a70:	68fa      	ldr	r2, [r7, #12]
   17a72:	18d3      	adds	r3, r2, r3
   17a74:	617b      	str	r3, [r7, #20]
			ST_WORD(p, (WORD)val);
   17a76:	687b      	ldr	r3, [r7, #4]
   17a78:	b2da      	uxtb	r2, r3
   17a7a:	697b      	ldr	r3, [r7, #20]
   17a7c:	701a      	strb	r2, [r3, #0]
   17a7e:	697b      	ldr	r3, [r7, #20]
   17a80:	3301      	adds	r3, #1
   17a82:	687a      	ldr	r2, [r7, #4]
   17a84:	1212      	asrs	r2, r2, #8
   17a86:	b2d2      	uxtb	r2, r2
   17a88:	701a      	strb	r2, [r3, #0]
			fs->wflag = 1;
   17a8a:	68fb      	ldr	r3, [r7, #12]
   17a8c:	2201      	movs	r2, #1
   17a8e:	711a      	strb	r2, [r3, #4]
			break;
   17a90:	e057      	b.n	17b42 <put_fat+0x22e>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   17a92:	68fb      	ldr	r3, [r7, #12]
   17a94:	6a1a      	ldr	r2, [r3, #32]
   17a96:	68bb      	ldr	r3, [r7, #8]
   17a98:	09db      	lsrs	r3, r3, #7
   17a9a:	18d2      	adds	r2, r2, r3
   17a9c:	231f      	movs	r3, #31
   17a9e:	18fc      	adds	r4, r7, r3
   17aa0:	68fb      	ldr	r3, [r7, #12]
   17aa2:	0011      	movs	r1, r2
   17aa4:	0018      	movs	r0, r3
   17aa6:	4b2a      	ldr	r3, [pc, #168]	; (17b50 <put_fat+0x23c>)
   17aa8:	4798      	blx	r3
   17aaa:	0003      	movs	r3, r0
   17aac:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) break;
   17aae:	231f      	movs	r3, #31
   17ab0:	18fb      	adds	r3, r7, r3
   17ab2:	781b      	ldrb	r3, [r3, #0]
   17ab4:	2b00      	cmp	r3, #0
   17ab6:	d143      	bne.n	17b40 <put_fat+0x22c>
			p = &fs->win[clst * 4 % SS(fs)];
   17ab8:	68bb      	ldr	r3, [r7, #8]
   17aba:	009a      	lsls	r2, r3, #2
   17abc:	23fe      	movs	r3, #254	; 0xfe
   17abe:	005b      	lsls	r3, r3, #1
   17ac0:	4013      	ands	r3, r2
   17ac2:	3330      	adds	r3, #48	; 0x30
   17ac4:	68fa      	ldr	r2, [r7, #12]
   17ac6:	18d3      	adds	r3, r2, r3
   17ac8:	617b      	str	r3, [r7, #20]
			val |= LD_DWORD(p) & 0xF0000000;
   17aca:	697b      	ldr	r3, [r7, #20]
   17acc:	3303      	adds	r3, #3
   17ace:	781b      	ldrb	r3, [r3, #0]
   17ad0:	061a      	lsls	r2, r3, #24
   17ad2:	697b      	ldr	r3, [r7, #20]
   17ad4:	3302      	adds	r3, #2
   17ad6:	781b      	ldrb	r3, [r3, #0]
   17ad8:	041b      	lsls	r3, r3, #16
   17ada:	4313      	orrs	r3, r2
   17adc:	697a      	ldr	r2, [r7, #20]
   17ade:	3201      	adds	r2, #1
   17ae0:	7812      	ldrb	r2, [r2, #0]
   17ae2:	0212      	lsls	r2, r2, #8
   17ae4:	4313      	orrs	r3, r2
   17ae6:	697a      	ldr	r2, [r7, #20]
   17ae8:	7812      	ldrb	r2, [r2, #0]
   17aea:	4313      	orrs	r3, r2
   17aec:	0f1b      	lsrs	r3, r3, #28
   17aee:	071b      	lsls	r3, r3, #28
   17af0:	687a      	ldr	r2, [r7, #4]
   17af2:	4313      	orrs	r3, r2
   17af4:	607b      	str	r3, [r7, #4]
			ST_DWORD(p, val);
   17af6:	687b      	ldr	r3, [r7, #4]
   17af8:	b2da      	uxtb	r2, r3
   17afa:	697b      	ldr	r3, [r7, #20]
   17afc:	701a      	strb	r2, [r3, #0]
   17afe:	697b      	ldr	r3, [r7, #20]
   17b00:	3301      	adds	r3, #1
   17b02:	687a      	ldr	r2, [r7, #4]
   17b04:	1212      	asrs	r2, r2, #8
   17b06:	b2d2      	uxtb	r2, r2
   17b08:	701a      	strb	r2, [r3, #0]
   17b0a:	697b      	ldr	r3, [r7, #20]
   17b0c:	3302      	adds	r3, #2
   17b0e:	687a      	ldr	r2, [r7, #4]
   17b10:	0c12      	lsrs	r2, r2, #16
   17b12:	b2d2      	uxtb	r2, r2
   17b14:	701a      	strb	r2, [r3, #0]
   17b16:	697b      	ldr	r3, [r7, #20]
   17b18:	3303      	adds	r3, #3
   17b1a:	687a      	ldr	r2, [r7, #4]
   17b1c:	0e12      	lsrs	r2, r2, #24
   17b1e:	b2d2      	uxtb	r2, r2
   17b20:	701a      	strb	r2, [r3, #0]
			fs->wflag = 1;
   17b22:	68fb      	ldr	r3, [r7, #12]
   17b24:	2201      	movs	r2, #1
   17b26:	711a      	strb	r2, [r3, #4]
			break;
   17b28:	e00b      	b.n	17b42 <put_fat+0x22e>

		default :
			res = FR_INT_ERR;
   17b2a:	231f      	movs	r3, #31
   17b2c:	18fb      	adds	r3, r7, r3
   17b2e:	2202      	movs	r2, #2
   17b30:	701a      	strb	r2, [r3, #0]
   17b32:	e006      	b.n	17b42 <put_fat+0x22e>
	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
   17b34:	46c0      	nop			; (mov r8, r8)
   17b36:	e004      	b.n	17b42 <put_fat+0x22e>
			p = &fs->win[bc++ % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
   17b38:	46c0      	nop			; (mov r8, r8)
   17b3a:	e002      	b.n	17b42 <put_fat+0x22e>
			fs->wflag = 1;
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
   17b3c:	46c0      	nop			; (mov r8, r8)
   17b3e:	e000      	b.n	17b42 <put_fat+0x22e>
			fs->wflag = 1;
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
			if (res != FR_OK) break;
   17b40:	46c0      	nop			; (mov r8, r8)
		default :
			res = FR_INT_ERR;
		}
	}

	return res;
   17b42:	231f      	movs	r3, #31
   17b44:	18fb      	adds	r3, r7, r3
   17b46:	781b      	ldrb	r3, [r3, #0]
}
   17b48:	0018      	movs	r0, r3
   17b4a:	46bd      	mov	sp, r7
   17b4c:	b009      	add	sp, #36	; 0x24
   17b4e:	bd90      	pop	{r4, r7, pc}
   17b50:	00017555 	.word	0x00017555

00017b54 <remove_chain>:
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
   17b54:	b590      	push	{r4, r7, lr}
   17b56:	b085      	sub	sp, #20
   17b58:	af00      	add	r7, sp, #0
   17b5a:	6078      	str	r0, [r7, #4]
   17b5c:	6039      	str	r1, [r7, #0]
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
   17b5e:	683b      	ldr	r3, [r7, #0]
   17b60:	2b01      	cmp	r3, #1
   17b62:	d904      	bls.n	17b6e <remove_chain+0x1a>
   17b64:	687b      	ldr	r3, [r7, #4]
   17b66:	695a      	ldr	r2, [r3, #20]
   17b68:	683b      	ldr	r3, [r7, #0]
   17b6a:	429a      	cmp	r2, r3
   17b6c:	d804      	bhi.n	17b78 <remove_chain+0x24>
		res = FR_INT_ERR;
   17b6e:	230f      	movs	r3, #15
   17b70:	18fb      	adds	r3, r7, r3
   17b72:	2202      	movs	r2, #2
   17b74:	701a      	strb	r2, [r3, #0]
   17b76:	e049      	b.n	17c0c <remove_chain+0xb8>

	} else {
		res = FR_OK;
   17b78:	230f      	movs	r3, #15
   17b7a:	18fb      	adds	r3, r7, r3
   17b7c:	2200      	movs	r2, #0
   17b7e:	701a      	strb	r2, [r3, #0]
		while (clst < fs->n_fatent) {			/* Not a last link? */
   17b80:	e03b      	b.n	17bfa <remove_chain+0xa6>
			nxt = get_fat(fs, clst);			/* Get cluster status */
   17b82:	683a      	ldr	r2, [r7, #0]
   17b84:	687b      	ldr	r3, [r7, #4]
   17b86:	0011      	movs	r1, r2
   17b88:	0018      	movs	r0, r3
   17b8a:	4b24      	ldr	r3, [pc, #144]	; (17c1c <remove_chain+0xc8>)
   17b8c:	4798      	blx	r3
   17b8e:	0003      	movs	r3, r0
   17b90:	60bb      	str	r3, [r7, #8]
			if (nxt == 0) break;				/* Empty cluster? */
   17b92:	68bb      	ldr	r3, [r7, #8]
   17b94:	2b00      	cmp	r3, #0
   17b96:	d036      	beq.n	17c06 <remove_chain+0xb2>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   17b98:	68bb      	ldr	r3, [r7, #8]
   17b9a:	2b01      	cmp	r3, #1
   17b9c:	d104      	bne.n	17ba8 <remove_chain+0x54>
   17b9e:	230f      	movs	r3, #15
   17ba0:	18fb      	adds	r3, r7, r3
   17ba2:	2202      	movs	r2, #2
   17ba4:	701a      	strb	r2, [r3, #0]
   17ba6:	e031      	b.n	17c0c <remove_chain+0xb8>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   17ba8:	68bb      	ldr	r3, [r7, #8]
   17baa:	3301      	adds	r3, #1
   17bac:	d104      	bne.n	17bb8 <remove_chain+0x64>
   17bae:	230f      	movs	r3, #15
   17bb0:	18fb      	adds	r3, r7, r3
   17bb2:	2201      	movs	r2, #1
   17bb4:	701a      	strb	r2, [r3, #0]
   17bb6:	e029      	b.n	17c0c <remove_chain+0xb8>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
   17bb8:	230f      	movs	r3, #15
   17bba:	18fc      	adds	r4, r7, r3
   17bbc:	6839      	ldr	r1, [r7, #0]
   17bbe:	687b      	ldr	r3, [r7, #4]
   17bc0:	2200      	movs	r2, #0
   17bc2:	0018      	movs	r0, r3
   17bc4:	4b16      	ldr	r3, [pc, #88]	; (17c20 <remove_chain+0xcc>)
   17bc6:	4798      	blx	r3
   17bc8:	0003      	movs	r3, r0
   17bca:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) break;
   17bcc:	230f      	movs	r3, #15
   17bce:	18fb      	adds	r3, r7, r3
   17bd0:	781b      	ldrb	r3, [r3, #0]
   17bd2:	2b00      	cmp	r3, #0
   17bd4:	d119      	bne.n	17c0a <remove_chain+0xb6>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
   17bd6:	687b      	ldr	r3, [r7, #4]
   17bd8:	691b      	ldr	r3, [r3, #16]
   17bda:	3301      	adds	r3, #1
   17bdc:	d00b      	beq.n	17bf6 <remove_chain+0xa2>
				fs->free_clust++;
   17bde:	687b      	ldr	r3, [r7, #4]
   17be0:	691b      	ldr	r3, [r3, #16]
   17be2:	1c5a      	adds	r2, r3, #1
   17be4:	687b      	ldr	r3, [r7, #4]
   17be6:	611a      	str	r2, [r3, #16]
				fs->fsi_flag |= 1;
   17be8:	687b      	ldr	r3, [r7, #4]
   17bea:	795b      	ldrb	r3, [r3, #5]
   17bec:	2201      	movs	r2, #1
   17bee:	4313      	orrs	r3, r2
   17bf0:	b2da      	uxtb	r2, r3
   17bf2:	687b      	ldr	r3, [r7, #4]
   17bf4:	715a      	strb	r2, [r3, #5]
				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
				disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Erase the block */
				scl = ecl = nxt;
			}
#endif
			clst = nxt;	/* Next cluster */
   17bf6:	68bb      	ldr	r3, [r7, #8]
   17bf8:	603b      	str	r3, [r7, #0]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
   17bfa:	687b      	ldr	r3, [r7, #4]
   17bfc:	695a      	ldr	r2, [r3, #20]
   17bfe:	683b      	ldr	r3, [r7, #0]
   17c00:	429a      	cmp	r2, r3
   17c02:	d8be      	bhi.n	17b82 <remove_chain+0x2e>
   17c04:	e002      	b.n	17c0c <remove_chain+0xb8>
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
   17c06:	46c0      	nop			; (mov r8, r8)
   17c08:	e000      	b.n	17c0c <remove_chain+0xb8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
   17c0a:	46c0      	nop			; (mov r8, r8)
#endif
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
   17c0c:	230f      	movs	r3, #15
   17c0e:	18fb      	adds	r3, r7, r3
   17c10:	781b      	ldrb	r3, [r3, #0]
}
   17c12:	0018      	movs	r0, r3
   17c14:	46bd      	mov	sp, r7
   17c16:	b005      	add	sp, #20
   17c18:	bd90      	pop	{r4, r7, pc}
   17c1a:	46c0      	nop			; (mov r8, r8)
   17c1c:	00017799 	.word	0x00017799
   17c20:	00017915 	.word	0x00017915

00017c24 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
   17c24:	b590      	push	{r4, r7, lr}
   17c26:	b087      	sub	sp, #28
   17c28:	af00      	add	r7, sp, #0
   17c2a:	6078      	str	r0, [r7, #4]
   17c2c:	6039      	str	r1, [r7, #0]
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
   17c2e:	683b      	ldr	r3, [r7, #0]
   17c30:	2b00      	cmp	r3, #0
   17c32:	d10d      	bne.n	17c50 <create_chain+0x2c>
		scl = fs->last_clust;			/* Get suggested start point */
   17c34:	687b      	ldr	r3, [r7, #4]
   17c36:	68db      	ldr	r3, [r3, #12]
   17c38:	613b      	str	r3, [r7, #16]
		if (!scl || scl >= fs->n_fatent) scl = 1;
   17c3a:	693b      	ldr	r3, [r7, #16]
   17c3c:	2b00      	cmp	r3, #0
   17c3e:	d004      	beq.n	17c4a <create_chain+0x26>
   17c40:	687b      	ldr	r3, [r7, #4]
   17c42:	695a      	ldr	r2, [r3, #20]
   17c44:	693b      	ldr	r3, [r7, #16]
   17c46:	429a      	cmp	r2, r3
   17c48:	d81d      	bhi.n	17c86 <create_chain+0x62>
   17c4a:	2301      	movs	r3, #1
   17c4c:	613b      	str	r3, [r7, #16]
   17c4e:	e01a      	b.n	17c86 <create_chain+0x62>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
   17c50:	683a      	ldr	r2, [r7, #0]
   17c52:	687b      	ldr	r3, [r7, #4]
   17c54:	0011      	movs	r1, r2
   17c56:	0018      	movs	r0, r3
   17c58:	4b43      	ldr	r3, [pc, #268]	; (17d68 <create_chain+0x144>)
   17c5a:	4798      	blx	r3
   17c5c:	0003      	movs	r3, r0
   17c5e:	60bb      	str	r3, [r7, #8]
		if (cs < 2) return 1;			/* Invalid value */
   17c60:	68bb      	ldr	r3, [r7, #8]
   17c62:	2b01      	cmp	r3, #1
   17c64:	d801      	bhi.n	17c6a <create_chain+0x46>
   17c66:	2301      	movs	r3, #1
   17c68:	e079      	b.n	17d5e <create_chain+0x13a>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
   17c6a:	68bb      	ldr	r3, [r7, #8]
   17c6c:	3301      	adds	r3, #1
   17c6e:	d101      	bne.n	17c74 <create_chain+0x50>
   17c70:	68bb      	ldr	r3, [r7, #8]
   17c72:	e074      	b.n	17d5e <create_chain+0x13a>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   17c74:	687b      	ldr	r3, [r7, #4]
   17c76:	695a      	ldr	r2, [r3, #20]
   17c78:	68bb      	ldr	r3, [r7, #8]
   17c7a:	429a      	cmp	r2, r3
   17c7c:	d901      	bls.n	17c82 <create_chain+0x5e>
   17c7e:	68bb      	ldr	r3, [r7, #8]
   17c80:	e06d      	b.n	17d5e <create_chain+0x13a>
		scl = clst;
   17c82:	683b      	ldr	r3, [r7, #0]
   17c84:	613b      	str	r3, [r7, #16]
	}

	ncl = scl;				/* Start cluster */
   17c86:	693b      	ldr	r3, [r7, #16]
   17c88:	617b      	str	r3, [r7, #20]
	for (;;) {
		ncl++;							/* Next cluster */
   17c8a:	697b      	ldr	r3, [r7, #20]
   17c8c:	3301      	adds	r3, #1
   17c8e:	617b      	str	r3, [r7, #20]
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
   17c90:	687b      	ldr	r3, [r7, #4]
   17c92:	695a      	ldr	r2, [r3, #20]
   17c94:	697b      	ldr	r3, [r7, #20]
   17c96:	429a      	cmp	r2, r3
   17c98:	d807      	bhi.n	17caa <create_chain+0x86>
			ncl = 2;
   17c9a:	2302      	movs	r3, #2
   17c9c:	617b      	str	r3, [r7, #20]
			if (ncl > scl) return 0;	/* No free cluster */
   17c9e:	697a      	ldr	r2, [r7, #20]
   17ca0:	693b      	ldr	r3, [r7, #16]
   17ca2:	429a      	cmp	r2, r3
   17ca4:	d901      	bls.n	17caa <create_chain+0x86>
   17ca6:	2300      	movs	r3, #0
   17ca8:	e059      	b.n	17d5e <create_chain+0x13a>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
   17caa:	697a      	ldr	r2, [r7, #20]
   17cac:	687b      	ldr	r3, [r7, #4]
   17cae:	0011      	movs	r1, r2
   17cb0:	0018      	movs	r0, r3
   17cb2:	4b2d      	ldr	r3, [pc, #180]	; (17d68 <create_chain+0x144>)
   17cb4:	4798      	blx	r3
   17cb6:	0003      	movs	r3, r0
   17cb8:	60bb      	str	r3, [r7, #8]
		if (cs == 0) break;				/* Found a free cluster */
   17cba:	68bb      	ldr	r3, [r7, #8]
   17cbc:	2b00      	cmp	r3, #0
   17cbe:	d00d      	beq.n	17cdc <create_chain+0xb8>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   17cc0:	68bb      	ldr	r3, [r7, #8]
   17cc2:	3301      	adds	r3, #1
   17cc4:	d002      	beq.n	17ccc <create_chain+0xa8>
   17cc6:	68bb      	ldr	r3, [r7, #8]
   17cc8:	2b01      	cmp	r3, #1
   17cca:	d101      	bne.n	17cd0 <create_chain+0xac>
			return cs;
   17ccc:	68bb      	ldr	r3, [r7, #8]
   17cce:	e046      	b.n	17d5e <create_chain+0x13a>
		if (ncl == scl) return 0;		/* No free cluster */
   17cd0:	697a      	ldr	r2, [r7, #20]
   17cd2:	693b      	ldr	r3, [r7, #16]
   17cd4:	429a      	cmp	r2, r3
   17cd6:	d1d8      	bne.n	17c8a <create_chain+0x66>
   17cd8:	2300      	movs	r3, #0
   17cda:	e040      	b.n	17d5e <create_chain+0x13a>
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
   17cdc:	46c0      	nop			; (mov r8, r8)
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   17cde:	230f      	movs	r3, #15
   17ce0:	18fc      	adds	r4, r7, r3
   17ce2:	4a22      	ldr	r2, [pc, #136]	; (17d6c <create_chain+0x148>)
   17ce4:	6979      	ldr	r1, [r7, #20]
   17ce6:	687b      	ldr	r3, [r7, #4]
   17ce8:	0018      	movs	r0, r3
   17cea:	4b21      	ldr	r3, [pc, #132]	; (17d70 <create_chain+0x14c>)
   17cec:	4798      	blx	r3
   17cee:	0003      	movs	r3, r0
   17cf0:	7023      	strb	r3, [r4, #0]
	if (res == FR_OK && clst != 0) {
   17cf2:	230f      	movs	r3, #15
   17cf4:	18fb      	adds	r3, r7, r3
   17cf6:	781b      	ldrb	r3, [r3, #0]
   17cf8:	2b00      	cmp	r3, #0
   17cfa:	d10c      	bne.n	17d16 <create_chain+0xf2>
   17cfc:	683b      	ldr	r3, [r7, #0]
   17cfe:	2b00      	cmp	r3, #0
   17d00:	d009      	beq.n	17d16 <create_chain+0xf2>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   17d02:	230f      	movs	r3, #15
   17d04:	18fc      	adds	r4, r7, r3
   17d06:	697a      	ldr	r2, [r7, #20]
   17d08:	6839      	ldr	r1, [r7, #0]
   17d0a:	687b      	ldr	r3, [r7, #4]
   17d0c:	0018      	movs	r0, r3
   17d0e:	4b18      	ldr	r3, [pc, #96]	; (17d70 <create_chain+0x14c>)
   17d10:	4798      	blx	r3
   17d12:	0003      	movs	r3, r0
   17d14:	7023      	strb	r3, [r4, #0]
	}
	if (res == FR_OK) {
   17d16:	230f      	movs	r3, #15
   17d18:	18fb      	adds	r3, r7, r3
   17d1a:	781b      	ldrb	r3, [r3, #0]
   17d1c:	2b00      	cmp	r3, #0
   17d1e:	d113      	bne.n	17d48 <create_chain+0x124>
		fs->last_clust = ncl;			/* Update FSINFO */
   17d20:	687b      	ldr	r3, [r7, #4]
   17d22:	697a      	ldr	r2, [r7, #20]
   17d24:	60da      	str	r2, [r3, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
   17d26:	687b      	ldr	r3, [r7, #4]
   17d28:	691b      	ldr	r3, [r3, #16]
   17d2a:	3301      	adds	r3, #1
   17d2c:	d016      	beq.n	17d5c <create_chain+0x138>
			fs->free_clust--;
   17d2e:	687b      	ldr	r3, [r7, #4]
   17d30:	691b      	ldr	r3, [r3, #16]
   17d32:	1e5a      	subs	r2, r3, #1
   17d34:	687b      	ldr	r3, [r7, #4]
   17d36:	611a      	str	r2, [r3, #16]
			fs->fsi_flag |= 1;
   17d38:	687b      	ldr	r3, [r7, #4]
   17d3a:	795b      	ldrb	r3, [r3, #5]
   17d3c:	2201      	movs	r2, #1
   17d3e:	4313      	orrs	r3, r2
   17d40:	b2da      	uxtb	r2, r3
   17d42:	687b      	ldr	r3, [r7, #4]
   17d44:	715a      	strb	r2, [r3, #5]
   17d46:	e009      	b.n	17d5c <create_chain+0x138>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   17d48:	230f      	movs	r3, #15
   17d4a:	18fb      	adds	r3, r7, r3
   17d4c:	781b      	ldrb	r3, [r3, #0]
   17d4e:	2b01      	cmp	r3, #1
   17d50:	d102      	bne.n	17d58 <create_chain+0x134>
   17d52:	2301      	movs	r3, #1
   17d54:	425b      	negs	r3, r3
   17d56:	e000      	b.n	17d5a <create_chain+0x136>
   17d58:	2301      	movs	r3, #1
   17d5a:	617b      	str	r3, [r7, #20]
	}

	return ncl;		/* Return new cluster number or error code */
   17d5c:	697b      	ldr	r3, [r7, #20]
}
   17d5e:	0018      	movs	r0, r3
   17d60:	46bd      	mov	sp, r7
   17d62:	b007      	add	sp, #28
   17d64:	bd90      	pop	{r4, r7, pc}
   17d66:	46c0      	nop			; (mov r8, r8)
   17d68:	00017799 	.word	0x00017799
   17d6c:	0fffffff 	.word	0x0fffffff
   17d70:	00017915 	.word	0x00017915

00017d74 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
   17d74:	b580      	push	{r7, lr}
   17d76:	b086      	sub	sp, #24
   17d78:	af00      	add	r7, sp, #0
   17d7a:	6078      	str	r0, [r7, #4]
   17d7c:	6039      	str	r1, [r7, #0]
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
   17d7e:	683b      	ldr	r3, [r7, #0]
   17d80:	b29a      	uxth	r2, r3
   17d82:	687b      	ldr	r3, [r7, #4]
   17d84:	80da      	strh	r2, [r3, #6]
	clst = dp->sclust;		/* Table start cluster (0:root) */
   17d86:	687b      	ldr	r3, [r7, #4]
   17d88:	689b      	ldr	r3, [r3, #8]
   17d8a:	617b      	str	r3, [r7, #20]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
   17d8c:	697b      	ldr	r3, [r7, #20]
   17d8e:	2b01      	cmp	r3, #1
   17d90:	d005      	beq.n	17d9e <dir_sdi+0x2a>
   17d92:	687b      	ldr	r3, [r7, #4]
   17d94:	681b      	ldr	r3, [r3, #0]
   17d96:	695a      	ldr	r2, [r3, #20]
   17d98:	697b      	ldr	r3, [r7, #20]
   17d9a:	429a      	cmp	r2, r3
   17d9c:	d801      	bhi.n	17da2 <dir_sdi+0x2e>
		return FR_INT_ERR;
   17d9e:	2302      	movs	r3, #2
   17da0:	e066      	b.n	17e70 <dir_sdi+0xfc>
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   17da2:	697b      	ldr	r3, [r7, #20]
   17da4:	2b00      	cmp	r3, #0
   17da6:	d108      	bne.n	17dba <dir_sdi+0x46>
   17da8:	687b      	ldr	r3, [r7, #4]
   17daa:	681b      	ldr	r3, [r3, #0]
   17dac:	781b      	ldrb	r3, [r3, #0]
   17dae:	2b03      	cmp	r3, #3
   17db0:	d103      	bne.n	17dba <dir_sdi+0x46>
		clst = dp->fs->dirbase;
   17db2:	687b      	ldr	r3, [r7, #4]
   17db4:	681b      	ldr	r3, [r3, #0]
   17db6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   17db8:	617b      	str	r3, [r7, #20]

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
   17dba:	697b      	ldr	r3, [r7, #20]
   17dbc:	2b00      	cmp	r3, #0
   17dbe:	d10d      	bne.n	17ddc <dir_sdi+0x68>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
   17dc0:	687b      	ldr	r3, [r7, #4]
   17dc2:	681b      	ldr	r3, [r3, #0]
   17dc4:	891b      	ldrh	r3, [r3, #8]
   17dc6:	1e1a      	subs	r2, r3, #0
   17dc8:	683b      	ldr	r3, [r7, #0]
   17dca:	429a      	cmp	r2, r3
   17dcc:	d801      	bhi.n	17dd2 <dir_sdi+0x5e>
			return FR_INT_ERR;
   17dce:	2302      	movs	r3, #2
   17dd0:	e04e      	b.n	17e70 <dir_sdi+0xfc>
		sect = dp->fs->dirbase;
   17dd2:	687b      	ldr	r3, [r7, #4]
   17dd4:	681b      	ldr	r3, [r3, #0]
   17dd6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   17dd8:	613b      	str	r3, [r7, #16]
   17dda:	e02f      	b.n	17e3c <dir_sdi+0xc8>
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
   17ddc:	687b      	ldr	r3, [r7, #4]
   17dde:	681b      	ldr	r3, [r3, #0]
   17de0:	789b      	ldrb	r3, [r3, #2]
   17de2:	011b      	lsls	r3, r3, #4
   17de4:	60fb      	str	r3, [r7, #12]
		while (idx >= ic) {	/* Follow cluster chain */
   17de6:	e01c      	b.n	17e22 <dir_sdi+0xae>
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
   17de8:	687b      	ldr	r3, [r7, #4]
   17dea:	681b      	ldr	r3, [r3, #0]
   17dec:	697a      	ldr	r2, [r7, #20]
   17dee:	0011      	movs	r1, r2
   17df0:	0018      	movs	r0, r3
   17df2:	4b21      	ldr	r3, [pc, #132]	; (17e78 <dir_sdi+0x104>)
   17df4:	4798      	blx	r3
   17df6:	0003      	movs	r3, r0
   17df8:	617b      	str	r3, [r7, #20]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   17dfa:	697b      	ldr	r3, [r7, #20]
   17dfc:	3301      	adds	r3, #1
   17dfe:	d101      	bne.n	17e04 <dir_sdi+0x90>
   17e00:	2301      	movs	r3, #1
   17e02:	e035      	b.n	17e70 <dir_sdi+0xfc>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
   17e04:	697b      	ldr	r3, [r7, #20]
   17e06:	2b01      	cmp	r3, #1
   17e08:	d905      	bls.n	17e16 <dir_sdi+0xa2>
   17e0a:	687b      	ldr	r3, [r7, #4]
   17e0c:	681b      	ldr	r3, [r3, #0]
   17e0e:	695a      	ldr	r2, [r3, #20]
   17e10:	697b      	ldr	r3, [r7, #20]
   17e12:	429a      	cmp	r2, r3
   17e14:	d801      	bhi.n	17e1a <dir_sdi+0xa6>
				return FR_INT_ERR;
   17e16:	2302      	movs	r3, #2
   17e18:	e02a      	b.n	17e70 <dir_sdi+0xfc>
			idx -= ic;
   17e1a:	683a      	ldr	r2, [r7, #0]
   17e1c:	68fb      	ldr	r3, [r7, #12]
   17e1e:	1ad3      	subs	r3, r2, r3
   17e20:	603b      	str	r3, [r7, #0]
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
   17e22:	683a      	ldr	r2, [r7, #0]
   17e24:	68fb      	ldr	r3, [r7, #12]
   17e26:	429a      	cmp	r2, r3
   17e28:	d2de      	bcs.n	17de8 <dir_sdi+0x74>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
   17e2a:	687b      	ldr	r3, [r7, #4]
   17e2c:	681b      	ldr	r3, [r3, #0]
   17e2e:	697a      	ldr	r2, [r7, #20]
   17e30:	0011      	movs	r1, r2
   17e32:	0018      	movs	r0, r3
   17e34:	4b11      	ldr	r3, [pc, #68]	; (17e7c <dir_sdi+0x108>)
   17e36:	4798      	blx	r3
   17e38:	0003      	movs	r3, r0
   17e3a:	613b      	str	r3, [r7, #16]
	}
	dp->clust = clst;	/* Current cluster# */
   17e3c:	687b      	ldr	r3, [r7, #4]
   17e3e:	697a      	ldr	r2, [r7, #20]
   17e40:	60da      	str	r2, [r3, #12]
	if (!sect) return FR_INT_ERR;
   17e42:	693b      	ldr	r3, [r7, #16]
   17e44:	2b00      	cmp	r3, #0
   17e46:	d101      	bne.n	17e4c <dir_sdi+0xd8>
   17e48:	2302      	movs	r3, #2
   17e4a:	e011      	b.n	17e70 <dir_sdi+0xfc>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
   17e4c:	683b      	ldr	r3, [r7, #0]
   17e4e:	091a      	lsrs	r2, r3, #4
   17e50:	693b      	ldr	r3, [r7, #16]
   17e52:	18d2      	adds	r2, r2, r3
   17e54:	687b      	ldr	r3, [r7, #4]
   17e56:	611a      	str	r2, [r3, #16]
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
   17e58:	687b      	ldr	r3, [r7, #4]
   17e5a:	681b      	ldr	r3, [r3, #0]
   17e5c:	3330      	adds	r3, #48	; 0x30
   17e5e:	001a      	movs	r2, r3
   17e60:	683b      	ldr	r3, [r7, #0]
   17e62:	210f      	movs	r1, #15
   17e64:	400b      	ands	r3, r1
   17e66:	015b      	lsls	r3, r3, #5
   17e68:	18d2      	adds	r2, r2, r3
   17e6a:	687b      	ldr	r3, [r7, #4]
   17e6c:	615a      	str	r2, [r3, #20]

	return FR_OK;
   17e6e:	2300      	movs	r3, #0
}
   17e70:	0018      	movs	r0, r3
   17e72:	46bd      	mov	sp, r7
   17e74:	b006      	add	sp, #24
   17e76:	bd80      	pop	{r7, pc}
   17e78:	00017799 	.word	0x00017799
   17e7c:	00017761 	.word	0x00017761

00017e80 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
   17e80:	b590      	push	{r4, r7, lr}
   17e82:	b087      	sub	sp, #28
   17e84:	af00      	add	r7, sp, #0
   17e86:	6078      	str	r0, [r7, #4]
   17e88:	6039      	str	r1, [r7, #0]
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
   17e8a:	687b      	ldr	r3, [r7, #4]
   17e8c:	88db      	ldrh	r3, [r3, #6]
   17e8e:	3301      	adds	r3, #1
   17e90:	60fb      	str	r3, [r7, #12]
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
   17e92:	68fb      	ldr	r3, [r7, #12]
   17e94:	041b      	lsls	r3, r3, #16
   17e96:	0c1b      	lsrs	r3, r3, #16
   17e98:	d003      	beq.n	17ea2 <dir_next+0x22>
   17e9a:	687b      	ldr	r3, [r7, #4]
   17e9c:	691b      	ldr	r3, [r3, #16]
   17e9e:	2b00      	cmp	r3, #0
   17ea0:	d101      	bne.n	17ea6 <dir_next+0x26>
		return FR_NO_FILE;
   17ea2:	2304      	movs	r3, #4
   17ea4:	e0ba      	b.n	1801c <dir_next+0x19c>

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
   17ea6:	68fb      	ldr	r3, [r7, #12]
   17ea8:	220f      	movs	r2, #15
   17eaa:	4013      	ands	r3, r2
   17eac:	d000      	beq.n	17eb0 <dir_next+0x30>
   17eae:	e0a5      	b.n	17ffc <dir_next+0x17c>
		dp->sect++;					/* Next sector */
   17eb0:	687b      	ldr	r3, [r7, #4]
   17eb2:	691b      	ldr	r3, [r3, #16]
   17eb4:	1c5a      	adds	r2, r3, #1
   17eb6:	687b      	ldr	r3, [r7, #4]
   17eb8:	611a      	str	r2, [r3, #16]

		if (!dp->clust) {		/* Static table */
   17eba:	687b      	ldr	r3, [r7, #4]
   17ebc:	68db      	ldr	r3, [r3, #12]
   17ebe:	2b00      	cmp	r3, #0
   17ec0:	d109      	bne.n	17ed6 <dir_next+0x56>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
   17ec2:	687b      	ldr	r3, [r7, #4]
   17ec4:	681b      	ldr	r3, [r3, #0]
   17ec6:	891b      	ldrh	r3, [r3, #8]
   17ec8:	1e1a      	subs	r2, r3, #0
   17eca:	68fb      	ldr	r3, [r7, #12]
   17ecc:	429a      	cmp	r2, r3
   17ece:	d900      	bls.n	17ed2 <dir_next+0x52>
   17ed0:	e094      	b.n	17ffc <dir_next+0x17c>
				return FR_NO_FILE;
   17ed2:	2304      	movs	r3, #4
   17ed4:	e0a2      	b.n	1801c <dir_next+0x19c>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
   17ed6:	68fb      	ldr	r3, [r7, #12]
   17ed8:	091a      	lsrs	r2, r3, #4
   17eda:	687b      	ldr	r3, [r7, #4]
   17edc:	681b      	ldr	r3, [r3, #0]
   17ede:	789b      	ldrb	r3, [r3, #2]
   17ee0:	3b01      	subs	r3, #1
   17ee2:	4013      	ands	r3, r2
   17ee4:	d000      	beq.n	17ee8 <dir_next+0x68>
   17ee6:	e089      	b.n	17ffc <dir_next+0x17c>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
   17ee8:	687b      	ldr	r3, [r7, #4]
   17eea:	681a      	ldr	r2, [r3, #0]
   17eec:	687b      	ldr	r3, [r7, #4]
   17eee:	68db      	ldr	r3, [r3, #12]
   17ef0:	0019      	movs	r1, r3
   17ef2:	0010      	movs	r0, r2
   17ef4:	4b4b      	ldr	r3, [pc, #300]	; (18024 <dir_next+0x1a4>)
   17ef6:	4798      	blx	r3
   17ef8:	0003      	movs	r3, r0
   17efa:	617b      	str	r3, [r7, #20]
				if (clst <= 1) return FR_INT_ERR;
   17efc:	697b      	ldr	r3, [r7, #20]
   17efe:	2b01      	cmp	r3, #1
   17f00:	d801      	bhi.n	17f06 <dir_next+0x86>
   17f02:	2302      	movs	r3, #2
   17f04:	e08a      	b.n	1801c <dir_next+0x19c>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   17f06:	697b      	ldr	r3, [r7, #20]
   17f08:	3301      	adds	r3, #1
   17f0a:	d101      	bne.n	17f10 <dir_next+0x90>
   17f0c:	2301      	movs	r3, #1
   17f0e:	e085      	b.n	1801c <dir_next+0x19c>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
   17f10:	687b      	ldr	r3, [r7, #4]
   17f12:	681b      	ldr	r3, [r3, #0]
   17f14:	695a      	ldr	r2, [r3, #20]
   17f16:	697b      	ldr	r3, [r7, #20]
   17f18:	429a      	cmp	r2, r3
   17f1a:	d862      	bhi.n	17fe2 <dir_next+0x162>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
   17f1c:	683b      	ldr	r3, [r7, #0]
   17f1e:	2b00      	cmp	r3, #0
   17f20:	d101      	bne.n	17f26 <dir_next+0xa6>
   17f22:	2304      	movs	r3, #4
   17f24:	e07a      	b.n	1801c <dir_next+0x19c>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
   17f26:	687b      	ldr	r3, [r7, #4]
   17f28:	681a      	ldr	r2, [r3, #0]
   17f2a:	687b      	ldr	r3, [r7, #4]
   17f2c:	68db      	ldr	r3, [r3, #12]
   17f2e:	0019      	movs	r1, r3
   17f30:	0010      	movs	r0, r2
   17f32:	4b3d      	ldr	r3, [pc, #244]	; (18028 <dir_next+0x1a8>)
   17f34:	4798      	blx	r3
   17f36:	0003      	movs	r3, r0
   17f38:	617b      	str	r3, [r7, #20]
					if (clst == 0) return FR_DENIED;			/* No free cluster */
   17f3a:	697b      	ldr	r3, [r7, #20]
   17f3c:	2b00      	cmp	r3, #0
   17f3e:	d101      	bne.n	17f44 <dir_next+0xc4>
   17f40:	2307      	movs	r3, #7
   17f42:	e06b      	b.n	1801c <dir_next+0x19c>
					if (clst == 1) return FR_INT_ERR;
   17f44:	697b      	ldr	r3, [r7, #20]
   17f46:	2b01      	cmp	r3, #1
   17f48:	d101      	bne.n	17f4e <dir_next+0xce>
   17f4a:	2302      	movs	r3, #2
   17f4c:	e066      	b.n	1801c <dir_next+0x19c>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   17f4e:	697b      	ldr	r3, [r7, #20]
   17f50:	3301      	adds	r3, #1
   17f52:	d101      	bne.n	17f58 <dir_next+0xd8>
   17f54:	2301      	movs	r3, #1
   17f56:	e061      	b.n	1801c <dir_next+0x19c>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
   17f58:	687b      	ldr	r3, [r7, #4]
   17f5a:	681b      	ldr	r3, [r3, #0]
   17f5c:	0018      	movs	r0, r3
   17f5e:	4b33      	ldr	r3, [pc, #204]	; (1802c <dir_next+0x1ac>)
   17f60:	4798      	blx	r3
   17f62:	1e03      	subs	r3, r0, #0
   17f64:	d001      	beq.n	17f6a <dir_next+0xea>
   17f66:	2301      	movs	r3, #1
   17f68:	e058      	b.n	1801c <dir_next+0x19c>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
   17f6a:	687b      	ldr	r3, [r7, #4]
   17f6c:	681b      	ldr	r3, [r3, #0]
   17f6e:	3330      	adds	r3, #48	; 0x30
   17f70:	0018      	movs	r0, r3
   17f72:	2380      	movs	r3, #128	; 0x80
   17f74:	009b      	lsls	r3, r3, #2
   17f76:	001a      	movs	r2, r3
   17f78:	2100      	movs	r1, #0
   17f7a:	4b2d      	ldr	r3, [pc, #180]	; (18030 <dir_next+0x1b0>)
   17f7c:	4798      	blx	r3
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
   17f7e:	687b      	ldr	r3, [r7, #4]
   17f80:	681c      	ldr	r4, [r3, #0]
   17f82:	687b      	ldr	r3, [r7, #4]
   17f84:	681b      	ldr	r3, [r3, #0]
   17f86:	697a      	ldr	r2, [r7, #20]
   17f88:	0011      	movs	r1, r2
   17f8a:	0018      	movs	r0, r3
   17f8c:	4b29      	ldr	r3, [pc, #164]	; (18034 <dir_next+0x1b4>)
   17f8e:	4798      	blx	r3
   17f90:	0003      	movs	r3, r0
   17f92:	62e3      	str	r3, [r4, #44]	; 0x2c
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
   17f94:	2300      	movs	r3, #0
   17f96:	613b      	str	r3, [r7, #16]
   17f98:	e014      	b.n	17fc4 <dir_next+0x144>
						dp->fs->wflag = 1;
   17f9a:	687b      	ldr	r3, [r7, #4]
   17f9c:	681b      	ldr	r3, [r3, #0]
   17f9e:	2201      	movs	r2, #1
   17fa0:	711a      	strb	r2, [r3, #4]
						if (sync_window(dp->fs)) return FR_DISK_ERR;
   17fa2:	687b      	ldr	r3, [r7, #4]
   17fa4:	681b      	ldr	r3, [r3, #0]
   17fa6:	0018      	movs	r0, r3
   17fa8:	4b20      	ldr	r3, [pc, #128]	; (1802c <dir_next+0x1ac>)
   17faa:	4798      	blx	r3
   17fac:	1e03      	subs	r3, r0, #0
   17fae:	d001      	beq.n	17fb4 <dir_next+0x134>
   17fb0:	2301      	movs	r3, #1
   17fb2:	e033      	b.n	1801c <dir_next+0x19c>
						dp->fs->winsect++;
   17fb4:	687b      	ldr	r3, [r7, #4]
   17fb6:	681b      	ldr	r3, [r3, #0]
   17fb8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   17fba:	3201      	adds	r2, #1
   17fbc:	62da      	str	r2, [r3, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
   17fbe:	693b      	ldr	r3, [r7, #16]
   17fc0:	3301      	adds	r3, #1
   17fc2:	613b      	str	r3, [r7, #16]
   17fc4:	687b      	ldr	r3, [r7, #4]
   17fc6:	681b      	ldr	r3, [r3, #0]
   17fc8:	789b      	ldrb	r3, [r3, #2]
   17fca:	1e1a      	subs	r2, r3, #0
   17fcc:	693b      	ldr	r3, [r7, #16]
   17fce:	429a      	cmp	r2, r3
   17fd0:	d8e3      	bhi.n	17f9a <dir_next+0x11a>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
   17fd2:	687b      	ldr	r3, [r7, #4]
   17fd4:	681b      	ldr	r3, [r3, #0]
   17fd6:	687a      	ldr	r2, [r7, #4]
   17fd8:	6812      	ldr	r2, [r2, #0]
   17fda:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
   17fdc:	693a      	ldr	r2, [r7, #16]
   17fde:	1a8a      	subs	r2, r1, r2
   17fe0:	62da      	str	r2, [r3, #44]	; 0x2c
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
   17fe2:	687b      	ldr	r3, [r7, #4]
   17fe4:	697a      	ldr	r2, [r7, #20]
   17fe6:	60da      	str	r2, [r3, #12]
				dp->sect = clust2sect(dp->fs, clst);
   17fe8:	687b      	ldr	r3, [r7, #4]
   17fea:	681b      	ldr	r3, [r3, #0]
   17fec:	697a      	ldr	r2, [r7, #20]
   17fee:	0011      	movs	r1, r2
   17ff0:	0018      	movs	r0, r3
   17ff2:	4b10      	ldr	r3, [pc, #64]	; (18034 <dir_next+0x1b4>)
   17ff4:	4798      	blx	r3
   17ff6:	0002      	movs	r2, r0
   17ff8:	687b      	ldr	r3, [r7, #4]
   17ffa:	611a      	str	r2, [r3, #16]
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
   17ffc:	68fb      	ldr	r3, [r7, #12]
   17ffe:	b29a      	uxth	r2, r3
   18000:	687b      	ldr	r3, [r7, #4]
   18002:	80da      	strh	r2, [r3, #6]
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
   18004:	687b      	ldr	r3, [r7, #4]
   18006:	681b      	ldr	r3, [r3, #0]
   18008:	3330      	adds	r3, #48	; 0x30
   1800a:	001a      	movs	r2, r3
   1800c:	68fb      	ldr	r3, [r7, #12]
   1800e:	210f      	movs	r1, #15
   18010:	400b      	ands	r3, r1
   18012:	015b      	lsls	r3, r3, #5
   18014:	18d2      	adds	r2, r2, r3
   18016:	687b      	ldr	r3, [r7, #4]
   18018:	615a      	str	r2, [r3, #20]

	return FR_OK;
   1801a:	2300      	movs	r3, #0
}
   1801c:	0018      	movs	r0, r3
   1801e:	46bd      	mov	sp, r7
   18020:	b007      	add	sp, #28
   18022:	bd90      	pop	{r4, r7, pc}
   18024:	00017799 	.word	0x00017799
   18028:	00017c25 	.word	0x00017c25
   1802c:	000174bd 	.word	0x000174bd
   18030:	0001740d 	.word	0x0001740d
   18034:	00017761 	.word	0x00017761

00018038 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
   18038:	b590      	push	{r4, r7, lr}
   1803a:	b085      	sub	sp, #20
   1803c:	af00      	add	r7, sp, #0
   1803e:	6078      	str	r0, [r7, #4]
   18040:	6039      	str	r1, [r7, #0]
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
   18042:	230f      	movs	r3, #15
   18044:	18fc      	adds	r4, r7, r3
   18046:	687b      	ldr	r3, [r7, #4]
   18048:	2100      	movs	r1, #0
   1804a:	0018      	movs	r0, r3
   1804c:	4b27      	ldr	r3, [pc, #156]	; (180ec <dir_alloc+0xb4>)
   1804e:	4798      	blx	r3
   18050:	0003      	movs	r3, r0
   18052:	7023      	strb	r3, [r4, #0]
	if (res == FR_OK) {
   18054:	230f      	movs	r3, #15
   18056:	18fb      	adds	r3, r7, r3
   18058:	781b      	ldrb	r3, [r3, #0]
   1805a:	2b00      	cmp	r3, #0
   1805c:	d136      	bne.n	180cc <dir_alloc+0x94>
		n = 0;
   1805e:	2300      	movs	r3, #0
   18060:	60bb      	str	r3, [r7, #8]
		do {
			res = move_window(dp->fs, dp->sect);
   18062:	687b      	ldr	r3, [r7, #4]
   18064:	681a      	ldr	r2, [r3, #0]
   18066:	687b      	ldr	r3, [r7, #4]
   18068:	691b      	ldr	r3, [r3, #16]
   1806a:	210f      	movs	r1, #15
   1806c:	187c      	adds	r4, r7, r1
   1806e:	0019      	movs	r1, r3
   18070:	0010      	movs	r0, r2
   18072:	4b1f      	ldr	r3, [pc, #124]	; (180f0 <dir_alloc+0xb8>)
   18074:	4798      	blx	r3
   18076:	0003      	movs	r3, r0
   18078:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) break;
   1807a:	230f      	movs	r3, #15
   1807c:	18fb      	adds	r3, r7, r3
   1807e:	781b      	ldrb	r3, [r3, #0]
   18080:	2b00      	cmp	r3, #0
   18082:	d122      	bne.n	180ca <dir_alloc+0x92>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
   18084:	687b      	ldr	r3, [r7, #4]
   18086:	695b      	ldr	r3, [r3, #20]
   18088:	781b      	ldrb	r3, [r3, #0]
   1808a:	2be5      	cmp	r3, #229	; 0xe5
   1808c:	d004      	beq.n	18098 <dir_alloc+0x60>
   1808e:	687b      	ldr	r3, [r7, #4]
   18090:	695b      	ldr	r3, [r3, #20]
   18092:	781b      	ldrb	r3, [r3, #0]
   18094:	2b00      	cmp	r3, #0
   18096:	d107      	bne.n	180a8 <dir_alloc+0x70>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
   18098:	68bb      	ldr	r3, [r7, #8]
   1809a:	3301      	adds	r3, #1
   1809c:	60bb      	str	r3, [r7, #8]
   1809e:	68ba      	ldr	r2, [r7, #8]
   180a0:	683b      	ldr	r3, [r7, #0]
   180a2:	429a      	cmp	r2, r3
   180a4:	d102      	bne.n	180ac <dir_alloc+0x74>
   180a6:	e011      	b.n	180cc <dir_alloc+0x94>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
   180a8:	2300      	movs	r3, #0
   180aa:	60bb      	str	r3, [r7, #8]
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
   180ac:	230f      	movs	r3, #15
   180ae:	18fc      	adds	r4, r7, r3
   180b0:	687b      	ldr	r3, [r7, #4]
   180b2:	2101      	movs	r1, #1
   180b4:	0018      	movs	r0, r3
   180b6:	4b0f      	ldr	r3, [pc, #60]	; (180f4 <dir_alloc+0xbc>)
   180b8:	4798      	blx	r3
   180ba:	0003      	movs	r3, r0
   180bc:	7023      	strb	r3, [r4, #0]
		} while (res == FR_OK);
   180be:	230f      	movs	r3, #15
   180c0:	18fb      	adds	r3, r7, r3
   180c2:	781b      	ldrb	r3, [r3, #0]
   180c4:	2b00      	cmp	r3, #0
   180c6:	d0cc      	beq.n	18062 <dir_alloc+0x2a>
   180c8:	e000      	b.n	180cc <dir_alloc+0x94>
	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
   180ca:	46c0      	nop			; (mov r8, r8)
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
		} while (res == FR_OK);
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
   180cc:	230f      	movs	r3, #15
   180ce:	18fb      	adds	r3, r7, r3
   180d0:	781b      	ldrb	r3, [r3, #0]
   180d2:	2b04      	cmp	r3, #4
   180d4:	d103      	bne.n	180de <dir_alloc+0xa6>
   180d6:	230f      	movs	r3, #15
   180d8:	18fb      	adds	r3, r7, r3
   180da:	2207      	movs	r2, #7
   180dc:	701a      	strb	r2, [r3, #0]
	return res;
   180de:	230f      	movs	r3, #15
   180e0:	18fb      	adds	r3, r7, r3
   180e2:	781b      	ldrb	r3, [r3, #0]
}
   180e4:	0018      	movs	r0, r3
   180e6:	46bd      	mov	sp, r7
   180e8:	b005      	add	sp, #20
   180ea:	bd90      	pop	{r4, r7, pc}
   180ec:	00017d75 	.word	0x00017d75
   180f0:	00017555 	.word	0x00017555
   180f4:	00017e81 	.word	0x00017e81

000180f8 <ld_clust>:
static
DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
	FATFS* fs,		/* Pointer to the fs object */
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
   180f8:	b580      	push	{r7, lr}
   180fa:	b084      	sub	sp, #16
   180fc:	af00      	add	r7, sp, #0
   180fe:	6078      	str	r0, [r7, #4]
   18100:	6039      	str	r1, [r7, #0]
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
   18102:	683b      	ldr	r3, [r7, #0]
   18104:	331b      	adds	r3, #27
   18106:	781b      	ldrb	r3, [r3, #0]
   18108:	021b      	lsls	r3, r3, #8
   1810a:	b21a      	sxth	r2, r3
   1810c:	683b      	ldr	r3, [r7, #0]
   1810e:	331a      	adds	r3, #26
   18110:	781b      	ldrb	r3, [r3, #0]
   18112:	b21b      	sxth	r3, r3
   18114:	4313      	orrs	r3, r2
   18116:	b21b      	sxth	r3, r3
   18118:	b29b      	uxth	r3, r3
   1811a:	60fb      	str	r3, [r7, #12]
	if (fs->fs_type == FS_FAT32)
   1811c:	687b      	ldr	r3, [r7, #4]
   1811e:	781b      	ldrb	r3, [r3, #0]
   18120:	2b03      	cmp	r3, #3
   18122:	d10f      	bne.n	18144 <ld_clust+0x4c>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
   18124:	683b      	ldr	r3, [r7, #0]
   18126:	3315      	adds	r3, #21
   18128:	781b      	ldrb	r3, [r3, #0]
   1812a:	021b      	lsls	r3, r3, #8
   1812c:	b21a      	sxth	r2, r3
   1812e:	683b      	ldr	r3, [r7, #0]
   18130:	3314      	adds	r3, #20
   18132:	781b      	ldrb	r3, [r3, #0]
   18134:	b21b      	sxth	r3, r3
   18136:	4313      	orrs	r3, r2
   18138:	b21b      	sxth	r3, r3
   1813a:	b29b      	uxth	r3, r3
   1813c:	041b      	lsls	r3, r3, #16
   1813e:	68fa      	ldr	r2, [r7, #12]
   18140:	4313      	orrs	r3, r2
   18142:	60fb      	str	r3, [r7, #12]

	return cl;
   18144:	68fb      	ldr	r3, [r7, #12]
}
   18146:	0018      	movs	r0, r3
   18148:	46bd      	mov	sp, r7
   1814a:	b004      	add	sp, #16
   1814c:	bd80      	pop	{r7, pc}
   1814e:	46c0      	nop			; (mov r8, r8)

00018150 <st_clust>:
static
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
   18150:	b580      	push	{r7, lr}
   18152:	b082      	sub	sp, #8
   18154:	af00      	add	r7, sp, #0
   18156:	6078      	str	r0, [r7, #4]
   18158:	6039      	str	r1, [r7, #0]
	ST_WORD(dir + DIR_FstClusLO, cl);
   1815a:	687b      	ldr	r3, [r7, #4]
   1815c:	331a      	adds	r3, #26
   1815e:	683a      	ldr	r2, [r7, #0]
   18160:	b2d2      	uxtb	r2, r2
   18162:	701a      	strb	r2, [r3, #0]
   18164:	687b      	ldr	r3, [r7, #4]
   18166:	331b      	adds	r3, #27
   18168:	683a      	ldr	r2, [r7, #0]
   1816a:	1212      	asrs	r2, r2, #8
   1816c:	b2d2      	uxtb	r2, r2
   1816e:	701a      	strb	r2, [r3, #0]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
   18170:	687b      	ldr	r3, [r7, #4]
   18172:	3314      	adds	r3, #20
   18174:	683a      	ldr	r2, [r7, #0]
   18176:	0c12      	lsrs	r2, r2, #16
   18178:	b2d2      	uxtb	r2, r2
   1817a:	701a      	strb	r2, [r3, #0]
   1817c:	687b      	ldr	r3, [r7, #4]
   1817e:	3315      	adds	r3, #21
   18180:	683a      	ldr	r2, [r7, #0]
   18182:	0c12      	lsrs	r2, r2, #16
   18184:	1212      	asrs	r2, r2, #8
   18186:	b2d2      	uxtb	r2, r2
   18188:	701a      	strb	r2, [r3, #0]
}
   1818a:	46c0      	nop			; (mov r8, r8)
   1818c:	46bd      	mov	sp, r7
   1818e:	b002      	add	sp, #8
   18190:	bd80      	pop	{r7, pc}
   18192:	46c0      	nop			; (mov r8, r8)

00018194 <cmp_lfn>:
static
int cmp_lfn (			/* 1:matched, 0:not matched */
	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer to be compared */
	BYTE* dir			/* Pointer to the directory entry containing the part of LFN */
)
{
   18194:	b590      	push	{r4, r7, lr}
   18196:	b087      	sub	sp, #28
   18198:	af00      	add	r7, sp, #0
   1819a:	6078      	str	r0, [r7, #4]
   1819c:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
   1819e:	683b      	ldr	r3, [r7, #0]
   181a0:	331b      	adds	r3, #27
   181a2:	781b      	ldrb	r3, [r3, #0]
   181a4:	021b      	lsls	r3, r3, #8
   181a6:	b21a      	sxth	r2, r3
   181a8:	683b      	ldr	r3, [r7, #0]
   181aa:	331a      	adds	r3, #26
   181ac:	781b      	ldrb	r3, [r3, #0]
   181ae:	b21b      	sxth	r3, r3
   181b0:	4313      	orrs	r3, r2
   181b2:	b21b      	sxth	r3, r3
   181b4:	2b00      	cmp	r3, #0
   181b6:	d001      	beq.n	181bc <cmp_lfn+0x28>
   181b8:	2300      	movs	r3, #0
   181ba:	e073      	b.n	182a4 <cmp_lfn+0x110>

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   181bc:	683b      	ldr	r3, [r7, #0]
   181be:	781b      	ldrb	r3, [r3, #0]
   181c0:	001a      	movs	r2, r3
   181c2:	233f      	movs	r3, #63	; 0x3f
   181c4:	4013      	ands	r3, r2
   181c6:	1e5a      	subs	r2, r3, #1
   181c8:	0013      	movs	r3, r2
   181ca:	005b      	lsls	r3, r3, #1
   181cc:	189b      	adds	r3, r3, r2
   181ce:	009b      	lsls	r3, r3, #2
   181d0:	189b      	adds	r3, r3, r2
   181d2:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   181d4:	230e      	movs	r3, #14
   181d6:	18fb      	adds	r3, r7, r3
   181d8:	2201      	movs	r2, #1
   181da:	801a      	strh	r2, [r3, #0]
   181dc:	2300      	movs	r3, #0
   181de:	613b      	str	r3, [r7, #16]
   181e0:	e048      	b.n	18274 <cmp_lfn+0xe0>
		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character */
   181e2:	4a32      	ldr	r2, [pc, #200]	; (182ac <cmp_lfn+0x118>)
   181e4:	693b      	ldr	r3, [r7, #16]
   181e6:	18d3      	adds	r3, r2, r3
   181e8:	781b      	ldrb	r3, [r3, #0]
   181ea:	3301      	adds	r3, #1
   181ec:	683a      	ldr	r2, [r7, #0]
   181ee:	18d3      	adds	r3, r2, r3
   181f0:	781b      	ldrb	r3, [r3, #0]
   181f2:	021b      	lsls	r3, r3, #8
   181f4:	b21a      	sxth	r2, r3
   181f6:	492d      	ldr	r1, [pc, #180]	; (182ac <cmp_lfn+0x118>)
   181f8:	693b      	ldr	r3, [r7, #16]
   181fa:	18cb      	adds	r3, r1, r3
   181fc:	781b      	ldrb	r3, [r3, #0]
   181fe:	0019      	movs	r1, r3
   18200:	683b      	ldr	r3, [r7, #0]
   18202:	185b      	adds	r3, r3, r1
   18204:	781b      	ldrb	r3, [r3, #0]
   18206:	b21b      	sxth	r3, r3
   18208:	4313      	orrs	r3, r2
   1820a:	b21a      	sxth	r2, r3
   1820c:	230c      	movs	r3, #12
   1820e:	18fb      	adds	r3, r7, r3
   18210:	801a      	strh	r2, [r3, #0]
		if (wc) {
   18212:	230e      	movs	r3, #14
   18214:	18fb      	adds	r3, r7, r3
   18216:	881b      	ldrh	r3, [r3, #0]
   18218:	2b00      	cmp	r3, #0
   1821a:	d020      	beq.n	1825e <cmp_lfn+0xca>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   1821c:	697b      	ldr	r3, [r7, #20]
   1821e:	2bfe      	cmp	r3, #254	; 0xfe
   18220:	d814      	bhi.n	1824c <cmp_lfn+0xb8>
   18222:	230c      	movs	r3, #12
   18224:	18fb      	adds	r3, r7, r3
   18226:	881b      	ldrh	r3, [r3, #0]
   18228:	0018      	movs	r0, r3
   1822a:	4b21      	ldr	r3, [pc, #132]	; (182b0 <cmp_lfn+0x11c>)
   1822c:	4798      	blx	r3
   1822e:	0003      	movs	r3, r0
   18230:	001c      	movs	r4, r3
   18232:	697b      	ldr	r3, [r7, #20]
   18234:	1c5a      	adds	r2, r3, #1
   18236:	617a      	str	r2, [r7, #20]
   18238:	005b      	lsls	r3, r3, #1
   1823a:	687a      	ldr	r2, [r7, #4]
   1823c:	18d3      	adds	r3, r2, r3
   1823e:	881b      	ldrh	r3, [r3, #0]
   18240:	0018      	movs	r0, r3
   18242:	4b1b      	ldr	r3, [pc, #108]	; (182b0 <cmp_lfn+0x11c>)
   18244:	4798      	blx	r3
   18246:	0003      	movs	r3, r0
   18248:	429c      	cmp	r4, r3
   1824a:	d001      	beq.n	18250 <cmp_lfn+0xbc>
				return 0;					/* Not matched */
   1824c:	2300      	movs	r3, #0
   1824e:	e029      	b.n	182a4 <cmp_lfn+0x110>
			wc = uc;
   18250:	230e      	movs	r3, #14
   18252:	18fb      	adds	r3, r7, r3
   18254:	220c      	movs	r2, #12
   18256:	18ba      	adds	r2, r7, r2
   18258:	8812      	ldrh	r2, [r2, #0]
   1825a:	801a      	strh	r2, [r3, #0]
   1825c:	e007      	b.n	1826e <cmp_lfn+0xda>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
   1825e:	230c      	movs	r3, #12
   18260:	18fb      	adds	r3, r7, r3
   18262:	881b      	ldrh	r3, [r3, #0]
   18264:	4a13      	ldr	r2, [pc, #76]	; (182b4 <cmp_lfn+0x120>)
   18266:	4293      	cmp	r3, r2
   18268:	d001      	beq.n	1826e <cmp_lfn+0xda>
   1826a:	2300      	movs	r3, #0
   1826c:	e01a      	b.n	182a4 <cmp_lfn+0x110>

	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   1826e:	693b      	ldr	r3, [r7, #16]
   18270:	3301      	adds	r3, #1
   18272:	613b      	str	r3, [r7, #16]
   18274:	693b      	ldr	r3, [r7, #16]
   18276:	2b0c      	cmp	r3, #12
   18278:	d9b3      	bls.n	181e2 <cmp_lfn+0x4e>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
		}
	}

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
   1827a:	683b      	ldr	r3, [r7, #0]
   1827c:	781b      	ldrb	r3, [r3, #0]
   1827e:	001a      	movs	r2, r3
   18280:	2340      	movs	r3, #64	; 0x40
   18282:	4013      	ands	r3, r2
   18284:	d00d      	beq.n	182a2 <cmp_lfn+0x10e>
   18286:	230e      	movs	r3, #14
   18288:	18fb      	adds	r3, r7, r3
   1828a:	881b      	ldrh	r3, [r3, #0]
   1828c:	2b00      	cmp	r3, #0
   1828e:	d008      	beq.n	182a2 <cmp_lfn+0x10e>
   18290:	697b      	ldr	r3, [r7, #20]
   18292:	005b      	lsls	r3, r3, #1
   18294:	687a      	ldr	r2, [r7, #4]
   18296:	18d3      	adds	r3, r2, r3
   18298:	881b      	ldrh	r3, [r3, #0]
   1829a:	2b00      	cmp	r3, #0
   1829c:	d001      	beq.n	182a2 <cmp_lfn+0x10e>
		return 0;
   1829e:	2300      	movs	r3, #0
   182a0:	e000      	b.n	182a4 <cmp_lfn+0x110>

	return 1;		/* The part of LFN matched */
   182a2:	2301      	movs	r3, #1
}
   182a4:	0018      	movs	r0, r3
   182a6:	46bd      	mov	sp, r7
   182a8:	b007      	add	sp, #28
   182aa:	bd90      	pop	{r4, r7, pc}
   182ac:	000211e4 	.word	0x000211e4
   182b0:	0001ae05 	.word	0x0001ae05
   182b4:	0000ffff 	.word	0x0000ffff

000182b8 <pick_lfn>:
static
int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
	BYTE* dir			/* Pointer to the LFN entry */
)
{
   182b8:	b580      	push	{r7, lr}
   182ba:	b086      	sub	sp, #24
   182bc:	af00      	add	r7, sp, #0
   182be:	6078      	str	r0, [r7, #4]
   182c0:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
   182c2:	683b      	ldr	r3, [r7, #0]
   182c4:	331b      	adds	r3, #27
   182c6:	781b      	ldrb	r3, [r3, #0]
   182c8:	021b      	lsls	r3, r3, #8
   182ca:	b21a      	sxth	r2, r3
   182cc:	683b      	ldr	r3, [r7, #0]
   182ce:	331a      	adds	r3, #26
   182d0:	781b      	ldrb	r3, [r3, #0]
   182d2:	b21b      	sxth	r3, r3
   182d4:	4313      	orrs	r3, r2
   182d6:	b21b      	sxth	r3, r3
   182d8:	2b00      	cmp	r3, #0
   182da:	d001      	beq.n	182e0 <pick_lfn+0x28>
   182dc:	2300      	movs	r3, #0
   182de:	e065      	b.n	183ac <pick_lfn+0xf4>

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   182e0:	683b      	ldr	r3, [r7, #0]
   182e2:	781b      	ldrb	r3, [r3, #0]
   182e4:	001a      	movs	r2, r3
   182e6:	233f      	movs	r3, #63	; 0x3f
   182e8:	4013      	ands	r3, r2
   182ea:	1e5a      	subs	r2, r3, #1
   182ec:	0013      	movs	r3, r2
   182ee:	005b      	lsls	r3, r3, #1
   182f0:	189b      	adds	r3, r3, r2
   182f2:	009b      	lsls	r3, r3, #2
   182f4:	189b      	adds	r3, r3, r2
   182f6:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   182f8:	230e      	movs	r3, #14
   182fa:	18fb      	adds	r3, r7, r3
   182fc:	2201      	movs	r2, #1
   182fe:	801a      	strh	r2, [r3, #0]
   18300:	2300      	movs	r3, #0
   18302:	613b      	str	r3, [r7, #16]
   18304:	e03d      	b.n	18382 <pick_lfn+0xca>
		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character */
   18306:	4a2b      	ldr	r2, [pc, #172]	; (183b4 <pick_lfn+0xfc>)
   18308:	693b      	ldr	r3, [r7, #16]
   1830a:	18d3      	adds	r3, r2, r3
   1830c:	781b      	ldrb	r3, [r3, #0]
   1830e:	3301      	adds	r3, #1
   18310:	683a      	ldr	r2, [r7, #0]
   18312:	18d3      	adds	r3, r2, r3
   18314:	781b      	ldrb	r3, [r3, #0]
   18316:	021b      	lsls	r3, r3, #8
   18318:	b21a      	sxth	r2, r3
   1831a:	4926      	ldr	r1, [pc, #152]	; (183b4 <pick_lfn+0xfc>)
   1831c:	693b      	ldr	r3, [r7, #16]
   1831e:	18cb      	adds	r3, r1, r3
   18320:	781b      	ldrb	r3, [r3, #0]
   18322:	0019      	movs	r1, r3
   18324:	683b      	ldr	r3, [r7, #0]
   18326:	185b      	adds	r3, r3, r1
   18328:	781b      	ldrb	r3, [r3, #0]
   1832a:	b21b      	sxth	r3, r3
   1832c:	4313      	orrs	r3, r2
   1832e:	b21a      	sxth	r2, r3
   18330:	230c      	movs	r3, #12
   18332:	18fb      	adds	r3, r7, r3
   18334:	801a      	strh	r2, [r3, #0]
		if (wc) {
   18336:	230e      	movs	r3, #14
   18338:	18fb      	adds	r3, r7, r3
   1833a:	881b      	ldrh	r3, [r3, #0]
   1833c:	2b00      	cmp	r3, #0
   1833e:	d015      	beq.n	1836c <pick_lfn+0xb4>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   18340:	697b      	ldr	r3, [r7, #20]
   18342:	2bfe      	cmp	r3, #254	; 0xfe
   18344:	d901      	bls.n	1834a <pick_lfn+0x92>
   18346:	2300      	movs	r3, #0
   18348:	e030      	b.n	183ac <pick_lfn+0xf4>
			lfnbuf[i++] = wc = uc;			/* Store it */
   1834a:	697b      	ldr	r3, [r7, #20]
   1834c:	1c5a      	adds	r2, r3, #1
   1834e:	617a      	str	r2, [r7, #20]
   18350:	005b      	lsls	r3, r3, #1
   18352:	687a      	ldr	r2, [r7, #4]
   18354:	18d3      	adds	r3, r2, r3
   18356:	220e      	movs	r2, #14
   18358:	18ba      	adds	r2, r7, r2
   1835a:	210c      	movs	r1, #12
   1835c:	1879      	adds	r1, r7, r1
   1835e:	8809      	ldrh	r1, [r1, #0]
   18360:	8011      	strh	r1, [r2, #0]
   18362:	220e      	movs	r2, #14
   18364:	18ba      	adds	r2, r7, r2
   18366:	8812      	ldrh	r2, [r2, #0]
   18368:	801a      	strh	r2, [r3, #0]
   1836a:	e007      	b.n	1837c <pick_lfn+0xc4>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
   1836c:	230c      	movs	r3, #12
   1836e:	18fb      	adds	r3, r7, r3
   18370:	881b      	ldrh	r3, [r3, #0]
   18372:	4a11      	ldr	r2, [pc, #68]	; (183b8 <pick_lfn+0x100>)
   18374:	4293      	cmp	r3, r2
   18376:	d001      	beq.n	1837c <pick_lfn+0xc4>
   18378:	2300      	movs	r3, #0
   1837a:	e017      	b.n	183ac <pick_lfn+0xf4>

	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   1837c:	693b      	ldr	r3, [r7, #16]
   1837e:	3301      	adds	r3, #1
   18380:	613b      	str	r3, [r7, #16]
   18382:	693b      	ldr	r3, [r7, #16]
   18384:	2b0c      	cmp	r3, #12
   18386:	d9be      	bls.n	18306 <pick_lfn+0x4e>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
		}
	}

	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
   18388:	683b      	ldr	r3, [r7, #0]
   1838a:	781b      	ldrb	r3, [r3, #0]
   1838c:	001a      	movs	r2, r3
   1838e:	2340      	movs	r3, #64	; 0x40
   18390:	4013      	ands	r3, r2
   18392:	d00a      	beq.n	183aa <pick_lfn+0xf2>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   18394:	697b      	ldr	r3, [r7, #20]
   18396:	2bfe      	cmp	r3, #254	; 0xfe
   18398:	d901      	bls.n	1839e <pick_lfn+0xe6>
   1839a:	2300      	movs	r3, #0
   1839c:	e006      	b.n	183ac <pick_lfn+0xf4>
		lfnbuf[i] = 0;
   1839e:	697b      	ldr	r3, [r7, #20]
   183a0:	005b      	lsls	r3, r3, #1
   183a2:	687a      	ldr	r2, [r7, #4]
   183a4:	18d3      	adds	r3, r2, r3
   183a6:	2200      	movs	r2, #0
   183a8:	801a      	strh	r2, [r3, #0]
	}

	return 1;		/* The part of LFN is valid */
   183aa:	2301      	movs	r3, #1
}
   183ac:	0018      	movs	r0, r3
   183ae:	46bd      	mov	sp, r7
   183b0:	b006      	add	sp, #24
   183b2:	bd80      	pop	{r7, pc}
   183b4:	000211e4 	.word	0x000211e4
   183b8:	0000ffff 	.word	0x0000ffff

000183bc <fit_lfn>:
	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer */
	BYTE* dir,				/* Pointer to the LFN entry to be processed */
	BYTE ord,				/* LFN order (1-20) */
	BYTE sum				/* Checksum of the corresponding SFN */
)
{
   183bc:	b580      	push	{r7, lr}
   183be:	b088      	sub	sp, #32
   183c0:	af00      	add	r7, sp, #0
   183c2:	60f8      	str	r0, [r7, #12]
   183c4:	60b9      	str	r1, [r7, #8]
   183c6:	0019      	movs	r1, r3
   183c8:	1dfb      	adds	r3, r7, #7
   183ca:	701a      	strb	r2, [r3, #0]
   183cc:	1dbb      	adds	r3, r7, #6
   183ce:	1c0a      	adds	r2, r1, #0
   183d0:	701a      	strb	r2, [r3, #0]
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set checksum */
   183d2:	68bb      	ldr	r3, [r7, #8]
   183d4:	330d      	adds	r3, #13
   183d6:	1dba      	adds	r2, r7, #6
   183d8:	7812      	ldrb	r2, [r2, #0]
   183da:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   183dc:	68bb      	ldr	r3, [r7, #8]
   183de:	330b      	adds	r3, #11
   183e0:	220f      	movs	r2, #15
   183e2:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Type] = 0;
   183e4:	68bb      	ldr	r3, [r7, #8]
   183e6:	330c      	adds	r3, #12
   183e8:	2200      	movs	r2, #0
   183ea:	701a      	strb	r2, [r3, #0]
	ST_WORD(dir + LDIR_FstClusLO, 0);
   183ec:	68bb      	ldr	r3, [r7, #8]
   183ee:	331a      	adds	r3, #26
   183f0:	2200      	movs	r2, #0
   183f2:	701a      	strb	r2, [r3, #0]
   183f4:	68bb      	ldr	r3, [r7, #8]
   183f6:	331b      	adds	r3, #27
   183f8:	2200      	movs	r2, #0
   183fa:	701a      	strb	r2, [r3, #0]

	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
   183fc:	1dfb      	adds	r3, r7, #7
   183fe:	781b      	ldrb	r3, [r3, #0]
   18400:	1e5a      	subs	r2, r3, #1
   18402:	0013      	movs	r3, r2
   18404:	005b      	lsls	r3, r3, #1
   18406:	189b      	adds	r3, r3, r2
   18408:	009b      	lsls	r3, r3, #2
   1840a:	189b      	adds	r3, r3, r2
   1840c:	61fb      	str	r3, [r7, #28]
	s = wc = 0;
   1840e:	2316      	movs	r3, #22
   18410:	18fb      	adds	r3, r7, r3
   18412:	2200      	movs	r2, #0
   18414:	801a      	strh	r2, [r3, #0]
   18416:	2300      	movs	r3, #0
   18418:	61bb      	str	r3, [r7, #24]
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
   1841a:	2316      	movs	r3, #22
   1841c:	18fb      	adds	r3, r7, r3
   1841e:	881b      	ldrh	r3, [r3, #0]
   18420:	4a28      	ldr	r2, [pc, #160]	; (184c4 <fit_lfn+0x108>)
   18422:	4293      	cmp	r3, r2
   18424:	d009      	beq.n	1843a <fit_lfn+0x7e>
   18426:	69fb      	ldr	r3, [r7, #28]
   18428:	1c5a      	adds	r2, r3, #1
   1842a:	61fa      	str	r2, [r7, #28]
   1842c:	005b      	lsls	r3, r3, #1
   1842e:	68fa      	ldr	r2, [r7, #12]
   18430:	18d2      	adds	r2, r2, r3
   18432:	2316      	movs	r3, #22
   18434:	18fb      	adds	r3, r7, r3
   18436:	8812      	ldrh	r2, [r2, #0]
   18438:	801a      	strh	r2, [r3, #0]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   1843a:	4a23      	ldr	r2, [pc, #140]	; (184c8 <fit_lfn+0x10c>)
   1843c:	69bb      	ldr	r3, [r7, #24]
   1843e:	18d3      	adds	r3, r2, r3
   18440:	781b      	ldrb	r3, [r3, #0]
   18442:	001a      	movs	r2, r3
   18444:	68bb      	ldr	r3, [r7, #8]
   18446:	189b      	adds	r3, r3, r2
   18448:	2216      	movs	r2, #22
   1844a:	18ba      	adds	r2, r7, r2
   1844c:	8812      	ldrh	r2, [r2, #0]
   1844e:	b2d2      	uxtb	r2, r2
   18450:	701a      	strb	r2, [r3, #0]
   18452:	4a1d      	ldr	r2, [pc, #116]	; (184c8 <fit_lfn+0x10c>)
   18454:	69bb      	ldr	r3, [r7, #24]
   18456:	18d3      	adds	r3, r2, r3
   18458:	781b      	ldrb	r3, [r3, #0]
   1845a:	3301      	adds	r3, #1
   1845c:	68ba      	ldr	r2, [r7, #8]
   1845e:	18d3      	adds	r3, r2, r3
   18460:	2216      	movs	r2, #22
   18462:	18ba      	adds	r2, r7, r2
   18464:	8812      	ldrh	r2, [r2, #0]
   18466:	0a12      	lsrs	r2, r2, #8
   18468:	b292      	uxth	r2, r2
   1846a:	b2d2      	uxtb	r2, r2
   1846c:	701a      	strb	r2, [r3, #0]
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
   1846e:	2316      	movs	r3, #22
   18470:	18fb      	adds	r3, r7, r3
   18472:	881b      	ldrh	r3, [r3, #0]
   18474:	2b00      	cmp	r3, #0
   18476:	d104      	bne.n	18482 <fit_lfn+0xc6>
   18478:	2316      	movs	r3, #22
   1847a:	18fb      	adds	r3, r7, r3
   1847c:	2201      	movs	r2, #1
   1847e:	4252      	negs	r2, r2
   18480:	801a      	strh	r2, [r3, #0]
	} while (++s < 13);
   18482:	69bb      	ldr	r3, [r7, #24]
   18484:	3301      	adds	r3, #1
   18486:	61bb      	str	r3, [r7, #24]
   18488:	69bb      	ldr	r3, [r7, #24]
   1848a:	2b0c      	cmp	r3, #12
   1848c:	d9c5      	bls.n	1841a <fit_lfn+0x5e>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLEF;	/* Bottom LFN part is the start of LFN sequence */
   1848e:	2316      	movs	r3, #22
   18490:	18fb      	adds	r3, r7, r3
   18492:	881b      	ldrh	r3, [r3, #0]
   18494:	4a0b      	ldr	r2, [pc, #44]	; (184c4 <fit_lfn+0x108>)
   18496:	4293      	cmp	r3, r2
   18498:	d006      	beq.n	184a8 <fit_lfn+0xec>
   1849a:	69fb      	ldr	r3, [r7, #28]
   1849c:	005b      	lsls	r3, r3, #1
   1849e:	68fa      	ldr	r2, [r7, #12]
   184a0:	18d3      	adds	r3, r2, r3
   184a2:	881b      	ldrh	r3, [r3, #0]
   184a4:	2b00      	cmp	r3, #0
   184a6:	d105      	bne.n	184b4 <fit_lfn+0xf8>
   184a8:	1dfb      	adds	r3, r7, #7
   184aa:	1dfa      	adds	r2, r7, #7
   184ac:	7812      	ldrb	r2, [r2, #0]
   184ae:	2140      	movs	r1, #64	; 0x40
   184b0:	430a      	orrs	r2, r1
   184b2:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   184b4:	68bb      	ldr	r3, [r7, #8]
   184b6:	1dfa      	adds	r2, r7, #7
   184b8:	7812      	ldrb	r2, [r2, #0]
   184ba:	701a      	strb	r2, [r3, #0]
}
   184bc:	46c0      	nop			; (mov r8, r8)
   184be:	46bd      	mov	sp, r7
   184c0:	b008      	add	sp, #32
   184c2:	bd80      	pop	{r7, pc}
   184c4:	0000ffff 	.word	0x0000ffff
   184c8:	000211e4 	.word	0x000211e4

000184cc <gen_numname>:
	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
	const BYTE* src,	/* Pointer to SFN */
	const WCHAR* lfn,	/* Pointer to LFN */
	UINT seq			/* Sequence number */
)
{
   184cc:	b580      	push	{r7, lr}
   184ce:	b08c      	sub	sp, #48	; 0x30
   184d0:	af00      	add	r7, sp, #0
   184d2:	60f8      	str	r0, [r7, #12]
   184d4:	60b9      	str	r1, [r7, #8]
   184d6:	607a      	str	r2, [r7, #4]
   184d8:	603b      	str	r3, [r7, #0]
	UINT i, j;
	WCHAR wc;
	DWORD sr;


	mem_cpy(dst, src, 11);
   184da:	68b9      	ldr	r1, [r7, #8]
   184dc:	68fb      	ldr	r3, [r7, #12]
   184de:	220b      	movs	r2, #11
   184e0:	0018      	movs	r0, r3
   184e2:	4b45      	ldr	r3, [pc, #276]	; (185f8 <gen_numname+0x12c>)
   184e4:	4798      	blx	r3

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   184e6:	683b      	ldr	r3, [r7, #0]
   184e8:	2b05      	cmp	r3, #5
   184ea:	d931      	bls.n	18550 <gen_numname+0x84>
		sr = seq;
   184ec:	683b      	ldr	r3, [r7, #0]
   184ee:	61fb      	str	r3, [r7, #28]
		while (*lfn) {	/* Create a CRC */
   184f0:	e028      	b.n	18544 <gen_numname+0x78>
			wc = *lfn++;
   184f2:	687b      	ldr	r3, [r7, #4]
   184f4:	1c9a      	adds	r2, r3, #2
   184f6:	607a      	str	r2, [r7, #4]
   184f8:	2222      	movs	r2, #34	; 0x22
   184fa:	18ba      	adds	r2, r7, r2
   184fc:	881b      	ldrh	r3, [r3, #0]
   184fe:	8013      	strh	r3, [r2, #0]
			for (i = 0; i < 16; i++) {
   18500:	2300      	movs	r3, #0
   18502:	62bb      	str	r3, [r7, #40]	; 0x28
   18504:	e01b      	b.n	1853e <gen_numname+0x72>
				sr = (sr << 1) + (wc & 1);
   18506:	69fb      	ldr	r3, [r7, #28]
   18508:	005a      	lsls	r2, r3, #1
   1850a:	2322      	movs	r3, #34	; 0x22
   1850c:	18fb      	adds	r3, r7, r3
   1850e:	881b      	ldrh	r3, [r3, #0]
   18510:	2101      	movs	r1, #1
   18512:	400b      	ands	r3, r1
   18514:	18d3      	adds	r3, r2, r3
   18516:	61fb      	str	r3, [r7, #28]
				wc >>= 1;
   18518:	2322      	movs	r3, #34	; 0x22
   1851a:	18fb      	adds	r3, r7, r3
   1851c:	2222      	movs	r2, #34	; 0x22
   1851e:	18ba      	adds	r2, r7, r2
   18520:	8812      	ldrh	r2, [r2, #0]
   18522:	0852      	lsrs	r2, r2, #1
   18524:	801a      	strh	r2, [r3, #0]
				if (sr & 0x10000) sr ^= 0x11021;
   18526:	69fa      	ldr	r2, [r7, #28]
   18528:	2380      	movs	r3, #128	; 0x80
   1852a:	025b      	lsls	r3, r3, #9
   1852c:	4013      	ands	r3, r2
   1852e:	d003      	beq.n	18538 <gen_numname+0x6c>
   18530:	69fb      	ldr	r3, [r7, #28]
   18532:	4a32      	ldr	r2, [pc, #200]	; (185fc <gen_numname+0x130>)
   18534:	4053      	eors	r3, r2
   18536:	61fb      	str	r3, [r7, #28]

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
		sr = seq;
		while (*lfn) {	/* Create a CRC */
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
   18538:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1853a:	3301      	adds	r3, #1
   1853c:	62bb      	str	r3, [r7, #40]	; 0x28
   1853e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   18540:	2b0f      	cmp	r3, #15
   18542:	d9e0      	bls.n	18506 <gen_numname+0x3a>

	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
		sr = seq;
		while (*lfn) {	/* Create a CRC */
   18544:	687b      	ldr	r3, [r7, #4]
   18546:	881b      	ldrh	r3, [r3, #0]
   18548:	2b00      	cmp	r3, #0
   1854a:	d1d2      	bne.n	184f2 <gen_numname+0x26>
				sr = (sr << 1) + (wc & 1);
				wc >>= 1;
				if (sr & 0x10000) sr ^= 0x11021;
			}
		}
		seq = (UINT)sr;
   1854c:	69fb      	ldr	r3, [r7, #28]
   1854e:	603b      	str	r3, [r7, #0]
	}

	/* itoa (hexdecimal) */
	i = 7;
   18550:	2307      	movs	r3, #7
   18552:	62bb      	str	r3, [r7, #40]	; 0x28
	do {
		c = (seq % 16) + '0';
   18554:	683b      	ldr	r3, [r7, #0]
   18556:	b2db      	uxtb	r3, r3
   18558:	220f      	movs	r2, #15
   1855a:	4013      	ands	r3, r2
   1855c:	b2da      	uxtb	r2, r3
   1855e:	232f      	movs	r3, #47	; 0x2f
   18560:	18fb      	adds	r3, r7, r3
   18562:	3230      	adds	r2, #48	; 0x30
   18564:	701a      	strb	r2, [r3, #0]
		if (c > '9') c += 7;
   18566:	232f      	movs	r3, #47	; 0x2f
   18568:	18fb      	adds	r3, r7, r3
   1856a:	781b      	ldrb	r3, [r3, #0]
   1856c:	2b39      	cmp	r3, #57	; 0x39
   1856e:	d906      	bls.n	1857e <gen_numname+0xb2>
   18570:	232f      	movs	r3, #47	; 0x2f
   18572:	18fb      	adds	r3, r7, r3
   18574:	222f      	movs	r2, #47	; 0x2f
   18576:	18ba      	adds	r2, r7, r2
   18578:	7812      	ldrb	r2, [r2, #0]
   1857a:	3207      	adds	r2, #7
   1857c:	701a      	strb	r2, [r3, #0]
		ns[i--] = c;
   1857e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   18580:	1e5a      	subs	r2, r3, #1
   18582:	62ba      	str	r2, [r7, #40]	; 0x28
   18584:	2214      	movs	r2, #20
   18586:	18ba      	adds	r2, r7, r2
   18588:	212f      	movs	r1, #47	; 0x2f
   1858a:	1879      	adds	r1, r7, r1
   1858c:	7809      	ldrb	r1, [r1, #0]
   1858e:	54d1      	strb	r1, [r2, r3]
		seq /= 16;
   18590:	683b      	ldr	r3, [r7, #0]
   18592:	091b      	lsrs	r3, r3, #4
   18594:	603b      	str	r3, [r7, #0]
	} while (seq);
   18596:	683b      	ldr	r3, [r7, #0]
   18598:	2b00      	cmp	r3, #0
   1859a:	d1db      	bne.n	18554 <gen_numname+0x88>
	ns[i] = '~';
   1859c:	2314      	movs	r3, #20
   1859e:	18fa      	adds	r2, r7, r3
   185a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   185a2:	18d3      	adds	r3, r2, r3
   185a4:	227e      	movs	r2, #126	; 0x7e
   185a6:	701a      	strb	r2, [r3, #0]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
   185a8:	2300      	movs	r3, #0
   185aa:	627b      	str	r3, [r7, #36]	; 0x24
   185ac:	e002      	b.n	185b4 <gen_numname+0xe8>
   185ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   185b0:	3301      	adds	r3, #1
   185b2:	627b      	str	r3, [r7, #36]	; 0x24
   185b4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   185b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   185b8:	429a      	cmp	r2, r3
   185ba:	d205      	bcs.n	185c8 <gen_numname+0xfc>
   185bc:	68fa      	ldr	r2, [r7, #12]
   185be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   185c0:	18d3      	adds	r3, r2, r3
   185c2:	781b      	ldrb	r3, [r3, #0]
   185c4:	2b20      	cmp	r3, #32
   185c6:	d1f2      	bne.n	185ae <gen_numname+0xe2>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
   185c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   185ca:	1c5a      	adds	r2, r3, #1
   185cc:	627a      	str	r2, [r7, #36]	; 0x24
   185ce:	68fa      	ldr	r2, [r7, #12]
   185d0:	18d2      	adds	r2, r2, r3
   185d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   185d4:	2b07      	cmp	r3, #7
   185d6:	d806      	bhi.n	185e6 <gen_numname+0x11a>
   185d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   185da:	1c59      	adds	r1, r3, #1
   185dc:	62b9      	str	r1, [r7, #40]	; 0x28
   185de:	2114      	movs	r1, #20
   185e0:	1879      	adds	r1, r7, r1
   185e2:	5ccb      	ldrb	r3, [r1, r3]
   185e4:	e000      	b.n	185e8 <gen_numname+0x11c>
   185e6:	2320      	movs	r3, #32
   185e8:	7013      	strb	r3, [r2, #0]
	} while (j < 8);
   185ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   185ec:	2b07      	cmp	r3, #7
   185ee:	d9eb      	bls.n	185c8 <gen_numname+0xfc>
}
   185f0:	46c0      	nop			; (mov r8, r8)
   185f2:	46bd      	mov	sp, r7
   185f4:	b00c      	add	sp, #48	; 0x30
   185f6:	bd80      	pop	{r7, pc}
   185f8:	000173d5 	.word	0x000173d5
   185fc:	00011021 	.word	0x00011021

00018600 <sum_sfn>:
#if _USE_LFN
static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
   18600:	b580      	push	{r7, lr}
   18602:	b084      	sub	sp, #16
   18604:	af00      	add	r7, sp, #0
   18606:	6078      	str	r0, [r7, #4]
	BYTE sum = 0;
   18608:	230f      	movs	r3, #15
   1860a:	18fb      	adds	r3, r7, r3
   1860c:	2200      	movs	r2, #0
   1860e:	701a      	strb	r2, [r3, #0]
	UINT n = 11;
   18610:	230b      	movs	r3, #11
   18612:	60bb      	str	r3, [r7, #8]

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   18614:	230f      	movs	r3, #15
   18616:	18fb      	adds	r3, r7, r3
   18618:	781b      	ldrb	r3, [r3, #0]
   1861a:	b2da      	uxtb	r2, r3
   1861c:	0852      	lsrs	r2, r2, #1
   1861e:	01db      	lsls	r3, r3, #7
   18620:	4313      	orrs	r3, r2
   18622:	b2d9      	uxtb	r1, r3
   18624:	687b      	ldr	r3, [r7, #4]
   18626:	1c5a      	adds	r2, r3, #1
   18628:	607a      	str	r2, [r7, #4]
   1862a:	781a      	ldrb	r2, [r3, #0]
   1862c:	230f      	movs	r3, #15
   1862e:	18fb      	adds	r3, r7, r3
   18630:	188a      	adds	r2, r1, r2
   18632:	701a      	strb	r2, [r3, #0]
   18634:	68bb      	ldr	r3, [r7, #8]
   18636:	3b01      	subs	r3, #1
   18638:	60bb      	str	r3, [r7, #8]
   1863a:	68bb      	ldr	r3, [r7, #8]
   1863c:	2b00      	cmp	r3, #0
   1863e:	d1e9      	bne.n	18614 <sum_sfn+0x14>
	return sum;
   18640:	230f      	movs	r3, #15
   18642:	18fb      	adds	r3, r7, r3
   18644:	781b      	ldrb	r3, [r3, #0]
}
   18646:	0018      	movs	r0, r3
   18648:	46bd      	mov	sp, r7
   1864a:	b004      	add	sp, #16
   1864c:	bd80      	pop	{r7, pc}
   1864e:	46c0      	nop			; (mov r8, r8)

00018650 <dir_find>:

static
FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp			/* Pointer to the directory object linked to the file name */
)
{
   18650:	b590      	push	{r4, r7, lr}
   18652:	b087      	sub	sp, #28
   18654:	af00      	add	r7, sp, #0
   18656:	6078      	str	r0, [r7, #4]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
   18658:	2317      	movs	r3, #23
   1865a:	18fc      	adds	r4, r7, r3
   1865c:	687b      	ldr	r3, [r7, #4]
   1865e:	2100      	movs	r1, #0
   18660:	0018      	movs	r0, r3
   18662:	4b78      	ldr	r3, [pc, #480]	; (18844 <dir_find+0x1f4>)
   18664:	4798      	blx	r3
   18666:	0003      	movs	r3, r0
   18668:	7023      	strb	r3, [r4, #0]
	if (res != FR_OK) return res;
   1866a:	2317      	movs	r3, #23
   1866c:	18fb      	adds	r3, r7, r3
   1866e:	781b      	ldrb	r3, [r3, #0]
   18670:	2b00      	cmp	r3, #0
   18672:	d003      	beq.n	1867c <dir_find+0x2c>
   18674:	2317      	movs	r3, #23
   18676:	18fb      	adds	r3, r7, r3
   18678:	781b      	ldrb	r3, [r3, #0]
   1867a:	e0de      	b.n	1883a <dir_find+0x1ea>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1867c:	2314      	movs	r3, #20
   1867e:	18fb      	adds	r3, r7, r3
   18680:	22ff      	movs	r2, #255	; 0xff
   18682:	701a      	strb	r2, [r3, #0]
   18684:	2315      	movs	r3, #21
   18686:	18fb      	adds	r3, r7, r3
   18688:	2214      	movs	r2, #20
   1868a:	18ba      	adds	r2, r7, r2
   1868c:	7812      	ldrb	r2, [r2, #0]
   1868e:	701a      	strb	r2, [r3, #0]
   18690:	687b      	ldr	r3, [r7, #4]
   18692:	2201      	movs	r2, #1
   18694:	4252      	negs	r2, r2
   18696:	841a      	strh	r2, [r3, #32]
#endif
	do {
		res = move_window(dp->fs, dp->sect);
   18698:	687b      	ldr	r3, [r7, #4]
   1869a:	681a      	ldr	r2, [r3, #0]
   1869c:	687b      	ldr	r3, [r7, #4]
   1869e:	691b      	ldr	r3, [r3, #16]
   186a0:	2117      	movs	r1, #23
   186a2:	187c      	adds	r4, r7, r1
   186a4:	0019      	movs	r1, r3
   186a6:	0010      	movs	r0, r2
   186a8:	4b67      	ldr	r3, [pc, #412]	; (18848 <dir_find+0x1f8>)
   186aa:	4798      	blx	r3
   186ac:	0003      	movs	r3, r0
   186ae:	7023      	strb	r3, [r4, #0]
		if (res != FR_OK) break;
   186b0:	2317      	movs	r3, #23
   186b2:	18fb      	adds	r3, r7, r3
   186b4:	781b      	ldrb	r3, [r3, #0]
   186b6:	2b00      	cmp	r3, #0
   186b8:	d000      	beq.n	186bc <dir_find+0x6c>
   186ba:	e0b6      	b.n	1882a <dir_find+0x1da>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
   186bc:	687b      	ldr	r3, [r7, #4]
   186be:	695b      	ldr	r3, [r3, #20]
   186c0:	613b      	str	r3, [r7, #16]
		c = dir[DIR_Name];
   186c2:	2316      	movs	r3, #22
   186c4:	18fb      	adds	r3, r7, r3
   186c6:	693a      	ldr	r2, [r7, #16]
   186c8:	7812      	ldrb	r2, [r2, #0]
   186ca:	701a      	strb	r2, [r3, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   186cc:	2316      	movs	r3, #22
   186ce:	18fb      	adds	r3, r7, r3
   186d0:	781b      	ldrb	r3, [r3, #0]
   186d2:	2b00      	cmp	r3, #0
   186d4:	d104      	bne.n	186e0 <dir_find+0x90>
   186d6:	2317      	movs	r3, #23
   186d8:	18fb      	adds	r3, r7, r3
   186da:	2204      	movs	r2, #4
   186dc:	701a      	strb	r2, [r3, #0]
   186de:	e0a9      	b.n	18834 <dir_find+0x1e4>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
   186e0:	693b      	ldr	r3, [r7, #16]
   186e2:	330b      	adds	r3, #11
   186e4:	781a      	ldrb	r2, [r3, #0]
   186e6:	230f      	movs	r3, #15
   186e8:	18fb      	adds	r3, r7, r3
   186ea:	213f      	movs	r1, #63	; 0x3f
   186ec:	400a      	ands	r2, r1
   186ee:	701a      	strb	r2, [r3, #0]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   186f0:	2316      	movs	r3, #22
   186f2:	18fb      	adds	r3, r7, r3
   186f4:	781b      	ldrb	r3, [r3, #0]
   186f6:	2be5      	cmp	r3, #229	; 0xe5
   186f8:	d00a      	beq.n	18710 <dir_find+0xc0>
   186fa:	230f      	movs	r3, #15
   186fc:	18fb      	adds	r3, r7, r3
   186fe:	781b      	ldrb	r3, [r3, #0]
   18700:	2208      	movs	r2, #8
   18702:	4013      	ands	r3, r2
   18704:	d00d      	beq.n	18722 <dir_find+0xd2>
   18706:	230f      	movs	r3, #15
   18708:	18fb      	adds	r3, r7, r3
   1870a:	781b      	ldrb	r3, [r3, #0]
   1870c:	2b0f      	cmp	r3, #15
   1870e:	d008      	beq.n	18722 <dir_find+0xd2>
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   18710:	2315      	movs	r3, #21
   18712:	18fb      	adds	r3, r7, r3
   18714:	22ff      	movs	r2, #255	; 0xff
   18716:	701a      	strb	r2, [r3, #0]
   18718:	687b      	ldr	r3, [r7, #4]
   1871a:	2201      	movs	r2, #1
   1871c:	4252      	negs	r2, r2
   1871e:	841a      	strh	r2, [r3, #32]
   18720:	e073      	b.n	1880a <dir_find+0x1ba>
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
   18722:	230f      	movs	r3, #15
   18724:	18fb      	adds	r3, r7, r3
   18726:	781b      	ldrb	r3, [r3, #0]
   18728:	2b0f      	cmp	r3, #15
   1872a:	d145      	bne.n	187b8 <dir_find+0x168>
				if (dp->lfn) {
   1872c:	687b      	ldr	r3, [r7, #4]
   1872e:	69db      	ldr	r3, [r3, #28]
   18730:	2b00      	cmp	r3, #0
   18732:	d100      	bne.n	18736 <dir_find+0xe6>
   18734:	e069      	b.n	1880a <dir_find+0x1ba>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
   18736:	2316      	movs	r3, #22
   18738:	18fb      	adds	r3, r7, r3
   1873a:	781b      	ldrb	r3, [r3, #0]
   1873c:	2240      	movs	r2, #64	; 0x40
   1873e:	4013      	ands	r3, r2
   18740:	d016      	beq.n	18770 <dir_find+0x120>
						sum = dir[LDIR_Chksum];
   18742:	2314      	movs	r3, #20
   18744:	18fb      	adds	r3, r7, r3
   18746:	693a      	ldr	r2, [r7, #16]
   18748:	7b52      	ldrb	r2, [r2, #13]
   1874a:	701a      	strb	r2, [r3, #0]
						c &= ~LLEF; ord = c;	/* LFN start order */
   1874c:	2316      	movs	r3, #22
   1874e:	18fb      	adds	r3, r7, r3
   18750:	2216      	movs	r2, #22
   18752:	18ba      	adds	r2, r7, r2
   18754:	7812      	ldrb	r2, [r2, #0]
   18756:	2140      	movs	r1, #64	; 0x40
   18758:	438a      	bics	r2, r1
   1875a:	701a      	strb	r2, [r3, #0]
   1875c:	2315      	movs	r3, #21
   1875e:	18fb      	adds	r3, r7, r3
   18760:	2216      	movs	r2, #22
   18762:	18ba      	adds	r2, r7, r2
   18764:	7812      	ldrb	r2, [r2, #0]
   18766:	701a      	strb	r2, [r3, #0]
						dp->lfn_idx = dp->index;	/* Start index of LFN */
   18768:	687b      	ldr	r3, [r7, #4]
   1876a:	88da      	ldrh	r2, [r3, #6]
   1876c:	687b      	ldr	r3, [r7, #4]
   1876e:	841a      	strh	r2, [r3, #32]
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
   18770:	2316      	movs	r3, #22
   18772:	18fa      	adds	r2, r7, r3
   18774:	2315      	movs	r3, #21
   18776:	18fb      	adds	r3, r7, r3
   18778:	7812      	ldrb	r2, [r2, #0]
   1877a:	781b      	ldrb	r3, [r3, #0]
   1877c:	429a      	cmp	r2, r3
   1877e:	d116      	bne.n	187ae <dir_find+0x15e>
   18780:	693b      	ldr	r3, [r7, #16]
   18782:	330d      	adds	r3, #13
   18784:	781b      	ldrb	r3, [r3, #0]
   18786:	2214      	movs	r2, #20
   18788:	18ba      	adds	r2, r7, r2
   1878a:	7812      	ldrb	r2, [r2, #0]
   1878c:	429a      	cmp	r2, r3
   1878e:	d10e      	bne.n	187ae <dir_find+0x15e>
   18790:	687b      	ldr	r3, [r7, #4]
   18792:	69db      	ldr	r3, [r3, #28]
   18794:	693a      	ldr	r2, [r7, #16]
   18796:	0011      	movs	r1, r2
   18798:	0018      	movs	r0, r3
   1879a:	4b2c      	ldr	r3, [pc, #176]	; (1884c <dir_find+0x1fc>)
   1879c:	4798      	blx	r3
   1879e:	1e03      	subs	r3, r0, #0
   187a0:	d005      	beq.n	187ae <dir_find+0x15e>
   187a2:	2315      	movs	r3, #21
   187a4:	18fb      	adds	r3, r7, r3
   187a6:	781b      	ldrb	r3, [r3, #0]
   187a8:	3b01      	subs	r3, #1
   187aa:	b2da      	uxtb	r2, r3
   187ac:	e000      	b.n	187b0 <dir_find+0x160>
   187ae:	22ff      	movs	r2, #255	; 0xff
   187b0:	2315      	movs	r3, #21
   187b2:	18fb      	adds	r3, r7, r3
   187b4:	701a      	strb	r2, [r3, #0]
   187b6:	e028      	b.n	1880a <dir_find+0x1ba>
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   187b8:	2315      	movs	r3, #21
   187ba:	18fb      	adds	r3, r7, r3
   187bc:	781b      	ldrb	r3, [r3, #0]
   187be:	2b00      	cmp	r3, #0
   187c0:	d10a      	bne.n	187d8 <dir_find+0x188>
   187c2:	693b      	ldr	r3, [r7, #16]
   187c4:	0018      	movs	r0, r3
   187c6:	4b22      	ldr	r3, [pc, #136]	; (18850 <dir_find+0x200>)
   187c8:	4798      	blx	r3
   187ca:	0003      	movs	r3, r0
   187cc:	001a      	movs	r2, r3
   187ce:	2314      	movs	r3, #20
   187d0:	18fb      	adds	r3, r7, r3
   187d2:	781b      	ldrb	r3, [r3, #0]
   187d4:	4293      	cmp	r3, r2
   187d6:	d02a      	beq.n	1882e <dir_find+0x1de>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
   187d8:	687b      	ldr	r3, [r7, #4]
   187da:	699b      	ldr	r3, [r3, #24]
   187dc:	330b      	adds	r3, #11
   187de:	781b      	ldrb	r3, [r3, #0]
   187e0:	001a      	movs	r2, r3
   187e2:	2301      	movs	r3, #1
   187e4:	4013      	ands	r3, r2
   187e6:	d108      	bne.n	187fa <dir_find+0x1aa>
   187e8:	687b      	ldr	r3, [r7, #4]
   187ea:	6999      	ldr	r1, [r3, #24]
   187ec:	693b      	ldr	r3, [r7, #16]
   187ee:	220b      	movs	r2, #11
   187f0:	0018      	movs	r0, r3
   187f2:	4b18      	ldr	r3, [pc, #96]	; (18854 <dir_find+0x204>)
   187f4:	4798      	blx	r3
   187f6:	1e03      	subs	r3, r0, #0
   187f8:	d01b      	beq.n	18832 <dir_find+0x1e2>
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   187fa:	2315      	movs	r3, #21
   187fc:	18fb      	adds	r3, r7, r3
   187fe:	22ff      	movs	r2, #255	; 0xff
   18800:	701a      	strb	r2, [r3, #0]
   18802:	687b      	ldr	r3, [r7, #4]
   18804:	2201      	movs	r2, #1
   18806:	4252      	negs	r2, r2
   18808:	841a      	strh	r2, [r3, #32]
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
   1880a:	2317      	movs	r3, #23
   1880c:	18fc      	adds	r4, r7, r3
   1880e:	687b      	ldr	r3, [r7, #4]
   18810:	2100      	movs	r1, #0
   18812:	0018      	movs	r0, r3
   18814:	4b10      	ldr	r3, [pc, #64]	; (18858 <dir_find+0x208>)
   18816:	4798      	blx	r3
   18818:	0003      	movs	r3, r0
   1881a:	7023      	strb	r3, [r4, #0]
	} while (res == FR_OK);
   1881c:	2317      	movs	r3, #23
   1881e:	18fb      	adds	r3, r7, r3
   18820:	781b      	ldrb	r3, [r3, #0]
   18822:	2b00      	cmp	r3, #0
   18824:	d100      	bne.n	18828 <dir_find+0x1d8>
   18826:	e737      	b.n	18698 <dir_find+0x48>
   18828:	e004      	b.n	18834 <dir_find+0x1e4>
#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
   1882a:	46c0      	nop			; (mov r8, r8)
   1882c:	e002      	b.n	18834 <dir_find+0x1e4>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   1882e:	46c0      	nop			; (mov r8, r8)
   18830:	e000      	b.n	18834 <dir_find+0x1e4>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
   18832:	46c0      	nop			; (mov r8, r8)
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
   18834:	2317      	movs	r3, #23
   18836:	18fb      	adds	r3, r7, r3
   18838:	781b      	ldrb	r3, [r3, #0]
}
   1883a:	0018      	movs	r0, r3
   1883c:	46bd      	mov	sp, r7
   1883e:	b007      	add	sp, #28
   18840:	bd90      	pop	{r4, r7, pc}
   18842:	46c0      	nop			; (mov r8, r8)
   18844:	00017d75 	.word	0x00017d75
   18848:	00017555 	.word	0x00017555
   1884c:	00018195 	.word	0x00018195
   18850:	00018601 	.word	0x00018601
   18854:	0001743d 	.word	0x0001743d
   18858:	00017e81 	.word	0x00017e81

0001885c <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
   1885c:	b590      	push	{r4, r7, lr}
   1885e:	b087      	sub	sp, #28
   18860:	af00      	add	r7, sp, #0
   18862:	6078      	str	r0, [r7, #4]
   18864:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE a, c, *dir;
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
   18866:	2315      	movs	r3, #21
   18868:	18fb      	adds	r3, r7, r3
   1886a:	22ff      	movs	r2, #255	; 0xff
   1886c:	701a      	strb	r2, [r3, #0]
   1886e:	2314      	movs	r3, #20
   18870:	18fb      	adds	r3, r7, r3
   18872:	22ff      	movs	r2, #255	; 0xff
   18874:	701a      	strb	r2, [r3, #0]
#endif

	res = FR_NO_FILE;
   18876:	2317      	movs	r3, #23
   18878:	18fb      	adds	r3, r7, r3
   1887a:	2204      	movs	r2, #4
   1887c:	701a      	strb	r2, [r3, #0]
	while (dp->sect) {
   1887e:	e0b0      	b.n	189e2 <dir_read+0x186>
		res = move_window(dp->fs, dp->sect);
   18880:	687b      	ldr	r3, [r7, #4]
   18882:	681a      	ldr	r2, [r3, #0]
   18884:	687b      	ldr	r3, [r7, #4]
   18886:	691b      	ldr	r3, [r3, #16]
   18888:	2117      	movs	r1, #23
   1888a:	187c      	adds	r4, r7, r1
   1888c:	0019      	movs	r1, r3
   1888e:	0010      	movs	r0, r2
   18890:	4b61      	ldr	r3, [pc, #388]	; (18a18 <dir_read+0x1bc>)
   18892:	4798      	blx	r3
   18894:	0003      	movs	r3, r0
   18896:	7023      	strb	r3, [r4, #0]
		if (res != FR_OK) break;
   18898:	2317      	movs	r3, #23
   1889a:	18fb      	adds	r3, r7, r3
   1889c:	781b      	ldrb	r3, [r3, #0]
   1889e:	2b00      	cmp	r3, #0
   188a0:	d000      	beq.n	188a4 <dir_read+0x48>
   188a2:	e0a4      	b.n	189ee <dir_read+0x192>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
   188a4:	687b      	ldr	r3, [r7, #4]
   188a6:	695b      	ldr	r3, [r3, #20]
   188a8:	613b      	str	r3, [r7, #16]
		c = dir[DIR_Name];
   188aa:	2316      	movs	r3, #22
   188ac:	18fb      	adds	r3, r7, r3
   188ae:	693a      	ldr	r2, [r7, #16]
   188b0:	7812      	ldrb	r2, [r2, #0]
   188b2:	701a      	strb	r2, [r3, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   188b4:	2316      	movs	r3, #22
   188b6:	18fb      	adds	r3, r7, r3
   188b8:	781b      	ldrb	r3, [r3, #0]
   188ba:	2b00      	cmp	r3, #0
   188bc:	d104      	bne.n	188c8 <dir_read+0x6c>
   188be:	2317      	movs	r3, #23
   188c0:	18fb      	adds	r3, r7, r3
   188c2:	2204      	movs	r2, #4
   188c4:	701a      	strb	r2, [r3, #0]
   188c6:	e097      	b.n	189f8 <dir_read+0x19c>
		a = dir[DIR_Attr] & AM_MASK;
   188c8:	693b      	ldr	r3, [r7, #16]
   188ca:	330b      	adds	r3, #11
   188cc:	781a      	ldrb	r2, [r3, #0]
   188ce:	230f      	movs	r3, #15
   188d0:	18fb      	adds	r3, r7, r3
   188d2:	213f      	movs	r1, #63	; 0x3f
   188d4:	400a      	ands	r2, r1
   188d6:	701a      	strb	r2, [r3, #0]
#if _USE_LFN	/* LFN configuration */
		if (c == DDEM || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
   188d8:	2316      	movs	r3, #22
   188da:	18fb      	adds	r3, r7, r3
   188dc:	781b      	ldrb	r3, [r3, #0]
   188de:	2be5      	cmp	r3, #229	; 0xe5
   188e0:	d011      	beq.n	18906 <dir_read+0xaa>
   188e2:	2316      	movs	r3, #22
   188e4:	18fb      	adds	r3, r7, r3
   188e6:	781b      	ldrb	r3, [r3, #0]
   188e8:	2b2e      	cmp	r3, #46	; 0x2e
   188ea:	d00c      	beq.n	18906 <dir_read+0xaa>
   188ec:	230f      	movs	r3, #15
   188ee:	18fb      	adds	r3, r7, r3
   188f0:	781b      	ldrb	r3, [r3, #0]
   188f2:	2220      	movs	r2, #32
   188f4:	4393      	bics	r3, r2
   188f6:	3b08      	subs	r3, #8
   188f8:	425a      	negs	r2, r3
   188fa:	4153      	adcs	r3, r2
   188fc:	b2db      	uxtb	r3, r3
   188fe:	1e1a      	subs	r2, r3, #0
   18900:	683b      	ldr	r3, [r7, #0]
   18902:	429a      	cmp	r2, r3
   18904:	d004      	beq.n	18910 <dir_read+0xb4>
			ord = 0xFF;
   18906:	2315      	movs	r3, #21
   18908:	18fb      	adds	r3, r7, r3
   1890a:	22ff      	movs	r2, #255	; 0xff
   1890c:	701a      	strb	r2, [r3, #0]
   1890e:	e05a      	b.n	189c6 <dir_read+0x16a>
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
   18910:	230f      	movs	r3, #15
   18912:	18fb      	adds	r3, r7, r3
   18914:	781b      	ldrb	r3, [r3, #0]
   18916:	2b0f      	cmp	r3, #15
   18918:	d140      	bne.n	1899c <dir_read+0x140>
				if (c & LLEF) {			/* Is it start of LFN sequence? */
   1891a:	2316      	movs	r3, #22
   1891c:	18fb      	adds	r3, r7, r3
   1891e:	781b      	ldrb	r3, [r3, #0]
   18920:	2240      	movs	r2, #64	; 0x40
   18922:	4013      	ands	r3, r2
   18924:	d016      	beq.n	18954 <dir_read+0xf8>
					sum = dir[LDIR_Chksum];
   18926:	2314      	movs	r3, #20
   18928:	18fb      	adds	r3, r7, r3
   1892a:	693a      	ldr	r2, [r7, #16]
   1892c:	7b52      	ldrb	r2, [r2, #13]
   1892e:	701a      	strb	r2, [r3, #0]
					c &= ~LLEF; ord = c;
   18930:	2316      	movs	r3, #22
   18932:	18fb      	adds	r3, r7, r3
   18934:	2216      	movs	r2, #22
   18936:	18ba      	adds	r2, r7, r2
   18938:	7812      	ldrb	r2, [r2, #0]
   1893a:	2140      	movs	r1, #64	; 0x40
   1893c:	438a      	bics	r2, r1
   1893e:	701a      	strb	r2, [r3, #0]
   18940:	2315      	movs	r3, #21
   18942:	18fb      	adds	r3, r7, r3
   18944:	2216      	movs	r2, #22
   18946:	18ba      	adds	r2, r7, r2
   18948:	7812      	ldrb	r2, [r2, #0]
   1894a:	701a      	strb	r2, [r3, #0]
					dp->lfn_idx = dp->index;
   1894c:	687b      	ldr	r3, [r7, #4]
   1894e:	88da      	ldrh	r2, [r3, #6]
   18950:	687b      	ldr	r3, [r7, #4]
   18952:	841a      	strh	r2, [r3, #32]
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
   18954:	2316      	movs	r3, #22
   18956:	18fa      	adds	r2, r7, r3
   18958:	2315      	movs	r3, #21
   1895a:	18fb      	adds	r3, r7, r3
   1895c:	7812      	ldrb	r2, [r2, #0]
   1895e:	781b      	ldrb	r3, [r3, #0]
   18960:	429a      	cmp	r2, r3
   18962:	d116      	bne.n	18992 <dir_read+0x136>
   18964:	693b      	ldr	r3, [r7, #16]
   18966:	330d      	adds	r3, #13
   18968:	781b      	ldrb	r3, [r3, #0]
   1896a:	2214      	movs	r2, #20
   1896c:	18ba      	adds	r2, r7, r2
   1896e:	7812      	ldrb	r2, [r2, #0]
   18970:	429a      	cmp	r2, r3
   18972:	d10e      	bne.n	18992 <dir_read+0x136>
   18974:	687b      	ldr	r3, [r7, #4]
   18976:	69db      	ldr	r3, [r3, #28]
   18978:	693a      	ldr	r2, [r7, #16]
   1897a:	0011      	movs	r1, r2
   1897c:	0018      	movs	r0, r3
   1897e:	4b27      	ldr	r3, [pc, #156]	; (18a1c <dir_read+0x1c0>)
   18980:	4798      	blx	r3
   18982:	1e03      	subs	r3, r0, #0
   18984:	d005      	beq.n	18992 <dir_read+0x136>
   18986:	2315      	movs	r3, #21
   18988:	18fb      	adds	r3, r7, r3
   1898a:	781b      	ldrb	r3, [r3, #0]
   1898c:	3b01      	subs	r3, #1
   1898e:	b2da      	uxtb	r2, r3
   18990:	e000      	b.n	18994 <dir_read+0x138>
   18992:	22ff      	movs	r2, #255	; 0xff
   18994:	2315      	movs	r3, #21
   18996:	18fb      	adds	r3, r7, r3
   18998:	701a      	strb	r2, [r3, #0]
   1899a:	e014      	b.n	189c6 <dir_read+0x16a>
			} else {					/* An SFN entry is found */
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   1899c:	2315      	movs	r3, #21
   1899e:	18fb      	adds	r3, r7, r3
   189a0:	781b      	ldrb	r3, [r3, #0]
   189a2:	2b00      	cmp	r3, #0
   189a4:	d10a      	bne.n	189bc <dir_read+0x160>
   189a6:	693b      	ldr	r3, [r7, #16]
   189a8:	0018      	movs	r0, r3
   189aa:	4b1d      	ldr	r3, [pc, #116]	; (18a20 <dir_read+0x1c4>)
   189ac:	4798      	blx	r3
   189ae:	0003      	movs	r3, r0
   189b0:	001a      	movs	r2, r3
   189b2:	2314      	movs	r3, #20
   189b4:	18fb      	adds	r3, r7, r3
   189b6:	781b      	ldrb	r3, [r3, #0]
   189b8:	4293      	cmp	r3, r2
   189ba:	d01a      	beq.n	189f2 <dir_read+0x196>
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
   189bc:	687b      	ldr	r3, [r7, #4]
   189be:	2201      	movs	r2, #1
   189c0:	4252      	negs	r2, r2
   189c2:	841a      	strh	r2, [r3, #32]
				break;
   189c4:	e015      	b.n	189f2 <dir_read+0x196>
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
   189c6:	2317      	movs	r3, #23
   189c8:	18fc      	adds	r4, r7, r3
   189ca:	687b      	ldr	r3, [r7, #4]
   189cc:	2100      	movs	r1, #0
   189ce:	0018      	movs	r0, r3
   189d0:	4b14      	ldr	r3, [pc, #80]	; (18a24 <dir_read+0x1c8>)
   189d2:	4798      	blx	r3
   189d4:	0003      	movs	r3, r0
   189d6:	7023      	strb	r3, [r4, #0]
		if (res != FR_OK) break;
   189d8:	2317      	movs	r3, #23
   189da:	18fb      	adds	r3, r7, r3
   189dc:	781b      	ldrb	r3, [r3, #0]
   189de:	2b00      	cmp	r3, #0
   189e0:	d109      	bne.n	189f6 <dir_read+0x19a>
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
   189e2:	687b      	ldr	r3, [r7, #4]
   189e4:	691b      	ldr	r3, [r3, #16]
   189e6:	2b00      	cmp	r3, #0
   189e8:	d000      	beq.n	189ec <dir_read+0x190>
   189ea:	e749      	b.n	18880 <dir_read+0x24>
   189ec:	e004      	b.n	189f8 <dir_read+0x19c>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
   189ee:	46c0      	nop			; (mov r8, r8)
   189f0:	e002      	b.n	189f8 <dir_read+0x19c>
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
			} else {					/* An SFN entry is found */
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
   189f2:	46c0      	nop			; (mov r8, r8)
   189f4:	e000      	b.n	189f8 <dir_read+0x19c>
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
   189f6:	46c0      	nop			; (mov r8, r8)
	}

	if (res != FR_OK) dp->sect = 0;
   189f8:	2317      	movs	r3, #23
   189fa:	18fb      	adds	r3, r7, r3
   189fc:	781b      	ldrb	r3, [r3, #0]
   189fe:	2b00      	cmp	r3, #0
   18a00:	d002      	beq.n	18a08 <dir_read+0x1ac>
   18a02:	687b      	ldr	r3, [r7, #4]
   18a04:	2200      	movs	r2, #0
   18a06:	611a      	str	r2, [r3, #16]

	return res;
   18a08:	2317      	movs	r3, #23
   18a0a:	18fb      	adds	r3, r7, r3
   18a0c:	781b      	ldrb	r3, [r3, #0]
}
   18a0e:	0018      	movs	r0, r3
   18a10:	46bd      	mov	sp, r7
   18a12:	b007      	add	sp, #28
   18a14:	bd90      	pop	{r4, r7, pc}
   18a16:	46c0      	nop			; (mov r8, r8)
   18a18:	00017555 	.word	0x00017555
   18a1c:	000182b9 	.word	0x000182b9
   18a20:	00018601 	.word	0x00018601
   18a24:	00017e81 	.word	0x00017e81

00018a28 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
   18a28:	b590      	push	{r4, r7, lr}
   18a2a:	b08d      	sub	sp, #52	; 0x34
   18a2c:	af00      	add	r7, sp, #0
   18a2e:	6078      	str	r0, [r7, #4]
	UINT n, nent;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
   18a30:	687b      	ldr	r3, [r7, #4]
   18a32:	699b      	ldr	r3, [r3, #24]
   18a34:	623b      	str	r3, [r7, #32]
   18a36:	687b      	ldr	r3, [r7, #4]
   18a38:	69db      	ldr	r3, [r3, #28]
   18a3a:	61fb      	str	r3, [r7, #28]
	mem_cpy(sn, fn, 12);
   18a3c:	6a39      	ldr	r1, [r7, #32]
   18a3e:	230c      	movs	r3, #12
   18a40:	18fb      	adds	r3, r7, r3
   18a42:	220c      	movs	r2, #12
   18a44:	0018      	movs	r0, r3
   18a46:	4b84      	ldr	r3, [pc, #528]	; (18c58 <dir_register+0x230>)
   18a48:	4798      	blx	r3

	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   18a4a:	230c      	movs	r3, #12
   18a4c:	18fb      	adds	r3, r7, r3
   18a4e:	7adb      	ldrb	r3, [r3, #11]
   18a50:	001a      	movs	r2, r3
   18a52:	2301      	movs	r3, #1
   18a54:	4013      	ands	r3, r2
   18a56:	d03c      	beq.n	18ad2 <dir_register+0xaa>
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
   18a58:	6a3b      	ldr	r3, [r7, #32]
   18a5a:	330b      	adds	r3, #11
   18a5c:	2200      	movs	r2, #0
   18a5e:	701a      	strb	r2, [r3, #0]
   18a60:	687b      	ldr	r3, [r7, #4]
   18a62:	2200      	movs	r2, #0
   18a64:	61da      	str	r2, [r3, #28]
		for (n = 1; n < 100; n++) {
   18a66:	2301      	movs	r3, #1
   18a68:	62bb      	str	r3, [r7, #40]	; 0x28
   18a6a:	e016      	b.n	18a9a <dir_register+0x72>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   18a6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   18a6e:	69fa      	ldr	r2, [r7, #28]
   18a70:	210c      	movs	r1, #12
   18a72:	1879      	adds	r1, r7, r1
   18a74:	6a38      	ldr	r0, [r7, #32]
   18a76:	4c79      	ldr	r4, [pc, #484]	; (18c5c <dir_register+0x234>)
   18a78:	47a0      	blx	r4
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
   18a7a:	232f      	movs	r3, #47	; 0x2f
   18a7c:	18fc      	adds	r4, r7, r3
   18a7e:	687b      	ldr	r3, [r7, #4]
   18a80:	0018      	movs	r0, r3
   18a82:	4b77      	ldr	r3, [pc, #476]	; (18c60 <dir_register+0x238>)
   18a84:	4798      	blx	r3
   18a86:	0003      	movs	r3, r0
   18a88:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) break;
   18a8a:	232f      	movs	r3, #47	; 0x2f
   18a8c:	18fb      	adds	r3, r7, r3
   18a8e:	781b      	ldrb	r3, [r3, #0]
   18a90:	2b00      	cmp	r3, #0
   18a92:	d106      	bne.n	18aa2 <dir_register+0x7a>
	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
   18a94:	6abb      	ldr	r3, [r7, #40]	; 0x28
   18a96:	3301      	adds	r3, #1
   18a98:	62bb      	str	r3, [r7, #40]	; 0x28
   18a9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   18a9c:	2b63      	cmp	r3, #99	; 0x63
   18a9e:	d9e5      	bls.n	18a6c <dir_register+0x44>
   18aa0:	e000      	b.n	18aa4 <dir_register+0x7c>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
   18aa2:	46c0      	nop			; (mov r8, r8)
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   18aa4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   18aa6:	2b64      	cmp	r3, #100	; 0x64
   18aa8:	d101      	bne.n	18aae <dir_register+0x86>
   18aaa:	2307      	movs	r3, #7
   18aac:	e0d0      	b.n	18c50 <dir_register+0x228>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   18aae:	232f      	movs	r3, #47	; 0x2f
   18ab0:	18fb      	adds	r3, r7, r3
   18ab2:	781b      	ldrb	r3, [r3, #0]
   18ab4:	2b04      	cmp	r3, #4
   18ab6:	d003      	beq.n	18ac0 <dir_register+0x98>
   18ab8:	232f      	movs	r3, #47	; 0x2f
   18aba:	18fb      	adds	r3, r7, r3
   18abc:	781b      	ldrb	r3, [r3, #0]
   18abe:	e0c7      	b.n	18c50 <dir_register+0x228>
		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
   18ac0:	6a3b      	ldr	r3, [r7, #32]
   18ac2:	330b      	adds	r3, #11
   18ac4:	220c      	movs	r2, #12
   18ac6:	18ba      	adds	r2, r7, r2
   18ac8:	7ad2      	ldrb	r2, [r2, #11]
   18aca:	701a      	strb	r2, [r3, #0]
   18acc:	687b      	ldr	r3, [r7, #4]
   18ace:	69fa      	ldr	r2, [r7, #28]
   18ad0:	61da      	str	r2, [r3, #28]
	}

	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
   18ad2:	230c      	movs	r3, #12
   18ad4:	18fb      	adds	r3, r7, r3
   18ad6:	7adb      	ldrb	r3, [r3, #11]
   18ad8:	001a      	movs	r2, r3
   18ada:	2302      	movs	r3, #2
   18adc:	4013      	ands	r3, r2
   18ade:	d016      	beq.n	18b0e <dir_register+0xe6>
		for (n = 0; lfn[n]; n++) ;
   18ae0:	2300      	movs	r3, #0
   18ae2:	62bb      	str	r3, [r7, #40]	; 0x28
   18ae4:	e002      	b.n	18aec <dir_register+0xc4>
   18ae6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   18ae8:	3301      	adds	r3, #1
   18aea:	62bb      	str	r3, [r7, #40]	; 0x28
   18aec:	6abb      	ldr	r3, [r7, #40]	; 0x28
   18aee:	005b      	lsls	r3, r3, #1
   18af0:	69fa      	ldr	r2, [r7, #28]
   18af2:	18d3      	adds	r3, r2, r3
   18af4:	881b      	ldrh	r3, [r3, #0]
   18af6:	2b00      	cmp	r3, #0
   18af8:	d1f5      	bne.n	18ae6 <dir_register+0xbe>
		nent = (n + 25) / 13;
   18afa:	6abb      	ldr	r3, [r7, #40]	; 0x28
   18afc:	3319      	adds	r3, #25
   18afe:	001a      	movs	r2, r3
   18b00:	4b58      	ldr	r3, [pc, #352]	; (18c64 <dir_register+0x23c>)
   18b02:	210d      	movs	r1, #13
   18b04:	0010      	movs	r0, r2
   18b06:	4798      	blx	r3
   18b08:	0003      	movs	r3, r0
   18b0a:	627b      	str	r3, [r7, #36]	; 0x24
   18b0c:	e001      	b.n	18b12 <dir_register+0xea>
	} else {						/* Otherwise allocate an entry for an SFN  */
		nent = 1;
   18b0e:	2301      	movs	r3, #1
   18b10:	627b      	str	r3, [r7, #36]	; 0x24
	}
	res = dir_alloc(dp, nent);		/* Allocate entries */
   18b12:	232f      	movs	r3, #47	; 0x2f
   18b14:	18fc      	adds	r4, r7, r3
   18b16:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   18b18:	687b      	ldr	r3, [r7, #4]
   18b1a:	0011      	movs	r1, r2
   18b1c:	0018      	movs	r0, r3
   18b1e:	4b52      	ldr	r3, [pc, #328]	; (18c68 <dir_register+0x240>)
   18b20:	4798      	blx	r3
   18b22:	0003      	movs	r3, r0
   18b24:	7023      	strb	r3, [r4, #0]

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
   18b26:	232f      	movs	r3, #47	; 0x2f
   18b28:	18fb      	adds	r3, r7, r3
   18b2a:	781b      	ldrb	r3, [r3, #0]
   18b2c:	2b00      	cmp	r3, #0
   18b2e:	d157      	bne.n	18be0 <dir_register+0x1b8>
   18b30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   18b32:	3b01      	subs	r3, #1
   18b34:	627b      	str	r3, [r7, #36]	; 0x24
   18b36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   18b38:	2b00      	cmp	r3, #0
   18b3a:	d051      	beq.n	18be0 <dir_register+0x1b8>
		res = dir_sdi(dp, dp->index - nent);
   18b3c:	687b      	ldr	r3, [r7, #4]
   18b3e:	88db      	ldrh	r3, [r3, #6]
   18b40:	001a      	movs	r2, r3
   18b42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   18b44:	1ad2      	subs	r2, r2, r3
   18b46:	232f      	movs	r3, #47	; 0x2f
   18b48:	18fc      	adds	r4, r7, r3
   18b4a:	687b      	ldr	r3, [r7, #4]
   18b4c:	0011      	movs	r1, r2
   18b4e:	0018      	movs	r0, r3
   18b50:	4b46      	ldr	r3, [pc, #280]	; (18c6c <dir_register+0x244>)
   18b52:	4798      	blx	r3
   18b54:	0003      	movs	r3, r0
   18b56:	7023      	strb	r3, [r4, #0]
		if (res == FR_OK) {
   18b58:	232f      	movs	r3, #47	; 0x2f
   18b5a:	18fb      	adds	r3, r7, r3
   18b5c:	781b      	ldrb	r3, [r3, #0]
   18b5e:	2b00      	cmp	r3, #0
   18b60:	d13e      	bne.n	18be0 <dir_register+0x1b8>
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
   18b62:	687b      	ldr	r3, [r7, #4]
   18b64:	699b      	ldr	r3, [r3, #24]
   18b66:	221b      	movs	r2, #27
   18b68:	18bc      	adds	r4, r7, r2
   18b6a:	0018      	movs	r0, r3
   18b6c:	4b40      	ldr	r3, [pc, #256]	; (18c70 <dir_register+0x248>)
   18b6e:	4798      	blx	r3
   18b70:	0003      	movs	r3, r0
   18b72:	7023      	strb	r3, [r4, #0]
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
   18b74:	687b      	ldr	r3, [r7, #4]
   18b76:	681a      	ldr	r2, [r3, #0]
   18b78:	687b      	ldr	r3, [r7, #4]
   18b7a:	691b      	ldr	r3, [r3, #16]
   18b7c:	212f      	movs	r1, #47	; 0x2f
   18b7e:	187c      	adds	r4, r7, r1
   18b80:	0019      	movs	r1, r3
   18b82:	0010      	movs	r0, r2
   18b84:	4b3b      	ldr	r3, [pc, #236]	; (18c74 <dir_register+0x24c>)
   18b86:	4798      	blx	r3
   18b88:	0003      	movs	r3, r0
   18b8a:	7023      	strb	r3, [r4, #0]
				if (res != FR_OK) break;
   18b8c:	232f      	movs	r3, #47	; 0x2f
   18b8e:	18fb      	adds	r3, r7, r3
   18b90:	781b      	ldrb	r3, [r3, #0]
   18b92:	2b00      	cmp	r3, #0
   18b94:	d123      	bne.n	18bde <dir_register+0x1b6>
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
   18b96:	687b      	ldr	r3, [r7, #4]
   18b98:	69d8      	ldr	r0, [r3, #28]
   18b9a:	687b      	ldr	r3, [r7, #4]
   18b9c:	6959      	ldr	r1, [r3, #20]
   18b9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   18ba0:	b2da      	uxtb	r2, r3
   18ba2:	231b      	movs	r3, #27
   18ba4:	18fb      	adds	r3, r7, r3
   18ba6:	781b      	ldrb	r3, [r3, #0]
   18ba8:	4c33      	ldr	r4, [pc, #204]	; (18c78 <dir_register+0x250>)
   18baa:	47a0      	blx	r4
				dp->fs->wflag = 1;
   18bac:	687b      	ldr	r3, [r7, #4]
   18bae:	681b      	ldr	r3, [r3, #0]
   18bb0:	2201      	movs	r2, #1
   18bb2:	711a      	strb	r2, [r3, #4]
				res = dir_next(dp, 0);	/* Next entry */
   18bb4:	232f      	movs	r3, #47	; 0x2f
   18bb6:	18fc      	adds	r4, r7, r3
   18bb8:	687b      	ldr	r3, [r7, #4]
   18bba:	2100      	movs	r1, #0
   18bbc:	0018      	movs	r0, r3
   18bbe:	4b2f      	ldr	r3, [pc, #188]	; (18c7c <dir_register+0x254>)
   18bc0:	4798      	blx	r3
   18bc2:	0003      	movs	r3, r0
   18bc4:	7023      	strb	r3, [r4, #0]
			} while (res == FR_OK && --nent);
   18bc6:	232f      	movs	r3, #47	; 0x2f
   18bc8:	18fb      	adds	r3, r7, r3
   18bca:	781b      	ldrb	r3, [r3, #0]
   18bcc:	2b00      	cmp	r3, #0
   18bce:	d107      	bne.n	18be0 <dir_register+0x1b8>
   18bd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   18bd2:	3b01      	subs	r3, #1
   18bd4:	627b      	str	r3, [r7, #36]	; 0x24
   18bd6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   18bd8:	2b00      	cmp	r3, #0
   18bda:	d1cb      	bne.n	18b74 <dir_register+0x14c>
   18bdc:	e000      	b.n	18be0 <dir_register+0x1b8>
		res = dir_sdi(dp, dp->index - nent);
		if (res == FR_OK) {
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
				if (res != FR_OK) break;
   18bde:	46c0      	nop			; (mov r8, r8)
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
#endif

	if (res == FR_OK) {				/* Set SFN entry */
   18be0:	232f      	movs	r3, #47	; 0x2f
   18be2:	18fb      	adds	r3, r7, r3
   18be4:	781b      	ldrb	r3, [r3, #0]
   18be6:	2b00      	cmp	r3, #0
   18be8:	d12f      	bne.n	18c4a <dir_register+0x222>
		res = move_window(dp->fs, dp->sect);
   18bea:	687b      	ldr	r3, [r7, #4]
   18bec:	681a      	ldr	r2, [r3, #0]
   18bee:	687b      	ldr	r3, [r7, #4]
   18bf0:	691b      	ldr	r3, [r3, #16]
   18bf2:	212f      	movs	r1, #47	; 0x2f
   18bf4:	187c      	adds	r4, r7, r1
   18bf6:	0019      	movs	r1, r3
   18bf8:	0010      	movs	r0, r2
   18bfa:	4b1e      	ldr	r3, [pc, #120]	; (18c74 <dir_register+0x24c>)
   18bfc:	4798      	blx	r3
   18bfe:	0003      	movs	r3, r0
   18c00:	7023      	strb	r3, [r4, #0]
		if (res == FR_OK) {
   18c02:	232f      	movs	r3, #47	; 0x2f
   18c04:	18fb      	adds	r3, r7, r3
   18c06:	781b      	ldrb	r3, [r3, #0]
   18c08:	2b00      	cmp	r3, #0
   18c0a:	d11e      	bne.n	18c4a <dir_register+0x222>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
   18c0c:	687b      	ldr	r3, [r7, #4]
   18c0e:	695b      	ldr	r3, [r3, #20]
   18c10:	2220      	movs	r2, #32
   18c12:	2100      	movs	r1, #0
   18c14:	0018      	movs	r0, r3
   18c16:	4b1a      	ldr	r3, [pc, #104]	; (18c80 <dir_register+0x258>)
   18c18:	4798      	blx	r3
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
   18c1a:	687b      	ldr	r3, [r7, #4]
   18c1c:	6958      	ldr	r0, [r3, #20]
   18c1e:	687b      	ldr	r3, [r7, #4]
   18c20:	699b      	ldr	r3, [r3, #24]
   18c22:	220b      	movs	r2, #11
   18c24:	0019      	movs	r1, r3
   18c26:	4b0c      	ldr	r3, [pc, #48]	; (18c58 <dir_register+0x230>)
   18c28:	4798      	blx	r3
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
   18c2a:	687b      	ldr	r3, [r7, #4]
   18c2c:	695b      	ldr	r3, [r3, #20]
   18c2e:	330c      	adds	r3, #12
   18c30:	001a      	movs	r2, r3
   18c32:	687b      	ldr	r3, [r7, #4]
   18c34:	699b      	ldr	r3, [r3, #24]
   18c36:	330b      	adds	r3, #11
   18c38:	781b      	ldrb	r3, [r3, #0]
   18c3a:	2118      	movs	r1, #24
   18c3c:	400b      	ands	r3, r1
   18c3e:	b2db      	uxtb	r3, r3
   18c40:	7013      	strb	r3, [r2, #0]
#endif
			dp->fs->wflag = 1;
   18c42:	687b      	ldr	r3, [r7, #4]
   18c44:	681b      	ldr	r3, [r3, #0]
   18c46:	2201      	movs	r2, #1
   18c48:	711a      	strb	r2, [r3, #4]
		}
	}

	return res;
   18c4a:	232f      	movs	r3, #47	; 0x2f
   18c4c:	18fb      	adds	r3, r7, r3
   18c4e:	781b      	ldrb	r3, [r3, #0]
}
   18c50:	0018      	movs	r0, r3
   18c52:	46bd      	mov	sp, r7
   18c54:	b00d      	add	sp, #52	; 0x34
   18c56:	bd90      	pop	{r4, r7, pc}
   18c58:	000173d5 	.word	0x000173d5
   18c5c:	000184cd 	.word	0x000184cd
   18c60:	00018651 	.word	0x00018651
   18c64:	0001d485 	.word	0x0001d485
   18c68:	00018039 	.word	0x00018039
   18c6c:	00017d75 	.word	0x00017d75
   18c70:	00018601 	.word	0x00018601
   18c74:	00017555 	.word	0x00017555
   18c78:	000183bd 	.word	0x000183bd
   18c7c:	00017e81 	.word	0x00017e81
   18c80:	0001740d 	.word	0x0001740d

00018c84 <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
	DIR* dp				/* Directory object pointing the entry to be removed */
)
{
   18c84:	b590      	push	{r4, r7, lr}
   18c86:	b085      	sub	sp, #20
   18c88:	af00      	add	r7, sp, #0
   18c8a:	6078      	str	r0, [r7, #4]
	FRESULT res;
#if _USE_LFN	/* LFN configuration */
	UINT i;

	i = dp->index;	/* SFN index */
   18c8c:	687b      	ldr	r3, [r7, #4]
   18c8e:	88db      	ldrh	r3, [r3, #6]
   18c90:	60bb      	str	r3, [r7, #8]
	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
   18c92:	687b      	ldr	r3, [r7, #4]
   18c94:	8c1b      	ldrh	r3, [r3, #32]
   18c96:	4a2e      	ldr	r2, [pc, #184]	; (18d50 <dir_remove+0xcc>)
   18c98:	4293      	cmp	r3, r2
   18c9a:	d002      	beq.n	18ca2 <dir_remove+0x1e>
   18c9c:	687b      	ldr	r3, [r7, #4]
   18c9e:	8c1b      	ldrh	r3, [r3, #32]
   18ca0:	e000      	b.n	18ca4 <dir_remove+0x20>
   18ca2:	68bb      	ldr	r3, [r7, #8]
   18ca4:	220f      	movs	r2, #15
   18ca6:	18bc      	adds	r4, r7, r2
   18ca8:	687a      	ldr	r2, [r7, #4]
   18caa:	0019      	movs	r1, r3
   18cac:	0010      	movs	r0, r2
   18cae:	4b29      	ldr	r3, [pc, #164]	; (18d54 <dir_remove+0xd0>)
   18cb0:	4798      	blx	r3
   18cb2:	0003      	movs	r3, r0
   18cb4:	7023      	strb	r3, [r4, #0]
	if (res == FR_OK) {
   18cb6:	230f      	movs	r3, #15
   18cb8:	18fb      	adds	r3, r7, r3
   18cba:	781b      	ldrb	r3, [r3, #0]
   18cbc:	2b00      	cmp	r3, #0
   18cbe:	d140      	bne.n	18d42 <dir_remove+0xbe>
		do {
			res = move_window(dp->fs, dp->sect);
   18cc0:	687b      	ldr	r3, [r7, #4]
   18cc2:	681a      	ldr	r2, [r3, #0]
   18cc4:	687b      	ldr	r3, [r7, #4]
   18cc6:	691b      	ldr	r3, [r3, #16]
   18cc8:	210f      	movs	r1, #15
   18cca:	187c      	adds	r4, r7, r1
   18ccc:	0019      	movs	r1, r3
   18cce:	0010      	movs	r0, r2
   18cd0:	4b21      	ldr	r3, [pc, #132]	; (18d58 <dir_remove+0xd4>)
   18cd2:	4798      	blx	r3
   18cd4:	0003      	movs	r3, r0
   18cd6:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) break;
   18cd8:	230f      	movs	r3, #15
   18cda:	18fb      	adds	r3, r7, r3
   18cdc:	781b      	ldrb	r3, [r3, #0]
   18cde:	2b00      	cmp	r3, #0
   18ce0:	d123      	bne.n	18d2a <dir_remove+0xa6>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
   18ce2:	687b      	ldr	r3, [r7, #4]
   18ce4:	695b      	ldr	r3, [r3, #20]
   18ce6:	2220      	movs	r2, #32
   18ce8:	2100      	movs	r1, #0
   18cea:	0018      	movs	r0, r3
   18cec:	4b1b      	ldr	r3, [pc, #108]	; (18d5c <dir_remove+0xd8>)
   18cee:	4798      	blx	r3
			*dp->dir = DDEM;
   18cf0:	687b      	ldr	r3, [r7, #4]
   18cf2:	695b      	ldr	r3, [r3, #20]
   18cf4:	22e5      	movs	r2, #229	; 0xe5
   18cf6:	701a      	strb	r2, [r3, #0]
			dp->fs->wflag = 1;
   18cf8:	687b      	ldr	r3, [r7, #4]
   18cfa:	681b      	ldr	r3, [r3, #0]
   18cfc:	2201      	movs	r2, #1
   18cfe:	711a      	strb	r2, [r3, #4]
			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   18d00:	687b      	ldr	r3, [r7, #4]
   18d02:	88db      	ldrh	r3, [r3, #6]
   18d04:	1e1a      	subs	r2, r3, #0
   18d06:	68bb      	ldr	r3, [r7, #8]
   18d08:	429a      	cmp	r2, r3
   18d0a:	d210      	bcs.n	18d2e <dir_remove+0xaa>
			res = dir_next(dp, 0);		/* Next entry */
   18d0c:	230f      	movs	r3, #15
   18d0e:	18fc      	adds	r4, r7, r3
   18d10:	687b      	ldr	r3, [r7, #4]
   18d12:	2100      	movs	r1, #0
   18d14:	0018      	movs	r0, r3
   18d16:	4b12      	ldr	r3, [pc, #72]	; (18d60 <dir_remove+0xdc>)
   18d18:	4798      	blx	r3
   18d1a:	0003      	movs	r3, r0
   18d1c:	7023      	strb	r3, [r4, #0]
		} while (res == FR_OK);
   18d1e:	230f      	movs	r3, #15
   18d20:	18fb      	adds	r3, r7, r3
   18d22:	781b      	ldrb	r3, [r3, #0]
   18d24:	2b00      	cmp	r3, #0
   18d26:	d0cb      	beq.n	18cc0 <dir_remove+0x3c>
   18d28:	e002      	b.n	18d30 <dir_remove+0xac>
	i = dp->index;	/* SFN index */
	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
	if (res == FR_OK) {
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
   18d2a:	46c0      	nop			; (mov r8, r8)
   18d2c:	e000      	b.n	18d30 <dir_remove+0xac>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
			*dp->dir = DDEM;
			dp->fs->wflag = 1;
			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   18d2e:	46c0      	nop			; (mov r8, r8)
			res = dir_next(dp, 0);		/* Next entry */
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
   18d30:	230f      	movs	r3, #15
   18d32:	18fb      	adds	r3, r7, r3
   18d34:	781b      	ldrb	r3, [r3, #0]
   18d36:	2b04      	cmp	r3, #4
   18d38:	d103      	bne.n	18d42 <dir_remove+0xbe>
   18d3a:	230f      	movs	r3, #15
   18d3c:	18fb      	adds	r3, r7, r3
   18d3e:	2202      	movs	r2, #2
   18d40:	701a      	strb	r2, [r3, #0]
			dp->fs->wflag = 1;
		}
	}
#endif

	return res;
   18d42:	230f      	movs	r3, #15
   18d44:	18fb      	adds	r3, r7, r3
   18d46:	781b      	ldrb	r3, [r3, #0]
}
   18d48:	0018      	movs	r0, r3
   18d4a:	46bd      	mov	sp, r7
   18d4c:	b005      	add	sp, #20
   18d4e:	bd90      	pop	{r4, r7, pc}
   18d50:	0000ffff 	.word	0x0000ffff
   18d54:	00017d75 	.word	0x00017d75
   18d58:	00017555 	.word	0x00017555
   18d5c:	0001740d 	.word	0x0001740d
   18d60:	00017e81 	.word	0x00017e81

00018d64 <create_name>:
static
FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
	DIR* dp,			/* Pointer to the directory object */
	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
)
{
   18d64:	b590      	push	{r4, r7, lr}
   18d66:	b08b      	sub	sp, #44	; 0x2c
   18d68:	af00      	add	r7, sp, #0
   18d6a:	6078      	str	r0, [r7, #4]
   18d6c:	6039      	str	r1, [r7, #0]
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   18d6e:	683b      	ldr	r3, [r7, #0]
   18d70:	681b      	ldr	r3, [r3, #0]
   18d72:	613b      	str	r3, [r7, #16]
   18d74:	e002      	b.n	18d7c <create_name+0x18>
   18d76:	693b      	ldr	r3, [r7, #16]
   18d78:	3301      	adds	r3, #1
   18d7a:	613b      	str	r3, [r7, #16]
   18d7c:	693b      	ldr	r3, [r7, #16]
   18d7e:	781b      	ldrb	r3, [r3, #0]
   18d80:	2b2f      	cmp	r3, #47	; 0x2f
   18d82:	d0f8      	beq.n	18d76 <create_name+0x12>
   18d84:	693b      	ldr	r3, [r7, #16]
   18d86:	781b      	ldrb	r3, [r3, #0]
   18d88:	2b5c      	cmp	r3, #92	; 0x5c
   18d8a:	d0f4      	beq.n	18d76 <create_name+0x12>
	lfn = dp->lfn;
   18d8c:	687b      	ldr	r3, [r7, #4]
   18d8e:	69db      	ldr	r3, [r3, #28]
   18d90:	60fb      	str	r3, [r7, #12]
	si = di = 0;
   18d92:	2300      	movs	r3, #0
   18d94:	617b      	str	r3, [r7, #20]
   18d96:	697b      	ldr	r3, [r7, #20]
   18d98:	61bb      	str	r3, [r7, #24]
	for (;;) {
		w = p[si++];					/* Get a character */
   18d9a:	69bb      	ldr	r3, [r7, #24]
   18d9c:	1c5a      	adds	r2, r3, #1
   18d9e:	61ba      	str	r2, [r7, #24]
   18da0:	693a      	ldr	r2, [r7, #16]
   18da2:	18d3      	adds	r3, r2, r3
   18da4:	781a      	ldrb	r2, [r3, #0]
   18da6:	2324      	movs	r3, #36	; 0x24
   18da8:	18fb      	adds	r3, r7, r3
   18daa:	801a      	strh	r2, [r3, #0]
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   18dac:	2324      	movs	r3, #36	; 0x24
   18dae:	18fb      	adds	r3, r7, r3
   18db0:	881b      	ldrh	r3, [r3, #0]
   18db2:	2b1f      	cmp	r3, #31
   18db4:	d944      	bls.n	18e40 <create_name+0xdc>
   18db6:	2324      	movs	r3, #36	; 0x24
   18db8:	18fb      	adds	r3, r7, r3
   18dba:	881b      	ldrh	r3, [r3, #0]
   18dbc:	2b2f      	cmp	r3, #47	; 0x2f
   18dbe:	d03f      	beq.n	18e40 <create_name+0xdc>
   18dc0:	2324      	movs	r3, #36	; 0x24
   18dc2:	18fb      	adds	r3, r7, r3
   18dc4:	881b      	ldrh	r3, [r3, #0]
   18dc6:	2b5c      	cmp	r3, #92	; 0x5c
   18dc8:	d03a      	beq.n	18e40 <create_name+0xdc>
		if (di >= _MAX_LFN)				/* Reject too long name */
   18dca:	697b      	ldr	r3, [r7, #20]
   18dcc:	2bfe      	cmp	r3, #254	; 0xfe
   18dce:	d901      	bls.n	18dd4 <create_name+0x70>
			return FR_INVALID_NAME;
   18dd0:	2306      	movs	r3, #6
   18dd2:	e1e7      	b.n	191a4 <create_name+0x440>
#if !_LFN_UNICODE
		w &= 0xFF;
   18dd4:	2324      	movs	r3, #36	; 0x24
   18dd6:	18fb      	adds	r3, r7, r3
   18dd8:	2224      	movs	r2, #36	; 0x24
   18dda:	18ba      	adds	r2, r7, r2
   18ddc:	8812      	ldrh	r2, [r2, #0]
   18dde:	21ff      	movs	r1, #255	; 0xff
   18de0:	400a      	ands	r2, r1
   18de2:	801a      	strh	r2, [r3, #0]
			b = (BYTE)p[si++];			/* Get 2nd byte */
			w = (w << 8) + b;			/* Create a DBC */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   18de4:	2324      	movs	r3, #36	; 0x24
   18de6:	18fc      	adds	r4, r7, r3
   18de8:	2324      	movs	r3, #36	; 0x24
   18dea:	18fb      	adds	r3, r7, r3
   18dec:	881b      	ldrh	r3, [r3, #0]
   18dee:	2101      	movs	r1, #1
   18df0:	0018      	movs	r0, r3
   18df2:	4bba      	ldr	r3, [pc, #744]	; (190dc <create_name+0x378>)
   18df4:	4798      	blx	r3
   18df6:	0003      	movs	r3, r0
   18df8:	8023      	strh	r3, [r4, #0]
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   18dfa:	2324      	movs	r3, #36	; 0x24
   18dfc:	18fb      	adds	r3, r7, r3
   18dfe:	881b      	ldrh	r3, [r3, #0]
   18e00:	2b00      	cmp	r3, #0
   18e02:	d101      	bne.n	18e08 <create_name+0xa4>
   18e04:	2306      	movs	r3, #6
   18e06:	e1cd      	b.n	191a4 <create_name+0x440>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
   18e08:	2324      	movs	r3, #36	; 0x24
   18e0a:	18fb      	adds	r3, r7, r3
   18e0c:	881b      	ldrh	r3, [r3, #0]
   18e0e:	2b7f      	cmp	r3, #127	; 0x7f
   18e10:	d80b      	bhi.n	18e2a <create_name+0xc6>
   18e12:	2324      	movs	r3, #36	; 0x24
   18e14:	18fb      	adds	r3, r7, r3
   18e16:	881a      	ldrh	r2, [r3, #0]
   18e18:	4bb1      	ldr	r3, [pc, #708]	; (190e0 <create_name+0x37c>)
   18e1a:	0011      	movs	r1, r2
   18e1c:	0018      	movs	r0, r3
   18e1e:	4bb1      	ldr	r3, [pc, #708]	; (190e4 <create_name+0x380>)
   18e20:	4798      	blx	r3
   18e22:	1e03      	subs	r3, r0, #0
   18e24:	d001      	beq.n	18e2a <create_name+0xc6>
			return FR_INVALID_NAME;
   18e26:	2306      	movs	r3, #6
   18e28:	e1bc      	b.n	191a4 <create_name+0x440>
		lfn[di++] = w;					/* Store the Unicode character */
   18e2a:	697b      	ldr	r3, [r7, #20]
   18e2c:	1c5a      	adds	r2, r3, #1
   18e2e:	617a      	str	r2, [r7, #20]
   18e30:	005b      	lsls	r3, r3, #1
   18e32:	68fa      	ldr	r2, [r7, #12]
   18e34:	18d3      	adds	r3, r2, r3
   18e36:	2224      	movs	r2, #36	; 0x24
   18e38:	18ba      	adds	r2, r7, r2
   18e3a:	8812      	ldrh	r2, [r2, #0]
   18e3c:	801a      	strh	r2, [r3, #0]
	}
   18e3e:	e7ac      	b.n	18d9a <create_name+0x36>
	*path = &p[si];						/* Return pointer to the next segment */
   18e40:	693a      	ldr	r2, [r7, #16]
   18e42:	69bb      	ldr	r3, [r7, #24]
   18e44:	18d2      	adds	r2, r2, r3
   18e46:	683b      	ldr	r3, [r7, #0]
   18e48:	601a      	str	r2, [r3, #0]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   18e4a:	2324      	movs	r3, #36	; 0x24
   18e4c:	18fb      	adds	r3, r7, r3
   18e4e:	881b      	ldrh	r3, [r3, #0]
   18e50:	2b1f      	cmp	r3, #31
   18e52:	d801      	bhi.n	18e58 <create_name+0xf4>
   18e54:	2204      	movs	r2, #4
   18e56:	e000      	b.n	18e5a <create_name+0xf6>
   18e58:	2200      	movs	r2, #0
   18e5a:	2326      	movs	r3, #38	; 0x26
   18e5c:	18fb      	adds	r3, r7, r3
   18e5e:	701a      	strb	r2, [r3, #0]
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Snip off trailing spaces and dots if exist */
   18e60:	e017      	b.n	18e92 <create_name+0x12e>
		w = lfn[di - 1];
   18e62:	697b      	ldr	r3, [r7, #20]
   18e64:	4aa0      	ldr	r2, [pc, #640]	; (190e8 <create_name+0x384>)
   18e66:	4694      	mov	ip, r2
   18e68:	4463      	add	r3, ip
   18e6a:	005b      	lsls	r3, r3, #1
   18e6c:	68fa      	ldr	r2, [r7, #12]
   18e6e:	18d2      	adds	r2, r2, r3
   18e70:	2324      	movs	r3, #36	; 0x24
   18e72:	18fb      	adds	r3, r7, r3
   18e74:	8812      	ldrh	r2, [r2, #0]
   18e76:	801a      	strh	r2, [r3, #0]
		if (w != ' ' && w != '.') break;
   18e78:	2324      	movs	r3, #36	; 0x24
   18e7a:	18fb      	adds	r3, r7, r3
   18e7c:	881b      	ldrh	r3, [r3, #0]
   18e7e:	2b20      	cmp	r3, #32
   18e80:	d004      	beq.n	18e8c <create_name+0x128>
   18e82:	2324      	movs	r3, #36	; 0x24
   18e84:	18fb      	adds	r3, r7, r3
   18e86:	881b      	ldrh	r3, [r3, #0]
   18e88:	2b2e      	cmp	r3, #46	; 0x2e
   18e8a:	d106      	bne.n	18e9a <create_name+0x136>
		di--;
   18e8c:	697b      	ldr	r3, [r7, #20]
   18e8e:	3b01      	subs	r3, #1
   18e90:	617b      	str	r3, [r7, #20]
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Snip off trailing spaces and dots if exist */
   18e92:	697b      	ldr	r3, [r7, #20]
   18e94:	2b00      	cmp	r3, #0
   18e96:	d1e4      	bne.n	18e62 <create_name+0xfe>
   18e98:	e000      	b.n	18e9c <create_name+0x138>
		w = lfn[di - 1];
		if (w != ' ' && w != '.') break;
   18e9a:	46c0      	nop			; (mov r8, r8)
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   18e9c:	697b      	ldr	r3, [r7, #20]
   18e9e:	2b00      	cmp	r3, #0
   18ea0:	d101      	bne.n	18ea6 <create_name+0x142>
   18ea2:	2306      	movs	r3, #6
   18ea4:	e17e      	b.n	191a4 <create_name+0x440>
	lfn[di] = 0;						/* LFN is created */
   18ea6:	697b      	ldr	r3, [r7, #20]
   18ea8:	005b      	lsls	r3, r3, #1
   18eaa:	68fa      	ldr	r2, [r7, #12]
   18eac:	18d3      	adds	r3, r2, r3
   18eae:	2200      	movs	r2, #0
   18eb0:	801a      	strh	r2, [r3, #0]

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
   18eb2:	687b      	ldr	r3, [r7, #4]
   18eb4:	699b      	ldr	r3, [r3, #24]
   18eb6:	220b      	movs	r2, #11
   18eb8:	2120      	movs	r1, #32
   18eba:	0018      	movs	r0, r3
   18ebc:	4b8b      	ldr	r3, [pc, #556]	; (190ec <create_name+0x388>)
   18ebe:	4798      	blx	r3
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   18ec0:	2300      	movs	r3, #0
   18ec2:	61bb      	str	r3, [r7, #24]
   18ec4:	e002      	b.n	18ecc <create_name+0x168>
   18ec6:	69bb      	ldr	r3, [r7, #24]
   18ec8:	3301      	adds	r3, #1
   18eca:	61bb      	str	r3, [r7, #24]
   18ecc:	69bb      	ldr	r3, [r7, #24]
   18ece:	005b      	lsls	r3, r3, #1
   18ed0:	68fa      	ldr	r2, [r7, #12]
   18ed2:	18d3      	adds	r3, r2, r3
   18ed4:	881b      	ldrh	r3, [r3, #0]
   18ed6:	2b20      	cmp	r3, #32
   18ed8:	d0f5      	beq.n	18ec6 <create_name+0x162>
   18eda:	69bb      	ldr	r3, [r7, #24]
   18edc:	005b      	lsls	r3, r3, #1
   18ede:	68fa      	ldr	r2, [r7, #12]
   18ee0:	18d3      	adds	r3, r2, r3
   18ee2:	881b      	ldrh	r3, [r3, #0]
   18ee4:	2b2e      	cmp	r3, #46	; 0x2e
   18ee6:	d0ee      	beq.n	18ec6 <create_name+0x162>
	if (si) cf |= NS_LOSS | NS_LFN;
   18ee8:	69bb      	ldr	r3, [r7, #24]
   18eea:	2b00      	cmp	r3, #0
   18eec:	d00b      	beq.n	18f06 <create_name+0x1a2>
   18eee:	2326      	movs	r3, #38	; 0x26
   18ef0:	18fb      	adds	r3, r7, r3
   18ef2:	2226      	movs	r2, #38	; 0x26
   18ef4:	18ba      	adds	r2, r7, r2
   18ef6:	7812      	ldrb	r2, [r2, #0]
   18ef8:	2103      	movs	r1, #3
   18efa:	430a      	orrs	r2, r1
   18efc:	701a      	strb	r2, [r3, #0]
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   18efe:	e002      	b.n	18f06 <create_name+0x1a2>
   18f00:	697b      	ldr	r3, [r7, #20]
   18f02:	3b01      	subs	r3, #1
   18f04:	617b      	str	r3, [r7, #20]
   18f06:	697b      	ldr	r3, [r7, #20]
   18f08:	2b00      	cmp	r3, #0
   18f0a:	d009      	beq.n	18f20 <create_name+0x1bc>
   18f0c:	697b      	ldr	r3, [r7, #20]
   18f0e:	4a76      	ldr	r2, [pc, #472]	; (190e8 <create_name+0x384>)
   18f10:	4694      	mov	ip, r2
   18f12:	4463      	add	r3, ip
   18f14:	005b      	lsls	r3, r3, #1
   18f16:	68fa      	ldr	r2, [r7, #12]
   18f18:	18d3      	adds	r3, r2, r3
   18f1a:	881b      	ldrh	r3, [r3, #0]
   18f1c:	2b2e      	cmp	r3, #46	; 0x2e
   18f1e:	d1ef      	bne.n	18f00 <create_name+0x19c>

	b = i = 0; ni = 8;
   18f20:	2300      	movs	r3, #0
   18f22:	623b      	str	r3, [r7, #32]
   18f24:	2327      	movs	r3, #39	; 0x27
   18f26:	18fb      	adds	r3, r7, r3
   18f28:	2200      	movs	r2, #0
   18f2a:	701a      	strb	r2, [r3, #0]
   18f2c:	2308      	movs	r3, #8
   18f2e:	61fb      	str	r3, [r7, #28]
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
   18f30:	69bb      	ldr	r3, [r7, #24]
   18f32:	1c5a      	adds	r2, r3, #1
   18f34:	61ba      	str	r2, [r7, #24]
   18f36:	005b      	lsls	r3, r3, #1
   18f38:	68fa      	ldr	r2, [r7, #12]
   18f3a:	18d2      	adds	r2, r2, r3
   18f3c:	2324      	movs	r3, #36	; 0x24
   18f3e:	18fb      	adds	r3, r7, r3
   18f40:	8812      	ldrh	r2, [r2, #0]
   18f42:	801a      	strh	r2, [r3, #0]
		if (!w) break;					/* Break on end of the LFN */
   18f44:	2324      	movs	r3, #36	; 0x24
   18f46:	18fb      	adds	r3, r7, r3
   18f48:	881b      	ldrh	r3, [r3, #0]
   18f4a:	2b00      	cmp	r3, #0
   18f4c:	d100      	bne.n	18f50 <create_name+0x1ec>
   18f4e:	e0c3      	b.n	190d8 <create_name+0x374>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   18f50:	2324      	movs	r3, #36	; 0x24
   18f52:	18fb      	adds	r3, r7, r3
   18f54:	881b      	ldrh	r3, [r3, #0]
   18f56:	2b20      	cmp	r3, #32
   18f58:	d008      	beq.n	18f6c <create_name+0x208>
   18f5a:	2324      	movs	r3, #36	; 0x24
   18f5c:	18fb      	adds	r3, r7, r3
   18f5e:	881b      	ldrh	r3, [r3, #0]
   18f60:	2b2e      	cmp	r3, #46	; 0x2e
   18f62:	d10c      	bne.n	18f7e <create_name+0x21a>
   18f64:	69ba      	ldr	r2, [r7, #24]
   18f66:	697b      	ldr	r3, [r7, #20]
   18f68:	429a      	cmp	r2, r3
   18f6a:	d008      	beq.n	18f7e <create_name+0x21a>
			cf |= NS_LOSS | NS_LFN; continue;
   18f6c:	2326      	movs	r3, #38	; 0x26
   18f6e:	18fb      	adds	r3, r7, r3
   18f70:	2226      	movs	r2, #38	; 0x26
   18f72:	18ba      	adds	r2, r7, r2
   18f74:	7812      	ldrb	r2, [r2, #0]
   18f76:	2103      	movs	r1, #3
   18f78:	430a      	orrs	r2, r1
   18f7a:	701a      	strb	r2, [r3, #0]
   18f7c:	e0ab      	b.n	190d6 <create_name+0x372>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
   18f7e:	6a3a      	ldr	r2, [r7, #32]
   18f80:	69fb      	ldr	r3, [r7, #28]
   18f82:	429a      	cmp	r2, r3
   18f84:	d203      	bcs.n	18f8e <create_name+0x22a>
   18f86:	69ba      	ldr	r2, [r7, #24]
   18f88:	697b      	ldr	r3, [r7, #20]
   18f8a:	429a      	cmp	r2, r3
   18f8c:	d12a      	bne.n	18fe4 <create_name+0x280>
			if (ni == 11) {				/* Long extension */
   18f8e:	69fb      	ldr	r3, [r7, #28]
   18f90:	2b0b      	cmp	r3, #11
   18f92:	d108      	bne.n	18fa6 <create_name+0x242>
				cf |= NS_LOSS | NS_LFN; break;
   18f94:	2326      	movs	r3, #38	; 0x26
   18f96:	18fb      	adds	r3, r7, r3
   18f98:	2226      	movs	r2, #38	; 0x26
   18f9a:	18ba      	adds	r2, r7, r2
   18f9c:	7812      	ldrb	r2, [r2, #0]
   18f9e:	2103      	movs	r1, #3
   18fa0:	430a      	orrs	r2, r1
   18fa2:	701a      	strb	r2, [r3, #0]
   18fa4:	e0a9      	b.n	190fa <create_name+0x396>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   18fa6:	69ba      	ldr	r2, [r7, #24]
   18fa8:	697b      	ldr	r3, [r7, #20]
   18faa:	429a      	cmp	r2, r3
   18fac:	d007      	beq.n	18fbe <create_name+0x25a>
   18fae:	2326      	movs	r3, #38	; 0x26
   18fb0:	18fb      	adds	r3, r7, r3
   18fb2:	2226      	movs	r2, #38	; 0x26
   18fb4:	18ba      	adds	r2, r7, r2
   18fb6:	7812      	ldrb	r2, [r2, #0]
   18fb8:	2103      	movs	r1, #3
   18fba:	430a      	orrs	r2, r1
   18fbc:	701a      	strb	r2, [r3, #0]
			if (si > di) break;			/* No extension */
   18fbe:	69ba      	ldr	r2, [r7, #24]
   18fc0:	697b      	ldr	r3, [r7, #20]
   18fc2:	429a      	cmp	r2, r3
   18fc4:	d900      	bls.n	18fc8 <create_name+0x264>
   18fc6:	e097      	b.n	190f8 <create_name+0x394>
			si = di; i = 8; ni = 11;	/* Enter extension section */
   18fc8:	697b      	ldr	r3, [r7, #20]
   18fca:	61bb      	str	r3, [r7, #24]
   18fcc:	2308      	movs	r3, #8
   18fce:	623b      	str	r3, [r7, #32]
   18fd0:	230b      	movs	r3, #11
   18fd2:	61fb      	str	r3, [r7, #28]
			b <<= 2; continue;
   18fd4:	2327      	movs	r3, #39	; 0x27
   18fd6:	18fb      	adds	r3, r7, r3
   18fd8:	2227      	movs	r2, #39	; 0x27
   18fda:	18ba      	adds	r2, r7, r2
   18fdc:	7812      	ldrb	r2, [r2, #0]
   18fde:	0092      	lsls	r2, r2, #2
   18fe0:	701a      	strb	r2, [r3, #0]
   18fe2:	e078      	b.n	190d6 <create_name+0x372>
		}

		if (w >= 0x80) {				/* Non ASCII character */
   18fe4:	2324      	movs	r3, #36	; 0x24
   18fe6:	18fb      	adds	r3, r7, r3
   18fe8:	881b      	ldrh	r3, [r3, #0]
   18fea:	2b7f      	cmp	r3, #127	; 0x7f
   18fec:	d920      	bls.n	19030 <create_name+0x2cc>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   18fee:	2324      	movs	r3, #36	; 0x24
   18ff0:	18fc      	adds	r4, r7, r3
   18ff2:	2324      	movs	r3, #36	; 0x24
   18ff4:	18fb      	adds	r3, r7, r3
   18ff6:	881b      	ldrh	r3, [r3, #0]
   18ff8:	2100      	movs	r1, #0
   18ffa:	0018      	movs	r0, r3
   18ffc:	4b37      	ldr	r3, [pc, #220]	; (190dc <create_name+0x378>)
   18ffe:	4798      	blx	r3
   19000:	0003      	movs	r3, r0
   19002:	8023      	strh	r3, [r4, #0]
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
   19004:	2324      	movs	r3, #36	; 0x24
   19006:	18fb      	adds	r3, r7, r3
   19008:	881b      	ldrh	r3, [r3, #0]
   1900a:	2b00      	cmp	r3, #0
   1900c:	d008      	beq.n	19020 <create_name+0x2bc>
   1900e:	2324      	movs	r3, #36	; 0x24
   19010:	18fb      	adds	r3, r7, r3
   19012:	881b      	ldrh	r3, [r3, #0]
   19014:	3b80      	subs	r3, #128	; 0x80
   19016:	4a36      	ldr	r2, [pc, #216]	; (190f0 <create_name+0x38c>)
   19018:	5cd2      	ldrb	r2, [r2, r3]
   1901a:	2324      	movs	r3, #36	; 0x24
   1901c:	18fb      	adds	r3, r7, r3
   1901e:	801a      	strh	r2, [r3, #0]
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
   19020:	2326      	movs	r3, #38	; 0x26
   19022:	18fb      	adds	r3, r7, r3
   19024:	2226      	movs	r2, #38	; 0x26
   19026:	18ba      	adds	r2, r7, r2
   19028:	7812      	ldrb	r2, [r2, #0]
   1902a:	2102      	movs	r1, #2
   1902c:	430a      	orrs	r2, r1
   1902e:	701a      	strb	r2, [r3, #0]
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
   19030:	2324      	movs	r3, #36	; 0x24
   19032:	18fb      	adds	r3, r7, r3
   19034:	881b      	ldrh	r3, [r3, #0]
   19036:	2b00      	cmp	r3, #0
   19038:	d009      	beq.n	1904e <create_name+0x2ea>
   1903a:	2324      	movs	r3, #36	; 0x24
   1903c:	18fb      	adds	r3, r7, r3
   1903e:	881a      	ldrh	r2, [r3, #0]
   19040:	4b2c      	ldr	r3, [pc, #176]	; (190f4 <create_name+0x390>)
   19042:	0011      	movs	r1, r2
   19044:	0018      	movs	r0, r3
   19046:	4b27      	ldr	r3, [pc, #156]	; (190e4 <create_name+0x380>)
   19048:	4798      	blx	r3
   1904a:	1e03      	subs	r3, r0, #0
   1904c:	d00c      	beq.n	19068 <create_name+0x304>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   1904e:	2324      	movs	r3, #36	; 0x24
   19050:	18fb      	adds	r3, r7, r3
   19052:	225f      	movs	r2, #95	; 0x5f
   19054:	801a      	strh	r2, [r3, #0]
   19056:	2326      	movs	r3, #38	; 0x26
   19058:	18fb      	adds	r3, r7, r3
   1905a:	2226      	movs	r2, #38	; 0x26
   1905c:	18ba      	adds	r2, r7, r2
   1905e:	7812      	ldrb	r2, [r2, #0]
   19060:	2103      	movs	r1, #3
   19062:	430a      	orrs	r2, r1
   19064:	701a      	strb	r2, [r3, #0]
   19066:	e02b      	b.n	190c0 <create_name+0x35c>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
   19068:	2324      	movs	r3, #36	; 0x24
   1906a:	18fb      	adds	r3, r7, r3
   1906c:	881b      	ldrh	r3, [r3, #0]
   1906e:	2b40      	cmp	r3, #64	; 0x40
   19070:	d90d      	bls.n	1908e <create_name+0x32a>
   19072:	2324      	movs	r3, #36	; 0x24
   19074:	18fb      	adds	r3, r7, r3
   19076:	881b      	ldrh	r3, [r3, #0]
   19078:	2b5a      	cmp	r3, #90	; 0x5a
   1907a:	d808      	bhi.n	1908e <create_name+0x32a>
					b |= 2;
   1907c:	2327      	movs	r3, #39	; 0x27
   1907e:	18fb      	adds	r3, r7, r3
   19080:	2227      	movs	r2, #39	; 0x27
   19082:	18ba      	adds	r2, r7, r2
   19084:	7812      	ldrb	r2, [r2, #0]
   19086:	2102      	movs	r1, #2
   19088:	430a      	orrs	r2, r1
   1908a:	701a      	strb	r2, [r3, #0]
   1908c:	e018      	b.n	190c0 <create_name+0x35c>
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
   1908e:	2324      	movs	r3, #36	; 0x24
   19090:	18fb      	adds	r3, r7, r3
   19092:	881b      	ldrh	r3, [r3, #0]
   19094:	2b60      	cmp	r3, #96	; 0x60
   19096:	d913      	bls.n	190c0 <create_name+0x35c>
   19098:	2324      	movs	r3, #36	; 0x24
   1909a:	18fb      	adds	r3, r7, r3
   1909c:	881b      	ldrh	r3, [r3, #0]
   1909e:	2b7a      	cmp	r3, #122	; 0x7a
   190a0:	d80e      	bhi.n	190c0 <create_name+0x35c>
						b |= 1; w -= 0x20;
   190a2:	2327      	movs	r3, #39	; 0x27
   190a4:	18fb      	adds	r3, r7, r3
   190a6:	2227      	movs	r2, #39	; 0x27
   190a8:	18ba      	adds	r2, r7, r2
   190aa:	7812      	ldrb	r2, [r2, #0]
   190ac:	2101      	movs	r1, #1
   190ae:	430a      	orrs	r2, r1
   190b0:	701a      	strb	r2, [r3, #0]
   190b2:	2324      	movs	r3, #36	; 0x24
   190b4:	18fb      	adds	r3, r7, r3
   190b6:	2224      	movs	r2, #36	; 0x24
   190b8:	18ba      	adds	r2, r7, r2
   190ba:	8812      	ldrh	r2, [r2, #0]
   190bc:	3a20      	subs	r2, #32
   190be:	801a      	strh	r2, [r3, #0]
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
   190c0:	687b      	ldr	r3, [r7, #4]
   190c2:	699a      	ldr	r2, [r3, #24]
   190c4:	6a3b      	ldr	r3, [r7, #32]
   190c6:	1c59      	adds	r1, r3, #1
   190c8:	6239      	str	r1, [r7, #32]
   190ca:	18d3      	adds	r3, r2, r3
   190cc:	2224      	movs	r2, #36	; 0x24
   190ce:	18ba      	adds	r2, r7, r2
   190d0:	8812      	ldrh	r2, [r2, #0]
   190d2:	b2d2      	uxtb	r2, r2
   190d4:	701a      	strb	r2, [r3, #0]
	}
   190d6:	e72b      	b.n	18f30 <create_name+0x1cc>
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
		if (!w) break;					/* Break on end of the LFN */
   190d8:	46c0      	nop			; (mov r8, r8)
   190da:	e00e      	b.n	190fa <create_name+0x396>
   190dc:	0001ad59 	.word	0x0001ad59
   190e0:	000211f4 	.word	0x000211f4
   190e4:	00017489 	.word	0x00017489
   190e8:	7fffffff 	.word	0x7fffffff
   190ec:	0001740d 	.word	0x0001740d
   190f0:	00021164 	.word	0x00021164
   190f4:	00021200 	.word	0x00021200
		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
   190f8:	46c0      	nop			; (mov r8, r8)
			}
		}
		dp->fn[i++] = (BYTE)w;
	}

	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
   190fa:	687b      	ldr	r3, [r7, #4]
   190fc:	699b      	ldr	r3, [r3, #24]
   190fe:	781b      	ldrb	r3, [r3, #0]
   19100:	2be5      	cmp	r3, #229	; 0xe5
   19102:	d103      	bne.n	1910c <create_name+0x3a8>
   19104:	687b      	ldr	r3, [r7, #4]
   19106:	699b      	ldr	r3, [r3, #24]
   19108:	2205      	movs	r2, #5
   1910a:	701a      	strb	r2, [r3, #0]

	if (ni == 8) b <<= 2;
   1910c:	69fb      	ldr	r3, [r7, #28]
   1910e:	2b08      	cmp	r3, #8
   19110:	d106      	bne.n	19120 <create_name+0x3bc>
   19112:	2327      	movs	r3, #39	; 0x27
   19114:	18fb      	adds	r3, r7, r3
   19116:	2227      	movs	r2, #39	; 0x27
   19118:	18ba      	adds	r2, r7, r2
   1911a:	7812      	ldrb	r2, [r2, #0]
   1911c:	0092      	lsls	r2, r2, #2
   1911e:	701a      	strb	r2, [r3, #0]
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   19120:	2327      	movs	r3, #39	; 0x27
   19122:	18fb      	adds	r3, r7, r3
   19124:	781b      	ldrb	r3, [r3, #0]
   19126:	220c      	movs	r2, #12
   19128:	4013      	ands	r3, r2
   1912a:	2b0c      	cmp	r3, #12
   1912c:	d006      	beq.n	1913c <create_name+0x3d8>
   1912e:	2327      	movs	r3, #39	; 0x27
   19130:	18fb      	adds	r3, r7, r3
   19132:	781b      	ldrb	r3, [r3, #0]
   19134:	2203      	movs	r2, #3
   19136:	4013      	ands	r3, r2
   19138:	2b03      	cmp	r3, #3
   1913a:	d107      	bne.n	1914c <create_name+0x3e8>
		cf |= NS_LFN;
   1913c:	2326      	movs	r3, #38	; 0x26
   1913e:	18fb      	adds	r3, r7, r3
   19140:	2226      	movs	r2, #38	; 0x26
   19142:	18ba      	adds	r2, r7, r2
   19144:	7812      	ldrb	r2, [r2, #0]
   19146:	2102      	movs	r1, #2
   19148:	430a      	orrs	r2, r1
   1914a:	701a      	strb	r2, [r3, #0]
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
   1914c:	2326      	movs	r3, #38	; 0x26
   1914e:	18fb      	adds	r3, r7, r3
   19150:	781b      	ldrb	r3, [r3, #0]
   19152:	2202      	movs	r2, #2
   19154:	4013      	ands	r3, r2
   19156:	d11d      	bne.n	19194 <create_name+0x430>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   19158:	2327      	movs	r3, #39	; 0x27
   1915a:	18fb      	adds	r3, r7, r3
   1915c:	781b      	ldrb	r3, [r3, #0]
   1915e:	2203      	movs	r2, #3
   19160:	4013      	ands	r3, r2
   19162:	2b01      	cmp	r3, #1
   19164:	d107      	bne.n	19176 <create_name+0x412>
   19166:	2326      	movs	r3, #38	; 0x26
   19168:	18fb      	adds	r3, r7, r3
   1916a:	2226      	movs	r2, #38	; 0x26
   1916c:	18ba      	adds	r2, r7, r2
   1916e:	7812      	ldrb	r2, [r2, #0]
   19170:	2110      	movs	r1, #16
   19172:	430a      	orrs	r2, r1
   19174:	701a      	strb	r2, [r3, #0]
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   19176:	2327      	movs	r3, #39	; 0x27
   19178:	18fb      	adds	r3, r7, r3
   1917a:	781b      	ldrb	r3, [r3, #0]
   1917c:	220c      	movs	r2, #12
   1917e:	4013      	ands	r3, r2
   19180:	2b04      	cmp	r3, #4
   19182:	d107      	bne.n	19194 <create_name+0x430>
   19184:	2326      	movs	r3, #38	; 0x26
   19186:	18fb      	adds	r3, r7, r3
   19188:	2226      	movs	r2, #38	; 0x26
   1918a:	18ba      	adds	r2, r7, r2
   1918c:	7812      	ldrb	r2, [r2, #0]
   1918e:	2108      	movs	r1, #8
   19190:	430a      	orrs	r2, r1
   19192:	701a      	strb	r2, [r3, #0]
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
   19194:	687b      	ldr	r3, [r7, #4]
   19196:	699b      	ldr	r3, [r3, #24]
   19198:	330b      	adds	r3, #11
   1919a:	2226      	movs	r2, #38	; 0x26
   1919c:	18ba      	adds	r2, r7, r2
   1919e:	7812      	ldrb	r2, [r2, #0]
   191a0:	701a      	strb	r2, [r3, #0]

	return FR_OK;
   191a2:	2300      	movs	r3, #0

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */

	return FR_OK;
#endif
}
   191a4:	0018      	movs	r0, r3
   191a6:	46bd      	mov	sp, r7
   191a8:	b00b      	add	sp, #44	; 0x2c
   191aa:	bd90      	pop	{r4, r7, pc}

000191ac <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
   191ac:	b590      	push	{r4, r7, lr}
   191ae:	b085      	sub	sp, #20
   191b0:	af00      	add	r7, sp, #0
   191b2:	6078      	str	r0, [r7, #4]
   191b4:	6039      	str	r1, [r7, #0]
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
   191b6:	683b      	ldr	r3, [r7, #0]
   191b8:	781b      	ldrb	r3, [r3, #0]
   191ba:	2b2f      	cmp	r3, #47	; 0x2f
   191bc:	d003      	beq.n	191c6 <follow_path+0x1a>
   191be:	683b      	ldr	r3, [r7, #0]
   191c0:	781b      	ldrb	r3, [r3, #0]
   191c2:	2b5c      	cmp	r3, #92	; 0x5c
   191c4:	d102      	bne.n	191cc <follow_path+0x20>
		path++;
   191c6:	683b      	ldr	r3, [r7, #0]
   191c8:	3301      	adds	r3, #1
   191ca:	603b      	str	r3, [r7, #0]
	dp->sclust = 0;							/* Always start from the root directory */
   191cc:	687b      	ldr	r3, [r7, #4]
   191ce:	2200      	movs	r2, #0
   191d0:	609a      	str	r2, [r3, #8]
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
   191d2:	683b      	ldr	r3, [r7, #0]
   191d4:	781b      	ldrb	r3, [r3, #0]
   191d6:	2b1f      	cmp	r3, #31
   191d8:	d80c      	bhi.n	191f4 <follow_path+0x48>
		res = dir_sdi(dp, 0);
   191da:	230f      	movs	r3, #15
   191dc:	18fc      	adds	r4, r7, r3
   191de:	687b      	ldr	r3, [r7, #4]
   191e0:	2100      	movs	r1, #0
   191e2:	0018      	movs	r0, r3
   191e4:	4b32      	ldr	r3, [pc, #200]	; (192b0 <follow_path+0x104>)
   191e6:	4798      	blx	r3
   191e8:	0003      	movs	r3, r0
   191ea:	7023      	strb	r3, [r4, #0]
		dp->dir = 0;
   191ec:	687b      	ldr	r3, [r7, #4]
   191ee:	2200      	movs	r2, #0
   191f0:	615a      	str	r2, [r3, #20]
   191f2:	e056      	b.n	192a2 <follow_path+0xf6>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
   191f4:	230f      	movs	r3, #15
   191f6:	18fc      	adds	r4, r7, r3
   191f8:	003a      	movs	r2, r7
   191fa:	687b      	ldr	r3, [r7, #4]
   191fc:	0011      	movs	r1, r2
   191fe:	0018      	movs	r0, r3
   19200:	4b2c      	ldr	r3, [pc, #176]	; (192b4 <follow_path+0x108>)
   19202:	4798      	blx	r3
   19204:	0003      	movs	r3, r0
   19206:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) break;
   19208:	230f      	movs	r3, #15
   1920a:	18fb      	adds	r3, r7, r3
   1920c:	781b      	ldrb	r3, [r3, #0]
   1920e:	2b00      	cmp	r3, #0
   19210:	d142      	bne.n	19298 <follow_path+0xec>
			res = dir_find(dp);				/* Find an object with the sagment name */
   19212:	230f      	movs	r3, #15
   19214:	18fc      	adds	r4, r7, r3
   19216:	687b      	ldr	r3, [r7, #4]
   19218:	0018      	movs	r0, r3
   1921a:	4b27      	ldr	r3, [pc, #156]	; (192b8 <follow_path+0x10c>)
   1921c:	4798      	blx	r3
   1921e:	0003      	movs	r3, r0
   19220:	7023      	strb	r3, [r4, #0]
			ns = dp->fn[NSFLAG];
   19222:	687b      	ldr	r3, [r7, #4]
   19224:	699a      	ldr	r2, [r3, #24]
   19226:	230e      	movs	r3, #14
   19228:	18fb      	adds	r3, r7, r3
   1922a:	7ad2      	ldrb	r2, [r2, #11]
   1922c:	701a      	strb	r2, [r3, #0]
			if (res != FR_OK) {				/* Failed to find the object */
   1922e:	230f      	movs	r3, #15
   19230:	18fb      	adds	r3, r7, r3
   19232:	781b      	ldrb	r3, [r3, #0]
   19234:	2b00      	cmp	r3, #0
   19236:	d00f      	beq.n	19258 <follow_path+0xac>
				if (res == FR_NO_FILE) {	/* Object is not found */
   19238:	230f      	movs	r3, #15
   1923a:	18fb      	adds	r3, r7, r3
   1923c:	781b      	ldrb	r3, [r3, #0]
   1923e:	2b04      	cmp	r3, #4
   19240:	d12c      	bne.n	1929c <follow_path+0xf0>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
   19242:	230e      	movs	r3, #14
   19244:	18fb      	adds	r3, r7, r3
   19246:	781b      	ldrb	r3, [r3, #0]
   19248:	2204      	movs	r2, #4
   1924a:	4013      	ands	r3, r2
   1924c:	d126      	bne.n	1929c <follow_path+0xf0>
   1924e:	230f      	movs	r3, #15
   19250:	18fb      	adds	r3, r7, r3
   19252:	2205      	movs	r2, #5
   19254:	701a      	strb	r2, [r3, #0]
					}
				}
				break;
   19256:	e021      	b.n	1929c <follow_path+0xf0>
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
   19258:	230e      	movs	r3, #14
   1925a:	18fb      	adds	r3, r7, r3
   1925c:	781b      	ldrb	r3, [r3, #0]
   1925e:	2204      	movs	r2, #4
   19260:	4013      	ands	r3, r2
   19262:	d11d      	bne.n	192a0 <follow_path+0xf4>
			dir = dp->dir;						/* Follow the sub-directory */
   19264:	687b      	ldr	r3, [r7, #4]
   19266:	695b      	ldr	r3, [r3, #20]
   19268:	60bb      	str	r3, [r7, #8]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
   1926a:	68bb      	ldr	r3, [r7, #8]
   1926c:	330b      	adds	r3, #11
   1926e:	781b      	ldrb	r3, [r3, #0]
   19270:	001a      	movs	r2, r3
   19272:	2310      	movs	r3, #16
   19274:	4013      	ands	r3, r2
   19276:	d104      	bne.n	19282 <follow_path+0xd6>
				res = FR_NO_PATH; break;
   19278:	230f      	movs	r3, #15
   1927a:	18fb      	adds	r3, r7, r3
   1927c:	2205      	movs	r2, #5
   1927e:	701a      	strb	r2, [r3, #0]
   19280:	e00f      	b.n	192a2 <follow_path+0xf6>
			}
			dp->sclust = ld_clust(dp->fs, dir);
   19282:	687b      	ldr	r3, [r7, #4]
   19284:	681b      	ldr	r3, [r3, #0]
   19286:	68ba      	ldr	r2, [r7, #8]
   19288:	0011      	movs	r1, r2
   1928a:	0018      	movs	r0, r3
   1928c:	4b0b      	ldr	r3, [pc, #44]	; (192bc <follow_path+0x110>)
   1928e:	4798      	blx	r3
   19290:	0002      	movs	r2, r0
   19292:	687b      	ldr	r3, [r7, #4]
   19294:	609a      	str	r2, [r3, #8]
		}
   19296:	e7ad      	b.n	191f4 <follow_path+0x48>
		res = dir_sdi(dp, 0);
		dp->dir = 0;
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
   19298:	46c0      	nop			; (mov r8, r8)
   1929a:	e002      	b.n	192a2 <follow_path+0xf6>
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
					}
				}
				break;
   1929c:	46c0      	nop			; (mov r8, r8)
   1929e:	e000      	b.n	192a2 <follow_path+0xf6>
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
   192a0:	46c0      	nop			; (mov r8, r8)
			}
			dp->sclust = ld_clust(dp->fs, dir);
		}
	}

	return res;
   192a2:	230f      	movs	r3, #15
   192a4:	18fb      	adds	r3, r7, r3
   192a6:	781b      	ldrb	r3, [r3, #0]
}
   192a8:	0018      	movs	r0, r3
   192aa:	46bd      	mov	sp, r7
   192ac:	b005      	add	sp, #20
   192ae:	bd90      	pop	{r4, r7, pc}
   192b0:	00017d75 	.word	0x00017d75
   192b4:	00018d65 	.word	0x00018d65
   192b8:	00018651 	.word	0x00018651
   192bc:	000180f9 	.word	0x000180f9

000192c0 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
   192c0:	b580      	push	{r7, lr}
   192c2:	b086      	sub	sp, #24
   192c4:	af00      	add	r7, sp, #0
   192c6:	6078      	str	r0, [r7, #4]
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
   192c8:	2301      	movs	r3, #1
   192ca:	425b      	negs	r3, r3
   192cc:	613b      	str	r3, [r7, #16]
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
   192ce:	687b      	ldr	r3, [r7, #4]
   192d0:	681b      	ldr	r3, [r3, #0]
   192d2:	2b00      	cmp	r3, #0
   192d4:	d031      	beq.n	1933a <get_ldnumber+0x7a>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
   192d6:	687b      	ldr	r3, [r7, #4]
   192d8:	681b      	ldr	r3, [r3, #0]
   192da:	617b      	str	r3, [r7, #20]
   192dc:	e002      	b.n	192e4 <get_ldnumber+0x24>
   192de:	697b      	ldr	r3, [r7, #20]
   192e0:	3301      	adds	r3, #1
   192e2:	617b      	str	r3, [r7, #20]
   192e4:	697b      	ldr	r3, [r7, #20]
   192e6:	781b      	ldrb	r3, [r3, #0]
   192e8:	2b1f      	cmp	r3, #31
   192ea:	d903      	bls.n	192f4 <get_ldnumber+0x34>
   192ec:	697b      	ldr	r3, [r7, #20]
   192ee:	781b      	ldrb	r3, [r3, #0]
   192f0:	2b3a      	cmp	r3, #58	; 0x3a
   192f2:	d1f4      	bne.n	192de <get_ldnumber+0x1e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
   192f4:	697b      	ldr	r3, [r7, #20]
   192f6:	781b      	ldrb	r3, [r3, #0]
   192f8:	2b3a      	cmp	r3, #58	; 0x3a
   192fa:	d11c      	bne.n	19336 <get_ldnumber+0x76>
			tp = *path;
   192fc:	687b      	ldr	r3, [r7, #4]
   192fe:	681b      	ldr	r3, [r3, #0]
   19300:	60fb      	str	r3, [r7, #12]
			i = *tp++ - '0'; 
   19302:	68fb      	ldr	r3, [r7, #12]
   19304:	1c5a      	adds	r2, r3, #1
   19306:	60fa      	str	r2, [r7, #12]
   19308:	781b      	ldrb	r3, [r3, #0]
   1930a:	3b30      	subs	r3, #48	; 0x30
   1930c:	60bb      	str	r3, [r7, #8]
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
   1930e:	68bb      	ldr	r3, [r7, #8]
   19310:	2b09      	cmp	r3, #9
   19312:	d80e      	bhi.n	19332 <get_ldnumber+0x72>
   19314:	68fa      	ldr	r2, [r7, #12]
   19316:	697b      	ldr	r3, [r7, #20]
   19318:	429a      	cmp	r2, r3
   1931a:	d10a      	bne.n	19332 <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   1931c:	68bb      	ldr	r3, [r7, #8]
   1931e:	2b07      	cmp	r3, #7
   19320:	d807      	bhi.n	19332 <get_ldnumber+0x72>
					vol = (int)i;
   19322:	68bb      	ldr	r3, [r7, #8]
   19324:	613b      	str	r3, [r7, #16]
					*path = ++tt;
   19326:	697b      	ldr	r3, [r7, #20]
   19328:	3301      	adds	r3, #1
   1932a:	617b      	str	r3, [r7, #20]
   1932c:	687b      	ldr	r3, [r7, #4]
   1932e:	697a      	ldr	r2, [r7, #20]
   19330:	601a      	str	r2, [r3, #0]
					vol = (int)i;
					*path = tt;
				}
			}
#endif
			return vol;
   19332:	693b      	ldr	r3, [r7, #16]
   19334:	e002      	b.n	1933c <get_ldnumber+0x7c>
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
   19336:	2300      	movs	r3, #0
   19338:	613b      	str	r3, [r7, #16]
#endif
	}
	return vol;
   1933a:	693b      	ldr	r3, [r7, #16]
}
   1933c:	0018      	movs	r0, r3
   1933e:	46bd      	mov	sp, r7
   19340:	b006      	add	sp, #24
   19342:	bd80      	pop	{r7, pc}

00019344 <check_fs>:
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
   19344:	b580      	push	{r7, lr}
   19346:	b082      	sub	sp, #8
   19348:	af00      	add	r7, sp, #0
   1934a:	6078      	str	r0, [r7, #4]
   1934c:	6039      	str	r1, [r7, #0]
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
   1934e:	687b      	ldr	r3, [r7, #4]
   19350:	2200      	movs	r2, #0
   19352:	711a      	strb	r2, [r3, #4]
   19354:	687b      	ldr	r3, [r7, #4]
   19356:	2201      	movs	r2, #1
   19358:	4252      	negs	r2, r2
   1935a:	62da      	str	r2, [r3, #44]	; 0x2c
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
   1935c:	683a      	ldr	r2, [r7, #0]
   1935e:	687b      	ldr	r3, [r7, #4]
   19360:	0011      	movs	r1, r2
   19362:	0018      	movs	r0, r3
   19364:	4b2a      	ldr	r3, [pc, #168]	; (19410 <check_fs+0xcc>)
   19366:	4798      	blx	r3
   19368:	1e03      	subs	r3, r0, #0
   1936a:	d001      	beq.n	19370 <check_fs+0x2c>
		return 3;
   1936c:	2303      	movs	r3, #3
   1936e:	e04b      	b.n	19408 <check_fs+0xc4>

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
   19370:	687b      	ldr	r3, [r7, #4]
   19372:	4a28      	ldr	r2, [pc, #160]	; (19414 <check_fs+0xd0>)
   19374:	4694      	mov	ip, r2
   19376:	4463      	add	r3, ip
   19378:	3301      	adds	r3, #1
   1937a:	781b      	ldrb	r3, [r3, #0]
   1937c:	021b      	lsls	r3, r3, #8
   1937e:	b21a      	sxth	r2, r3
   19380:	687b      	ldr	r3, [r7, #4]
   19382:	4924      	ldr	r1, [pc, #144]	; (19414 <check_fs+0xd0>)
   19384:	5c5b      	ldrb	r3, [r3, r1]
   19386:	b21b      	sxth	r3, r3
   19388:	4313      	orrs	r3, r2
   1938a:	b21b      	sxth	r3, r3
   1938c:	4a22      	ldr	r2, [pc, #136]	; (19418 <check_fs+0xd4>)
   1938e:	4293      	cmp	r3, r2
   19390:	d001      	beq.n	19396 <check_fs+0x52>
		return 2;
   19392:	2302      	movs	r3, #2
   19394:	e038      	b.n	19408 <check_fs+0xc4>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
   19396:	687b      	ldr	r3, [r7, #4]
   19398:	3366      	adds	r3, #102	; 0x66
   1939a:	3303      	adds	r3, #3
   1939c:	781b      	ldrb	r3, [r3, #0]
   1939e:	061a      	lsls	r2, r3, #24
   193a0:	687b      	ldr	r3, [r7, #4]
   193a2:	3366      	adds	r3, #102	; 0x66
   193a4:	3302      	adds	r3, #2
   193a6:	781b      	ldrb	r3, [r3, #0]
   193a8:	041b      	lsls	r3, r3, #16
   193aa:	4313      	orrs	r3, r2
   193ac:	687a      	ldr	r2, [r7, #4]
   193ae:	3266      	adds	r2, #102	; 0x66
   193b0:	3201      	adds	r2, #1
   193b2:	7812      	ldrb	r2, [r2, #0]
   193b4:	0212      	lsls	r2, r2, #8
   193b6:	4313      	orrs	r3, r2
   193b8:	687a      	ldr	r2, [r7, #4]
   193ba:	2166      	movs	r1, #102	; 0x66
   193bc:	5c52      	ldrb	r2, [r2, r1]
   193be:	4313      	orrs	r3, r2
   193c0:	021b      	lsls	r3, r3, #8
   193c2:	0a1b      	lsrs	r3, r3, #8
   193c4:	4a15      	ldr	r2, [pc, #84]	; (1941c <check_fs+0xd8>)
   193c6:	4293      	cmp	r3, r2
   193c8:	d101      	bne.n	193ce <check_fs+0x8a>
		return 0;
   193ca:	2300      	movs	r3, #0
   193cc:	e01c      	b.n	19408 <check_fs+0xc4>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   193ce:	687b      	ldr	r3, [r7, #4]
   193d0:	3382      	adds	r3, #130	; 0x82
   193d2:	3303      	adds	r3, #3
   193d4:	781b      	ldrb	r3, [r3, #0]
   193d6:	061a      	lsls	r2, r3, #24
   193d8:	687b      	ldr	r3, [r7, #4]
   193da:	3382      	adds	r3, #130	; 0x82
   193dc:	3302      	adds	r3, #2
   193de:	781b      	ldrb	r3, [r3, #0]
   193e0:	041b      	lsls	r3, r3, #16
   193e2:	4313      	orrs	r3, r2
   193e4:	687a      	ldr	r2, [r7, #4]
   193e6:	3282      	adds	r2, #130	; 0x82
   193e8:	3201      	adds	r2, #1
   193ea:	7812      	ldrb	r2, [r2, #0]
   193ec:	0212      	lsls	r2, r2, #8
   193ee:	4313      	orrs	r3, r2
   193f0:	687a      	ldr	r2, [r7, #4]
   193f2:	2182      	movs	r1, #130	; 0x82
   193f4:	5c52      	ldrb	r2, [r2, r1]
   193f6:	4313      	orrs	r3, r2
   193f8:	021b      	lsls	r3, r3, #8
   193fa:	0a1b      	lsrs	r3, r3, #8
   193fc:	4a07      	ldr	r2, [pc, #28]	; (1941c <check_fs+0xd8>)
   193fe:	4293      	cmp	r3, r2
   19400:	d101      	bne.n	19406 <check_fs+0xc2>
		return 0;
   19402:	2300      	movs	r3, #0
   19404:	e000      	b.n	19408 <check_fs+0xc4>

	return 1;
   19406:	2301      	movs	r3, #1
}
   19408:	0018      	movs	r0, r3
   1940a:	46bd      	mov	sp, r7
   1940c:	b002      	add	sp, #8
   1940e:	bd80      	pop	{r7, pc}
   19410:	00017555 	.word	0x00017555
   19414:	0000022e 	.word	0x0000022e
   19418:	ffffaa55 	.word	0xffffaa55
   1941c:	00544146 	.word	0x00544146

00019420 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
   19420:	b590      	push	{r4, r7, lr}
   19422:	b097      	sub	sp, #92	; 0x5c
   19424:	af00      	add	r7, sp, #0
   19426:	60f8      	str	r0, [r7, #12]
   19428:	60b9      	str	r1, [r7, #8]
   1942a:	1dfb      	adds	r3, r7, #7
   1942c:	701a      	strb	r2, [r3, #0]
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
   1942e:	68fb      	ldr	r3, [r7, #12]
   19430:	2200      	movs	r2, #0
   19432:	601a      	str	r2, [r3, #0]
	vol = get_ldnumber(path);
   19434:	68bb      	ldr	r3, [r7, #8]
   19436:	0018      	movs	r0, r3
   19438:	4bd0      	ldr	r3, [pc, #832]	; (1977c <find_volume+0x35c>)
   1943a:	4798      	blx	r3
   1943c:	0003      	movs	r3, r0
   1943e:	63fb      	str	r3, [r7, #60]	; 0x3c
	if (vol < 0) return FR_INVALID_DRIVE;
   19440:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   19442:	2b00      	cmp	r3, #0
   19444:	da01      	bge.n	1944a <find_volume+0x2a>
   19446:	230b      	movs	r3, #11
   19448:	e2b8      	b.n	199bc <find_volume+0x59c>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
   1944a:	4bcd      	ldr	r3, [pc, #820]	; (19780 <find_volume+0x360>)
   1944c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   1944e:	0092      	lsls	r2, r2, #2
   19450:	58d3      	ldr	r3, [r2, r3]
   19452:	63bb      	str	r3, [r7, #56]	; 0x38
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   19454:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19456:	2b00      	cmp	r3, #0
   19458:	d101      	bne.n	1945e <find_volume+0x3e>
   1945a:	230c      	movs	r3, #12
   1945c:	e2ae      	b.n	199bc <find_volume+0x59c>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
   1945e:	68fb      	ldr	r3, [r7, #12]
   19460:	6bba      	ldr	r2, [r7, #56]	; 0x38
   19462:	601a      	str	r2, [r3, #0]

	if (fs->fs_type) {					/* If the volume has been mounted */
   19464:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19466:	781b      	ldrb	r3, [r3, #0]
   19468:	2b00      	cmp	r3, #0
   1946a:	d01c      	beq.n	194a6 <find_volume+0x86>
		stat = disk_status(fs->drv);
   1946c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1946e:	785b      	ldrb	r3, [r3, #1]
   19470:	2237      	movs	r2, #55	; 0x37
   19472:	18bc      	adds	r4, r7, r2
   19474:	0018      	movs	r0, r3
   19476:	4bc3      	ldr	r3, [pc, #780]	; (19784 <find_volume+0x364>)
   19478:	4798      	blx	r3
   1947a:	0003      	movs	r3, r0
   1947c:	7023      	strb	r3, [r4, #0]
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
   1947e:	2337      	movs	r3, #55	; 0x37
   19480:	18fb      	adds	r3, r7, r3
   19482:	781b      	ldrb	r3, [r3, #0]
   19484:	2201      	movs	r2, #1
   19486:	4013      	ands	r3, r2
   19488:	d10d      	bne.n	194a6 <find_volume+0x86>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
   1948a:	1dfb      	adds	r3, r7, #7
   1948c:	781b      	ldrb	r3, [r3, #0]
   1948e:	2b00      	cmp	r3, #0
   19490:	d007      	beq.n	194a2 <find_volume+0x82>
   19492:	2337      	movs	r3, #55	; 0x37
   19494:	18fb      	adds	r3, r7, r3
   19496:	781b      	ldrb	r3, [r3, #0]
   19498:	2204      	movs	r2, #4
   1949a:	4013      	ands	r3, r2
   1949c:	d001      	beq.n	194a2 <find_volume+0x82>
				return FR_WRITE_PROTECTED;
   1949e:	230a      	movs	r3, #10
   194a0:	e28c      	b.n	199bc <find_volume+0x59c>
			return FR_OK;				/* The file system object is valid */
   194a2:	2300      	movs	r3, #0
   194a4:	e28a      	b.n	199bc <find_volume+0x59c>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
   194a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   194a8:	2200      	movs	r2, #0
   194aa:	701a      	strb	r2, [r3, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   194ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   194ae:	b2da      	uxtb	r2, r3
   194b0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   194b2:	705a      	strb	r2, [r3, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   194b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   194b6:	785b      	ldrb	r3, [r3, #1]
   194b8:	2237      	movs	r2, #55	; 0x37
   194ba:	18bc      	adds	r4, r7, r2
   194bc:	0018      	movs	r0, r3
   194be:	4bb2      	ldr	r3, [pc, #712]	; (19788 <find_volume+0x368>)
   194c0:	4798      	blx	r3
   194c2:	0003      	movs	r3, r0
   194c4:	7023      	strb	r3, [r4, #0]
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   194c6:	2337      	movs	r3, #55	; 0x37
   194c8:	18fb      	adds	r3, r7, r3
   194ca:	781b      	ldrb	r3, [r3, #0]
   194cc:	2201      	movs	r2, #1
   194ce:	4013      	ands	r3, r2
   194d0:	d001      	beq.n	194d6 <find_volume+0xb6>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   194d2:	2303      	movs	r3, #3
   194d4:	e272      	b.n	199bc <find_volume+0x59c>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   194d6:	1dfb      	adds	r3, r7, #7
   194d8:	781b      	ldrb	r3, [r3, #0]
   194da:	2b00      	cmp	r3, #0
   194dc:	d007      	beq.n	194ee <find_volume+0xce>
   194de:	2337      	movs	r3, #55	; 0x37
   194e0:	18fb      	adds	r3, r7, r3
   194e2:	781b      	ldrb	r3, [r3, #0]
   194e4:	2204      	movs	r2, #4
   194e6:	4013      	ands	r3, r2
   194e8:	d001      	beq.n	194ee <find_volume+0xce>
		return FR_WRITE_PROTECTED;
   194ea:	230a      	movs	r3, #10
   194ec:	e266      	b.n	199bc <find_volume+0x59c>
#if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
   194ee:	2300      	movs	r3, #0
   194f0:	653b      	str	r3, [r7, #80]	; 0x50
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
   194f2:	2357      	movs	r3, #87	; 0x57
   194f4:	18fc      	adds	r4, r7, r3
   194f6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   194f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   194fa:	0011      	movs	r1, r2
   194fc:	0018      	movs	r0, r3
   194fe:	4ba3      	ldr	r3, [pc, #652]	; (1978c <find_volume+0x36c>)
   19500:	4798      	blx	r3
   19502:	0003      	movs	r3, r0
   19504:	7023      	strb	r3, [r4, #0]
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
   19506:	2357      	movs	r3, #87	; 0x57
   19508:	18fb      	adds	r3, r7, r3
   1950a:	781b      	ldrb	r3, [r3, #0]
   1950c:	2b01      	cmp	r3, #1
   1950e:	d158      	bne.n	195c2 <find_volume+0x1a2>
		for (i = 0; i < 4; i++) {			/* Get partition offset */
   19510:	2300      	movs	r3, #0
   19512:	643b      	str	r3, [r7, #64]	; 0x40
   19514:	e029      	b.n	1956a <find_volume+0x14a>
			pt = fs->win + MBR_Table + i * SZ_PTE;
   19516:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19518:	3330      	adds	r3, #48	; 0x30
   1951a:	001a      	movs	r2, r3
   1951c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1951e:	011b      	lsls	r3, r3, #4
   19520:	33bf      	adds	r3, #191	; 0xbf
   19522:	33ff      	adds	r3, #255	; 0xff
   19524:	18d3      	adds	r3, r2, r3
   19526:	633b      	str	r3, [r7, #48]	; 0x30
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
   19528:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1952a:	3304      	adds	r3, #4
   1952c:	781b      	ldrb	r3, [r3, #0]
   1952e:	2b00      	cmp	r3, #0
   19530:	d012      	beq.n	19558 <find_volume+0x138>
   19532:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   19534:	330b      	adds	r3, #11
   19536:	781b      	ldrb	r3, [r3, #0]
   19538:	061a      	lsls	r2, r3, #24
   1953a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1953c:	330a      	adds	r3, #10
   1953e:	781b      	ldrb	r3, [r3, #0]
   19540:	041b      	lsls	r3, r3, #16
   19542:	4313      	orrs	r3, r2
   19544:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   19546:	3209      	adds	r2, #9
   19548:	7812      	ldrb	r2, [r2, #0]
   1954a:	0212      	lsls	r2, r2, #8
   1954c:	4313      	orrs	r3, r2
   1954e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   19550:	3208      	adds	r2, #8
   19552:	7812      	ldrb	r2, [r2, #0]
   19554:	4313      	orrs	r3, r2
   19556:	e000      	b.n	1955a <find_volume+0x13a>
   19558:	2300      	movs	r3, #0
   1955a:	2214      	movs	r2, #20
   1955c:	18ba      	adds	r2, r7, r2
   1955e:	6c39      	ldr	r1, [r7, #64]	; 0x40
   19560:	0089      	lsls	r1, r1, #2
   19562:	508b      	str	r3, [r1, r2]
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
   19564:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   19566:	3301      	adds	r3, #1
   19568:	643b      	str	r3, [r7, #64]	; 0x40
   1956a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1956c:	2b03      	cmp	r3, #3
   1956e:	d9d2      	bls.n	19516 <find_volume+0xf6>
			pt = fs->win + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
   19570:	2300      	movs	r3, #0
   19572:	643b      	str	r3, [r7, #64]	; 0x40
		if (i) i--;
   19574:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   19576:	2b00      	cmp	r3, #0
   19578:	d002      	beq.n	19580 <find_volume+0x160>
   1957a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1957c:	3b01      	subs	r3, #1
   1957e:	643b      	str	r3, [r7, #64]	; 0x40
		do {								/* Find an FAT volume */
			bsect = br[i];
   19580:	2314      	movs	r3, #20
   19582:	18fb      	adds	r3, r7, r3
   19584:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   19586:	0092      	lsls	r2, r2, #2
   19588:	58d3      	ldr	r3, [r2, r3]
   1958a:	653b      	str	r3, [r7, #80]	; 0x50
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
   1958c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   1958e:	2b00      	cmp	r3, #0
   19590:	d008      	beq.n	195a4 <find_volume+0x184>
   19592:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   19594:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19596:	0011      	movs	r1, r2
   19598:	0018      	movs	r0, r3
   1959a:	4b7c      	ldr	r3, [pc, #496]	; (1978c <find_volume+0x36c>)
   1959c:	4798      	blx	r3
   1959e:	0003      	movs	r3, r0
   195a0:	001a      	movs	r2, r3
   195a2:	e000      	b.n	195a6 <find_volume+0x186>
   195a4:	2202      	movs	r2, #2
   195a6:	2357      	movs	r3, #87	; 0x57
   195a8:	18fb      	adds	r3, r7, r3
   195aa:	701a      	strb	r2, [r3, #0]
		} while (!LD2PT(vol) && fmt && ++i < 4);
   195ac:	2357      	movs	r3, #87	; 0x57
   195ae:	18fb      	adds	r3, r7, r3
   195b0:	781b      	ldrb	r3, [r3, #0]
   195b2:	2b00      	cmp	r3, #0
   195b4:	d005      	beq.n	195c2 <find_volume+0x1a2>
   195b6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   195b8:	3301      	adds	r3, #1
   195ba:	643b      	str	r3, [r7, #64]	; 0x40
   195bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   195be:	2b03      	cmp	r3, #3
   195c0:	d9de      	bls.n	19580 <find_volume+0x160>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
   195c2:	2357      	movs	r3, #87	; 0x57
   195c4:	18fb      	adds	r3, r7, r3
   195c6:	781b      	ldrb	r3, [r3, #0]
   195c8:	2b03      	cmp	r3, #3
   195ca:	d101      	bne.n	195d0 <find_volume+0x1b0>
   195cc:	2301      	movs	r3, #1
   195ce:	e1f5      	b.n	199bc <find_volume+0x59c>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   195d0:	2357      	movs	r3, #87	; 0x57
   195d2:	18fb      	adds	r3, r7, r3
   195d4:	781b      	ldrb	r3, [r3, #0]
   195d6:	2b00      	cmp	r3, #0
   195d8:	d001      	beq.n	195de <find_volume+0x1be>
   195da:	230d      	movs	r3, #13
   195dc:	e1ee      	b.n	199bc <find_volume+0x59c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
   195de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   195e0:	223c      	movs	r2, #60	; 0x3c
   195e2:	5c9b      	ldrb	r3, [r3, r2]
   195e4:	021b      	lsls	r3, r3, #8
   195e6:	b21a      	sxth	r2, r3
   195e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   195ea:	213b      	movs	r1, #59	; 0x3b
   195ec:	5c5b      	ldrb	r3, [r3, r1]
   195ee:	b21b      	sxth	r3, r3
   195f0:	4313      	orrs	r3, r2
   195f2:	b21a      	sxth	r2, r3
   195f4:	2380      	movs	r3, #128	; 0x80
   195f6:	009b      	lsls	r3, r3, #2
   195f8:	429a      	cmp	r2, r3
   195fa:	d001      	beq.n	19600 <find_volume+0x1e0>
		return FR_NO_FILESYSTEM;
   195fc:	230d      	movs	r3, #13
   195fe:	e1dd      	b.n	199bc <find_volume+0x59c>

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
   19600:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19602:	2247      	movs	r2, #71	; 0x47
   19604:	5c9b      	ldrb	r3, [r3, r2]
   19606:	021b      	lsls	r3, r3, #8
   19608:	b21a      	sxth	r2, r3
   1960a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1960c:	2146      	movs	r1, #70	; 0x46
   1960e:	5c5b      	ldrb	r3, [r3, r1]
   19610:	b21b      	sxth	r3, r3
   19612:	4313      	orrs	r3, r2
   19614:	b21b      	sxth	r3, r3
   19616:	b29b      	uxth	r3, r3
   19618:	64fb      	str	r3, [r7, #76]	; 0x4c
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
   1961a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1961c:	2b00      	cmp	r3, #0
   1961e:	d112      	bne.n	19646 <find_volume+0x226>
   19620:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19622:	2257      	movs	r2, #87	; 0x57
   19624:	5c9b      	ldrb	r3, [r3, r2]
   19626:	061a      	lsls	r2, r3, #24
   19628:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1962a:	2156      	movs	r1, #86	; 0x56
   1962c:	5c5b      	ldrb	r3, [r3, r1]
   1962e:	041b      	lsls	r3, r3, #16
   19630:	4313      	orrs	r3, r2
   19632:	6bba      	ldr	r2, [r7, #56]	; 0x38
   19634:	2155      	movs	r1, #85	; 0x55
   19636:	5c52      	ldrb	r2, [r2, r1]
   19638:	0212      	lsls	r2, r2, #8
   1963a:	4313      	orrs	r3, r2
   1963c:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1963e:	2154      	movs	r1, #84	; 0x54
   19640:	5c52      	ldrb	r2, [r2, r1]
   19642:	4313      	orrs	r3, r2
   19644:	64fb      	str	r3, [r7, #76]	; 0x4c
	fs->fsize = fasize;
   19646:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19648:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   1964a:	619a      	str	r2, [r3, #24]

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
   1964c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1964e:	2240      	movs	r2, #64	; 0x40
   19650:	5c9a      	ldrb	r2, [r3, r2]
   19652:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19654:	70da      	strb	r2, [r3, #3]
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
   19656:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19658:	78db      	ldrb	r3, [r3, #3]
   1965a:	2b01      	cmp	r3, #1
   1965c:	d005      	beq.n	1966a <find_volume+0x24a>
   1965e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19660:	78db      	ldrb	r3, [r3, #3]
   19662:	2b02      	cmp	r3, #2
   19664:	d001      	beq.n	1966a <find_volume+0x24a>
		return FR_NO_FILESYSTEM;
   19666:	230d      	movs	r3, #13
   19668:	e1a8      	b.n	199bc <find_volume+0x59c>
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
   1966a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1966c:	78db      	ldrb	r3, [r3, #3]
   1966e:	001a      	movs	r2, r3
   19670:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   19672:	4353      	muls	r3, r2
   19674:	64fb      	str	r3, [r7, #76]	; 0x4c

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
   19676:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19678:	223d      	movs	r2, #61	; 0x3d
   1967a:	5c9a      	ldrb	r2, [r3, r2]
   1967c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1967e:	709a      	strb	r2, [r3, #2]
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
   19680:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19682:	789b      	ldrb	r3, [r3, #2]
   19684:	2b00      	cmp	r3, #0
   19686:	d007      	beq.n	19698 <find_volume+0x278>
   19688:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1968a:	789b      	ldrb	r3, [r3, #2]
   1968c:	001a      	movs	r2, r3
   1968e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19690:	789b      	ldrb	r3, [r3, #2]
   19692:	3b01      	subs	r3, #1
   19694:	4013      	ands	r3, r2
   19696:	d001      	beq.n	1969c <find_volume+0x27c>
		return FR_NO_FILESYSTEM;
   19698:	230d      	movs	r3, #13
   1969a:	e18f      	b.n	199bc <find_volume+0x59c>

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
   1969c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1969e:	2242      	movs	r2, #66	; 0x42
   196a0:	5c9b      	ldrb	r3, [r3, r2]
   196a2:	021b      	lsls	r3, r3, #8
   196a4:	b21a      	sxth	r2, r3
   196a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   196a8:	2141      	movs	r1, #65	; 0x41
   196aa:	5c5b      	ldrb	r3, [r3, r1]
   196ac:	b21b      	sxth	r3, r3
   196ae:	4313      	orrs	r3, r2
   196b0:	b21b      	sxth	r3, r3
   196b2:	b29a      	uxth	r2, r3
   196b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   196b6:	811a      	strh	r2, [r3, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
   196b8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   196ba:	891b      	ldrh	r3, [r3, #8]
   196bc:	220f      	movs	r2, #15
   196be:	4013      	ands	r3, r2
   196c0:	b29b      	uxth	r3, r3
   196c2:	2b00      	cmp	r3, #0
   196c4:	d001      	beq.n	196ca <find_volume+0x2aa>
		return FR_NO_FILESYSTEM;
   196c6:	230d      	movs	r3, #13
   196c8:	e178      	b.n	199bc <find_volume+0x59c>

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
   196ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   196cc:	2244      	movs	r2, #68	; 0x44
   196ce:	5c9b      	ldrb	r3, [r3, r2]
   196d0:	021b      	lsls	r3, r3, #8
   196d2:	b21a      	sxth	r2, r3
   196d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   196d6:	2143      	movs	r1, #67	; 0x43
   196d8:	5c5b      	ldrb	r3, [r3, r1]
   196da:	b21b      	sxth	r3, r3
   196dc:	4313      	orrs	r3, r2
   196de:	b21b      	sxth	r3, r3
   196e0:	b29b      	uxth	r3, r3
   196e2:	64bb      	str	r3, [r7, #72]	; 0x48
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
   196e4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   196e6:	2b00      	cmp	r3, #0
   196e8:	d112      	bne.n	19710 <find_volume+0x2f0>
   196ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   196ec:	2253      	movs	r2, #83	; 0x53
   196ee:	5c9b      	ldrb	r3, [r3, r2]
   196f0:	061a      	lsls	r2, r3, #24
   196f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   196f4:	2152      	movs	r1, #82	; 0x52
   196f6:	5c5b      	ldrb	r3, [r3, r1]
   196f8:	041b      	lsls	r3, r3, #16
   196fa:	4313      	orrs	r3, r2
   196fc:	6bba      	ldr	r2, [r7, #56]	; 0x38
   196fe:	2151      	movs	r1, #81	; 0x51
   19700:	5c52      	ldrb	r2, [r2, r1]
   19702:	0212      	lsls	r2, r2, #8
   19704:	4313      	orrs	r3, r2
   19706:	6bba      	ldr	r2, [r7, #56]	; 0x38
   19708:	2150      	movs	r1, #80	; 0x50
   1970a:	5c52      	ldrb	r2, [r2, r1]
   1970c:	4313      	orrs	r3, r2
   1970e:	64bb      	str	r3, [r7, #72]	; 0x48

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
   19710:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19712:	223f      	movs	r2, #63	; 0x3f
   19714:	5c9b      	ldrb	r3, [r3, r2]
   19716:	021b      	lsls	r3, r3, #8
   19718:	b21a      	sxth	r2, r3
   1971a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1971c:	213e      	movs	r1, #62	; 0x3e
   1971e:	5c5b      	ldrb	r3, [r3, r1]
   19720:	b21b      	sxth	r3, r3
   19722:	4313      	orrs	r3, r2
   19724:	b21a      	sxth	r2, r3
   19726:	232e      	movs	r3, #46	; 0x2e
   19728:	18fb      	adds	r3, r7, r3
   1972a:	801a      	strh	r2, [r3, #0]
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
   1972c:	232e      	movs	r3, #46	; 0x2e
   1972e:	18fb      	adds	r3, r7, r3
   19730:	881b      	ldrh	r3, [r3, #0]
   19732:	2b00      	cmp	r3, #0
   19734:	d101      	bne.n	1973a <find_volume+0x31a>
   19736:	230d      	movs	r3, #13
   19738:	e140      	b.n	199bc <find_volume+0x59c>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
   1973a:	232e      	movs	r3, #46	; 0x2e
   1973c:	18fb      	adds	r3, r7, r3
   1973e:	881a      	ldrh	r2, [r3, #0]
   19740:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   19742:	18d3      	adds	r3, r2, r3
   19744:	6bba      	ldr	r2, [r7, #56]	; 0x38
   19746:	8912      	ldrh	r2, [r2, #8]
   19748:	0912      	lsrs	r2, r2, #4
   1974a:	b292      	uxth	r2, r2
   1974c:	189b      	adds	r3, r3, r2
   1974e:	62bb      	str	r3, [r7, #40]	; 0x28
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   19750:	6cba      	ldr	r2, [r7, #72]	; 0x48
   19752:	6abb      	ldr	r3, [r7, #40]	; 0x28
   19754:	429a      	cmp	r2, r3
   19756:	d201      	bcs.n	1975c <find_volume+0x33c>
   19758:	230d      	movs	r3, #13
   1975a:	e12f      	b.n	199bc <find_volume+0x59c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   1975c:	6cba      	ldr	r2, [r7, #72]	; 0x48
   1975e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   19760:	1ad2      	subs	r2, r2, r3
   19762:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19764:	789b      	ldrb	r3, [r3, #2]
   19766:	0019      	movs	r1, r3
   19768:	4b09      	ldr	r3, [pc, #36]	; (19790 <find_volume+0x370>)
   1976a:	0010      	movs	r0, r2
   1976c:	4798      	blx	r3
   1976e:	0003      	movs	r3, r0
   19770:	627b      	str	r3, [r7, #36]	; 0x24
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   19772:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   19774:	2b00      	cmp	r3, #0
   19776:	d10d      	bne.n	19794 <find_volume+0x374>
   19778:	230d      	movs	r3, #13
   1977a:	e11f      	b.n	199bc <find_volume+0x59c>
   1977c:	000192c1 	.word	0x000192c1
   19780:	20002e6c 	.word	0x20002e6c
   19784:	000170b9 	.word	0x000170b9
   19788:	00017035 	.word	0x00017035
   1978c:	00019345 	.word	0x00019345
   19790:	0001d485 	.word	0x0001d485
	fmt = FS_FAT12;
   19794:	2357      	movs	r3, #87	; 0x57
   19796:	18fb      	adds	r3, r7, r3
   19798:	2201      	movs	r2, #1
   1979a:	701a      	strb	r2, [r3, #0]
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   1979c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1979e:	4a89      	ldr	r2, [pc, #548]	; (199c4 <find_volume+0x5a4>)
   197a0:	4293      	cmp	r3, r2
   197a2:	d903      	bls.n	197ac <find_volume+0x38c>
   197a4:	2357      	movs	r3, #87	; 0x57
   197a6:	18fb      	adds	r3, r7, r3
   197a8:	2202      	movs	r2, #2
   197aa:	701a      	strb	r2, [r3, #0]
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   197ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   197ae:	4a86      	ldr	r2, [pc, #536]	; (199c8 <find_volume+0x5a8>)
   197b0:	4293      	cmp	r3, r2
   197b2:	d903      	bls.n	197bc <find_volume+0x39c>
   197b4:	2357      	movs	r3, #87	; 0x57
   197b6:	18fb      	adds	r3, r7, r3
   197b8:	2203      	movs	r2, #3
   197ba:	701a      	strb	r2, [r3, #0]

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   197bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   197be:	1c9a      	adds	r2, r3, #2
   197c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   197c2:	615a      	str	r2, [r3, #20]
	fs->volbase = bsect;								/* Volume start sector */
   197c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   197c6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   197c8:	61da      	str	r2, [r3, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   197ca:	232e      	movs	r3, #46	; 0x2e
   197cc:	18fb      	adds	r3, r7, r3
   197ce:	881a      	ldrh	r2, [r3, #0]
   197d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   197d2:	18d2      	adds	r2, r2, r3
   197d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   197d6:	621a      	str	r2, [r3, #32]
	fs->database = bsect + sysect;						/* Data start sector */
   197d8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   197da:	6abb      	ldr	r3, [r7, #40]	; 0x28
   197dc:	18d2      	adds	r2, r2, r3
   197de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   197e0:	629a      	str	r2, [r3, #40]	; 0x28
	if (fmt == FS_FAT32) {
   197e2:	2357      	movs	r3, #87	; 0x57
   197e4:	18fb      	adds	r3, r7, r3
   197e6:	781b      	ldrb	r3, [r3, #0]
   197e8:	2b03      	cmp	r3, #3
   197ea:	d11e      	bne.n	1982a <find_volume+0x40a>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   197ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   197ee:	891b      	ldrh	r3, [r3, #8]
   197f0:	2b00      	cmp	r3, #0
   197f2:	d001      	beq.n	197f8 <find_volume+0x3d8>
   197f4:	230d      	movs	r3, #13
   197f6:	e0e1      	b.n	199bc <find_volume+0x59c>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
   197f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   197fa:	225f      	movs	r2, #95	; 0x5f
   197fc:	5c9b      	ldrb	r3, [r3, r2]
   197fe:	061a      	lsls	r2, r3, #24
   19800:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19802:	215e      	movs	r1, #94	; 0x5e
   19804:	5c5b      	ldrb	r3, [r3, r1]
   19806:	041b      	lsls	r3, r3, #16
   19808:	4313      	orrs	r3, r2
   1980a:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1980c:	215d      	movs	r1, #93	; 0x5d
   1980e:	5c52      	ldrb	r2, [r2, r1]
   19810:	0212      	lsls	r2, r2, #8
   19812:	4313      	orrs	r3, r2
   19814:	6bba      	ldr	r2, [r7, #56]	; 0x38
   19816:	215c      	movs	r1, #92	; 0x5c
   19818:	5c52      	ldrb	r2, [r2, r1]
   1981a:	431a      	orrs	r2, r3
   1981c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1981e:	625a      	str	r2, [r3, #36]	; 0x24
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
   19820:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19822:	695b      	ldr	r3, [r3, #20]
   19824:	009b      	lsls	r3, r3, #2
   19826:	647b      	str	r3, [r7, #68]	; 0x44
   19828:	e020      	b.n	1986c <find_volume+0x44c>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   1982a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1982c:	891b      	ldrh	r3, [r3, #8]
   1982e:	2b00      	cmp	r3, #0
   19830:	d101      	bne.n	19836 <find_volume+0x416>
   19832:	230d      	movs	r3, #13
   19834:	e0c2      	b.n	199bc <find_volume+0x59c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   19836:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19838:	6a1a      	ldr	r2, [r3, #32]
   1983a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1983c:	18d2      	adds	r2, r2, r3
   1983e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19840:	625a      	str	r2, [r3, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   19842:	2357      	movs	r3, #87	; 0x57
   19844:	18fb      	adds	r3, r7, r3
   19846:	781b      	ldrb	r3, [r3, #0]
   19848:	2b02      	cmp	r3, #2
   1984a:	d103      	bne.n	19854 <find_volume+0x434>
   1984c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1984e:	695b      	ldr	r3, [r3, #20]
   19850:	005b      	lsls	r3, r3, #1
   19852:	e00a      	b.n	1986a <find_volume+0x44a>
   19854:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19856:	695a      	ldr	r2, [r3, #20]
   19858:	0013      	movs	r3, r2
   1985a:	005b      	lsls	r3, r3, #1
   1985c:	189b      	adds	r3, r3, r2
   1985e:	085a      	lsrs	r2, r3, #1
   19860:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19862:	695b      	ldr	r3, [r3, #20]
   19864:	2101      	movs	r1, #1
   19866:	400b      	ands	r3, r1
   19868:	18d3      	adds	r3, r2, r3
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
   1986a:	647b      	str	r3, [r7, #68]	; 0x44
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
   1986c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1986e:	699a      	ldr	r2, [r3, #24]
   19870:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   19872:	4956      	ldr	r1, [pc, #344]	; (199cc <find_volume+0x5ac>)
   19874:	468c      	mov	ip, r1
   19876:	4463      	add	r3, ip
   19878:	0a5b      	lsrs	r3, r3, #9
   1987a:	429a      	cmp	r2, r3
   1987c:	d201      	bcs.n	19882 <find_volume+0x462>
		return FR_NO_FILESYSTEM;
   1987e:	230d      	movs	r3, #13
   19880:	e09c      	b.n	199bc <find_volume+0x59c>

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
   19882:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19884:	2201      	movs	r2, #1
   19886:	4252      	negs	r2, r2
   19888:	611a      	str	r2, [r3, #16]
   1988a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1988c:	691a      	ldr	r2, [r3, #16]
   1988e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19890:	60da      	str	r2, [r3, #12]

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
   19892:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19894:	2280      	movs	r2, #128	; 0x80
   19896:	715a      	strb	r2, [r3, #5]
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
   19898:	2357      	movs	r3, #87	; 0x57
   1989a:	18fb      	adds	r3, r7, r3
   1989c:	781b      	ldrb	r3, [r3, #0]
   1989e:	2b03      	cmp	r3, #3
   198a0:	d000      	beq.n	198a4 <find_volume+0x484>
   198a2:	e07b      	b.n	1999c <find_volume+0x57c>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
   198a4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   198a6:	2261      	movs	r2, #97	; 0x61
   198a8:	5c9b      	ldrb	r3, [r3, r2]
   198aa:	021b      	lsls	r3, r3, #8
   198ac:	b21a      	sxth	r2, r3
   198ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   198b0:	2160      	movs	r1, #96	; 0x60
   198b2:	5c5b      	ldrb	r3, [r3, r1]
   198b4:	b21b      	sxth	r3, r3
   198b6:	4313      	orrs	r3, r2
   198b8:	b21b      	sxth	r3, r3
   198ba:	2b01      	cmp	r3, #1
   198bc:	d16e      	bne.n	1999c <find_volume+0x57c>
		&& move_window(fs, bsect + 1) == FR_OK)
   198be:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   198c0:	1c5a      	adds	r2, r3, #1
   198c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   198c4:	0011      	movs	r1, r2
   198c6:	0018      	movs	r0, r3
   198c8:	4b41      	ldr	r3, [pc, #260]	; (199d0 <find_volume+0x5b0>)
   198ca:	4798      	blx	r3
   198cc:	1e03      	subs	r3, r0, #0
   198ce:	d165      	bne.n	1999c <find_volume+0x57c>
	{
		fs->fsi_flag = 0;
   198d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   198d2:	2200      	movs	r2, #0
   198d4:	715a      	strb	r2, [r3, #5]
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
   198d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   198d8:	4a3e      	ldr	r2, [pc, #248]	; (199d4 <find_volume+0x5b4>)
   198da:	5c9b      	ldrb	r3, [r3, r2]
   198dc:	021b      	lsls	r3, r3, #8
   198de:	b21a      	sxth	r2, r3
   198e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   198e2:	493d      	ldr	r1, [pc, #244]	; (199d8 <find_volume+0x5b8>)
   198e4:	5c5b      	ldrb	r3, [r3, r1]
   198e6:	b21b      	sxth	r3, r3
   198e8:	4313      	orrs	r3, r2
   198ea:	b21b      	sxth	r3, r3
   198ec:	4a3b      	ldr	r2, [pc, #236]	; (199dc <find_volume+0x5bc>)
   198ee:	4293      	cmp	r3, r2
   198f0:	d154      	bne.n	1999c <find_volume+0x57c>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
   198f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   198f4:	2233      	movs	r2, #51	; 0x33
   198f6:	5c9b      	ldrb	r3, [r3, r2]
   198f8:	061a      	lsls	r2, r3, #24
   198fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   198fc:	2132      	movs	r1, #50	; 0x32
   198fe:	5c5b      	ldrb	r3, [r3, r1]
   19900:	041b      	lsls	r3, r3, #16
   19902:	4313      	orrs	r3, r2
   19904:	6bba      	ldr	r2, [r7, #56]	; 0x38
   19906:	2131      	movs	r1, #49	; 0x31
   19908:	5c52      	ldrb	r2, [r2, r1]
   1990a:	0212      	lsls	r2, r2, #8
   1990c:	4313      	orrs	r3, r2
   1990e:	6bba      	ldr	r2, [r7, #56]	; 0x38
   19910:	2130      	movs	r1, #48	; 0x30
   19912:	5c52      	ldrb	r2, [r2, r1]
   19914:	4313      	orrs	r3, r2
   19916:	4a32      	ldr	r2, [pc, #200]	; (199e0 <find_volume+0x5c0>)
   19918:	4293      	cmp	r3, r2
   1991a:	d13f      	bne.n	1999c <find_volume+0x57c>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
   1991c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1991e:	4a31      	ldr	r2, [pc, #196]	; (199e4 <find_volume+0x5c4>)
   19920:	5c9b      	ldrb	r3, [r3, r2]
   19922:	061a      	lsls	r2, r3, #24
   19924:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19926:	4930      	ldr	r1, [pc, #192]	; (199e8 <find_volume+0x5c8>)
   19928:	5c5b      	ldrb	r3, [r3, r1]
   1992a:	041b      	lsls	r3, r3, #16
   1992c:	4313      	orrs	r3, r2
   1992e:	6bba      	ldr	r2, [r7, #56]	; 0x38
   19930:	492e      	ldr	r1, [pc, #184]	; (199ec <find_volume+0x5cc>)
   19932:	5c52      	ldrb	r2, [r2, r1]
   19934:	0212      	lsls	r2, r2, #8
   19936:	4313      	orrs	r3, r2
   19938:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   1993a:	2285      	movs	r2, #133	; 0x85
   1993c:	0092      	lsls	r2, r2, #2
   1993e:	5c8a      	ldrb	r2, [r1, r2]
   19940:	4313      	orrs	r3, r2
   19942:	4a2b      	ldr	r2, [pc, #172]	; (199f0 <find_volume+0x5d0>)
   19944:	4293      	cmp	r3, r2
   19946:	d129      	bne.n	1999c <find_volume+0x57c>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
   19948:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1994a:	4a2a      	ldr	r2, [pc, #168]	; (199f4 <find_volume+0x5d4>)
   1994c:	5c9b      	ldrb	r3, [r3, r2]
   1994e:	061a      	lsls	r2, r3, #24
   19950:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19952:	4929      	ldr	r1, [pc, #164]	; (199f8 <find_volume+0x5d8>)
   19954:	5c5b      	ldrb	r3, [r3, r1]
   19956:	041b      	lsls	r3, r3, #16
   19958:	4313      	orrs	r3, r2
   1995a:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1995c:	4927      	ldr	r1, [pc, #156]	; (199fc <find_volume+0x5dc>)
   1995e:	5c52      	ldrb	r2, [r2, r1]
   19960:	0212      	lsls	r2, r2, #8
   19962:	4313      	orrs	r3, r2
   19964:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   19966:	2286      	movs	r2, #134	; 0x86
   19968:	0092      	lsls	r2, r2, #2
   1996a:	5c8a      	ldrb	r2, [r1, r2]
   1996c:	431a      	orrs	r2, r3
   1996e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19970:	611a      	str	r2, [r3, #16]
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
   19972:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19974:	4a22      	ldr	r2, [pc, #136]	; (19a00 <find_volume+0x5e0>)
   19976:	5c9b      	ldrb	r3, [r3, r2]
   19978:	061a      	lsls	r2, r3, #24
   1997a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1997c:	4921      	ldr	r1, [pc, #132]	; (19a04 <find_volume+0x5e4>)
   1997e:	5c5b      	ldrb	r3, [r3, r1]
   19980:	041b      	lsls	r3, r3, #16
   19982:	4313      	orrs	r3, r2
   19984:	6bba      	ldr	r2, [r7, #56]	; 0x38
   19986:	4920      	ldr	r1, [pc, #128]	; (19a08 <find_volume+0x5e8>)
   19988:	5c52      	ldrb	r2, [r2, r1]
   1998a:	0212      	lsls	r2, r2, #8
   1998c:	4313      	orrs	r3, r2
   1998e:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   19990:	2287      	movs	r2, #135	; 0x87
   19992:	0092      	lsls	r2, r2, #2
   19994:	5c8a      	ldrb	r2, [r1, r2]
   19996:	431a      	orrs	r2, r3
   19998:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1999a:	60da      	str	r2, [r3, #12]
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
   1999c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1999e:	2257      	movs	r2, #87	; 0x57
   199a0:	18ba      	adds	r2, r7, r2
   199a2:	7812      	ldrb	r2, [r2, #0]
   199a4:	701a      	strb	r2, [r3, #0]
	fs->id = ++Fsid;	/* File system mount ID */
   199a6:	4b19      	ldr	r3, [pc, #100]	; (19a0c <find_volume+0x5ec>)
   199a8:	881b      	ldrh	r3, [r3, #0]
   199aa:	3301      	adds	r3, #1
   199ac:	b29a      	uxth	r2, r3
   199ae:	4b17      	ldr	r3, [pc, #92]	; (19a0c <find_volume+0x5ec>)
   199b0:	801a      	strh	r2, [r3, #0]
   199b2:	4b16      	ldr	r3, [pc, #88]	; (19a0c <find_volume+0x5ec>)
   199b4:	881a      	ldrh	r2, [r3, #0]
   199b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   199b8:	80da      	strh	r2, [r3, #6]
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
   199ba:	2300      	movs	r3, #0
}
   199bc:	0018      	movs	r0, r3
   199be:	46bd      	mov	sp, r7
   199c0:	b017      	add	sp, #92	; 0x5c
   199c2:	bd90      	pop	{r4, r7, pc}
   199c4:	00000ff5 	.word	0x00000ff5
   199c8:	0000fff5 	.word	0x0000fff5
   199cc:	000001ff 	.word	0x000001ff
   199d0:	00017555 	.word	0x00017555
   199d4:	0000022f 	.word	0x0000022f
   199d8:	0000022e 	.word	0x0000022e
   199dc:	ffffaa55 	.word	0xffffaa55
   199e0:	41615252 	.word	0x41615252
   199e4:	00000217 	.word	0x00000217
   199e8:	00000216 	.word	0x00000216
   199ec:	00000215 	.word	0x00000215
   199f0:	61417272 	.word	0x61417272
   199f4:	0000021b 	.word	0x0000021b
   199f8:	0000021a 	.word	0x0000021a
   199fc:	00000219 	.word	0x00000219
   19a00:	0000021f 	.word	0x0000021f
   19a04:	0000021e 	.word	0x0000021e
   19a08:	0000021d 	.word	0x0000021d
   19a0c:	20002e8c 	.word	0x20002e8c

00019a10 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
   19a10:	b580      	push	{r7, lr}
   19a12:	b084      	sub	sp, #16
   19a14:	af00      	add	r7, sp, #0
   19a16:	6078      	str	r0, [r7, #4]
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
   19a18:	687b      	ldr	r3, [r7, #4]
   19a1a:	60fb      	str	r3, [r7, #12]


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
   19a1c:	68fb      	ldr	r3, [r7, #12]
   19a1e:	2b00      	cmp	r3, #0
   19a20:	d01a      	beq.n	19a58 <validate+0x48>
   19a22:	68fb      	ldr	r3, [r7, #12]
   19a24:	681b      	ldr	r3, [r3, #0]
   19a26:	2b00      	cmp	r3, #0
   19a28:	d016      	beq.n	19a58 <validate+0x48>
   19a2a:	68fb      	ldr	r3, [r7, #12]
   19a2c:	681b      	ldr	r3, [r3, #0]
   19a2e:	781b      	ldrb	r3, [r3, #0]
   19a30:	2b00      	cmp	r3, #0
   19a32:	d011      	beq.n	19a58 <validate+0x48>
   19a34:	68fb      	ldr	r3, [r7, #12]
   19a36:	681b      	ldr	r3, [r3, #0]
   19a38:	88da      	ldrh	r2, [r3, #6]
   19a3a:	68fb      	ldr	r3, [r7, #12]
   19a3c:	889b      	ldrh	r3, [r3, #4]
   19a3e:	429a      	cmp	r2, r3
   19a40:	d10a      	bne.n	19a58 <validate+0x48>
   19a42:	68fb      	ldr	r3, [r7, #12]
   19a44:	681b      	ldr	r3, [r3, #0]
   19a46:	785b      	ldrb	r3, [r3, #1]
   19a48:	0018      	movs	r0, r3
   19a4a:	4b07      	ldr	r3, [pc, #28]	; (19a68 <validate+0x58>)
   19a4c:	4798      	blx	r3
   19a4e:	0003      	movs	r3, r0
   19a50:	001a      	movs	r2, r3
   19a52:	2301      	movs	r3, #1
   19a54:	4013      	ands	r3, r2
   19a56:	d001      	beq.n	19a5c <validate+0x4c>
		return FR_INVALID_OBJECT;
   19a58:	2309      	movs	r3, #9
   19a5a:	e000      	b.n	19a5e <validate+0x4e>

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
   19a5c:	2300      	movs	r3, #0
}
   19a5e:	0018      	movs	r0, r3
   19a60:	46bd      	mov	sp, r7
   19a62:	b004      	add	sp, #16
   19a64:	bd80      	pop	{r7, pc}
   19a66:	46c0      	nop			; (mov r8, r8)
   19a68:	000170b9 	.word	0x000170b9

00019a6c <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
   19a6c:	b590      	push	{r4, r7, lr}
   19a6e:	b089      	sub	sp, #36	; 0x24
   19a70:	af00      	add	r7, sp, #0
   19a72:	60f8      	str	r0, [r7, #12]
   19a74:	60b9      	str	r1, [r7, #8]
   19a76:	1dfb      	adds	r3, r7, #7
   19a78:	701a      	strb	r2, [r3, #0]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
   19a7a:	68bb      	ldr	r3, [r7, #8]
   19a7c:	613b      	str	r3, [r7, #16]


	vol = get_ldnumber(&rp);
   19a7e:	2310      	movs	r3, #16
   19a80:	18fb      	adds	r3, r7, r3
   19a82:	0018      	movs	r0, r3
   19a84:	4b1d      	ldr	r3, [pc, #116]	; (19afc <f_mount+0x90>)
   19a86:	4798      	blx	r3
   19a88:	0003      	movs	r3, r0
   19a8a:	61fb      	str	r3, [r7, #28]
	if (vol < 0) return FR_INVALID_DRIVE;
   19a8c:	69fb      	ldr	r3, [r7, #28]
   19a8e:	2b00      	cmp	r3, #0
   19a90:	da01      	bge.n	19a96 <f_mount+0x2a>
   19a92:	230b      	movs	r3, #11
   19a94:	e02d      	b.n	19af2 <f_mount+0x86>
	cfs = FatFs[vol];					/* Pointer to fs object */
   19a96:	4b1a      	ldr	r3, [pc, #104]	; (19b00 <f_mount+0x94>)
   19a98:	69fa      	ldr	r2, [r7, #28]
   19a9a:	0092      	lsls	r2, r2, #2
   19a9c:	58d3      	ldr	r3, [r2, r3]
   19a9e:	61bb      	str	r3, [r7, #24]

	if (cfs) {
   19aa0:	69bb      	ldr	r3, [r7, #24]
   19aa2:	2b00      	cmp	r3, #0
   19aa4:	d002      	beq.n	19aac <f_mount+0x40>
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
   19aa6:	69bb      	ldr	r3, [r7, #24]
   19aa8:	2200      	movs	r2, #0
   19aaa:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
   19aac:	68fb      	ldr	r3, [r7, #12]
   19aae:	2b00      	cmp	r3, #0
   19ab0:	d002      	beq.n	19ab8 <f_mount+0x4c>
		fs->fs_type = 0;				/* Clear new fs object */
   19ab2:	68fb      	ldr	r3, [r7, #12]
   19ab4:	2200      	movs	r2, #0
   19ab6:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
   19ab8:	68f9      	ldr	r1, [r7, #12]
   19aba:	4b11      	ldr	r3, [pc, #68]	; (19b00 <f_mount+0x94>)
   19abc:	69fa      	ldr	r2, [r7, #28]
   19abe:	0092      	lsls	r2, r2, #2
   19ac0:	50d1      	str	r1, [r2, r3]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
   19ac2:	68fb      	ldr	r3, [r7, #12]
   19ac4:	2b00      	cmp	r3, #0
   19ac6:	d003      	beq.n	19ad0 <f_mount+0x64>
   19ac8:	1dfb      	adds	r3, r7, #7
   19aca:	781b      	ldrb	r3, [r3, #0]
   19acc:	2b01      	cmp	r3, #1
   19ace:	d001      	beq.n	19ad4 <f_mount+0x68>
   19ad0:	2300      	movs	r3, #0
   19ad2:	e00e      	b.n	19af2 <f_mount+0x86>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
   19ad4:	2317      	movs	r3, #23
   19ad6:	18fc      	adds	r4, r7, r3
   19ad8:	2308      	movs	r3, #8
   19ada:	18f9      	adds	r1, r7, r3
   19adc:	230c      	movs	r3, #12
   19ade:	18fb      	adds	r3, r7, r3
   19ae0:	2200      	movs	r2, #0
   19ae2:	0018      	movs	r0, r3
   19ae4:	4b07      	ldr	r3, [pc, #28]	; (19b04 <f_mount+0x98>)
   19ae6:	4798      	blx	r3
   19ae8:	0003      	movs	r3, r0
   19aea:	7023      	strb	r3, [r4, #0]
	LEAVE_FF(fs, res);
   19aec:	2317      	movs	r3, #23
   19aee:	18fb      	adds	r3, r7, r3
   19af0:	781b      	ldrb	r3, [r3, #0]
}
   19af2:	0018      	movs	r0, r3
   19af4:	46bd      	mov	sp, r7
   19af6:	b009      	add	sp, #36	; 0x24
   19af8:	bd90      	pop	{r4, r7, pc}
   19afa:	46c0      	nop			; (mov r8, r8)
   19afc:	000192c1 	.word	0x000192c1
   19b00:	20002e6c 	.word	0x20002e6c
   19b04:	00019421 	.word	0x00019421

00019b08 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
   19b08:	b590      	push	{r4, r7, lr}
   19b0a:	b095      	sub	sp, #84	; 0x54
   19b0c:	af00      	add	r7, sp, #0
   19b0e:	60f8      	str	r0, [r7, #12]
   19b10:	60b9      	str	r1, [r7, #8]
   19b12:	1dfb      	adds	r3, r7, #7
   19b14:	701a      	strb	r2, [r3, #0]
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
   19b16:	68fb      	ldr	r3, [r7, #12]
   19b18:	2b00      	cmp	r3, #0
   19b1a:	d101      	bne.n	19b20 <f_open+0x18>
   19b1c:	2309      	movs	r3, #9
   19b1e:	e185      	b.n	19e2c <f_open+0x324>
	fp->fs = 0;			/* Clear file object */
   19b20:	68fb      	ldr	r3, [r7, #12]
   19b22:	2200      	movs	r2, #0
   19b24:	601a      	str	r2, [r3, #0]

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   19b26:	1dfb      	adds	r3, r7, #7
   19b28:	1dfa      	adds	r2, r7, #7
   19b2a:	7812      	ldrb	r2, [r2, #0]
   19b2c:	211f      	movs	r1, #31
   19b2e:	400a      	ands	r2, r1
   19b30:	701a      	strb	r2, [r3, #0]
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
   19b32:	1dfb      	adds	r3, r7, #7
   19b34:	781b      	ldrb	r3, [r3, #0]
   19b36:	2201      	movs	r2, #1
   19b38:	4393      	bics	r3, r2
   19b3a:	b2da      	uxtb	r2, r3
   19b3c:	234f      	movs	r3, #79	; 0x4f
   19b3e:	18fc      	adds	r4, r7, r3
   19b40:	2308      	movs	r3, #8
   19b42:	18f9      	adds	r1, r7, r3
   19b44:	231c      	movs	r3, #28
   19b46:	18fb      	adds	r3, r7, r3
   19b48:	0018      	movs	r0, r3
   19b4a:	4bba      	ldr	r3, [pc, #744]	; (19e34 <f_open+0x32c>)
   19b4c:	4798      	blx	r3
   19b4e:	0003      	movs	r3, r0
   19b50:	7023      	strb	r3, [r4, #0]
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
   19b52:	234f      	movs	r3, #79	; 0x4f
   19b54:	18fb      	adds	r3, r7, r3
   19b56:	781b      	ldrb	r3, [r3, #0]
   19b58:	2b00      	cmp	r3, #0
   19b5a:	d000      	beq.n	19b5e <f_open+0x56>
   19b5c:	e163      	b.n	19e26 <f_open+0x31e>
		INIT_BUF(dj);
   19b5e:	231c      	movs	r3, #28
   19b60:	18fb      	adds	r3, r7, r3
   19b62:	2210      	movs	r2, #16
   19b64:	18ba      	adds	r2, r7, r2
   19b66:	619a      	str	r2, [r3, #24]
   19b68:	231c      	movs	r3, #28
   19b6a:	18fb      	adds	r3, r7, r3
   19b6c:	4ab2      	ldr	r2, [pc, #712]	; (19e38 <f_open+0x330>)
   19b6e:	61da      	str	r2, [r3, #28]
		res = follow_path(&dj, path);	/* Follow the file path */
   19b70:	68ba      	ldr	r2, [r7, #8]
   19b72:	234f      	movs	r3, #79	; 0x4f
   19b74:	18fc      	adds	r4, r7, r3
   19b76:	231c      	movs	r3, #28
   19b78:	18fb      	adds	r3, r7, r3
   19b7a:	0011      	movs	r1, r2
   19b7c:	0018      	movs	r0, r3
   19b7e:	4baf      	ldr	r3, [pc, #700]	; (19e3c <f_open+0x334>)
   19b80:	4798      	blx	r3
   19b82:	0003      	movs	r3, r0
   19b84:	7023      	strb	r3, [r4, #0]
		dir = dj.dir;
   19b86:	231c      	movs	r3, #28
   19b88:	18fb      	adds	r3, r7, r3
   19b8a:	695b      	ldr	r3, [r3, #20]
   19b8c:	64bb      	str	r3, [r7, #72]	; 0x48
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
   19b8e:	234f      	movs	r3, #79	; 0x4f
   19b90:	18fb      	adds	r3, r7, r3
   19b92:	781b      	ldrb	r3, [r3, #0]
   19b94:	2b00      	cmp	r3, #0
   19b96:	d106      	bne.n	19ba6 <f_open+0x9e>
			if (!dir)	/* Default directory itself */
   19b98:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19b9a:	2b00      	cmp	r3, #0
   19b9c:	d103      	bne.n	19ba6 <f_open+0x9e>
				res = FR_INVALID_NAME;
   19b9e:	234f      	movs	r3, #79	; 0x4f
   19ba0:	18fb      	adds	r3, r7, r3
   19ba2:	2206      	movs	r2, #6
   19ba4:	701a      	strb	r2, [r3, #0]
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   19ba6:	1dfb      	adds	r3, r7, #7
   19ba8:	781b      	ldrb	r3, [r3, #0]
   19baa:	221c      	movs	r2, #28
   19bac:	4013      	ands	r3, r2
   19bae:	d100      	bne.n	19bb2 <f_open+0xaa>
   19bb0:	e0c4      	b.n	19d3c <f_open+0x234>
			if (res != FR_OK) {					/* No file, create new */
   19bb2:	234f      	movs	r3, #79	; 0x4f
   19bb4:	18fb      	adds	r3, r7, r3
   19bb6:	781b      	ldrb	r3, [r3, #0]
   19bb8:	2b00      	cmp	r3, #0
   19bba:	d018      	beq.n	19bee <f_open+0xe6>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   19bbc:	234f      	movs	r3, #79	; 0x4f
   19bbe:	18fb      	adds	r3, r7, r3
   19bc0:	781b      	ldrb	r3, [r3, #0]
   19bc2:	2b04      	cmp	r3, #4
   19bc4:	d108      	bne.n	19bd8 <f_open+0xd0>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
   19bc6:	234f      	movs	r3, #79	; 0x4f
   19bc8:	18fc      	adds	r4, r7, r3
   19bca:	231c      	movs	r3, #28
   19bcc:	18fb      	adds	r3, r7, r3
   19bce:	0018      	movs	r0, r3
   19bd0:	4b9b      	ldr	r3, [pc, #620]	; (19e40 <f_open+0x338>)
   19bd2:	4798      	blx	r3
   19bd4:	0003      	movs	r3, r0
   19bd6:	7023      	strb	r3, [r4, #0]
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
   19bd8:	1dfb      	adds	r3, r7, #7
   19bda:	1dfa      	adds	r2, r7, #7
   19bdc:	7812      	ldrb	r2, [r2, #0]
   19bde:	2108      	movs	r1, #8
   19be0:	430a      	orrs	r2, r1
   19be2:	701a      	strb	r2, [r3, #0]
				dir = dj.dir;					/* New entry */
   19be4:	231c      	movs	r3, #28
   19be6:	18fb      	adds	r3, r7, r3
   19be8:	695b      	ldr	r3, [r3, #20]
   19bea:	64bb      	str	r3, [r7, #72]	; 0x48
   19bec:	e014      	b.n	19c18 <f_open+0x110>
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   19bee:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19bf0:	330b      	adds	r3, #11
   19bf2:	781b      	ldrb	r3, [r3, #0]
   19bf4:	001a      	movs	r2, r3
   19bf6:	2311      	movs	r3, #17
   19bf8:	4013      	ands	r3, r2
   19bfa:	d004      	beq.n	19c06 <f_open+0xfe>
					res = FR_DENIED;
   19bfc:	234f      	movs	r3, #79	; 0x4f
   19bfe:	18fb      	adds	r3, r7, r3
   19c00:	2207      	movs	r2, #7
   19c02:	701a      	strb	r2, [r3, #0]
   19c04:	e008      	b.n	19c18 <f_open+0x110>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   19c06:	1dfb      	adds	r3, r7, #7
   19c08:	781b      	ldrb	r3, [r3, #0]
   19c0a:	2204      	movs	r2, #4
   19c0c:	4013      	ands	r3, r2
   19c0e:	d003      	beq.n	19c18 <f_open+0x110>
						res = FR_EXIST;
   19c10:	234f      	movs	r3, #79	; 0x4f
   19c12:	18fb      	adds	r3, r7, r3
   19c14:	2208      	movs	r2, #8
   19c16:	701a      	strb	r2, [r3, #0]
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   19c18:	234f      	movs	r3, #79	; 0x4f
   19c1a:	18fb      	adds	r3, r7, r3
   19c1c:	781b      	ldrb	r3, [r3, #0]
   19c1e:	2b00      	cmp	r3, #0
   19c20:	d000      	beq.n	19c24 <f_open+0x11c>
   19c22:	e0ac      	b.n	19d7e <f_open+0x276>
   19c24:	1dfb      	adds	r3, r7, #7
   19c26:	781b      	ldrb	r3, [r3, #0]
   19c28:	2208      	movs	r2, #8
   19c2a:	4013      	ands	r3, r2
   19c2c:	d100      	bne.n	19c30 <f_open+0x128>
   19c2e:	e0a6      	b.n	19d7e <f_open+0x276>
				dw = GET_FATTIME();
   19c30:	4b84      	ldr	r3, [pc, #528]	; (19e44 <f_open+0x33c>)
   19c32:	4798      	blx	r3
   19c34:	0003      	movs	r3, r0
   19c36:	647b      	str	r3, [r7, #68]	; 0x44
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
   19c38:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c3a:	330e      	adds	r3, #14
   19c3c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   19c3e:	b2d2      	uxtb	r2, r2
   19c40:	701a      	strb	r2, [r3, #0]
   19c42:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c44:	330f      	adds	r3, #15
   19c46:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   19c48:	1212      	asrs	r2, r2, #8
   19c4a:	b2d2      	uxtb	r2, r2
   19c4c:	701a      	strb	r2, [r3, #0]
   19c4e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c50:	3310      	adds	r3, #16
   19c52:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   19c54:	0c12      	lsrs	r2, r2, #16
   19c56:	b2d2      	uxtb	r2, r2
   19c58:	701a      	strb	r2, [r3, #0]
   19c5a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c5c:	3311      	adds	r3, #17
   19c5e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   19c60:	0e12      	lsrs	r2, r2, #24
   19c62:	b2d2      	uxtb	r2, r2
   19c64:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
   19c66:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c68:	3316      	adds	r3, #22
   19c6a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   19c6c:	b2d2      	uxtb	r2, r2
   19c6e:	701a      	strb	r2, [r3, #0]
   19c70:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c72:	3317      	adds	r3, #23
   19c74:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   19c76:	1212      	asrs	r2, r2, #8
   19c78:	b2d2      	uxtb	r2, r2
   19c7a:	701a      	strb	r2, [r3, #0]
   19c7c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c7e:	3318      	adds	r3, #24
   19c80:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   19c82:	0c12      	lsrs	r2, r2, #16
   19c84:	b2d2      	uxtb	r2, r2
   19c86:	701a      	strb	r2, [r3, #0]
   19c88:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c8a:	3319      	adds	r3, #25
   19c8c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   19c8e:	0e12      	lsrs	r2, r2, #24
   19c90:	b2d2      	uxtb	r2, r2
   19c92:	701a      	strb	r2, [r3, #0]
				dir[DIR_Attr] = 0;				/* Reset attribute */
   19c94:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c96:	330b      	adds	r3, #11
   19c98:	2200      	movs	r2, #0
   19c9a:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
   19c9c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19c9e:	331c      	adds	r3, #28
   19ca0:	2200      	movs	r2, #0
   19ca2:	701a      	strb	r2, [r3, #0]
   19ca4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19ca6:	331d      	adds	r3, #29
   19ca8:	2200      	movs	r2, #0
   19caa:	701a      	strb	r2, [r3, #0]
   19cac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19cae:	331e      	adds	r3, #30
   19cb0:	2200      	movs	r2, #0
   19cb2:	701a      	strb	r2, [r3, #0]
   19cb4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19cb6:	331f      	adds	r3, #31
   19cb8:	2200      	movs	r2, #0
   19cba:	701a      	strb	r2, [r3, #0]
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
   19cbc:	231c      	movs	r3, #28
   19cbe:	18fb      	adds	r3, r7, r3
   19cc0:	681b      	ldr	r3, [r3, #0]
   19cc2:	6cba      	ldr	r2, [r7, #72]	; 0x48
   19cc4:	0011      	movs	r1, r2
   19cc6:	0018      	movs	r0, r3
   19cc8:	4b5f      	ldr	r3, [pc, #380]	; (19e48 <f_open+0x340>)
   19cca:	4798      	blx	r3
   19ccc:	0003      	movs	r3, r0
   19cce:	643b      	str	r3, [r7, #64]	; 0x40
				st_clust(dir, 0);				/* Reset cluster */
   19cd0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19cd2:	2100      	movs	r1, #0
   19cd4:	0018      	movs	r0, r3
   19cd6:	4b5d      	ldr	r3, [pc, #372]	; (19e4c <f_open+0x344>)
   19cd8:	4798      	blx	r3
				dj.fs->wflag = 1;
   19cda:	231c      	movs	r3, #28
   19cdc:	18fb      	adds	r3, r7, r3
   19cde:	681b      	ldr	r3, [r3, #0]
   19ce0:	2201      	movs	r2, #1
   19ce2:	711a      	strb	r2, [r3, #4]
				if (cl) {						/* Remove the cluster chain if exist */
   19ce4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   19ce6:	2b00      	cmp	r3, #0
   19ce8:	d049      	beq.n	19d7e <f_open+0x276>
					dw = dj.fs->winsect;
   19cea:	231c      	movs	r3, #28
   19cec:	18fb      	adds	r3, r7, r3
   19cee:	681b      	ldr	r3, [r3, #0]
   19cf0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   19cf2:	647b      	str	r3, [r7, #68]	; 0x44
					res = remove_chain(dj.fs, cl);
   19cf4:	231c      	movs	r3, #28
   19cf6:	18fb      	adds	r3, r7, r3
   19cf8:	681b      	ldr	r3, [r3, #0]
   19cfa:	224f      	movs	r2, #79	; 0x4f
   19cfc:	18bc      	adds	r4, r7, r2
   19cfe:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   19d00:	0011      	movs	r1, r2
   19d02:	0018      	movs	r0, r3
   19d04:	4b52      	ldr	r3, [pc, #328]	; (19e50 <f_open+0x348>)
   19d06:	4798      	blx	r3
   19d08:	0003      	movs	r3, r0
   19d0a:	7023      	strb	r3, [r4, #0]
					if (res == FR_OK) {
   19d0c:	234f      	movs	r3, #79	; 0x4f
   19d0e:	18fb      	adds	r3, r7, r3
   19d10:	781b      	ldrb	r3, [r3, #0]
   19d12:	2b00      	cmp	r3, #0
   19d14:	d133      	bne.n	19d7e <f_open+0x276>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   19d16:	231c      	movs	r3, #28
   19d18:	18fb      	adds	r3, r7, r3
   19d1a:	681b      	ldr	r3, [r3, #0]
   19d1c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   19d1e:	3a01      	subs	r2, #1
   19d20:	60da      	str	r2, [r3, #12]
						res = move_window(dj.fs, dw);
   19d22:	231c      	movs	r3, #28
   19d24:	18fb      	adds	r3, r7, r3
   19d26:	681b      	ldr	r3, [r3, #0]
   19d28:	224f      	movs	r2, #79	; 0x4f
   19d2a:	18bc      	adds	r4, r7, r2
   19d2c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   19d2e:	0011      	movs	r1, r2
   19d30:	0018      	movs	r0, r3
   19d32:	4b48      	ldr	r3, [pc, #288]	; (19e54 <f_open+0x34c>)
   19d34:	4798      	blx	r3
   19d36:	0003      	movs	r3, r0
   19d38:	7023      	strb	r3, [r4, #0]
   19d3a:	e020      	b.n	19d7e <f_open+0x276>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
   19d3c:	234f      	movs	r3, #79	; 0x4f
   19d3e:	18fb      	adds	r3, r7, r3
   19d40:	781b      	ldrb	r3, [r3, #0]
   19d42:	2b00      	cmp	r3, #0
   19d44:	d11b      	bne.n	19d7e <f_open+0x276>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
   19d46:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19d48:	330b      	adds	r3, #11
   19d4a:	781b      	ldrb	r3, [r3, #0]
   19d4c:	001a      	movs	r2, r3
   19d4e:	2310      	movs	r3, #16
   19d50:	4013      	ands	r3, r2
   19d52:	d004      	beq.n	19d5e <f_open+0x256>
					res = FR_NO_FILE;
   19d54:	234f      	movs	r3, #79	; 0x4f
   19d56:	18fb      	adds	r3, r7, r3
   19d58:	2204      	movs	r2, #4
   19d5a:	701a      	strb	r2, [r3, #0]
   19d5c:	e00f      	b.n	19d7e <f_open+0x276>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   19d5e:	1dfb      	adds	r3, r7, #7
   19d60:	781b      	ldrb	r3, [r3, #0]
   19d62:	2202      	movs	r2, #2
   19d64:	4013      	ands	r3, r2
   19d66:	d00a      	beq.n	19d7e <f_open+0x276>
   19d68:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19d6a:	330b      	adds	r3, #11
   19d6c:	781b      	ldrb	r3, [r3, #0]
   19d6e:	001a      	movs	r2, r3
   19d70:	2301      	movs	r3, #1
   19d72:	4013      	ands	r3, r2
   19d74:	d003      	beq.n	19d7e <f_open+0x276>
						res = FR_DENIED;
   19d76:	234f      	movs	r3, #79	; 0x4f
   19d78:	18fb      	adds	r3, r7, r3
   19d7a:	2207      	movs	r2, #7
   19d7c:	701a      	strb	r2, [r3, #0]
				}
			}
		}
		if (res == FR_OK) {
   19d7e:	234f      	movs	r3, #79	; 0x4f
   19d80:	18fb      	adds	r3, r7, r3
   19d82:	781b      	ldrb	r3, [r3, #0]
   19d84:	2b00      	cmp	r3, #0
   19d86:	d113      	bne.n	19db0 <f_open+0x2a8>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
   19d88:	1dfb      	adds	r3, r7, #7
   19d8a:	781b      	ldrb	r3, [r3, #0]
   19d8c:	2208      	movs	r2, #8
   19d8e:	4013      	ands	r3, r2
   19d90:	d005      	beq.n	19d9e <f_open+0x296>
				mode |= FA__WRITTEN;
   19d92:	1dfb      	adds	r3, r7, #7
   19d94:	1dfa      	adds	r2, r7, #7
   19d96:	7812      	ldrb	r2, [r2, #0]
   19d98:	2120      	movs	r1, #32
   19d9a:	430a      	orrs	r2, r1
   19d9c:	701a      	strb	r2, [r3, #0]
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
   19d9e:	231c      	movs	r3, #28
   19da0:	18fb      	adds	r3, r7, r3
   19da2:	681b      	ldr	r3, [r3, #0]
   19da4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   19da6:	68fb      	ldr	r3, [r7, #12]
   19da8:	61da      	str	r2, [r3, #28]
			fp->dir_ptr = dir;
   19daa:	68fb      	ldr	r3, [r7, #12]
   19dac:	6cba      	ldr	r2, [r7, #72]	; 0x48
   19dae:	621a      	str	r2, [r3, #32]
			}
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
   19db0:	234f      	movs	r3, #79	; 0x4f
   19db2:	18fb      	adds	r3, r7, r3
   19db4:	781b      	ldrb	r3, [r3, #0]
   19db6:	2b00      	cmp	r3, #0
   19db8:	d135      	bne.n	19e26 <f_open+0x31e>
			fp->flag = mode;					/* File access mode */
   19dba:	68fb      	ldr	r3, [r7, #12]
   19dbc:	1dfa      	adds	r2, r7, #7
   19dbe:	7812      	ldrb	r2, [r2, #0]
   19dc0:	719a      	strb	r2, [r3, #6]
			fp->err = 0;						/* Clear error flag */
   19dc2:	68fb      	ldr	r3, [r7, #12]
   19dc4:	2200      	movs	r2, #0
   19dc6:	71da      	strb	r2, [r3, #7]
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
   19dc8:	231c      	movs	r3, #28
   19dca:	18fb      	adds	r3, r7, r3
   19dcc:	681b      	ldr	r3, [r3, #0]
   19dce:	6cba      	ldr	r2, [r7, #72]	; 0x48
   19dd0:	0011      	movs	r1, r2
   19dd2:	0018      	movs	r0, r3
   19dd4:	4b1c      	ldr	r3, [pc, #112]	; (19e48 <f_open+0x340>)
   19dd6:	4798      	blx	r3
   19dd8:	0002      	movs	r2, r0
   19dda:	68fb      	ldr	r3, [r7, #12]
   19ddc:	611a      	str	r2, [r3, #16]
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
   19dde:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19de0:	331f      	adds	r3, #31
   19de2:	781b      	ldrb	r3, [r3, #0]
   19de4:	061a      	lsls	r2, r3, #24
   19de6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   19de8:	331e      	adds	r3, #30
   19dea:	781b      	ldrb	r3, [r3, #0]
   19dec:	041b      	lsls	r3, r3, #16
   19dee:	4313      	orrs	r3, r2
   19df0:	6cba      	ldr	r2, [r7, #72]	; 0x48
   19df2:	321d      	adds	r2, #29
   19df4:	7812      	ldrb	r2, [r2, #0]
   19df6:	0212      	lsls	r2, r2, #8
   19df8:	4313      	orrs	r3, r2
   19dfa:	6cba      	ldr	r2, [r7, #72]	; 0x48
   19dfc:	321c      	adds	r2, #28
   19dfe:	7812      	ldrb	r2, [r2, #0]
   19e00:	431a      	orrs	r2, r3
   19e02:	68fb      	ldr	r3, [r7, #12]
   19e04:	60da      	str	r2, [r3, #12]
			fp->fptr = 0;						/* File pointer */
   19e06:	68fb      	ldr	r3, [r7, #12]
   19e08:	2200      	movs	r2, #0
   19e0a:	609a      	str	r2, [r3, #8]
			fp->dsect = 0;
   19e0c:	68fb      	ldr	r3, [r7, #12]
   19e0e:	2200      	movs	r2, #0
   19e10:	619a      	str	r2, [r3, #24]
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
   19e12:	231c      	movs	r3, #28
   19e14:	18fb      	adds	r3, r7, r3
   19e16:	681a      	ldr	r2, [r3, #0]
   19e18:	68fb      	ldr	r3, [r7, #12]
   19e1a:	601a      	str	r2, [r3, #0]
			fp->id = fp->fs->id;
   19e1c:	68fb      	ldr	r3, [r7, #12]
   19e1e:	681b      	ldr	r3, [r3, #0]
   19e20:	88da      	ldrh	r2, [r3, #6]
   19e22:	68fb      	ldr	r3, [r7, #12]
   19e24:	809a      	strh	r2, [r3, #4]
		}
	}

	LEAVE_FF(dj.fs, res);
   19e26:	234f      	movs	r3, #79	; 0x4f
   19e28:	18fb      	adds	r3, r7, r3
   19e2a:	781b      	ldrb	r3, [r3, #0]
}
   19e2c:	0018      	movs	r0, r3
   19e2e:	46bd      	mov	sp, r7
   19e30:	b015      	add	sp, #84	; 0x54
   19e32:	bd90      	pop	{r4, r7, pc}
   19e34:	00019421 	.word	0x00019421
   19e38:	20002e90 	.word	0x20002e90
   19e3c:	000191ad 	.word	0x000191ad
   19e40:	00018a29 	.word	0x00018a29
   19e44:	00017379 	.word	0x00017379
   19e48:	000180f9 	.word	0x000180f9
   19e4c:	00018151 	.word	0x00018151
   19e50:	00017b55 	.word	0x00017b55
   19e54:	00017555 	.word	0x00017555

00019e58 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
   19e58:	b590      	push	{r4, r7, lr}
   19e5a:	b08d      	sub	sp, #52	; 0x34
   19e5c:	af00      	add	r7, sp, #0
   19e5e:	60f8      	str	r0, [r7, #12]
   19e60:	60b9      	str	r1, [r7, #8]
   19e62:	607a      	str	r2, [r7, #4]
   19e64:	603b      	str	r3, [r7, #0]
	FRESULT res;
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;
   19e66:	68bb      	ldr	r3, [r7, #8]
   19e68:	623b      	str	r3, [r7, #32]


	*br = 0;	/* Clear read byte counter */
   19e6a:	683b      	ldr	r3, [r7, #0]
   19e6c:	2200      	movs	r2, #0
   19e6e:	601a      	str	r2, [r3, #0]

	res = validate(fp);							/* Check validity */
   19e70:	231f      	movs	r3, #31
   19e72:	18fc      	adds	r4, r7, r3
   19e74:	68fb      	ldr	r3, [r7, #12]
   19e76:	0018      	movs	r0, r3
   19e78:	4b9b      	ldr	r3, [pc, #620]	; (1a0e8 <f_read+0x290>)
   19e7a:	4798      	blx	r3
   19e7c:	0003      	movs	r3, r0
   19e7e:	7023      	strb	r3, [r4, #0]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   19e80:	231f      	movs	r3, #31
   19e82:	18fb      	adds	r3, r7, r3
   19e84:	781b      	ldrb	r3, [r3, #0]
   19e86:	2b00      	cmp	r3, #0
   19e88:	d003      	beq.n	19e92 <f_read+0x3a>
   19e8a:	231f      	movs	r3, #31
   19e8c:	18fb      	adds	r3, r7, r3
   19e8e:	781b      	ldrb	r3, [r3, #0]
   19e90:	e125      	b.n	1a0de <f_read+0x286>
	if (fp->err)								/* Check error */
   19e92:	68fb      	ldr	r3, [r7, #12]
   19e94:	79db      	ldrb	r3, [r3, #7]
   19e96:	2b00      	cmp	r3, #0
   19e98:	d002      	beq.n	19ea0 <f_read+0x48>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   19e9a:	68fb      	ldr	r3, [r7, #12]
   19e9c:	79db      	ldrb	r3, [r3, #7]
   19e9e:	e11e      	b.n	1a0de <f_read+0x286>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   19ea0:	68fb      	ldr	r3, [r7, #12]
   19ea2:	799b      	ldrb	r3, [r3, #6]
   19ea4:	001a      	movs	r2, r3
   19ea6:	2301      	movs	r3, #1
   19ea8:	4013      	ands	r3, r2
   19eaa:	d101      	bne.n	19eb0 <f_read+0x58>
		LEAVE_FF(fp->fs, FR_DENIED);
   19eac:	2307      	movs	r3, #7
   19eae:	e116      	b.n	1a0de <f_read+0x286>
	remain = fp->fsize - fp->fptr;
   19eb0:	68fb      	ldr	r3, [r7, #12]
   19eb2:	68da      	ldr	r2, [r3, #12]
   19eb4:	68fb      	ldr	r3, [r7, #12]
   19eb6:	689b      	ldr	r3, [r3, #8]
   19eb8:	1ad3      	subs	r3, r2, r3
   19eba:	61bb      	str	r3, [r7, #24]
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   19ebc:	687a      	ldr	r2, [r7, #4]
   19ebe:	69bb      	ldr	r3, [r7, #24]
   19ec0:	429a      	cmp	r2, r3
   19ec2:	d800      	bhi.n	19ec6 <f_read+0x6e>
   19ec4:	e106      	b.n	1a0d4 <f_read+0x27c>
   19ec6:	69bb      	ldr	r3, [r7, #24]
   19ec8:	607b      	str	r3, [r7, #4]

	for ( ;  btr;								/* Repeat until all data read */
   19eca:	e103      	b.n	1a0d4 <f_read+0x27c>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   19ecc:	68fb      	ldr	r3, [r7, #12]
   19ece:	689b      	ldr	r3, [r3, #8]
   19ed0:	05db      	lsls	r3, r3, #23
   19ed2:	0ddb      	lsrs	r3, r3, #23
   19ed4:	d000      	beq.n	19ed8 <f_read+0x80>
   19ed6:	e0ce      	b.n	1a076 <f_read+0x21e>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   19ed8:	68fb      	ldr	r3, [r7, #12]
   19eda:	689b      	ldr	r3, [r3, #8]
   19edc:	0a5b      	lsrs	r3, r3, #9
   19ede:	b2da      	uxtb	r2, r3
   19ee0:	68fb      	ldr	r3, [r7, #12]
   19ee2:	681b      	ldr	r3, [r3, #0]
   19ee4:	789b      	ldrb	r3, [r3, #2]
   19ee6:	3b01      	subs	r3, #1
   19ee8:	b2d9      	uxtb	r1, r3
   19eea:	2317      	movs	r3, #23
   19eec:	18fb      	adds	r3, r7, r3
   19eee:	400a      	ands	r2, r1
   19ef0:	701a      	strb	r2, [r3, #0]
			if (!csect) {						/* On the cluster boundary? */
   19ef2:	2317      	movs	r3, #23
   19ef4:	18fb      	adds	r3, r7, r3
   19ef6:	781b      	ldrb	r3, [r3, #0]
   19ef8:	2b00      	cmp	r3, #0
   19efa:	d124      	bne.n	19f46 <f_read+0xee>
				if (fp->fptr == 0) {			/* On the top of the file? */
   19efc:	68fb      	ldr	r3, [r7, #12]
   19efe:	689b      	ldr	r3, [r3, #8]
   19f00:	2b00      	cmp	r3, #0
   19f02:	d103      	bne.n	19f0c <f_read+0xb4>
					clst = fp->sclust;			/* Follow from the origin */
   19f04:	68fb      	ldr	r3, [r7, #12]
   19f06:	691b      	ldr	r3, [r3, #16]
   19f08:	62fb      	str	r3, [r7, #44]	; 0x2c
   19f0a:	e009      	b.n	19f20 <f_read+0xc8>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   19f0c:	68fb      	ldr	r3, [r7, #12]
   19f0e:	681a      	ldr	r2, [r3, #0]
   19f10:	68fb      	ldr	r3, [r7, #12]
   19f12:	695b      	ldr	r3, [r3, #20]
   19f14:	0019      	movs	r1, r3
   19f16:	0010      	movs	r0, r2
   19f18:	4b74      	ldr	r3, [pc, #464]	; (1a0ec <f_read+0x294>)
   19f1a:	4798      	blx	r3
   19f1c:	0003      	movs	r3, r0
   19f1e:	62fb      	str	r3, [r7, #44]	; 0x2c
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   19f20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   19f22:	2b01      	cmp	r3, #1
   19f24:	d804      	bhi.n	19f30 <f_read+0xd8>
   19f26:	68fb      	ldr	r3, [r7, #12]
   19f28:	2202      	movs	r2, #2
   19f2a:	71da      	strb	r2, [r3, #7]
   19f2c:	2302      	movs	r3, #2
   19f2e:	e0d6      	b.n	1a0de <f_read+0x286>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   19f30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   19f32:	3301      	adds	r3, #1
   19f34:	d104      	bne.n	19f40 <f_read+0xe8>
   19f36:	68fb      	ldr	r3, [r7, #12]
   19f38:	2201      	movs	r2, #1
   19f3a:	71da      	strb	r2, [r3, #7]
   19f3c:	2301      	movs	r3, #1
   19f3e:	e0ce      	b.n	1a0de <f_read+0x286>
				fp->clust = clst;				/* Update current cluster */
   19f40:	68fb      	ldr	r3, [r7, #12]
   19f42:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   19f44:	615a      	str	r2, [r3, #20]
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   19f46:	68fb      	ldr	r3, [r7, #12]
   19f48:	681a      	ldr	r2, [r3, #0]
   19f4a:	68fb      	ldr	r3, [r7, #12]
   19f4c:	695b      	ldr	r3, [r3, #20]
   19f4e:	0019      	movs	r1, r3
   19f50:	0010      	movs	r0, r2
   19f52:	4b67      	ldr	r3, [pc, #412]	; (1a0f0 <f_read+0x298>)
   19f54:	4798      	blx	r3
   19f56:	0003      	movs	r3, r0
   19f58:	613b      	str	r3, [r7, #16]
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   19f5a:	693b      	ldr	r3, [r7, #16]
   19f5c:	2b00      	cmp	r3, #0
   19f5e:	d104      	bne.n	19f6a <f_read+0x112>
   19f60:	68fb      	ldr	r3, [r7, #12]
   19f62:	2202      	movs	r2, #2
   19f64:	71da      	strb	r2, [r3, #7]
   19f66:	2302      	movs	r3, #2
   19f68:	e0b9      	b.n	1a0de <f_read+0x286>
			sect += csect;
   19f6a:	2317      	movs	r3, #23
   19f6c:	18fb      	adds	r3, r7, r3
   19f6e:	781b      	ldrb	r3, [r3, #0]
   19f70:	693a      	ldr	r2, [r7, #16]
   19f72:	18d3      	adds	r3, r2, r3
   19f74:	613b      	str	r3, [r7, #16]
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   19f76:	687b      	ldr	r3, [r7, #4]
   19f78:	0a5b      	lsrs	r3, r3, #9
   19f7a:	627b      	str	r3, [r7, #36]	; 0x24
			if (cc) {							/* Read maximum contiguous sectors directly */
   19f7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   19f7e:	2b00      	cmp	r3, #0
   19f80:	d041      	beq.n	1a006 <f_read+0x1ae>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   19f82:	2317      	movs	r3, #23
   19f84:	18fb      	adds	r3, r7, r3
   19f86:	781a      	ldrb	r2, [r3, #0]
   19f88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   19f8a:	18d2      	adds	r2, r2, r3
   19f8c:	68fb      	ldr	r3, [r7, #12]
   19f8e:	681b      	ldr	r3, [r3, #0]
   19f90:	789b      	ldrb	r3, [r3, #2]
   19f92:	429a      	cmp	r2, r3
   19f94:	d908      	bls.n	19fa8 <f_read+0x150>
					cc = fp->fs->csize - csect;
   19f96:	68fb      	ldr	r3, [r7, #12]
   19f98:	681b      	ldr	r3, [r3, #0]
   19f9a:	789b      	ldrb	r3, [r3, #2]
   19f9c:	001a      	movs	r2, r3
   19f9e:	2317      	movs	r3, #23
   19fa0:	18fb      	adds	r3, r7, r3
   19fa2:	781b      	ldrb	r3, [r3, #0]
   19fa4:	1ad3      	subs	r3, r2, r3
   19fa6:	627b      	str	r3, [r7, #36]	; 0x24
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
   19fa8:	68fb      	ldr	r3, [r7, #12]
   19faa:	681b      	ldr	r3, [r3, #0]
   19fac:	7858      	ldrb	r0, [r3, #1]
   19fae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   19fb0:	693a      	ldr	r2, [r7, #16]
   19fb2:	6a39      	ldr	r1, [r7, #32]
   19fb4:	4c4f      	ldr	r4, [pc, #316]	; (1a0f4 <f_read+0x29c>)
   19fb6:	47a0      	blx	r4
   19fb8:	1e03      	subs	r3, r0, #0
   19fba:	d004      	beq.n	19fc6 <f_read+0x16e>
					ABORT(fp->fs, FR_DISK_ERR);
   19fbc:	68fb      	ldr	r3, [r7, #12]
   19fbe:	2201      	movs	r2, #1
   19fc0:	71da      	strb	r2, [r3, #7]
   19fc2:	2301      	movs	r3, #1
   19fc4:	e08b      	b.n	1a0de <f_read+0x286>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   19fc6:	68fb      	ldr	r3, [r7, #12]
   19fc8:	799b      	ldrb	r3, [r3, #6]
   19fca:	001a      	movs	r2, r3
   19fcc:	2340      	movs	r3, #64	; 0x40
   19fce:	4013      	ands	r3, r2
   19fd0:	d015      	beq.n	19ffe <f_read+0x1a6>
   19fd2:	68fb      	ldr	r3, [r7, #12]
   19fd4:	699a      	ldr	r2, [r3, #24]
   19fd6:	693b      	ldr	r3, [r7, #16]
   19fd8:	1ad2      	subs	r2, r2, r3
   19fda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   19fdc:	429a      	cmp	r2, r3
   19fde:	d20e      	bcs.n	19ffe <f_read+0x1a6>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   19fe0:	68fb      	ldr	r3, [r7, #12]
   19fe2:	699a      	ldr	r2, [r3, #24]
   19fe4:	693b      	ldr	r3, [r7, #16]
   19fe6:	1ad3      	subs	r3, r2, r3
   19fe8:	025b      	lsls	r3, r3, #9
   19fea:	6a3a      	ldr	r2, [r7, #32]
   19fec:	18d0      	adds	r0, r2, r3
   19fee:	68fb      	ldr	r3, [r7, #12]
   19ff0:	3324      	adds	r3, #36	; 0x24
   19ff2:	0019      	movs	r1, r3
   19ff4:	2380      	movs	r3, #128	; 0x80
   19ff6:	009b      	lsls	r3, r3, #2
   19ff8:	001a      	movs	r2, r3
   19ffa:	4b3f      	ldr	r3, [pc, #252]	; (1a0f8 <f_read+0x2a0>)
   19ffc:	4798      	blx	r3
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   19ffe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1a000:	025b      	lsls	r3, r3, #9
   1a002:	62bb      	str	r3, [r7, #40]	; 0x28
				continue;
   1a004:	e052      	b.n	1a0ac <f_read+0x254>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   1a006:	68fb      	ldr	r3, [r7, #12]
   1a008:	699a      	ldr	r2, [r3, #24]
   1a00a:	693b      	ldr	r3, [r7, #16]
   1a00c:	429a      	cmp	r2, r3
   1a00e:	d02f      	beq.n	1a070 <f_read+0x218>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   1a010:	68fb      	ldr	r3, [r7, #12]
   1a012:	799b      	ldrb	r3, [r3, #6]
   1a014:	001a      	movs	r2, r3
   1a016:	2340      	movs	r3, #64	; 0x40
   1a018:	4013      	ands	r3, r2
   1a01a:	d018      	beq.n	1a04e <f_read+0x1f6>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   1a01c:	68fb      	ldr	r3, [r7, #12]
   1a01e:	681b      	ldr	r3, [r3, #0]
   1a020:	7858      	ldrb	r0, [r3, #1]
   1a022:	68fb      	ldr	r3, [r7, #12]
   1a024:	3324      	adds	r3, #36	; 0x24
   1a026:	0019      	movs	r1, r3
   1a028:	68fb      	ldr	r3, [r7, #12]
   1a02a:	699a      	ldr	r2, [r3, #24]
   1a02c:	2301      	movs	r3, #1
   1a02e:	4c33      	ldr	r4, [pc, #204]	; (1a0fc <f_read+0x2a4>)
   1a030:	47a0      	blx	r4
   1a032:	1e03      	subs	r3, r0, #0
   1a034:	d004      	beq.n	1a040 <f_read+0x1e8>
						ABORT(fp->fs, FR_DISK_ERR);
   1a036:	68fb      	ldr	r3, [r7, #12]
   1a038:	2201      	movs	r2, #1
   1a03a:	71da      	strb	r2, [r3, #7]
   1a03c:	2301      	movs	r3, #1
   1a03e:	e04e      	b.n	1a0de <f_read+0x286>
					fp->flag &= ~FA__DIRTY;
   1a040:	68fb      	ldr	r3, [r7, #12]
   1a042:	799b      	ldrb	r3, [r3, #6]
   1a044:	2240      	movs	r2, #64	; 0x40
   1a046:	4393      	bics	r3, r2
   1a048:	b2da      	uxtb	r2, r3
   1a04a:	68fb      	ldr	r3, [r7, #12]
   1a04c:	719a      	strb	r2, [r3, #6]
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   1a04e:	68fb      	ldr	r3, [r7, #12]
   1a050:	681b      	ldr	r3, [r3, #0]
   1a052:	7858      	ldrb	r0, [r3, #1]
   1a054:	68fb      	ldr	r3, [r7, #12]
   1a056:	3324      	adds	r3, #36	; 0x24
   1a058:	0019      	movs	r1, r3
   1a05a:	693a      	ldr	r2, [r7, #16]
   1a05c:	2301      	movs	r3, #1
   1a05e:	4c25      	ldr	r4, [pc, #148]	; (1a0f4 <f_read+0x29c>)
   1a060:	47a0      	blx	r4
   1a062:	1e03      	subs	r3, r0, #0
   1a064:	d004      	beq.n	1a070 <f_read+0x218>
					ABORT(fp->fs, FR_DISK_ERR);
   1a066:	68fb      	ldr	r3, [r7, #12]
   1a068:	2201      	movs	r2, #1
   1a06a:	71da      	strb	r2, [r3, #7]
   1a06c:	2301      	movs	r3, #1
   1a06e:	e036      	b.n	1a0de <f_read+0x286>
			}
#endif
			fp->dsect = sect;
   1a070:	68fb      	ldr	r3, [r7, #12]
   1a072:	693a      	ldr	r2, [r7, #16]
   1a074:	619a      	str	r2, [r3, #24]
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   1a076:	68fb      	ldr	r3, [r7, #12]
   1a078:	689b      	ldr	r3, [r3, #8]
   1a07a:	05db      	lsls	r3, r3, #23
   1a07c:	0ddb      	lsrs	r3, r3, #23
   1a07e:	2280      	movs	r2, #128	; 0x80
   1a080:	0092      	lsls	r2, r2, #2
   1a082:	1ad3      	subs	r3, r2, r3
   1a084:	62bb      	str	r3, [r7, #40]	; 0x28
		if (rcnt > btr) rcnt = btr;
   1a086:	6aba      	ldr	r2, [r7, #40]	; 0x28
   1a088:	687b      	ldr	r3, [r7, #4]
   1a08a:	429a      	cmp	r2, r3
   1a08c:	d901      	bls.n	1a092 <f_read+0x23a>
   1a08e:	687b      	ldr	r3, [r7, #4]
   1a090:	62bb      	str	r3, [r7, #40]	; 0x28
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   1a092:	68fb      	ldr	r3, [r7, #12]
   1a094:	689b      	ldr	r3, [r3, #8]
   1a096:	05db      	lsls	r3, r3, #23
   1a098:	0ddb      	lsrs	r3, r3, #23
   1a09a:	3320      	adds	r3, #32
   1a09c:	68fa      	ldr	r2, [r7, #12]
   1a09e:	18d3      	adds	r3, r2, r3
   1a0a0:	1d19      	adds	r1, r3, #4
   1a0a2:	6aba      	ldr	r2, [r7, #40]	; 0x28
   1a0a4:	6a3b      	ldr	r3, [r7, #32]
   1a0a6:	0018      	movs	r0, r3
   1a0a8:	4b13      	ldr	r3, [pc, #76]	; (1a0f8 <f_read+0x2a0>)
   1a0aa:	4798      	blx	r3
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   1a0ac:	6a3a      	ldr	r2, [r7, #32]
   1a0ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1a0b0:	18d3      	adds	r3, r2, r3
   1a0b2:	623b      	str	r3, [r7, #32]
   1a0b4:	68fb      	ldr	r3, [r7, #12]
   1a0b6:	689a      	ldr	r2, [r3, #8]
   1a0b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1a0ba:	18d2      	adds	r2, r2, r3
   1a0bc:	68fb      	ldr	r3, [r7, #12]
   1a0be:	609a      	str	r2, [r3, #8]
   1a0c0:	683b      	ldr	r3, [r7, #0]
   1a0c2:	681a      	ldr	r2, [r3, #0]
   1a0c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1a0c6:	18d2      	adds	r2, r2, r3
   1a0c8:	683b      	ldr	r3, [r7, #0]
   1a0ca:	601a      	str	r2, [r3, #0]
   1a0cc:	687a      	ldr	r2, [r7, #4]
   1a0ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1a0d0:	1ad3      	subs	r3, r2, r3
   1a0d2:	607b      	str	r3, [r7, #4]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
   1a0d4:	687b      	ldr	r3, [r7, #4]
   1a0d6:	2b00      	cmp	r3, #0
   1a0d8:	d000      	beq.n	1a0dc <f_read+0x284>
   1a0da:	e6f7      	b.n	19ecc <f_read+0x74>
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
   1a0dc:	2300      	movs	r3, #0
}
   1a0de:	0018      	movs	r0, r3
   1a0e0:	46bd      	mov	sp, r7
   1a0e2:	b00d      	add	sp, #52	; 0x34
   1a0e4:	bd90      	pop	{r4, r7, pc}
   1a0e6:	46c0      	nop			; (mov r8, r8)
   1a0e8:	00019a11 	.word	0x00019a11
   1a0ec:	00017799 	.word	0x00017799
   1a0f0:	00017761 	.word	0x00017761
   1a0f4:	000170f1 	.word	0x000170f1
   1a0f8:	000173d5 	.word	0x000173d5
   1a0fc:	000171b9 	.word	0x000171b9

0001a100 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
   1a100:	b590      	push	{r4, r7, lr}
   1a102:	b08b      	sub	sp, #44	; 0x2c
   1a104:	af00      	add	r7, sp, #0
   1a106:	60f8      	str	r0, [r7, #12]
   1a108:	60b9      	str	r1, [r7, #8]
   1a10a:	607a      	str	r2, [r7, #4]
   1a10c:	603b      	str	r3, [r7, #0]
	FRESULT res;
	DWORD clst, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
   1a10e:	68bb      	ldr	r3, [r7, #8]
   1a110:	61bb      	str	r3, [r7, #24]
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
   1a112:	683b      	ldr	r3, [r7, #0]
   1a114:	2200      	movs	r2, #0
   1a116:	601a      	str	r2, [r3, #0]

	res = validate(fp);						/* Check validity */
   1a118:	2317      	movs	r3, #23
   1a11a:	18fc      	adds	r4, r7, r3
   1a11c:	68fb      	ldr	r3, [r7, #12]
   1a11e:	0018      	movs	r0, r3
   1a120:	4bb5      	ldr	r3, [pc, #724]	; (1a3f8 <f_write+0x2f8>)
   1a122:	4798      	blx	r3
   1a124:	0003      	movs	r3, r0
   1a126:	7023      	strb	r3, [r4, #0]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   1a128:	2317      	movs	r3, #23
   1a12a:	18fb      	adds	r3, r7, r3
   1a12c:	781b      	ldrb	r3, [r3, #0]
   1a12e:	2b00      	cmp	r3, #0
   1a130:	d003      	beq.n	1a13a <f_write+0x3a>
   1a132:	2317      	movs	r3, #23
   1a134:	18fb      	adds	r3, r7, r3
   1a136:	781b      	ldrb	r3, [r3, #0]
   1a138:	e15a      	b.n	1a3f0 <f_write+0x2f0>
	if (fp->err)							/* Check error */
   1a13a:	68fb      	ldr	r3, [r7, #12]
   1a13c:	79db      	ldrb	r3, [r3, #7]
   1a13e:	2b00      	cmp	r3, #0
   1a140:	d002      	beq.n	1a148 <f_write+0x48>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   1a142:	68fb      	ldr	r3, [r7, #12]
   1a144:	79db      	ldrb	r3, [r3, #7]
   1a146:	e153      	b.n	1a3f0 <f_write+0x2f0>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   1a148:	68fb      	ldr	r3, [r7, #12]
   1a14a:	799b      	ldrb	r3, [r3, #6]
   1a14c:	001a      	movs	r2, r3
   1a14e:	2302      	movs	r3, #2
   1a150:	4013      	ands	r3, r2
   1a152:	d101      	bne.n	1a158 <f_write+0x58>
		LEAVE_FF(fp->fs, FR_DENIED);
   1a154:	2307      	movs	r3, #7
   1a156:	e14b      	b.n	1a3f0 <f_write+0x2f0>
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
   1a158:	68fb      	ldr	r3, [r7, #12]
   1a15a:	689a      	ldr	r2, [r3, #8]
   1a15c:	687b      	ldr	r3, [r7, #4]
   1a15e:	18d2      	adds	r2, r2, r3
   1a160:	68fb      	ldr	r3, [r7, #12]
   1a162:	689b      	ldr	r3, [r3, #8]
   1a164:	429a      	cmp	r2, r3
   1a166:	d300      	bcc.n	1a16a <f_write+0x6a>
   1a168:	e12a      	b.n	1a3c0 <f_write+0x2c0>
   1a16a:	2300      	movs	r3, #0
   1a16c:	607b      	str	r3, [r7, #4]

	for ( ;  btw;							/* Repeat until all data written */
   1a16e:	e127      	b.n	1a3c0 <f_write+0x2c0>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   1a170:	68fb      	ldr	r3, [r7, #12]
   1a172:	689b      	ldr	r3, [r3, #8]
   1a174:	05db      	lsls	r3, r3, #23
   1a176:	0ddb      	lsrs	r3, r3, #23
   1a178:	d000      	beq.n	1a17c <f_write+0x7c>
   1a17a:	e0eb      	b.n	1a354 <f_write+0x254>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   1a17c:	68fb      	ldr	r3, [r7, #12]
   1a17e:	689b      	ldr	r3, [r3, #8]
   1a180:	0a5b      	lsrs	r3, r3, #9
   1a182:	b2da      	uxtb	r2, r3
   1a184:	68fb      	ldr	r3, [r7, #12]
   1a186:	681b      	ldr	r3, [r3, #0]
   1a188:	789b      	ldrb	r3, [r3, #2]
   1a18a:	3b01      	subs	r3, #1
   1a18c:	b2d9      	uxtb	r1, r3
   1a18e:	2316      	movs	r3, #22
   1a190:	18fb      	adds	r3, r7, r3
   1a192:	400a      	ands	r2, r1
   1a194:	701a      	strb	r2, [r3, #0]
			if (!csect) {					/* On the cluster boundary? */
   1a196:	2316      	movs	r3, #22
   1a198:	18fb      	adds	r3, r7, r3
   1a19a:	781b      	ldrb	r3, [r3, #0]
   1a19c:	2b00      	cmp	r3, #0
   1a19e:	d13a      	bne.n	1a216 <f_write+0x116>
				if (fp->fptr == 0) {		/* On the top of the file? */
   1a1a0:	68fb      	ldr	r3, [r7, #12]
   1a1a2:	689b      	ldr	r3, [r3, #8]
   1a1a4:	2b00      	cmp	r3, #0
   1a1a6:	d10e      	bne.n	1a1c6 <f_write+0xc6>
					clst = fp->sclust;		/* Follow from the origin */
   1a1a8:	68fb      	ldr	r3, [r7, #12]
   1a1aa:	691b      	ldr	r3, [r3, #16]
   1a1ac:	627b      	str	r3, [r7, #36]	; 0x24
					if (clst == 0)			/* When no cluster is allocated, */
   1a1ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1a1b0:	2b00      	cmp	r3, #0
   1a1b2:	d112      	bne.n	1a1da <f_write+0xda>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   1a1b4:	68fb      	ldr	r3, [r7, #12]
   1a1b6:	681b      	ldr	r3, [r3, #0]
   1a1b8:	2100      	movs	r1, #0
   1a1ba:	0018      	movs	r0, r3
   1a1bc:	4b8f      	ldr	r3, [pc, #572]	; (1a3fc <f_write+0x2fc>)
   1a1be:	4798      	blx	r3
   1a1c0:	0003      	movs	r3, r0
   1a1c2:	627b      	str	r3, [r7, #36]	; 0x24
   1a1c4:	e009      	b.n	1a1da <f_write+0xda>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   1a1c6:	68fb      	ldr	r3, [r7, #12]
   1a1c8:	681a      	ldr	r2, [r3, #0]
   1a1ca:	68fb      	ldr	r3, [r7, #12]
   1a1cc:	695b      	ldr	r3, [r3, #20]
   1a1ce:	0019      	movs	r1, r3
   1a1d0:	0010      	movs	r0, r2
   1a1d2:	4b8a      	ldr	r3, [pc, #552]	; (1a3fc <f_write+0x2fc>)
   1a1d4:	4798      	blx	r3
   1a1d6:	0003      	movs	r3, r0
   1a1d8:	627b      	str	r3, [r7, #36]	; 0x24
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   1a1da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1a1dc:	2b00      	cmp	r3, #0
   1a1de:	d100      	bne.n	1a1e2 <f_write+0xe2>
   1a1e0:	e0f3      	b.n	1a3ca <f_write+0x2ca>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   1a1e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1a1e4:	2b01      	cmp	r3, #1
   1a1e6:	d104      	bne.n	1a1f2 <f_write+0xf2>
   1a1e8:	68fb      	ldr	r3, [r7, #12]
   1a1ea:	2202      	movs	r2, #2
   1a1ec:	71da      	strb	r2, [r3, #7]
   1a1ee:	2302      	movs	r3, #2
   1a1f0:	e0fe      	b.n	1a3f0 <f_write+0x2f0>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   1a1f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1a1f4:	3301      	adds	r3, #1
   1a1f6:	d104      	bne.n	1a202 <f_write+0x102>
   1a1f8:	68fb      	ldr	r3, [r7, #12]
   1a1fa:	2201      	movs	r2, #1
   1a1fc:	71da      	strb	r2, [r3, #7]
   1a1fe:	2301      	movs	r3, #1
   1a200:	e0f6      	b.n	1a3f0 <f_write+0x2f0>
				fp->clust = clst;			/* Update current cluster */
   1a202:	68fb      	ldr	r3, [r7, #12]
   1a204:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1a206:	615a      	str	r2, [r3, #20]
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
   1a208:	68fb      	ldr	r3, [r7, #12]
   1a20a:	691b      	ldr	r3, [r3, #16]
   1a20c:	2b00      	cmp	r3, #0
   1a20e:	d102      	bne.n	1a216 <f_write+0x116>
   1a210:	68fb      	ldr	r3, [r7, #12]
   1a212:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1a214:	611a      	str	r2, [r3, #16]
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   1a216:	68fb      	ldr	r3, [r7, #12]
   1a218:	799b      	ldrb	r3, [r3, #6]
   1a21a:	001a      	movs	r2, r3
   1a21c:	2340      	movs	r3, #64	; 0x40
   1a21e:	4013      	ands	r3, r2
   1a220:	d018      	beq.n	1a254 <f_write+0x154>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   1a222:	68fb      	ldr	r3, [r7, #12]
   1a224:	681b      	ldr	r3, [r3, #0]
   1a226:	7858      	ldrb	r0, [r3, #1]
   1a228:	68fb      	ldr	r3, [r7, #12]
   1a22a:	3324      	adds	r3, #36	; 0x24
   1a22c:	0019      	movs	r1, r3
   1a22e:	68fb      	ldr	r3, [r7, #12]
   1a230:	699a      	ldr	r2, [r3, #24]
   1a232:	2301      	movs	r3, #1
   1a234:	4c72      	ldr	r4, [pc, #456]	; (1a400 <f_write+0x300>)
   1a236:	47a0      	blx	r4
   1a238:	1e03      	subs	r3, r0, #0
   1a23a:	d004      	beq.n	1a246 <f_write+0x146>
					ABORT(fp->fs, FR_DISK_ERR);
   1a23c:	68fb      	ldr	r3, [r7, #12]
   1a23e:	2201      	movs	r2, #1
   1a240:	71da      	strb	r2, [r3, #7]
   1a242:	2301      	movs	r3, #1
   1a244:	e0d4      	b.n	1a3f0 <f_write+0x2f0>
				fp->flag &= ~FA__DIRTY;
   1a246:	68fb      	ldr	r3, [r7, #12]
   1a248:	799b      	ldrb	r3, [r3, #6]
   1a24a:	2240      	movs	r2, #64	; 0x40
   1a24c:	4393      	bics	r3, r2
   1a24e:	b2da      	uxtb	r2, r3
   1a250:	68fb      	ldr	r3, [r7, #12]
   1a252:	719a      	strb	r2, [r3, #6]
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   1a254:	68fb      	ldr	r3, [r7, #12]
   1a256:	681a      	ldr	r2, [r3, #0]
   1a258:	68fb      	ldr	r3, [r7, #12]
   1a25a:	695b      	ldr	r3, [r3, #20]
   1a25c:	0019      	movs	r1, r3
   1a25e:	0010      	movs	r0, r2
   1a260:	4b68      	ldr	r3, [pc, #416]	; (1a404 <f_write+0x304>)
   1a262:	4798      	blx	r3
   1a264:	0003      	movs	r3, r0
   1a266:	613b      	str	r3, [r7, #16]
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   1a268:	693b      	ldr	r3, [r7, #16]
   1a26a:	2b00      	cmp	r3, #0
   1a26c:	d104      	bne.n	1a278 <f_write+0x178>
   1a26e:	68fb      	ldr	r3, [r7, #12]
   1a270:	2202      	movs	r2, #2
   1a272:	71da      	strb	r2, [r3, #7]
   1a274:	2302      	movs	r3, #2
   1a276:	e0bb      	b.n	1a3f0 <f_write+0x2f0>
			sect += csect;
   1a278:	2316      	movs	r3, #22
   1a27a:	18fb      	adds	r3, r7, r3
   1a27c:	781b      	ldrb	r3, [r3, #0]
   1a27e:	693a      	ldr	r2, [r7, #16]
   1a280:	18d3      	adds	r3, r2, r3
   1a282:	613b      	str	r3, [r7, #16]
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   1a284:	687b      	ldr	r3, [r7, #4]
   1a286:	0a5b      	lsrs	r3, r3, #9
   1a288:	61fb      	str	r3, [r7, #28]
			if (cc) {						/* Write maximum contiguous sectors directly */
   1a28a:	69fb      	ldr	r3, [r7, #28]
   1a28c:	2b00      	cmp	r3, #0
   1a28e:	d042      	beq.n	1a316 <f_write+0x216>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   1a290:	2316      	movs	r3, #22
   1a292:	18fb      	adds	r3, r7, r3
   1a294:	781a      	ldrb	r2, [r3, #0]
   1a296:	69fb      	ldr	r3, [r7, #28]
   1a298:	18d2      	adds	r2, r2, r3
   1a29a:	68fb      	ldr	r3, [r7, #12]
   1a29c:	681b      	ldr	r3, [r3, #0]
   1a29e:	789b      	ldrb	r3, [r3, #2]
   1a2a0:	429a      	cmp	r2, r3
   1a2a2:	d908      	bls.n	1a2b6 <f_write+0x1b6>
					cc = fp->fs->csize - csect;
   1a2a4:	68fb      	ldr	r3, [r7, #12]
   1a2a6:	681b      	ldr	r3, [r3, #0]
   1a2a8:	789b      	ldrb	r3, [r3, #2]
   1a2aa:	001a      	movs	r2, r3
   1a2ac:	2316      	movs	r3, #22
   1a2ae:	18fb      	adds	r3, r7, r3
   1a2b0:	781b      	ldrb	r3, [r3, #0]
   1a2b2:	1ad3      	subs	r3, r2, r3
   1a2b4:	61fb      	str	r3, [r7, #28]
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
   1a2b6:	68fb      	ldr	r3, [r7, #12]
   1a2b8:	681b      	ldr	r3, [r3, #0]
   1a2ba:	7858      	ldrb	r0, [r3, #1]
   1a2bc:	69fb      	ldr	r3, [r7, #28]
   1a2be:	693a      	ldr	r2, [r7, #16]
   1a2c0:	69b9      	ldr	r1, [r7, #24]
   1a2c2:	4c4f      	ldr	r4, [pc, #316]	; (1a400 <f_write+0x300>)
   1a2c4:	47a0      	blx	r4
   1a2c6:	1e03      	subs	r3, r0, #0
   1a2c8:	d004      	beq.n	1a2d4 <f_write+0x1d4>
					ABORT(fp->fs, FR_DISK_ERR);
   1a2ca:	68fb      	ldr	r3, [r7, #12]
   1a2cc:	2201      	movs	r2, #1
   1a2ce:	71da      	strb	r2, [r3, #7]
   1a2d0:	2301      	movs	r3, #1
   1a2d2:	e08d      	b.n	1a3f0 <f_write+0x2f0>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   1a2d4:	68fb      	ldr	r3, [r7, #12]
   1a2d6:	699a      	ldr	r2, [r3, #24]
   1a2d8:	693b      	ldr	r3, [r7, #16]
   1a2da:	1ad2      	subs	r2, r2, r3
   1a2dc:	69fb      	ldr	r3, [r7, #28]
   1a2de:	429a      	cmp	r2, r3
   1a2e0:	d215      	bcs.n	1a30e <f_write+0x20e>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   1a2e2:	68fb      	ldr	r3, [r7, #12]
   1a2e4:	3324      	adds	r3, #36	; 0x24
   1a2e6:	0018      	movs	r0, r3
   1a2e8:	68fb      	ldr	r3, [r7, #12]
   1a2ea:	699a      	ldr	r2, [r3, #24]
   1a2ec:	693b      	ldr	r3, [r7, #16]
   1a2ee:	1ad3      	subs	r3, r2, r3
   1a2f0:	025b      	lsls	r3, r3, #9
   1a2f2:	69ba      	ldr	r2, [r7, #24]
   1a2f4:	18d1      	adds	r1, r2, r3
   1a2f6:	2380      	movs	r3, #128	; 0x80
   1a2f8:	009b      	lsls	r3, r3, #2
   1a2fa:	001a      	movs	r2, r3
   1a2fc:	4b42      	ldr	r3, [pc, #264]	; (1a408 <f_write+0x308>)
   1a2fe:	4798      	blx	r3
					fp->flag &= ~FA__DIRTY;
   1a300:	68fb      	ldr	r3, [r7, #12]
   1a302:	799b      	ldrb	r3, [r3, #6]
   1a304:	2240      	movs	r2, #64	; 0x40
   1a306:	4393      	bics	r3, r2
   1a308:	b2da      	uxtb	r2, r3
   1a30a:	68fb      	ldr	r3, [r7, #12]
   1a30c:	719a      	strb	r2, [r3, #6]
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   1a30e:	69fb      	ldr	r3, [r7, #28]
   1a310:	025b      	lsls	r3, r3, #9
   1a312:	623b      	str	r3, [r7, #32]
				continue;
   1a314:	e040      	b.n	1a398 <f_write+0x298>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   1a316:	68fb      	ldr	r3, [r7, #12]
   1a318:	699a      	ldr	r2, [r3, #24]
   1a31a:	693b      	ldr	r3, [r7, #16]
   1a31c:	429a      	cmp	r2, r3
   1a31e:	d016      	beq.n	1a34e <f_write+0x24e>
				if (fp->fptr < fp->fsize &&
   1a320:	68fb      	ldr	r3, [r7, #12]
   1a322:	689a      	ldr	r2, [r3, #8]
   1a324:	68fb      	ldr	r3, [r7, #12]
   1a326:	68db      	ldr	r3, [r3, #12]
   1a328:	429a      	cmp	r2, r3
   1a32a:	d210      	bcs.n	1a34e <f_write+0x24e>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   1a32c:	68fb      	ldr	r3, [r7, #12]
   1a32e:	681b      	ldr	r3, [r3, #0]
   1a330:	7858      	ldrb	r0, [r3, #1]
   1a332:	68fb      	ldr	r3, [r7, #12]
   1a334:	3324      	adds	r3, #36	; 0x24
   1a336:	0019      	movs	r1, r3
   1a338:	693a      	ldr	r2, [r7, #16]
   1a33a:	2301      	movs	r3, #1
   1a33c:	4c33      	ldr	r4, [pc, #204]	; (1a40c <f_write+0x30c>)
   1a33e:	47a0      	blx	r4
   1a340:	1e03      	subs	r3, r0, #0
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
   1a342:	d004      	beq.n	1a34e <f_write+0x24e>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
   1a344:	68fb      	ldr	r3, [r7, #12]
   1a346:	2201      	movs	r2, #1
   1a348:	71da      	strb	r2, [r3, #7]
   1a34a:	2301      	movs	r3, #1
   1a34c:	e050      	b.n	1a3f0 <f_write+0x2f0>
			}
#endif
			fp->dsect = sect;
   1a34e:	68fb      	ldr	r3, [r7, #12]
   1a350:	693a      	ldr	r2, [r7, #16]
   1a352:	619a      	str	r2, [r3, #24]
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   1a354:	68fb      	ldr	r3, [r7, #12]
   1a356:	689b      	ldr	r3, [r3, #8]
   1a358:	05db      	lsls	r3, r3, #23
   1a35a:	0ddb      	lsrs	r3, r3, #23
   1a35c:	2280      	movs	r2, #128	; 0x80
   1a35e:	0092      	lsls	r2, r2, #2
   1a360:	1ad3      	subs	r3, r2, r3
   1a362:	623b      	str	r3, [r7, #32]
		if (wcnt > btw) wcnt = btw;
   1a364:	6a3a      	ldr	r2, [r7, #32]
   1a366:	687b      	ldr	r3, [r7, #4]
   1a368:	429a      	cmp	r2, r3
   1a36a:	d901      	bls.n	1a370 <f_write+0x270>
   1a36c:	687b      	ldr	r3, [r7, #4]
   1a36e:	623b      	str	r3, [r7, #32]
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   1a370:	68fb      	ldr	r3, [r7, #12]
   1a372:	689b      	ldr	r3, [r3, #8]
   1a374:	05db      	lsls	r3, r3, #23
   1a376:	0ddb      	lsrs	r3, r3, #23
   1a378:	3320      	adds	r3, #32
   1a37a:	68fa      	ldr	r2, [r7, #12]
   1a37c:	18d3      	adds	r3, r2, r3
   1a37e:	3304      	adds	r3, #4
   1a380:	6a3a      	ldr	r2, [r7, #32]
   1a382:	69b9      	ldr	r1, [r7, #24]
   1a384:	0018      	movs	r0, r3
   1a386:	4b20      	ldr	r3, [pc, #128]	; (1a408 <f_write+0x308>)
   1a388:	4798      	blx	r3
		fp->flag |= FA__DIRTY;
   1a38a:	68fb      	ldr	r3, [r7, #12]
   1a38c:	799b      	ldrb	r3, [r3, #6]
   1a38e:	2240      	movs	r2, #64	; 0x40
   1a390:	4313      	orrs	r3, r2
   1a392:	b2da      	uxtb	r2, r3
   1a394:	68fb      	ldr	r3, [r7, #12]
   1a396:	719a      	strb	r2, [r3, #6]
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   1a398:	69ba      	ldr	r2, [r7, #24]
   1a39a:	6a3b      	ldr	r3, [r7, #32]
   1a39c:	18d3      	adds	r3, r2, r3
   1a39e:	61bb      	str	r3, [r7, #24]
   1a3a0:	68fb      	ldr	r3, [r7, #12]
   1a3a2:	689a      	ldr	r2, [r3, #8]
   1a3a4:	6a3b      	ldr	r3, [r7, #32]
   1a3a6:	18d2      	adds	r2, r2, r3
   1a3a8:	68fb      	ldr	r3, [r7, #12]
   1a3aa:	609a      	str	r2, [r3, #8]
   1a3ac:	683b      	ldr	r3, [r7, #0]
   1a3ae:	681a      	ldr	r2, [r3, #0]
   1a3b0:	6a3b      	ldr	r3, [r7, #32]
   1a3b2:	18d2      	adds	r2, r2, r3
   1a3b4:	683b      	ldr	r3, [r7, #0]
   1a3b6:	601a      	str	r2, [r3, #0]
   1a3b8:	687a      	ldr	r2, [r7, #4]
   1a3ba:	6a3b      	ldr	r3, [r7, #32]
   1a3bc:	1ad3      	subs	r3, r2, r3
   1a3be:	607b      	str	r3, [r7, #4]
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
   1a3c0:	687b      	ldr	r3, [r7, #4]
   1a3c2:	2b00      	cmp	r3, #0
   1a3c4:	d000      	beq.n	1a3c8 <f_write+0x2c8>
   1a3c6:	e6d3      	b.n	1a170 <f_write+0x70>
   1a3c8:	e000      	b.n	1a3cc <f_write+0x2cc>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   1a3ca:	46c0      	nop			; (mov r8, r8)
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   1a3cc:	68fb      	ldr	r3, [r7, #12]
   1a3ce:	689a      	ldr	r2, [r3, #8]
   1a3d0:	68fb      	ldr	r3, [r7, #12]
   1a3d2:	68db      	ldr	r3, [r3, #12]
   1a3d4:	429a      	cmp	r2, r3
   1a3d6:	d903      	bls.n	1a3e0 <f_write+0x2e0>
   1a3d8:	68fb      	ldr	r3, [r7, #12]
   1a3da:	689a      	ldr	r2, [r3, #8]
   1a3dc:	68fb      	ldr	r3, [r7, #12]
   1a3de:	60da      	str	r2, [r3, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   1a3e0:	68fb      	ldr	r3, [r7, #12]
   1a3e2:	799b      	ldrb	r3, [r3, #6]
   1a3e4:	2220      	movs	r2, #32
   1a3e6:	4313      	orrs	r3, r2
   1a3e8:	b2da      	uxtb	r2, r3
   1a3ea:	68fb      	ldr	r3, [r7, #12]
   1a3ec:	719a      	strb	r2, [r3, #6]

	LEAVE_FF(fp->fs, FR_OK);
   1a3ee:	2300      	movs	r3, #0
}
   1a3f0:	0018      	movs	r0, r3
   1a3f2:	46bd      	mov	sp, r7
   1a3f4:	b00b      	add	sp, #44	; 0x2c
   1a3f6:	bd90      	pop	{r4, r7, pc}
   1a3f8:	00019a11 	.word	0x00019a11
   1a3fc:	00017c25 	.word	0x00017c25
   1a400:	000171b9 	.word	0x000171b9
   1a404:	00017761 	.word	0x00017761
   1a408:	000173d5 	.word	0x000173d5
   1a40c:	000170f1 	.word	0x000170f1

0001a410 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
   1a410:	b590      	push	{r4, r7, lr}
   1a412:	b087      	sub	sp, #28
   1a414:	af00      	add	r7, sp, #0
   1a416:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
   1a418:	2317      	movs	r3, #23
   1a41a:	18fc      	adds	r4, r7, r3
   1a41c:	687b      	ldr	r3, [r7, #4]
   1a41e:	0018      	movs	r0, r3
   1a420:	4b56      	ldr	r3, [pc, #344]	; (1a57c <f_sync+0x16c>)
   1a422:	4798      	blx	r3
   1a424:	0003      	movs	r3, r0
   1a426:	7023      	strb	r3, [r4, #0]
	if (res == FR_OK) {
   1a428:	2317      	movs	r3, #23
   1a42a:	18fb      	adds	r3, r7, r3
   1a42c:	781b      	ldrb	r3, [r3, #0]
   1a42e:	2b00      	cmp	r3, #0
   1a430:	d000      	beq.n	1a434 <f_sync+0x24>
   1a432:	e09c      	b.n	1a56e <f_sync+0x15e>
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
   1a434:	687b      	ldr	r3, [r7, #4]
   1a436:	799b      	ldrb	r3, [r3, #6]
   1a438:	001a      	movs	r2, r3
   1a43a:	2320      	movs	r3, #32
   1a43c:	4013      	ands	r3, r2
   1a43e:	d100      	bne.n	1a442 <f_sync+0x32>
   1a440:	e095      	b.n	1a56e <f_sync+0x15e>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
   1a442:	687b      	ldr	r3, [r7, #4]
   1a444:	799b      	ldrb	r3, [r3, #6]
   1a446:	001a      	movs	r2, r3
   1a448:	2340      	movs	r3, #64	; 0x40
   1a44a:	4013      	ands	r3, r2
   1a44c:	d015      	beq.n	1a47a <f_sync+0x6a>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   1a44e:	687b      	ldr	r3, [r7, #4]
   1a450:	681b      	ldr	r3, [r3, #0]
   1a452:	7858      	ldrb	r0, [r3, #1]
   1a454:	687b      	ldr	r3, [r7, #4]
   1a456:	3324      	adds	r3, #36	; 0x24
   1a458:	0019      	movs	r1, r3
   1a45a:	687b      	ldr	r3, [r7, #4]
   1a45c:	699a      	ldr	r2, [r3, #24]
   1a45e:	2301      	movs	r3, #1
   1a460:	4c47      	ldr	r4, [pc, #284]	; (1a580 <f_sync+0x170>)
   1a462:	47a0      	blx	r4
   1a464:	1e03      	subs	r3, r0, #0
   1a466:	d001      	beq.n	1a46c <f_sync+0x5c>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
   1a468:	2301      	movs	r3, #1
   1a46a:	e083      	b.n	1a574 <f_sync+0x164>
				fp->flag &= ~FA__DIRTY;
   1a46c:	687b      	ldr	r3, [r7, #4]
   1a46e:	799b      	ldrb	r3, [r3, #6]
   1a470:	2240      	movs	r2, #64	; 0x40
   1a472:	4393      	bics	r3, r2
   1a474:	b2da      	uxtb	r2, r3
   1a476:	687b      	ldr	r3, [r7, #4]
   1a478:	719a      	strb	r2, [r3, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
   1a47a:	687b      	ldr	r3, [r7, #4]
   1a47c:	681a      	ldr	r2, [r3, #0]
   1a47e:	687b      	ldr	r3, [r7, #4]
   1a480:	69db      	ldr	r3, [r3, #28]
   1a482:	2117      	movs	r1, #23
   1a484:	187c      	adds	r4, r7, r1
   1a486:	0019      	movs	r1, r3
   1a488:	0010      	movs	r0, r2
   1a48a:	4b3e      	ldr	r3, [pc, #248]	; (1a584 <f_sync+0x174>)
   1a48c:	4798      	blx	r3
   1a48e:	0003      	movs	r3, r0
   1a490:	7023      	strb	r3, [r4, #0]
			if (res == FR_OK) {
   1a492:	2317      	movs	r3, #23
   1a494:	18fb      	adds	r3, r7, r3
   1a496:	781b      	ldrb	r3, [r3, #0]
   1a498:	2b00      	cmp	r3, #0
   1a49a:	d168      	bne.n	1a56e <f_sync+0x15e>
				dir = fp->dir_ptr;
   1a49c:	687b      	ldr	r3, [r7, #4]
   1a49e:	6a1b      	ldr	r3, [r3, #32]
   1a4a0:	613b      	str	r3, [r7, #16]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   1a4a2:	693b      	ldr	r3, [r7, #16]
   1a4a4:	330b      	adds	r3, #11
   1a4a6:	693a      	ldr	r2, [r7, #16]
   1a4a8:	320b      	adds	r2, #11
   1a4aa:	7812      	ldrb	r2, [r2, #0]
   1a4ac:	2120      	movs	r1, #32
   1a4ae:	430a      	orrs	r2, r1
   1a4b0:	b2d2      	uxtb	r2, r2
   1a4b2:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
   1a4b4:	693b      	ldr	r3, [r7, #16]
   1a4b6:	331c      	adds	r3, #28
   1a4b8:	001a      	movs	r2, r3
   1a4ba:	687b      	ldr	r3, [r7, #4]
   1a4bc:	68db      	ldr	r3, [r3, #12]
   1a4be:	b2db      	uxtb	r3, r3
   1a4c0:	7013      	strb	r3, [r2, #0]
   1a4c2:	693b      	ldr	r3, [r7, #16]
   1a4c4:	331d      	adds	r3, #29
   1a4c6:	001a      	movs	r2, r3
   1a4c8:	687b      	ldr	r3, [r7, #4]
   1a4ca:	68db      	ldr	r3, [r3, #12]
   1a4cc:	121b      	asrs	r3, r3, #8
   1a4ce:	b2db      	uxtb	r3, r3
   1a4d0:	7013      	strb	r3, [r2, #0]
   1a4d2:	693b      	ldr	r3, [r7, #16]
   1a4d4:	331e      	adds	r3, #30
   1a4d6:	001a      	movs	r2, r3
   1a4d8:	687b      	ldr	r3, [r7, #4]
   1a4da:	68db      	ldr	r3, [r3, #12]
   1a4dc:	0c1b      	lsrs	r3, r3, #16
   1a4de:	b2db      	uxtb	r3, r3
   1a4e0:	7013      	strb	r3, [r2, #0]
   1a4e2:	693b      	ldr	r3, [r7, #16]
   1a4e4:	331f      	adds	r3, #31
   1a4e6:	001a      	movs	r2, r3
   1a4e8:	687b      	ldr	r3, [r7, #4]
   1a4ea:	68db      	ldr	r3, [r3, #12]
   1a4ec:	0e1b      	lsrs	r3, r3, #24
   1a4ee:	b2db      	uxtb	r3, r3
   1a4f0:	7013      	strb	r3, [r2, #0]
				st_clust(dir, fp->sclust);					/* Update start cluster */
   1a4f2:	687b      	ldr	r3, [r7, #4]
   1a4f4:	691a      	ldr	r2, [r3, #16]
   1a4f6:	693b      	ldr	r3, [r7, #16]
   1a4f8:	0011      	movs	r1, r2
   1a4fa:	0018      	movs	r0, r3
   1a4fc:	4b22      	ldr	r3, [pc, #136]	; (1a588 <f_sync+0x178>)
   1a4fe:	4798      	blx	r3
				tm = GET_FATTIME();							/* Update modified time */
   1a500:	4b22      	ldr	r3, [pc, #136]	; (1a58c <f_sync+0x17c>)
   1a502:	4798      	blx	r3
   1a504:	0003      	movs	r3, r0
   1a506:	60fb      	str	r3, [r7, #12]
				ST_DWORD(dir + DIR_WrtTime, tm);
   1a508:	693b      	ldr	r3, [r7, #16]
   1a50a:	3316      	adds	r3, #22
   1a50c:	68fa      	ldr	r2, [r7, #12]
   1a50e:	b2d2      	uxtb	r2, r2
   1a510:	701a      	strb	r2, [r3, #0]
   1a512:	693b      	ldr	r3, [r7, #16]
   1a514:	3317      	adds	r3, #23
   1a516:	68fa      	ldr	r2, [r7, #12]
   1a518:	1212      	asrs	r2, r2, #8
   1a51a:	b2d2      	uxtb	r2, r2
   1a51c:	701a      	strb	r2, [r3, #0]
   1a51e:	693b      	ldr	r3, [r7, #16]
   1a520:	3318      	adds	r3, #24
   1a522:	68fa      	ldr	r2, [r7, #12]
   1a524:	0c12      	lsrs	r2, r2, #16
   1a526:	b2d2      	uxtb	r2, r2
   1a528:	701a      	strb	r2, [r3, #0]
   1a52a:	693b      	ldr	r3, [r7, #16]
   1a52c:	3319      	adds	r3, #25
   1a52e:	68fa      	ldr	r2, [r7, #12]
   1a530:	0e12      	lsrs	r2, r2, #24
   1a532:	b2d2      	uxtb	r2, r2
   1a534:	701a      	strb	r2, [r3, #0]
				ST_WORD(dir + DIR_LstAccDate, 0);
   1a536:	693b      	ldr	r3, [r7, #16]
   1a538:	3312      	adds	r3, #18
   1a53a:	2200      	movs	r2, #0
   1a53c:	701a      	strb	r2, [r3, #0]
   1a53e:	693b      	ldr	r3, [r7, #16]
   1a540:	3313      	adds	r3, #19
   1a542:	2200      	movs	r2, #0
   1a544:	701a      	strb	r2, [r3, #0]
				fp->flag &= ~FA__WRITTEN;
   1a546:	687b      	ldr	r3, [r7, #4]
   1a548:	799b      	ldrb	r3, [r3, #6]
   1a54a:	2220      	movs	r2, #32
   1a54c:	4393      	bics	r3, r2
   1a54e:	b2da      	uxtb	r2, r3
   1a550:	687b      	ldr	r3, [r7, #4]
   1a552:	719a      	strb	r2, [r3, #6]
				fp->fs->wflag = 1;
   1a554:	687b      	ldr	r3, [r7, #4]
   1a556:	681b      	ldr	r3, [r3, #0]
   1a558:	2201      	movs	r2, #1
   1a55a:	711a      	strb	r2, [r3, #4]
				res = sync_fs(fp->fs);
   1a55c:	687b      	ldr	r3, [r7, #4]
   1a55e:	681b      	ldr	r3, [r3, #0]
   1a560:	2217      	movs	r2, #23
   1a562:	18bc      	adds	r4, r7, r2
   1a564:	0018      	movs	r0, r3
   1a566:	4b0a      	ldr	r3, [pc, #40]	; (1a590 <f_sync+0x180>)
   1a568:	4798      	blx	r3
   1a56a:	0003      	movs	r3, r0
   1a56c:	7023      	strb	r3, [r4, #0]
			}
		}
	}

	LEAVE_FF(fp->fs, res);
   1a56e:	2317      	movs	r3, #23
   1a570:	18fb      	adds	r3, r7, r3
   1a572:	781b      	ldrb	r3, [r3, #0]
}
   1a574:	0018      	movs	r0, r3
   1a576:	46bd      	mov	sp, r7
   1a578:	b007      	add	sp, #28
   1a57a:	bd90      	pop	{r4, r7, pc}
   1a57c:	00019a11 	.word	0x00019a11
   1a580:	000171b9 	.word	0x000171b9
   1a584:	00017555 	.word	0x00017555
   1a588:	00018151 	.word	0x00018151
   1a58c:	00017379 	.word	0x00017379
   1a590:	000175cd 	.word	0x000175cd

0001a594 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
   1a594:	b590      	push	{r4, r7, lr}
   1a596:	b085      	sub	sp, #20
   1a598:	af00      	add	r7, sp, #0
   1a59a:	6078      	str	r0, [r7, #4]
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
   1a59c:	230f      	movs	r3, #15
   1a59e:	18fc      	adds	r4, r7, r3
   1a5a0:	687b      	ldr	r3, [r7, #4]
   1a5a2:	0018      	movs	r0, r3
   1a5a4:	4b0f      	ldr	r3, [pc, #60]	; (1a5e4 <f_close+0x50>)
   1a5a6:	4798      	blx	r3
   1a5a8:	0003      	movs	r3, r0
   1a5aa:	7023      	strb	r3, [r4, #0]
	if (res == FR_OK)
   1a5ac:	230f      	movs	r3, #15
   1a5ae:	18fb      	adds	r3, r7, r3
   1a5b0:	781b      	ldrb	r3, [r3, #0]
   1a5b2:	2b00      	cmp	r3, #0
   1a5b4:	d10f      	bne.n	1a5d6 <f_close+0x42>
#endif
	{
		res = validate(fp);				/* Lock volume */
   1a5b6:	230f      	movs	r3, #15
   1a5b8:	18fc      	adds	r4, r7, r3
   1a5ba:	687b      	ldr	r3, [r7, #4]
   1a5bc:	0018      	movs	r0, r3
   1a5be:	4b0a      	ldr	r3, [pc, #40]	; (1a5e8 <f_close+0x54>)
   1a5c0:	4798      	blx	r3
   1a5c2:	0003      	movs	r3, r0
   1a5c4:	7023      	strb	r3, [r4, #0]
		if (res == FR_OK) {
   1a5c6:	230f      	movs	r3, #15
   1a5c8:	18fb      	adds	r3, r7, r3
   1a5ca:	781b      	ldrb	r3, [r3, #0]
   1a5cc:	2b00      	cmp	r3, #0
   1a5ce:	d102      	bne.n	1a5d6 <f_close+0x42>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
   1a5d0:	687b      	ldr	r3, [r7, #4]
   1a5d2:	2200      	movs	r2, #0
   1a5d4:	601a      	str	r2, [r3, #0]
#if _FS_REENTRANT
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
   1a5d6:	230f      	movs	r3, #15
   1a5d8:	18fb      	adds	r3, r7, r3
   1a5da:	781b      	ldrb	r3, [r3, #0]
}
   1a5dc:	0018      	movs	r0, r3
   1a5de:	46bd      	mov	sp, r7
   1a5e0:	b005      	add	sp, #20
   1a5e2:	bd90      	pop	{r4, r7, pc}
   1a5e4:	0001a411 	.word	0x0001a411
   1a5e8:	00019a11 	.word	0x00019a11

0001a5ec <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
   1a5ec:	b590      	push	{r4, r7, lr}
   1a5ee:	b089      	sub	sp, #36	; 0x24
   1a5f0:	af00      	add	r7, sp, #0
   1a5f2:	6078      	str	r0, [r7, #4]
   1a5f4:	6039      	str	r1, [r7, #0]
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
   1a5f6:	2317      	movs	r3, #23
   1a5f8:	18fc      	adds	r4, r7, r3
   1a5fa:	687b      	ldr	r3, [r7, #4]
   1a5fc:	0018      	movs	r0, r3
   1a5fe:	4b9c      	ldr	r3, [pc, #624]	; (1a870 <f_lseek+0x284>)
   1a600:	4798      	blx	r3
   1a602:	0003      	movs	r3, r0
   1a604:	7023      	strb	r3, [r4, #0]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   1a606:	2317      	movs	r3, #23
   1a608:	18fb      	adds	r3, r7, r3
   1a60a:	781b      	ldrb	r3, [r3, #0]
   1a60c:	2b00      	cmp	r3, #0
   1a60e:	d003      	beq.n	1a618 <f_lseek+0x2c>
   1a610:	2317      	movs	r3, #23
   1a612:	18fb      	adds	r3, r7, r3
   1a614:	781b      	ldrb	r3, [r3, #0]
   1a616:	e127      	b.n	1a868 <f_lseek+0x27c>
	if (fp->err)						/* Check error */
   1a618:	687b      	ldr	r3, [r7, #4]
   1a61a:	79db      	ldrb	r3, [r3, #7]
   1a61c:	2b00      	cmp	r3, #0
   1a61e:	d002      	beq.n	1a626 <f_lseek+0x3a>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   1a620:	687b      	ldr	r3, [r7, #4]
   1a622:	79db      	ldrb	r3, [r3, #7]
   1a624:	e120      	b.n	1a868 <f_lseek+0x27c>
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   1a626:	687b      	ldr	r3, [r7, #4]
   1a628:	68da      	ldr	r2, [r3, #12]
   1a62a:	683b      	ldr	r3, [r7, #0]
   1a62c:	429a      	cmp	r2, r3
   1a62e:	d208      	bcs.n	1a642 <f_lseek+0x56>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
   1a630:	687b      	ldr	r3, [r7, #4]
   1a632:	799b      	ldrb	r3, [r3, #6]
   1a634:	001a      	movs	r2, r3
   1a636:	2302      	movs	r3, #2
   1a638:	4013      	ands	r3, r2
   1a63a:	d102      	bne.n	1a642 <f_lseek+0x56>
#endif
			) ofs = fp->fsize;
   1a63c:	687b      	ldr	r3, [r7, #4]
   1a63e:	68db      	ldr	r3, [r3, #12]
   1a640:	603b      	str	r3, [r7, #0]

		ifptr = fp->fptr;
   1a642:	687b      	ldr	r3, [r7, #4]
   1a644:	689b      	ldr	r3, [r3, #8]
   1a646:	613b      	str	r3, [r7, #16]
		fp->fptr = nsect = 0;
   1a648:	2300      	movs	r3, #0
   1a64a:	61bb      	str	r3, [r7, #24]
   1a64c:	687b      	ldr	r3, [r7, #4]
   1a64e:	69ba      	ldr	r2, [r7, #24]
   1a650:	609a      	str	r2, [r3, #8]
		if (ofs) {
   1a652:	683b      	ldr	r3, [r7, #0]
   1a654:	2b00      	cmp	r3, #0
   1a656:	d100      	bne.n	1a65a <f_lseek+0x6e>
   1a658:	e0b5      	b.n	1a7c6 <f_lseek+0x1da>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   1a65a:	687b      	ldr	r3, [r7, #4]
   1a65c:	681b      	ldr	r3, [r3, #0]
   1a65e:	789b      	ldrb	r3, [r3, #2]
   1a660:	025b      	lsls	r3, r3, #9
   1a662:	60fb      	str	r3, [r7, #12]
			if (ifptr > 0 &&
   1a664:	693b      	ldr	r3, [r7, #16]
   1a666:	2b00      	cmp	r3, #0
   1a668:	d020      	beq.n	1a6ac <f_lseek+0xc0>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   1a66a:	683b      	ldr	r3, [r7, #0]
   1a66c:	1e5a      	subs	r2, r3, #1
   1a66e:	4b81      	ldr	r3, [pc, #516]	; (1a874 <f_lseek+0x288>)
   1a670:	68f9      	ldr	r1, [r7, #12]
   1a672:	0010      	movs	r0, r2
   1a674:	4798      	blx	r3
   1a676:	0003      	movs	r3, r0
   1a678:	001c      	movs	r4, r3
   1a67a:	693b      	ldr	r3, [r7, #16]
   1a67c:	1e5a      	subs	r2, r3, #1
   1a67e:	4b7d      	ldr	r3, [pc, #500]	; (1a874 <f_lseek+0x288>)
   1a680:	68f9      	ldr	r1, [r7, #12]
   1a682:	0010      	movs	r0, r2
   1a684:	4798      	blx	r3
   1a686:	0003      	movs	r3, r0

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
   1a688:	429c      	cmp	r4, r3
   1a68a:	d30f      	bcc.n	1a6ac <f_lseek+0xc0>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   1a68c:	693b      	ldr	r3, [r7, #16]
   1a68e:	3b01      	subs	r3, #1
   1a690:	68fa      	ldr	r2, [r7, #12]
   1a692:	4252      	negs	r2, r2
   1a694:	401a      	ands	r2, r3
   1a696:	687b      	ldr	r3, [r7, #4]
   1a698:	609a      	str	r2, [r3, #8]
				ofs -= fp->fptr;
   1a69a:	687b      	ldr	r3, [r7, #4]
   1a69c:	689b      	ldr	r3, [r3, #8]
   1a69e:	683a      	ldr	r2, [r7, #0]
   1a6a0:	1ad3      	subs	r3, r2, r3
   1a6a2:	603b      	str	r3, [r7, #0]
				clst = fp->clust;
   1a6a4:	687b      	ldr	r3, [r7, #4]
   1a6a6:	695b      	ldr	r3, [r3, #20]
   1a6a8:	61fb      	str	r3, [r7, #28]
   1a6aa:	e023      	b.n	1a6f4 <f_lseek+0x108>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
   1a6ac:	687b      	ldr	r3, [r7, #4]
   1a6ae:	691b      	ldr	r3, [r3, #16]
   1a6b0:	61fb      	str	r3, [r7, #28]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
   1a6b2:	69fb      	ldr	r3, [r7, #28]
   1a6b4:	2b00      	cmp	r3, #0
   1a6b6:	d11a      	bne.n	1a6ee <f_lseek+0x102>
					clst = create_chain(fp->fs, 0);
   1a6b8:	687b      	ldr	r3, [r7, #4]
   1a6ba:	681b      	ldr	r3, [r3, #0]
   1a6bc:	2100      	movs	r1, #0
   1a6be:	0018      	movs	r0, r3
   1a6c0:	4b6d      	ldr	r3, [pc, #436]	; (1a878 <f_lseek+0x28c>)
   1a6c2:	4798      	blx	r3
   1a6c4:	0003      	movs	r3, r0
   1a6c6:	61fb      	str	r3, [r7, #28]
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   1a6c8:	69fb      	ldr	r3, [r7, #28]
   1a6ca:	2b01      	cmp	r3, #1
   1a6cc:	d104      	bne.n	1a6d8 <f_lseek+0xec>
   1a6ce:	687b      	ldr	r3, [r7, #4]
   1a6d0:	2202      	movs	r2, #2
   1a6d2:	71da      	strb	r2, [r3, #7]
   1a6d4:	2302      	movs	r3, #2
   1a6d6:	e0c7      	b.n	1a868 <f_lseek+0x27c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   1a6d8:	69fb      	ldr	r3, [r7, #28]
   1a6da:	3301      	adds	r3, #1
   1a6dc:	d104      	bne.n	1a6e8 <f_lseek+0xfc>
   1a6de:	687b      	ldr	r3, [r7, #4]
   1a6e0:	2201      	movs	r2, #1
   1a6e2:	71da      	strb	r2, [r3, #7]
   1a6e4:	2301      	movs	r3, #1
   1a6e6:	e0bf      	b.n	1a868 <f_lseek+0x27c>
					fp->sclust = clst;
   1a6e8:	687b      	ldr	r3, [r7, #4]
   1a6ea:	69fa      	ldr	r2, [r7, #28]
   1a6ec:	611a      	str	r2, [r3, #16]
				}
#endif
				fp->clust = clst;
   1a6ee:	687b      	ldr	r3, [r7, #4]
   1a6f0:	69fa      	ldr	r2, [r7, #28]
   1a6f2:	615a      	str	r2, [r3, #20]
			}
			if (clst != 0) {
   1a6f4:	69fb      	ldr	r3, [r7, #28]
   1a6f6:	2b00      	cmp	r3, #0
   1a6f8:	d065      	beq.n	1a7c6 <f_lseek+0x1da>
				while (ofs > bcs) {						/* Cluster following loop */
   1a6fa:	e040      	b.n	1a77e <f_lseek+0x192>
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   1a6fc:	687b      	ldr	r3, [r7, #4]
   1a6fe:	799b      	ldrb	r3, [r3, #6]
   1a700:	001a      	movs	r2, r3
   1a702:	2302      	movs	r3, #2
   1a704:	4013      	ands	r3, r2
   1a706:	d00e      	beq.n	1a726 <f_lseek+0x13a>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   1a708:	687b      	ldr	r3, [r7, #4]
   1a70a:	681b      	ldr	r3, [r3, #0]
   1a70c:	69fa      	ldr	r2, [r7, #28]
   1a70e:	0011      	movs	r1, r2
   1a710:	0018      	movs	r0, r3
   1a712:	4b59      	ldr	r3, [pc, #356]	; (1a878 <f_lseek+0x28c>)
   1a714:	4798      	blx	r3
   1a716:	0003      	movs	r3, r0
   1a718:	61fb      	str	r3, [r7, #28]
						if (clst == 0) {				/* When disk gets full, clip file size */
   1a71a:	69fb      	ldr	r3, [r7, #28]
   1a71c:	2b00      	cmp	r3, #0
   1a71e:	d10b      	bne.n	1a738 <f_lseek+0x14c>
							ofs = bcs; break;
   1a720:	68fb      	ldr	r3, [r7, #12]
   1a722:	603b      	str	r3, [r7, #0]
   1a724:	e02f      	b.n	1a786 <f_lseek+0x19a>
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   1a726:	687b      	ldr	r3, [r7, #4]
   1a728:	681b      	ldr	r3, [r3, #0]
   1a72a:	69fa      	ldr	r2, [r7, #28]
   1a72c:	0011      	movs	r1, r2
   1a72e:	0018      	movs	r0, r3
   1a730:	4b52      	ldr	r3, [pc, #328]	; (1a87c <f_lseek+0x290>)
   1a732:	4798      	blx	r3
   1a734:	0003      	movs	r3, r0
   1a736:	61fb      	str	r3, [r7, #28]
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   1a738:	69fb      	ldr	r3, [r7, #28]
   1a73a:	3301      	adds	r3, #1
   1a73c:	d104      	bne.n	1a748 <f_lseek+0x15c>
   1a73e:	687b      	ldr	r3, [r7, #4]
   1a740:	2201      	movs	r2, #1
   1a742:	71da      	strb	r2, [r3, #7]
   1a744:	2301      	movs	r3, #1
   1a746:	e08f      	b.n	1a868 <f_lseek+0x27c>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   1a748:	69fb      	ldr	r3, [r7, #28]
   1a74a:	2b01      	cmp	r3, #1
   1a74c:	d905      	bls.n	1a75a <f_lseek+0x16e>
   1a74e:	687b      	ldr	r3, [r7, #4]
   1a750:	681b      	ldr	r3, [r3, #0]
   1a752:	695a      	ldr	r2, [r3, #20]
   1a754:	69fb      	ldr	r3, [r7, #28]
   1a756:	429a      	cmp	r2, r3
   1a758:	d804      	bhi.n	1a764 <f_lseek+0x178>
   1a75a:	687b      	ldr	r3, [r7, #4]
   1a75c:	2202      	movs	r2, #2
   1a75e:	71da      	strb	r2, [r3, #7]
   1a760:	2302      	movs	r3, #2
   1a762:	e081      	b.n	1a868 <f_lseek+0x27c>
					fp->clust = clst;
   1a764:	687b      	ldr	r3, [r7, #4]
   1a766:	69fa      	ldr	r2, [r7, #28]
   1a768:	615a      	str	r2, [r3, #20]
					fp->fptr += bcs;
   1a76a:	687b      	ldr	r3, [r7, #4]
   1a76c:	689a      	ldr	r2, [r3, #8]
   1a76e:	68fb      	ldr	r3, [r7, #12]
   1a770:	18d2      	adds	r2, r2, r3
   1a772:	687b      	ldr	r3, [r7, #4]
   1a774:	609a      	str	r2, [r3, #8]
					ofs -= bcs;
   1a776:	683a      	ldr	r2, [r7, #0]
   1a778:	68fb      	ldr	r3, [r7, #12]
   1a77a:	1ad3      	subs	r3, r2, r3
   1a77c:	603b      	str	r3, [r7, #0]
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
   1a77e:	683a      	ldr	r2, [r7, #0]
   1a780:	68fb      	ldr	r3, [r7, #12]
   1a782:	429a      	cmp	r2, r3
   1a784:	d8ba      	bhi.n	1a6fc <f_lseek+0x110>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
   1a786:	687b      	ldr	r3, [r7, #4]
   1a788:	689a      	ldr	r2, [r3, #8]
   1a78a:	683b      	ldr	r3, [r7, #0]
   1a78c:	18d2      	adds	r2, r2, r3
   1a78e:	687b      	ldr	r3, [r7, #4]
   1a790:	609a      	str	r2, [r3, #8]
				if (ofs % SS(fp->fs)) {
   1a792:	683b      	ldr	r3, [r7, #0]
   1a794:	05db      	lsls	r3, r3, #23
   1a796:	0ddb      	lsrs	r3, r3, #23
   1a798:	d015      	beq.n	1a7c6 <f_lseek+0x1da>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   1a79a:	687b      	ldr	r3, [r7, #4]
   1a79c:	681b      	ldr	r3, [r3, #0]
   1a79e:	69fa      	ldr	r2, [r7, #28]
   1a7a0:	0011      	movs	r1, r2
   1a7a2:	0018      	movs	r0, r3
   1a7a4:	4b36      	ldr	r3, [pc, #216]	; (1a880 <f_lseek+0x294>)
   1a7a6:	4798      	blx	r3
   1a7a8:	0003      	movs	r3, r0
   1a7aa:	61bb      	str	r3, [r7, #24]
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   1a7ac:	69bb      	ldr	r3, [r7, #24]
   1a7ae:	2b00      	cmp	r3, #0
   1a7b0:	d104      	bne.n	1a7bc <f_lseek+0x1d0>
   1a7b2:	687b      	ldr	r3, [r7, #4]
   1a7b4:	2202      	movs	r2, #2
   1a7b6:	71da      	strb	r2, [r3, #7]
   1a7b8:	2302      	movs	r3, #2
   1a7ba:	e055      	b.n	1a868 <f_lseek+0x27c>
					nsect += ofs / SS(fp->fs);
   1a7bc:	683b      	ldr	r3, [r7, #0]
   1a7be:	0a5b      	lsrs	r3, r3, #9
   1a7c0:	69ba      	ldr	r2, [r7, #24]
   1a7c2:	18d3      	adds	r3, r2, r3
   1a7c4:	61bb      	str	r3, [r7, #24]
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   1a7c6:	687b      	ldr	r3, [r7, #4]
   1a7c8:	689b      	ldr	r3, [r3, #8]
   1a7ca:	05db      	lsls	r3, r3, #23
   1a7cc:	0ddb      	lsrs	r3, r3, #23
   1a7ce:	d037      	beq.n	1a840 <f_lseek+0x254>
   1a7d0:	687b      	ldr	r3, [r7, #4]
   1a7d2:	699a      	ldr	r2, [r3, #24]
   1a7d4:	69bb      	ldr	r3, [r7, #24]
   1a7d6:	429a      	cmp	r2, r3
   1a7d8:	d032      	beq.n	1a840 <f_lseek+0x254>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   1a7da:	687b      	ldr	r3, [r7, #4]
   1a7dc:	799b      	ldrb	r3, [r3, #6]
   1a7de:	001a      	movs	r2, r3
   1a7e0:	2340      	movs	r3, #64	; 0x40
   1a7e2:	4013      	ands	r3, r2
   1a7e4:	d018      	beq.n	1a818 <f_lseek+0x22c>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   1a7e6:	687b      	ldr	r3, [r7, #4]
   1a7e8:	681b      	ldr	r3, [r3, #0]
   1a7ea:	7858      	ldrb	r0, [r3, #1]
   1a7ec:	687b      	ldr	r3, [r7, #4]
   1a7ee:	3324      	adds	r3, #36	; 0x24
   1a7f0:	0019      	movs	r1, r3
   1a7f2:	687b      	ldr	r3, [r7, #4]
   1a7f4:	699a      	ldr	r2, [r3, #24]
   1a7f6:	2301      	movs	r3, #1
   1a7f8:	4c22      	ldr	r4, [pc, #136]	; (1a884 <f_lseek+0x298>)
   1a7fa:	47a0      	blx	r4
   1a7fc:	1e03      	subs	r3, r0, #0
   1a7fe:	d004      	beq.n	1a80a <f_lseek+0x21e>
					ABORT(fp->fs, FR_DISK_ERR);
   1a800:	687b      	ldr	r3, [r7, #4]
   1a802:	2201      	movs	r2, #1
   1a804:	71da      	strb	r2, [r3, #7]
   1a806:	2301      	movs	r3, #1
   1a808:	e02e      	b.n	1a868 <f_lseek+0x27c>
				fp->flag &= ~FA__DIRTY;
   1a80a:	687b      	ldr	r3, [r7, #4]
   1a80c:	799b      	ldrb	r3, [r3, #6]
   1a80e:	2240      	movs	r2, #64	; 0x40
   1a810:	4393      	bics	r3, r2
   1a812:	b2da      	uxtb	r2, r3
   1a814:	687b      	ldr	r3, [r7, #4]
   1a816:	719a      	strb	r2, [r3, #6]
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   1a818:	687b      	ldr	r3, [r7, #4]
   1a81a:	681b      	ldr	r3, [r3, #0]
   1a81c:	7858      	ldrb	r0, [r3, #1]
   1a81e:	687b      	ldr	r3, [r7, #4]
   1a820:	3324      	adds	r3, #36	; 0x24
   1a822:	0019      	movs	r1, r3
   1a824:	69ba      	ldr	r2, [r7, #24]
   1a826:	2301      	movs	r3, #1
   1a828:	4c17      	ldr	r4, [pc, #92]	; (1a888 <f_lseek+0x29c>)
   1a82a:	47a0      	blx	r4
   1a82c:	1e03      	subs	r3, r0, #0
   1a82e:	d004      	beq.n	1a83a <f_lseek+0x24e>
				ABORT(fp->fs, FR_DISK_ERR);
   1a830:	687b      	ldr	r3, [r7, #4]
   1a832:	2201      	movs	r2, #1
   1a834:	71da      	strb	r2, [r3, #7]
   1a836:	2301      	movs	r3, #1
   1a838:	e016      	b.n	1a868 <f_lseek+0x27c>
#endif
			fp->dsect = nsect;
   1a83a:	687b      	ldr	r3, [r7, #4]
   1a83c:	69ba      	ldr	r2, [r7, #24]
   1a83e:	619a      	str	r2, [r3, #24]
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   1a840:	687b      	ldr	r3, [r7, #4]
   1a842:	689a      	ldr	r2, [r3, #8]
   1a844:	687b      	ldr	r3, [r7, #4]
   1a846:	68db      	ldr	r3, [r3, #12]
   1a848:	429a      	cmp	r2, r3
   1a84a:	d90a      	bls.n	1a862 <f_lseek+0x276>
			fp->fsize = fp->fptr;
   1a84c:	687b      	ldr	r3, [r7, #4]
   1a84e:	689a      	ldr	r2, [r3, #8]
   1a850:	687b      	ldr	r3, [r7, #4]
   1a852:	60da      	str	r2, [r3, #12]
			fp->flag |= FA__WRITTEN;
   1a854:	687b      	ldr	r3, [r7, #4]
   1a856:	799b      	ldrb	r3, [r3, #6]
   1a858:	2220      	movs	r2, #32
   1a85a:	4313      	orrs	r3, r2
   1a85c:	b2da      	uxtb	r2, r3
   1a85e:	687b      	ldr	r3, [r7, #4]
   1a860:	719a      	strb	r2, [r3, #6]
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
   1a862:	2317      	movs	r3, #23
   1a864:	18fb      	adds	r3, r7, r3
   1a866:	781b      	ldrb	r3, [r3, #0]
}
   1a868:	0018      	movs	r0, r3
   1a86a:	46bd      	mov	sp, r7
   1a86c:	b009      	add	sp, #36	; 0x24
   1a86e:	bd90      	pop	{r4, r7, pc}
   1a870:	00019a11 	.word	0x00019a11
   1a874:	0001d485 	.word	0x0001d485
   1a878:	00017c25 	.word	0x00017c25
   1a87c:	00017799 	.word	0x00017799
   1a880:	00017761 	.word	0x00017761
   1a884:	000171b9 	.word	0x000171b9
   1a888:	000170f1 	.word	0x000170f1

0001a88c <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
   1a88c:	b590      	push	{r4, r7, lr}
   1a88e:	b09b      	sub	sp, #108	; 0x6c
   1a890:	af00      	add	r7, sp, #0
   1a892:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DIR dj, sdj;
	BYTE *dir;
	DWORD dclst = 0;
   1a894:	2300      	movs	r3, #0
   1a896:	663b      	str	r3, [r7, #96]	; 0x60
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
   1a898:	2367      	movs	r3, #103	; 0x67
   1a89a:	18fc      	adds	r4, r7, r3
   1a89c:	1d39      	adds	r1, r7, #4
   1a89e:	2338      	movs	r3, #56	; 0x38
   1a8a0:	18fb      	adds	r3, r7, r3
   1a8a2:	2201      	movs	r2, #1
   1a8a4:	0018      	movs	r0, r3
   1a8a6:	4b61      	ldr	r3, [pc, #388]	; (1aa2c <f_unlink+0x1a0>)
   1a8a8:	4798      	blx	r3
   1a8aa:	0003      	movs	r3, r0
   1a8ac:	7023      	strb	r3, [r4, #0]
	if (res == FR_OK) {
   1a8ae:	2367      	movs	r3, #103	; 0x67
   1a8b0:	18fb      	adds	r3, r7, r3
   1a8b2:	781b      	ldrb	r3, [r3, #0]
   1a8b4:	2b00      	cmp	r3, #0
   1a8b6:	d000      	beq.n	1a8ba <f_unlink+0x2e>
   1a8b8:	e0b1      	b.n	1aa1e <f_unlink+0x192>
		INIT_BUF(dj);
   1a8ba:	2338      	movs	r3, #56	; 0x38
   1a8bc:	18fb      	adds	r3, r7, r3
   1a8be:	2208      	movs	r2, #8
   1a8c0:	18ba      	adds	r2, r7, r2
   1a8c2:	619a      	str	r2, [r3, #24]
   1a8c4:	2338      	movs	r3, #56	; 0x38
   1a8c6:	18fb      	adds	r3, r7, r3
   1a8c8:	4a59      	ldr	r2, [pc, #356]	; (1aa30 <f_unlink+0x1a4>)
   1a8ca:	61da      	str	r2, [r3, #28]
		res = follow_path(&dj, path);		/* Follow the file path */
   1a8cc:	687a      	ldr	r2, [r7, #4]
   1a8ce:	2367      	movs	r3, #103	; 0x67
   1a8d0:	18fc      	adds	r4, r7, r3
   1a8d2:	2338      	movs	r3, #56	; 0x38
   1a8d4:	18fb      	adds	r3, r7, r3
   1a8d6:	0011      	movs	r1, r2
   1a8d8:	0018      	movs	r0, r3
   1a8da:	4b56      	ldr	r3, [pc, #344]	; (1aa34 <f_unlink+0x1a8>)
   1a8dc:	4798      	blx	r3
   1a8de:	0003      	movs	r3, r0
   1a8e0:	7023      	strb	r3, [r4, #0]
		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open object */
#endif
		if (res == FR_OK) {					/* The object is accessible */
   1a8e2:	2367      	movs	r3, #103	; 0x67
   1a8e4:	18fb      	adds	r3, r7, r3
   1a8e6:	781b      	ldrb	r3, [r3, #0]
   1a8e8:	2b00      	cmp	r3, #0
   1a8ea:	d000      	beq.n	1a8ee <f_unlink+0x62>
   1a8ec:	e097      	b.n	1aa1e <f_unlink+0x192>
			dir = dj.dir;
   1a8ee:	2338      	movs	r3, #56	; 0x38
   1a8f0:	18fb      	adds	r3, r7, r3
   1a8f2:	695b      	ldr	r3, [r3, #20]
   1a8f4:	65fb      	str	r3, [r7, #92]	; 0x5c
			if (!dir) {
   1a8f6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1a8f8:	2b00      	cmp	r3, #0
   1a8fa:	d104      	bne.n	1a906 <f_unlink+0x7a>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
   1a8fc:	2367      	movs	r3, #103	; 0x67
   1a8fe:	18fb      	adds	r3, r7, r3
   1a900:	2206      	movs	r2, #6
   1a902:	701a      	strb	r2, [r3, #0]
   1a904:	e00a      	b.n	1a91c <f_unlink+0x90>
			} else {
				if (dir[DIR_Attr] & AM_RDO)
   1a906:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1a908:	330b      	adds	r3, #11
   1a90a:	781b      	ldrb	r3, [r3, #0]
   1a90c:	001a      	movs	r2, r3
   1a90e:	2301      	movs	r3, #1
   1a910:	4013      	ands	r3, r2
   1a912:	d003      	beq.n	1a91c <f_unlink+0x90>
					res = FR_DENIED;		/* Cannot remove R/O object */
   1a914:	2367      	movs	r3, #103	; 0x67
   1a916:	18fb      	adds	r3, r7, r3
   1a918:	2207      	movs	r2, #7
   1a91a:	701a      	strb	r2, [r3, #0]
			}
			if (res == FR_OK) {
   1a91c:	2367      	movs	r3, #103	; 0x67
   1a91e:	18fb      	adds	r3, r7, r3
   1a920:	781b      	ldrb	r3, [r3, #0]
   1a922:	2b00      	cmp	r3, #0
   1a924:	d14a      	bne.n	1a9bc <f_unlink+0x130>
				dclst = ld_clust(dj.fs, dir);
   1a926:	2338      	movs	r3, #56	; 0x38
   1a928:	18fb      	adds	r3, r7, r3
   1a92a:	681b      	ldr	r3, [r3, #0]
   1a92c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   1a92e:	0011      	movs	r1, r2
   1a930:	0018      	movs	r0, r3
   1a932:	4b41      	ldr	r3, [pc, #260]	; (1aa38 <f_unlink+0x1ac>)
   1a934:	4798      	blx	r3
   1a936:	0003      	movs	r3, r0
   1a938:	663b      	str	r3, [r7, #96]	; 0x60
				if (dclst && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-directory ? */
   1a93a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1a93c:	2b00      	cmp	r3, #0
   1a93e:	d03d      	beq.n	1a9bc <f_unlink+0x130>
   1a940:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1a942:	330b      	adds	r3, #11
   1a944:	781b      	ldrb	r3, [r3, #0]
   1a946:	001a      	movs	r2, r3
   1a948:	2310      	movs	r3, #16
   1a94a:	4013      	ands	r3, r2
   1a94c:	d036      	beq.n	1a9bc <f_unlink+0x130>
					if (dclst == dj.fs->cdir) {		 		/* Is it the current directory? */
						res = FR_DENIED;
					} else
#endif
					{
						mem_cpy(&sdj, &dj, sizeof (DIR));	/* Open the sub-directory */
   1a94e:	2338      	movs	r3, #56	; 0x38
   1a950:	18f9      	adds	r1, r7, r3
   1a952:	2314      	movs	r3, #20
   1a954:	18fb      	adds	r3, r7, r3
   1a956:	2224      	movs	r2, #36	; 0x24
   1a958:	0018      	movs	r0, r3
   1a95a:	4b38      	ldr	r3, [pc, #224]	; (1aa3c <f_unlink+0x1b0>)
   1a95c:	4798      	blx	r3
						sdj.sclust = dclst;
   1a95e:	2314      	movs	r3, #20
   1a960:	18fb      	adds	r3, r7, r3
   1a962:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   1a964:	609a      	str	r2, [r3, #8]
						res = dir_sdi(&sdj, 2);
   1a966:	2367      	movs	r3, #103	; 0x67
   1a968:	18fc      	adds	r4, r7, r3
   1a96a:	2314      	movs	r3, #20
   1a96c:	18fb      	adds	r3, r7, r3
   1a96e:	2102      	movs	r1, #2
   1a970:	0018      	movs	r0, r3
   1a972:	4b33      	ldr	r3, [pc, #204]	; (1aa40 <f_unlink+0x1b4>)
   1a974:	4798      	blx	r3
   1a976:	0003      	movs	r3, r0
   1a978:	7023      	strb	r3, [r4, #0]
						if (res == FR_OK) {
   1a97a:	2367      	movs	r3, #103	; 0x67
   1a97c:	18fb      	adds	r3, r7, r3
   1a97e:	781b      	ldrb	r3, [r3, #0]
   1a980:	2b00      	cmp	r3, #0
   1a982:	d11b      	bne.n	1a9bc <f_unlink+0x130>
							res = dir_read(&sdj, 0);			/* Read an item (excluding dot entries) */
   1a984:	2367      	movs	r3, #103	; 0x67
   1a986:	18fc      	adds	r4, r7, r3
   1a988:	2314      	movs	r3, #20
   1a98a:	18fb      	adds	r3, r7, r3
   1a98c:	2100      	movs	r1, #0
   1a98e:	0018      	movs	r0, r3
   1a990:	4b2c      	ldr	r3, [pc, #176]	; (1aa44 <f_unlink+0x1b8>)
   1a992:	4798      	blx	r3
   1a994:	0003      	movs	r3, r0
   1a996:	7023      	strb	r3, [r4, #0]
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? (cannot remove) */
   1a998:	2367      	movs	r3, #103	; 0x67
   1a99a:	18fb      	adds	r3, r7, r3
   1a99c:	781b      	ldrb	r3, [r3, #0]
   1a99e:	2b00      	cmp	r3, #0
   1a9a0:	d103      	bne.n	1a9aa <f_unlink+0x11e>
   1a9a2:	2367      	movs	r3, #103	; 0x67
   1a9a4:	18fb      	adds	r3, r7, r3
   1a9a6:	2207      	movs	r2, #7
   1a9a8:	701a      	strb	r2, [r3, #0]
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? (can remove) */
   1a9aa:	2367      	movs	r3, #103	; 0x67
   1a9ac:	18fb      	adds	r3, r7, r3
   1a9ae:	781b      	ldrb	r3, [r3, #0]
   1a9b0:	2b04      	cmp	r3, #4
   1a9b2:	d103      	bne.n	1a9bc <f_unlink+0x130>
   1a9b4:	2367      	movs	r3, #103	; 0x67
   1a9b6:	18fb      	adds	r3, r7, r3
   1a9b8:	2200      	movs	r2, #0
   1a9ba:	701a      	strb	r2, [r3, #0]
						}
					}
				}
			}
			if (res == FR_OK) {
   1a9bc:	2367      	movs	r3, #103	; 0x67
   1a9be:	18fb      	adds	r3, r7, r3
   1a9c0:	781b      	ldrb	r3, [r3, #0]
   1a9c2:	2b00      	cmp	r3, #0
   1a9c4:	d12b      	bne.n	1aa1e <f_unlink+0x192>
				res = dir_remove(&dj);		/* Remove the directory entry */
   1a9c6:	2367      	movs	r3, #103	; 0x67
   1a9c8:	18fc      	adds	r4, r7, r3
   1a9ca:	2338      	movs	r3, #56	; 0x38
   1a9cc:	18fb      	adds	r3, r7, r3
   1a9ce:	0018      	movs	r0, r3
   1a9d0:	4b1d      	ldr	r3, [pc, #116]	; (1aa48 <f_unlink+0x1bc>)
   1a9d2:	4798      	blx	r3
   1a9d4:	0003      	movs	r3, r0
   1a9d6:	7023      	strb	r3, [r4, #0]
				if (res == FR_OK && dclst)	/* Remove the cluster chain if exist */
   1a9d8:	2367      	movs	r3, #103	; 0x67
   1a9da:	18fb      	adds	r3, r7, r3
   1a9dc:	781b      	ldrb	r3, [r3, #0]
   1a9de:	2b00      	cmp	r3, #0
   1a9e0:	d10e      	bne.n	1aa00 <f_unlink+0x174>
   1a9e2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1a9e4:	2b00      	cmp	r3, #0
   1a9e6:	d00b      	beq.n	1aa00 <f_unlink+0x174>
					res = remove_chain(dj.fs, dclst);
   1a9e8:	2338      	movs	r3, #56	; 0x38
   1a9ea:	18fb      	adds	r3, r7, r3
   1a9ec:	681b      	ldr	r3, [r3, #0]
   1a9ee:	2267      	movs	r2, #103	; 0x67
   1a9f0:	18bc      	adds	r4, r7, r2
   1a9f2:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   1a9f4:	0011      	movs	r1, r2
   1a9f6:	0018      	movs	r0, r3
   1a9f8:	4b14      	ldr	r3, [pc, #80]	; (1aa4c <f_unlink+0x1c0>)
   1a9fa:	4798      	blx	r3
   1a9fc:	0003      	movs	r3, r0
   1a9fe:	7023      	strb	r3, [r4, #0]
				if (res == FR_OK) res = sync_fs(dj.fs);
   1aa00:	2367      	movs	r3, #103	; 0x67
   1aa02:	18fb      	adds	r3, r7, r3
   1aa04:	781b      	ldrb	r3, [r3, #0]
   1aa06:	2b00      	cmp	r3, #0
   1aa08:	d109      	bne.n	1aa1e <f_unlink+0x192>
   1aa0a:	2338      	movs	r3, #56	; 0x38
   1aa0c:	18fb      	adds	r3, r7, r3
   1aa0e:	681b      	ldr	r3, [r3, #0]
   1aa10:	2267      	movs	r2, #103	; 0x67
   1aa12:	18bc      	adds	r4, r7, r2
   1aa14:	0018      	movs	r0, r3
   1aa16:	4b0e      	ldr	r3, [pc, #56]	; (1aa50 <f_unlink+0x1c4>)
   1aa18:	4798      	blx	r3
   1aa1a:	0003      	movs	r3, r0
   1aa1c:	7023      	strb	r3, [r4, #0]
			}
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
   1aa1e:	2367      	movs	r3, #103	; 0x67
   1aa20:	18fb      	adds	r3, r7, r3
   1aa22:	781b      	ldrb	r3, [r3, #0]
}
   1aa24:	0018      	movs	r0, r3
   1aa26:	46bd      	mov	sp, r7
   1aa28:	b01b      	add	sp, #108	; 0x6c
   1aa2a:	bd90      	pop	{r4, r7, pc}
   1aa2c:	00019421 	.word	0x00019421
   1aa30:	20002e90 	.word	0x20002e90
   1aa34:	000191ad 	.word	0x000191ad
   1aa38:	000180f9 	.word	0x000180f9
   1aa3c:	000173d5 	.word	0x000173d5
   1aa40:	00017d75 	.word	0x00017d75
   1aa44:	0001885d 	.word	0x0001885d
   1aa48:	00018c85 	.word	0x00018c85
   1aa4c:	00017b55 	.word	0x00017b55
   1aa50:	000175cd 	.word	0x000175cd

0001aa54 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
   1aa54:	b590      	push	{r4, r7, lr}
   1aa56:	b095      	sub	sp, #84	; 0x54
   1aa58:	af00      	add	r7, sp, #0
   1aa5a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
   1aa5c:	4bb1      	ldr	r3, [pc, #708]	; (1ad24 <f_mkdir+0x2d0>)
   1aa5e:	4798      	blx	r3
   1aa60:	0003      	movs	r3, r0
   1aa62:	643b      	str	r3, [r7, #64]	; 0x40
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
   1aa64:	234f      	movs	r3, #79	; 0x4f
   1aa66:	18fc      	adds	r4, r7, r3
   1aa68:	1d39      	adds	r1, r7, #4
   1aa6a:	2314      	movs	r3, #20
   1aa6c:	18fb      	adds	r3, r7, r3
   1aa6e:	2201      	movs	r2, #1
   1aa70:	0018      	movs	r0, r3
   1aa72:	4bad      	ldr	r3, [pc, #692]	; (1ad28 <f_mkdir+0x2d4>)
   1aa74:	4798      	blx	r3
   1aa76:	0003      	movs	r3, r0
   1aa78:	7023      	strb	r3, [r4, #0]
	if (res == FR_OK) {
   1aa7a:	234f      	movs	r3, #79	; 0x4f
   1aa7c:	18fb      	adds	r3, r7, r3
   1aa7e:	781b      	ldrb	r3, [r3, #0]
   1aa80:	2b00      	cmp	r3, #0
   1aa82:	d000      	beq.n	1aa86 <f_mkdir+0x32>
   1aa84:	e146      	b.n	1ad14 <f_mkdir+0x2c0>
		INIT_BUF(dj);
   1aa86:	2314      	movs	r3, #20
   1aa88:	18fb      	adds	r3, r7, r3
   1aa8a:	2208      	movs	r2, #8
   1aa8c:	18ba      	adds	r2, r7, r2
   1aa8e:	619a      	str	r2, [r3, #24]
   1aa90:	2314      	movs	r3, #20
   1aa92:	18fb      	adds	r3, r7, r3
   1aa94:	4aa5      	ldr	r2, [pc, #660]	; (1ad2c <f_mkdir+0x2d8>)
   1aa96:	61da      	str	r2, [r3, #28]
		res = follow_path(&dj, path);			/* Follow the file path */
   1aa98:	687a      	ldr	r2, [r7, #4]
   1aa9a:	234f      	movs	r3, #79	; 0x4f
   1aa9c:	18fc      	adds	r4, r7, r3
   1aa9e:	2314      	movs	r3, #20
   1aaa0:	18fb      	adds	r3, r7, r3
   1aaa2:	0011      	movs	r1, r2
   1aaa4:	0018      	movs	r0, r3
   1aaa6:	4ba2      	ldr	r3, [pc, #648]	; (1ad30 <f_mkdir+0x2dc>)
   1aaa8:	4798      	blx	r3
   1aaaa:	0003      	movs	r3, r0
   1aaac:	7023      	strb	r3, [r4, #0]
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   1aaae:	234f      	movs	r3, #79	; 0x4f
   1aab0:	18fb      	adds	r3, r7, r3
   1aab2:	781b      	ldrb	r3, [r3, #0]
   1aab4:	2b00      	cmp	r3, #0
   1aab6:	d103      	bne.n	1aac0 <f_mkdir+0x6c>
   1aab8:	234f      	movs	r3, #79	; 0x4f
   1aaba:	18fb      	adds	r3, r7, r3
   1aabc:	2208      	movs	r2, #8
   1aabe:	701a      	strb	r2, [r3, #0]
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
   1aac0:	234f      	movs	r3, #79	; 0x4f
   1aac2:	18fb      	adds	r3, r7, r3
   1aac4:	781b      	ldrb	r3, [r3, #0]
   1aac6:	2b04      	cmp	r3, #4
   1aac8:	d000      	beq.n	1aacc <f_mkdir+0x78>
   1aaca:	e123      	b.n	1ad14 <f_mkdir+0x2c0>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   1aacc:	2314      	movs	r3, #20
   1aace:	18fb      	adds	r3, r7, r3
   1aad0:	681b      	ldr	r3, [r3, #0]
   1aad2:	2100      	movs	r1, #0
   1aad4:	0018      	movs	r0, r3
   1aad6:	4b97      	ldr	r3, [pc, #604]	; (1ad34 <f_mkdir+0x2e0>)
   1aad8:	4798      	blx	r3
   1aada:	0003      	movs	r3, r0
   1aadc:	63fb      	str	r3, [r7, #60]	; 0x3c
			res = FR_OK;
   1aade:	234f      	movs	r3, #79	; 0x4f
   1aae0:	18fb      	adds	r3, r7, r3
   1aae2:	2200      	movs	r2, #0
   1aae4:	701a      	strb	r2, [r3, #0]
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   1aae6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1aae8:	2b00      	cmp	r3, #0
   1aaea:	d103      	bne.n	1aaf4 <f_mkdir+0xa0>
   1aaec:	234f      	movs	r3, #79	; 0x4f
   1aaee:	18fb      	adds	r3, r7, r3
   1aaf0:	2207      	movs	r2, #7
   1aaf2:	701a      	strb	r2, [r3, #0]
			if (dcl == 1) res = FR_INT_ERR;
   1aaf4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1aaf6:	2b01      	cmp	r3, #1
   1aaf8:	d103      	bne.n	1ab02 <f_mkdir+0xae>
   1aafa:	234f      	movs	r3, #79	; 0x4f
   1aafc:	18fb      	adds	r3, r7, r3
   1aafe:	2202      	movs	r2, #2
   1ab00:	701a      	strb	r2, [r3, #0]
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   1ab02:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1ab04:	3301      	adds	r3, #1
   1ab06:	d103      	bne.n	1ab10 <f_mkdir+0xbc>
   1ab08:	234f      	movs	r3, #79	; 0x4f
   1ab0a:	18fb      	adds	r3, r7, r3
   1ab0c:	2201      	movs	r2, #1
   1ab0e:	701a      	strb	r2, [r3, #0]
			if (res == FR_OK)					/* Flush FAT */
   1ab10:	234f      	movs	r3, #79	; 0x4f
   1ab12:	18fb      	adds	r3, r7, r3
   1ab14:	781b      	ldrb	r3, [r3, #0]
   1ab16:	2b00      	cmp	r3, #0
   1ab18:	d109      	bne.n	1ab2e <f_mkdir+0xda>
				res = sync_window(dj.fs);
   1ab1a:	2314      	movs	r3, #20
   1ab1c:	18fb      	adds	r3, r7, r3
   1ab1e:	681b      	ldr	r3, [r3, #0]
   1ab20:	224f      	movs	r2, #79	; 0x4f
   1ab22:	18bc      	adds	r4, r7, r2
   1ab24:	0018      	movs	r0, r3
   1ab26:	4b84      	ldr	r3, [pc, #528]	; (1ad38 <f_mkdir+0x2e4>)
   1ab28:	4798      	blx	r3
   1ab2a:	0003      	movs	r3, r0
   1ab2c:	7023      	strb	r3, [r4, #0]
			if (res == FR_OK) {					/* Initialize the new directory table */
   1ab2e:	234f      	movs	r3, #79	; 0x4f
   1ab30:	18fb      	adds	r3, r7, r3
   1ab32:	781b      	ldrb	r3, [r3, #0]
   1ab34:	2b00      	cmp	r3, #0
   1ab36:	d000      	beq.n	1ab3a <f_mkdir+0xe6>
   1ab38:	e09c      	b.n	1ac74 <f_mkdir+0x220>
				dsc = clust2sect(dj.fs, dcl);
   1ab3a:	2314      	movs	r3, #20
   1ab3c:	18fb      	adds	r3, r7, r3
   1ab3e:	681b      	ldr	r3, [r3, #0]
   1ab40:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   1ab42:	0011      	movs	r1, r2
   1ab44:	0018      	movs	r0, r3
   1ab46:	4b7d      	ldr	r3, [pc, #500]	; (1ad3c <f_mkdir+0x2e8>)
   1ab48:	4798      	blx	r3
   1ab4a:	0003      	movs	r3, r0
   1ab4c:	64bb      	str	r3, [r7, #72]	; 0x48
				dir = dj.fs->win;
   1ab4e:	2314      	movs	r3, #20
   1ab50:	18fb      	adds	r3, r7, r3
   1ab52:	681b      	ldr	r3, [r3, #0]
   1ab54:	3330      	adds	r3, #48	; 0x30
   1ab56:	63bb      	str	r3, [r7, #56]	; 0x38
				mem_set(dir, 0, SS(dj.fs));
   1ab58:	2380      	movs	r3, #128	; 0x80
   1ab5a:	009a      	lsls	r2, r3, #2
   1ab5c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ab5e:	2100      	movs	r1, #0
   1ab60:	0018      	movs	r0, r3
   1ab62:	4b77      	ldr	r3, [pc, #476]	; (1ad40 <f_mkdir+0x2ec>)
   1ab64:	4798      	blx	r3
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
   1ab66:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ab68:	220b      	movs	r2, #11
   1ab6a:	2120      	movs	r1, #32
   1ab6c:	0018      	movs	r0, r3
   1ab6e:	4b74      	ldr	r3, [pc, #464]	; (1ad40 <f_mkdir+0x2ec>)
   1ab70:	4798      	blx	r3
				dir[DIR_Name] = '.';
   1ab72:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ab74:	222e      	movs	r2, #46	; 0x2e
   1ab76:	701a      	strb	r2, [r3, #0]
				dir[DIR_Attr] = AM_DIR;
   1ab78:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ab7a:	330b      	adds	r3, #11
   1ab7c:	2210      	movs	r2, #16
   1ab7e:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir + DIR_WrtTime, tm);
   1ab80:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ab82:	3316      	adds	r3, #22
   1ab84:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1ab86:	b2d2      	uxtb	r2, r2
   1ab88:	701a      	strb	r2, [r3, #0]
   1ab8a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ab8c:	3317      	adds	r3, #23
   1ab8e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1ab90:	1212      	asrs	r2, r2, #8
   1ab92:	b2d2      	uxtb	r2, r2
   1ab94:	701a      	strb	r2, [r3, #0]
   1ab96:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ab98:	3318      	adds	r3, #24
   1ab9a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1ab9c:	0c12      	lsrs	r2, r2, #16
   1ab9e:	b2d2      	uxtb	r2, r2
   1aba0:	701a      	strb	r2, [r3, #0]
   1aba2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1aba4:	3319      	adds	r3, #25
   1aba6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1aba8:	0e12      	lsrs	r2, r2, #24
   1abaa:	b2d2      	uxtb	r2, r2
   1abac:	701a      	strb	r2, [r3, #0]
				st_clust(dir, dcl);
   1abae:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   1abb0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1abb2:	0011      	movs	r1, r2
   1abb4:	0018      	movs	r0, r3
   1abb6:	4b63      	ldr	r3, [pc, #396]	; (1ad44 <f_mkdir+0x2f0>)
   1abb8:	4798      	blx	r3
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
   1abba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1abbc:	3320      	adds	r3, #32
   1abbe:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   1abc0:	2220      	movs	r2, #32
   1abc2:	0018      	movs	r0, r3
   1abc4:	4b60      	ldr	r3, [pc, #384]	; (1ad48 <f_mkdir+0x2f4>)
   1abc6:	4798      	blx	r3
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
   1abc8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1abca:	3321      	adds	r3, #33	; 0x21
   1abcc:	222e      	movs	r2, #46	; 0x2e
   1abce:	701a      	strb	r2, [r3, #0]
   1abd0:	2314      	movs	r3, #20
   1abd2:	18fb      	adds	r3, r7, r3
   1abd4:	689b      	ldr	r3, [r3, #8]
   1abd6:	647b      	str	r3, [r7, #68]	; 0x44
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   1abd8:	2314      	movs	r3, #20
   1abda:	18fb      	adds	r3, r7, r3
   1abdc:	681b      	ldr	r3, [r3, #0]
   1abde:	781b      	ldrb	r3, [r3, #0]
   1abe0:	2b03      	cmp	r3, #3
   1abe2:	d108      	bne.n	1abf6 <f_mkdir+0x1a2>
   1abe4:	2314      	movs	r3, #20
   1abe6:	18fb      	adds	r3, r7, r3
   1abe8:	681b      	ldr	r3, [r3, #0]
   1abea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   1abec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1abee:	429a      	cmp	r2, r3
   1abf0:	d101      	bne.n	1abf6 <f_mkdir+0x1a2>
					pcl = 0;
   1abf2:	2300      	movs	r3, #0
   1abf4:	647b      	str	r3, [r7, #68]	; 0x44
				st_clust(dir + SZ_DIRE, pcl);
   1abf6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1abf8:	3320      	adds	r3, #32
   1abfa:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1abfc:	0011      	movs	r1, r2
   1abfe:	0018      	movs	r0, r3
   1ac00:	4b50      	ldr	r3, [pc, #320]	; (1ad44 <f_mkdir+0x2f0>)
   1ac02:	4798      	blx	r3
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   1ac04:	2314      	movs	r3, #20
   1ac06:	18fb      	adds	r3, r7, r3
   1ac08:	681a      	ldr	r2, [r3, #0]
   1ac0a:	234e      	movs	r3, #78	; 0x4e
   1ac0c:	18fb      	adds	r3, r7, r3
   1ac0e:	7892      	ldrb	r2, [r2, #2]
   1ac10:	701a      	strb	r2, [r3, #0]
   1ac12:	e028      	b.n	1ac66 <f_mkdir+0x212>
					dj.fs->winsect = dsc++;
   1ac14:	2314      	movs	r3, #20
   1ac16:	18fb      	adds	r3, r7, r3
   1ac18:	681b      	ldr	r3, [r3, #0]
   1ac1a:	6cba      	ldr	r2, [r7, #72]	; 0x48
   1ac1c:	1c51      	adds	r1, r2, #1
   1ac1e:	64b9      	str	r1, [r7, #72]	; 0x48
   1ac20:	62da      	str	r2, [r3, #44]	; 0x2c
					dj.fs->wflag = 1;
   1ac22:	2314      	movs	r3, #20
   1ac24:	18fb      	adds	r3, r7, r3
   1ac26:	681b      	ldr	r3, [r3, #0]
   1ac28:	2201      	movs	r2, #1
   1ac2a:	711a      	strb	r2, [r3, #4]
					res = sync_window(dj.fs);
   1ac2c:	2314      	movs	r3, #20
   1ac2e:	18fb      	adds	r3, r7, r3
   1ac30:	681b      	ldr	r3, [r3, #0]
   1ac32:	224f      	movs	r2, #79	; 0x4f
   1ac34:	18bc      	adds	r4, r7, r2
   1ac36:	0018      	movs	r0, r3
   1ac38:	4b3f      	ldr	r3, [pc, #252]	; (1ad38 <f_mkdir+0x2e4>)
   1ac3a:	4798      	blx	r3
   1ac3c:	0003      	movs	r3, r0
   1ac3e:	7023      	strb	r3, [r4, #0]
					if (res != FR_OK) break;
   1ac40:	234f      	movs	r3, #79	; 0x4f
   1ac42:	18fb      	adds	r3, r7, r3
   1ac44:	781b      	ldrb	r3, [r3, #0]
   1ac46:	2b00      	cmp	r3, #0
   1ac48:	d113      	bne.n	1ac72 <f_mkdir+0x21e>
					mem_set(dir, 0, SS(dj.fs));
   1ac4a:	2380      	movs	r3, #128	; 0x80
   1ac4c:	009a      	lsls	r2, r3, #2
   1ac4e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ac50:	2100      	movs	r1, #0
   1ac52:	0018      	movs	r0, r3
   1ac54:	4b3a      	ldr	r3, [pc, #232]	; (1ad40 <f_mkdir+0x2ec>)
   1ac56:	4798      	blx	r3
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   1ac58:	234e      	movs	r3, #78	; 0x4e
   1ac5a:	18fb      	adds	r3, r7, r3
   1ac5c:	781a      	ldrb	r2, [r3, #0]
   1ac5e:	234e      	movs	r3, #78	; 0x4e
   1ac60:	18fb      	adds	r3, r7, r3
   1ac62:	3a01      	subs	r2, #1
   1ac64:	701a      	strb	r2, [r3, #0]
   1ac66:	234e      	movs	r3, #78	; 0x4e
   1ac68:	18fb      	adds	r3, r7, r3
   1ac6a:	781b      	ldrb	r3, [r3, #0]
   1ac6c:	2b00      	cmp	r3, #0
   1ac6e:	d1d1      	bne.n	1ac14 <f_mkdir+0x1c0>
   1ac70:	e000      	b.n	1ac74 <f_mkdir+0x220>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
   1ac72:	46c0      	nop			; (mov r8, r8)
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   1ac74:	234f      	movs	r3, #79	; 0x4f
   1ac76:	18fb      	adds	r3, r7, r3
   1ac78:	781b      	ldrb	r3, [r3, #0]
   1ac7a:	2b00      	cmp	r3, #0
   1ac7c:	d108      	bne.n	1ac90 <f_mkdir+0x23c>
   1ac7e:	234f      	movs	r3, #79	; 0x4f
   1ac80:	18fc      	adds	r4, r7, r3
   1ac82:	2314      	movs	r3, #20
   1ac84:	18fb      	adds	r3, r7, r3
   1ac86:	0018      	movs	r0, r3
   1ac88:	4b30      	ldr	r3, [pc, #192]	; (1ad4c <f_mkdir+0x2f8>)
   1ac8a:	4798      	blx	r3
   1ac8c:	0003      	movs	r3, r0
   1ac8e:	7023      	strb	r3, [r4, #0]
			if (res != FR_OK) {
   1ac90:	234f      	movs	r3, #79	; 0x4f
   1ac92:	18fb      	adds	r3, r7, r3
   1ac94:	781b      	ldrb	r3, [r3, #0]
   1ac96:	2b00      	cmp	r3, #0
   1ac98:	d008      	beq.n	1acac <f_mkdir+0x258>
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   1ac9a:	2314      	movs	r3, #20
   1ac9c:	18fb      	adds	r3, r7, r3
   1ac9e:	681b      	ldr	r3, [r3, #0]
   1aca0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   1aca2:	0011      	movs	r1, r2
   1aca4:	0018      	movs	r0, r3
   1aca6:	4b2a      	ldr	r3, [pc, #168]	; (1ad50 <f_mkdir+0x2fc>)
   1aca8:	4798      	blx	r3
   1acaa:	e033      	b.n	1ad14 <f_mkdir+0x2c0>
			} else {
				dir = dj.dir;
   1acac:	2314      	movs	r3, #20
   1acae:	18fb      	adds	r3, r7, r3
   1acb0:	695b      	ldr	r3, [r3, #20]
   1acb2:	63bb      	str	r3, [r7, #56]	; 0x38
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   1acb4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1acb6:	330b      	adds	r3, #11
   1acb8:	2210      	movs	r2, #16
   1acba:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
   1acbc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1acbe:	3316      	adds	r3, #22
   1acc0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1acc2:	b2d2      	uxtb	r2, r2
   1acc4:	701a      	strb	r2, [r3, #0]
   1acc6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1acc8:	3317      	adds	r3, #23
   1acca:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1accc:	1212      	asrs	r2, r2, #8
   1acce:	b2d2      	uxtb	r2, r2
   1acd0:	701a      	strb	r2, [r3, #0]
   1acd2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1acd4:	3318      	adds	r3, #24
   1acd6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1acd8:	0c12      	lsrs	r2, r2, #16
   1acda:	b2d2      	uxtb	r2, r2
   1acdc:	701a      	strb	r2, [r3, #0]
   1acde:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ace0:	3319      	adds	r3, #25
   1ace2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1ace4:	0e12      	lsrs	r2, r2, #24
   1ace6:	b2d2      	uxtb	r2, r2
   1ace8:	701a      	strb	r2, [r3, #0]
				st_clust(dir, dcl);					/* Table start cluster */
   1acea:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   1acec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1acee:	0011      	movs	r1, r2
   1acf0:	0018      	movs	r0, r3
   1acf2:	4b14      	ldr	r3, [pc, #80]	; (1ad44 <f_mkdir+0x2f0>)
   1acf4:	4798      	blx	r3
				dj.fs->wflag = 1;
   1acf6:	2314      	movs	r3, #20
   1acf8:	18fb      	adds	r3, r7, r3
   1acfa:	681b      	ldr	r3, [r3, #0]
   1acfc:	2201      	movs	r2, #1
   1acfe:	711a      	strb	r2, [r3, #4]
				res = sync_fs(dj.fs);
   1ad00:	2314      	movs	r3, #20
   1ad02:	18fb      	adds	r3, r7, r3
   1ad04:	681b      	ldr	r3, [r3, #0]
   1ad06:	224f      	movs	r2, #79	; 0x4f
   1ad08:	18bc      	adds	r4, r7, r2
   1ad0a:	0018      	movs	r0, r3
   1ad0c:	4b11      	ldr	r3, [pc, #68]	; (1ad54 <f_mkdir+0x300>)
   1ad0e:	4798      	blx	r3
   1ad10:	0003      	movs	r3, r0
   1ad12:	7023      	strb	r3, [r4, #0]
			}
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
   1ad14:	234f      	movs	r3, #79	; 0x4f
   1ad16:	18fb      	adds	r3, r7, r3
   1ad18:	781b      	ldrb	r3, [r3, #0]
}
   1ad1a:	0018      	movs	r0, r3
   1ad1c:	46bd      	mov	sp, r7
   1ad1e:	b015      	add	sp, #84	; 0x54
   1ad20:	bd90      	pop	{r4, r7, pc}
   1ad22:	46c0      	nop			; (mov r8, r8)
   1ad24:	00017379 	.word	0x00017379
   1ad28:	00019421 	.word	0x00019421
   1ad2c:	20002e90 	.word	0x20002e90
   1ad30:	000191ad 	.word	0x000191ad
   1ad34:	00017c25 	.word	0x00017c25
   1ad38:	000174bd 	.word	0x000174bd
   1ad3c:	00017761 	.word	0x00017761
   1ad40:	0001740d 	.word	0x0001740d
   1ad44:	00018151 	.word	0x00018151
   1ad48:	000173d5 	.word	0x000173d5
   1ad4c:	00018a29 	.word	0x00018a29
   1ad50:	00017b55 	.word	0x00017b55
   1ad54:	000175cd 	.word	0x000175cd

0001ad58 <ff_convert>:

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	chr,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEM code, 1: OEM code to Unicode */
)
{
   1ad58:	b580      	push	{r7, lr}
   1ad5a:	b084      	sub	sp, #16
   1ad5c:	af00      	add	r7, sp, #0
   1ad5e:	0002      	movs	r2, r0
   1ad60:	6039      	str	r1, [r7, #0]
   1ad62:	1dbb      	adds	r3, r7, #6
   1ad64:	801a      	strh	r2, [r3, #0]
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
   1ad66:	1dbb      	adds	r3, r7, #6
   1ad68:	881b      	ldrh	r3, [r3, #0]
   1ad6a:	2b7f      	cmp	r3, #127	; 0x7f
   1ad6c:	d805      	bhi.n	1ad7a <ff_convert+0x22>
		c = chr;
   1ad6e:	230e      	movs	r3, #14
   1ad70:	18fb      	adds	r3, r7, r3
   1ad72:	1dba      	adds	r2, r7, #6
   1ad74:	8812      	ldrh	r2, [r2, #0]
   1ad76:	801a      	strh	r2, [r3, #0]
   1ad78:	e03a      	b.n	1adf0 <ff_convert+0x98>

	} else {
		if (dir) {		/* OEM code to Unicode */
   1ad7a:	683b      	ldr	r3, [r7, #0]
   1ad7c:	2b00      	cmp	r3, #0
   1ad7e:	d010      	beq.n	1ada2 <ff_convert+0x4a>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
   1ad80:	1dbb      	adds	r3, r7, #6
   1ad82:	881b      	ldrh	r3, [r3, #0]
   1ad84:	2bff      	cmp	r3, #255	; 0xff
   1ad86:	d807      	bhi.n	1ad98 <ff_convert+0x40>
   1ad88:	1dbb      	adds	r3, r7, #6
   1ad8a:	881b      	ldrh	r3, [r3, #0]
   1ad8c:	3b80      	subs	r3, #128	; 0x80
   1ad8e:	001a      	movs	r2, r3
   1ad90:	4b1b      	ldr	r3, [pc, #108]	; (1ae00 <ff_convert+0xa8>)
   1ad92:	0052      	lsls	r2, r2, #1
   1ad94:	5ad2      	ldrh	r2, [r2, r3]
   1ad96:	e000      	b.n	1ad9a <ff_convert+0x42>
   1ad98:	2200      	movs	r2, #0
   1ad9a:	230e      	movs	r3, #14
   1ad9c:	18fb      	adds	r3, r7, r3
   1ad9e:	801a      	strh	r2, [r3, #0]
   1ada0:	e026      	b.n	1adf0 <ff_convert+0x98>

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
   1ada2:	230e      	movs	r3, #14
   1ada4:	18fb      	adds	r3, r7, r3
   1ada6:	2200      	movs	r2, #0
   1ada8:	801a      	strh	r2, [r3, #0]
   1adaa:	e010      	b.n	1adce <ff_convert+0x76>
				if (chr == Tbl[c]) break;
   1adac:	230e      	movs	r3, #14
   1adae:	18fb      	adds	r3, r7, r3
   1adb0:	881a      	ldrh	r2, [r3, #0]
   1adb2:	4b13      	ldr	r3, [pc, #76]	; (1ae00 <ff_convert+0xa8>)
   1adb4:	0052      	lsls	r2, r2, #1
   1adb6:	5ad3      	ldrh	r3, [r2, r3]
   1adb8:	1dba      	adds	r2, r7, #6
   1adba:	8812      	ldrh	r2, [r2, #0]
   1adbc:	429a      	cmp	r2, r3
   1adbe:	d00c      	beq.n	1adda <ff_convert+0x82>
	} else {
		if (dir) {		/* OEM code to Unicode */
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
   1adc0:	230e      	movs	r3, #14
   1adc2:	18fb      	adds	r3, r7, r3
   1adc4:	881a      	ldrh	r2, [r3, #0]
   1adc6:	230e      	movs	r3, #14
   1adc8:	18fb      	adds	r3, r7, r3
   1adca:	3201      	adds	r2, #1
   1adcc:	801a      	strh	r2, [r3, #0]
   1adce:	230e      	movs	r3, #14
   1add0:	18fb      	adds	r3, r7, r3
   1add2:	881b      	ldrh	r3, [r3, #0]
   1add4:	2b7f      	cmp	r3, #127	; 0x7f
   1add6:	d9e9      	bls.n	1adac <ff_convert+0x54>
   1add8:	e000      	b.n	1addc <ff_convert+0x84>
				if (chr == Tbl[c]) break;
   1adda:	46c0      	nop			; (mov r8, r8)
			}
			c = (c + 0x80) & 0xFF;
   1addc:	230e      	movs	r3, #14
   1adde:	18fb      	adds	r3, r7, r3
   1ade0:	881b      	ldrh	r3, [r3, #0]
   1ade2:	3380      	adds	r3, #128	; 0x80
   1ade4:	b29a      	uxth	r2, r3
   1ade6:	230e      	movs	r3, #14
   1ade8:	18fb      	adds	r3, r7, r3
   1adea:	21ff      	movs	r1, #255	; 0xff
   1adec:	400a      	ands	r2, r1
   1adee:	801a      	strh	r2, [r3, #0]
		}
	}

	return c;
   1adf0:	230e      	movs	r3, #14
   1adf2:	18fb      	adds	r3, r7, r3
   1adf4:	881b      	ldrh	r3, [r3, #0]
}
   1adf6:	0018      	movs	r0, r3
   1adf8:	46bd      	mov	sp, r7
   1adfa:	b004      	add	sp, #16
   1adfc:	bd80      	pop	{r7, pc}
   1adfe:	46c0      	nop			; (mov r8, r8)
   1ae00:	00021208 	.word	0x00021208

0001ae04 <ff_wtoupper>:


WCHAR ff_wtoupper (	/* Returns upper converted character */
	WCHAR chr		/* Unicode character to be upper converted */
)
{
   1ae04:	b580      	push	{r7, lr}
   1ae06:	b086      	sub	sp, #24
   1ae08:	af00      	add	r7, sp, #0
   1ae0a:	0002      	movs	r2, r0
   1ae0c:	1dbb      	adds	r3, r7, #6
   1ae0e:	801a      	strh	r2, [r3, #0]
									0xFF21,0xFF22,0xFF23,0xFF24,0xFF25,0xFF26,0xFF27,0xFF28,0xFF29,0xFF2A,0xFF2B,0xFF2C,0xFF2D,0xFF2E,0xFF2F,0xFF30,0xFF31,0xFF32,0xFF33,0xFF34,0xFF35,0xFF36,0xFF37,0xFF38,0xFF39,0xFF3A
	};
	UINT i, n, hi, li;


	if (chr < 0x80) {	/* ASCII characters (acceleration) */
   1ae10:	1dbb      	adds	r3, r7, #6
   1ae12:	881b      	ldrh	r3, [r3, #0]
   1ae14:	2b7f      	cmp	r3, #127	; 0x7f
   1ae16:	d80d      	bhi.n	1ae34 <ff_wtoupper+0x30>
		if (chr >= 0x61 && chr <= 0x7A) chr -= 0x20;
   1ae18:	1dbb      	adds	r3, r7, #6
   1ae1a:	881b      	ldrh	r3, [r3, #0]
   1ae1c:	2b60      	cmp	r3, #96	; 0x60
   1ae1e:	d93d      	bls.n	1ae9c <ff_wtoupper+0x98>
   1ae20:	1dbb      	adds	r3, r7, #6
   1ae22:	881b      	ldrh	r3, [r3, #0]
   1ae24:	2b7a      	cmp	r3, #122	; 0x7a
   1ae26:	d839      	bhi.n	1ae9c <ff_wtoupper+0x98>
   1ae28:	1dbb      	adds	r3, r7, #6
   1ae2a:	1dba      	adds	r2, r7, #6
   1ae2c:	8812      	ldrh	r2, [r2, #0]
   1ae2e:	3a20      	subs	r2, #32
   1ae30:	801a      	strh	r2, [r3, #0]
   1ae32:	e033      	b.n	1ae9c <ff_wtoupper+0x98>

	} else {			/* Non ASCII characters (table search) */
		n = 12; li = 0; hi = sizeof lower / sizeof lower[0];
   1ae34:	230c      	movs	r3, #12
   1ae36:	617b      	str	r3, [r7, #20]
   1ae38:	2300      	movs	r3, #0
   1ae3a:	60fb      	str	r3, [r7, #12]
   1ae3c:	23f7      	movs	r3, #247	; 0xf7
   1ae3e:	005b      	lsls	r3, r3, #1
   1ae40:	613b      	str	r3, [r7, #16]
		do {
			i = li + (hi - li) / 2;
   1ae42:	693a      	ldr	r2, [r7, #16]
   1ae44:	68fb      	ldr	r3, [r7, #12]
   1ae46:	1ad3      	subs	r3, r2, r3
   1ae48:	085a      	lsrs	r2, r3, #1
   1ae4a:	68fb      	ldr	r3, [r7, #12]
   1ae4c:	18d3      	adds	r3, r2, r3
   1ae4e:	60bb      	str	r3, [r7, #8]
			if (chr == lower[i]) break;
   1ae50:	4b15      	ldr	r3, [pc, #84]	; (1aea8 <ff_wtoupper+0xa4>)
   1ae52:	68ba      	ldr	r2, [r7, #8]
   1ae54:	0052      	lsls	r2, r2, #1
   1ae56:	5ad3      	ldrh	r3, [r2, r3]
   1ae58:	1dba      	adds	r2, r7, #6
   1ae5a:	8812      	ldrh	r2, [r2, #0]
   1ae5c:	429a      	cmp	r2, r3
   1ae5e:	d013      	beq.n	1ae88 <ff_wtoupper+0x84>
			if (chr > lower[i]) li = i; else hi = i;
   1ae60:	4b11      	ldr	r3, [pc, #68]	; (1aea8 <ff_wtoupper+0xa4>)
   1ae62:	68ba      	ldr	r2, [r7, #8]
   1ae64:	0052      	lsls	r2, r2, #1
   1ae66:	5ad3      	ldrh	r3, [r2, r3]
   1ae68:	1dba      	adds	r2, r7, #6
   1ae6a:	8812      	ldrh	r2, [r2, #0]
   1ae6c:	429a      	cmp	r2, r3
   1ae6e:	d902      	bls.n	1ae76 <ff_wtoupper+0x72>
   1ae70:	68bb      	ldr	r3, [r7, #8]
   1ae72:	60fb      	str	r3, [r7, #12]
   1ae74:	e001      	b.n	1ae7a <ff_wtoupper+0x76>
   1ae76:	68bb      	ldr	r3, [r7, #8]
   1ae78:	613b      	str	r3, [r7, #16]
		} while (--n);
   1ae7a:	697b      	ldr	r3, [r7, #20]
   1ae7c:	3b01      	subs	r3, #1
   1ae7e:	617b      	str	r3, [r7, #20]
   1ae80:	697b      	ldr	r3, [r7, #20]
   1ae82:	2b00      	cmp	r3, #0
   1ae84:	d1dd      	bne.n	1ae42 <ff_wtoupper+0x3e>
   1ae86:	e000      	b.n	1ae8a <ff_wtoupper+0x86>

	} else {			/* Non ASCII characters (table search) */
		n = 12; li = 0; hi = sizeof lower / sizeof lower[0];
		do {
			i = li + (hi - li) / 2;
			if (chr == lower[i]) break;
   1ae88:	46c0      	nop			; (mov r8, r8)
			if (chr > lower[i]) li = i; else hi = i;
		} while (--n);
		if (n) chr = upper[i];
   1ae8a:	697b      	ldr	r3, [r7, #20]
   1ae8c:	2b00      	cmp	r3, #0
   1ae8e:	d005      	beq.n	1ae9c <ff_wtoupper+0x98>
   1ae90:	1dbb      	adds	r3, r7, #6
   1ae92:	4a06      	ldr	r2, [pc, #24]	; (1aeac <ff_wtoupper+0xa8>)
   1ae94:	68b9      	ldr	r1, [r7, #8]
   1ae96:	0049      	lsls	r1, r1, #1
   1ae98:	5a8a      	ldrh	r2, [r1, r2]
   1ae9a:	801a      	strh	r2, [r3, #0]
	}

	return chr;
   1ae9c:	1dbb      	adds	r3, r7, #6
   1ae9e:	881b      	ldrh	r3, [r3, #0]
}
   1aea0:	0018      	movs	r0, r3
   1aea2:	46bd      	mov	sp, r7
   1aea4:	b006      	add	sp, #24
   1aea6:	bd80      	pop	{r7, pc}
   1aea8:	00021308 	.word	0x00021308
   1aeac:	000216e4 	.word	0x000216e4

0001aeb0 <usCrc16>:
};

////////////////////////////////////////////////////////////////////////////////

unsigned short usCrc16(unsigned char *ucBuffer, unsigned short usSize, unsigned short usCrc)
{   
   1aeb0:	b580      	push	{r7, lr}
   1aeb2:	b082      	sub	sp, #8
   1aeb4:	af00      	add	r7, sp, #0
   1aeb6:	6078      	str	r0, [r7, #4]
   1aeb8:	0008      	movs	r0, r1
   1aeba:	0011      	movs	r1, r2
   1aebc:	1cbb      	adds	r3, r7, #2
   1aebe:	1c02      	adds	r2, r0, #0
   1aec0:	801a      	strh	r2, [r3, #0]
   1aec2:	003b      	movs	r3, r7
   1aec4:	1c0a      	adds	r2, r1, #0
   1aec6:	801a      	strh	r2, [r3, #0]
    while (usSize--)
   1aec8:	e017      	b.n	1aefa <usCrc16+0x4a>
        usCrc= updcrc( *ucBuffer++,usCrc); // ((unsigned char*) buffer)++),0); //(*((unsigned char*)buffer)++), crc);
   1aeca:	003b      	movs	r3, r7
   1aecc:	881b      	ldrh	r3, [r3, #0]
   1aece:	0a1b      	lsrs	r3, r3, #8
   1aed0:	b29b      	uxth	r3, r3
   1aed2:	001a      	movs	r2, r3
   1aed4:	23ff      	movs	r3, #255	; 0xff
   1aed6:	401a      	ands	r2, r3
   1aed8:	687b      	ldr	r3, [r7, #4]
   1aeda:	1c59      	adds	r1, r3, #1
   1aedc:	6079      	str	r1, [r7, #4]
   1aede:	781b      	ldrb	r3, [r3, #0]
   1aee0:	405a      	eors	r2, r3
   1aee2:	4b0c      	ldr	r3, [pc, #48]	; (1af14 <usCrc16+0x64>)
   1aee4:	0052      	lsls	r2, r2, #1
   1aee6:	5ad3      	ldrh	r3, [r2, r3]
   1aee8:	b21a      	sxth	r2, r3
   1aeea:	003b      	movs	r3, r7
   1aeec:	881b      	ldrh	r3, [r3, #0]
   1aeee:	021b      	lsls	r3, r3, #8
   1aef0:	b21b      	sxth	r3, r3
   1aef2:	4053      	eors	r3, r2
   1aef4:	b21a      	sxth	r2, r3
   1aef6:	003b      	movs	r3, r7
   1aef8:	801a      	strh	r2, [r3, #0]

////////////////////////////////////////////////////////////////////////////////

unsigned short usCrc16(unsigned char *ucBuffer, unsigned short usSize, unsigned short usCrc)
{   
    while (usSize--)
   1aefa:	1cbb      	adds	r3, r7, #2
   1aefc:	881b      	ldrh	r3, [r3, #0]
   1aefe:	1cba      	adds	r2, r7, #2
   1af00:	1e59      	subs	r1, r3, #1
   1af02:	8011      	strh	r1, [r2, #0]
   1af04:	2b00      	cmp	r3, #0
   1af06:	d1e0      	bne.n	1aeca <usCrc16+0x1a>
        usCrc= updcrc( *ucBuffer++,usCrc); // ((unsigned char*) buffer)++),0); //(*((unsigned char*)buffer)++), crc);
    return usCrc;
   1af08:	003b      	movs	r3, r7
   1af0a:	881b      	ldrh	r3, [r3, #0]
}
   1af0c:	0018      	movs	r0, r3
   1af0e:	46bd      	mov	sp, r7
   1af10:	b002      	add	sp, #8
   1af12:	bd80      	pop	{r7, pc}
   1af14:	00021ac0 	.word	0x00021ac0

0001af18 <vApplicationTickHook>:
}

//////////////////////////////////////////////////////////////////////////////////////////

void vApplicationTickHook( void )
{
   1af18:	b580      	push	{r7, lr}
   1af1a:	af00      	add	r7, sp, #0
	wdt_reset_count();
   1af1c:	4b02      	ldr	r3, [pc, #8]	; (1af28 <vApplicationTickHook+0x10>)
   1af1e:	4798      	blx	r3
   1af20:	46c0      	nop			; (mov r8, r8)
   1af22:	46bd      	mov	sp, r7
   1af24:	bd80      	pop	{r7, pc}
   1af26:	46c0      	nop			; (mov r8, r8)
   1af28:	0000f9a5 	.word	0x0000f9a5

0001af2c <NVIC_SystemReset>:
/** \brief  System Reset

    The function initiates a system reset request to reset the MCU.
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
   1af2c:	b580      	push	{r7, lr}
   1af2e:	af00      	add	r7, sp, #0
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
   1af30:	f3bf 8f4f 	dsb	sy
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
   1af34:	4b02      	ldr	r3, [pc, #8]	; (1af40 <NVIC_SystemReset+0x14>)
   1af36:	4a03      	ldr	r2, [pc, #12]	; (1af44 <NVIC_SystemReset+0x18>)
   1af38:	60da      	str	r2, [r3, #12]
   1af3a:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                     /* Ensure completion of memory access */
  while(1);                                                    /* wait until reset */
   1af3e:	e7fe      	b.n	1af3e <NVIC_SystemReset+0x12>
   1af40:	e000ed00 	.word	0xe000ed00
   1af44:	05fa0004 	.word	0x05fa0004

0001af48 <dma_crc_get_config_defaults>:
 *  \li CRC Beat size: BYTE
 *
 * \param[in] config default configurations
 */
static inline void dma_crc_get_config_defaults(struct dma_crc_config *config)
{
   1af48:	b580      	push	{r7, lr}
   1af4a:	b082      	sub	sp, #8
   1af4c:	af00      	add	r7, sp, #0
   1af4e:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->type = CRC_TYPE_16;
   1af50:	687b      	ldr	r3, [r7, #4]
   1af52:	2200      	movs	r2, #0
   1af54:	701a      	strb	r2, [r3, #0]
	config->size = CRC_BEAT_SIZE_BYTE;
   1af56:	687b      	ldr	r3, [r7, #4]
   1af58:	2200      	movs	r2, #0
   1af5a:	705a      	strb	r2, [r3, #1]
}
   1af5c:	46c0      	nop			; (mov r8, r8)
   1af5e:	46bd      	mov	sp, r7
   1af60:	b002      	add	sp, #8
   1af62:	bd80      	pop	{r7, pc}

0001af64 <dma_crc_disable>:
/**
 * \brief Disable DMA CRC module.
 *
 */
static inline void dma_crc_disable(void)
{
   1af64:	b580      	push	{r7, lr}
   1af66:	af00      	add	r7, sp, #0
	DMAC->CTRL.reg &= ~DMAC_CTRL_CRCENABLE;
   1af68:	4a06      	ldr	r2, [pc, #24]	; (1af84 <dma_crc_disable+0x20>)
   1af6a:	4b06      	ldr	r3, [pc, #24]	; (1af84 <dma_crc_disable+0x20>)
   1af6c:	881b      	ldrh	r3, [r3, #0]
   1af6e:	b29b      	uxth	r3, r3
   1af70:	2104      	movs	r1, #4
   1af72:	438b      	bics	r3, r1
   1af74:	b29b      	uxth	r3, r3
   1af76:	8013      	strh	r3, [r2, #0]
	DMAC->CRCCTRL.reg = 0;
   1af78:	4b02      	ldr	r3, [pc, #8]	; (1af84 <dma_crc_disable+0x20>)
   1af7a:	2200      	movs	r2, #0
   1af7c:	805a      	strh	r2, [r3, #2]
}
   1af7e:	46c0      	nop			; (mov r8, r8)
   1af80:	46bd      	mov	sp, r7
   1af82:	bd80      	pop	{r7, pc}
   1af84:	41004800 	.word	0x41004800

0001af88 <dma_crc_get_checksum>:
 * \brief Get DMA CRC checksum value.
 *
 * \return Calculated CRC checksum.
 */
static inline uint32_t dma_crc_get_checksum(void)
{
   1af88:	b580      	push	{r7, lr}
   1af8a:	af00      	add	r7, sp, #0
	if (DMAC->CRCCTRL.bit.CRCSRC == DMAC_CRCCTRL_CRCSRC_IO_Val) {
   1af8c:	4b07      	ldr	r3, [pc, #28]	; (1afac <dma_crc_get_checksum+0x24>)
   1af8e:	885b      	ldrh	r3, [r3, #2]
   1af90:	049b      	lsls	r3, r3, #18
   1af92:	0e9b      	lsrs	r3, r3, #26
   1af94:	b2db      	uxtb	r3, r3
   1af96:	2b01      	cmp	r3, #1
   1af98:	d102      	bne.n	1afa0 <dma_crc_get_checksum+0x18>
		DMAC->CRCSTATUS.reg = DMAC_CRCSTATUS_CRCBUSY;
   1af9a:	4b04      	ldr	r3, [pc, #16]	; (1afac <dma_crc_get_checksum+0x24>)
   1af9c:	2201      	movs	r2, #1
   1af9e:	731a      	strb	r2, [r3, #12]
	}

	return DMAC->CRCCHKSUM.reg;
   1afa0:	4b02      	ldr	r3, [pc, #8]	; (1afac <dma_crc_get_checksum+0x24>)
   1afa2:	689b      	ldr	r3, [r3, #8]
}
   1afa4:	0018      	movs	r0, r3
   1afa6:	46bd      	mov	sp, r7
   1afa8:	bd80      	pop	{r7, pc}
   1afaa:	46c0      	nop			; (mov r8, r8)
   1afac:	41004800 	.word	0x41004800

0001afb0 <dma_crc_io_enable>:
 * \retval STATUS_OK Get the DMA CRC module
 * \retval STATUS_BUSY DMA CRC module is already taken and not ready yet
 */
static inline enum status_code dma_crc_io_enable(
		struct dma_crc_config *config)
{
   1afb0:	b580      	push	{r7, lr}
   1afb2:	b082      	sub	sp, #8
   1afb4:	af00      	add	r7, sp, #0
   1afb6:	6078      	str	r0, [r7, #4]
	if (DMAC->CRCSTATUS.reg & DMAC_CRCSTATUS_CRCBUSY) {
   1afb8:	4b1e      	ldr	r3, [pc, #120]	; (1b034 <dma_crc_io_enable+0x84>)
   1afba:	7b1b      	ldrb	r3, [r3, #12]
   1afbc:	b2db      	uxtb	r3, r3
   1afbe:	001a      	movs	r2, r3
   1afc0:	2301      	movs	r3, #1
   1afc2:	4013      	ands	r3, r2
   1afc4:	d001      	beq.n	1afca <dma_crc_io_enable+0x1a>
		return STATUS_BUSY;
   1afc6:	2305      	movs	r3, #5
   1afc8:	e02f      	b.n	1b02a <dma_crc_io_enable+0x7a>
	}

	if (DMAC->CTRL.reg & DMAC_CTRL_CRCENABLE) {
   1afca:	4b1a      	ldr	r3, [pc, #104]	; (1b034 <dma_crc_io_enable+0x84>)
   1afcc:	881b      	ldrh	r3, [r3, #0]
   1afce:	b29b      	uxth	r3, r3
   1afd0:	001a      	movs	r2, r3
   1afd2:	2304      	movs	r3, #4
   1afd4:	4013      	ands	r3, r2
   1afd6:	d001      	beq.n	1afdc <dma_crc_io_enable+0x2c>
		return STATUS_BUSY;
   1afd8:	2305      	movs	r3, #5
   1afda:	e026      	b.n	1b02a <dma_crc_io_enable+0x7a>
	}

	DMAC->CRCCTRL.reg = DMAC_CRCCTRL_CRCBEATSIZE(config->size) |
   1afdc:	4915      	ldr	r1, [pc, #84]	; (1b034 <dma_crc_io_enable+0x84>)
   1afde:	687b      	ldr	r3, [r7, #4]
   1afe0:	785b      	ldrb	r3, [r3, #1]
   1afe2:	b29b      	uxth	r3, r3
   1afe4:	2203      	movs	r2, #3
   1afe6:	4013      	ands	r3, r2
   1afe8:	b29a      	uxth	r2, r3
		DMAC_CRCCTRL_CRCPOLY(config->type) |
   1afea:	687b      	ldr	r3, [r7, #4]
   1afec:	781b      	ldrb	r3, [r3, #0]

	if (DMAC->CTRL.reg & DMAC_CTRL_CRCENABLE) {
		return STATUS_BUSY;
	}

	DMAC->CRCCTRL.reg = DMAC_CRCCTRL_CRCBEATSIZE(config->size) |
   1afee:	b29b      	uxth	r3, r3
   1aff0:	009b      	lsls	r3, r3, #2
   1aff2:	b29b      	uxth	r3, r3
   1aff4:	200c      	movs	r0, #12
   1aff6:	4003      	ands	r3, r0
   1aff8:	b29b      	uxth	r3, r3
   1affa:	4313      	orrs	r3, r2
   1affc:	b29b      	uxth	r3, r3
   1affe:	2280      	movs	r2, #128	; 0x80
   1b000:	0052      	lsls	r2, r2, #1
   1b002:	4313      	orrs	r3, r2
   1b004:	b29b      	uxth	r3, r3
   1b006:	804b      	strh	r3, [r1, #2]
		DMAC_CRCCTRL_CRCPOLY(config->type) |
		DMAC_CRCCTRL_CRCSRC_IO;

	if (config->type == CRC_TYPE_32) {
   1b008:	687b      	ldr	r3, [r7, #4]
   1b00a:	781b      	ldrb	r3, [r3, #0]
   1b00c:	2b01      	cmp	r3, #1
   1b00e:	d103      	bne.n	1b018 <dma_crc_io_enable+0x68>
		DMAC->CRCCHKSUM.reg = 0xFFFFFFFF;
   1b010:	4b08      	ldr	r3, [pc, #32]	; (1b034 <dma_crc_io_enable+0x84>)
   1b012:	2201      	movs	r2, #1
   1b014:	4252      	negs	r2, r2
   1b016:	609a      	str	r2, [r3, #8]
	}

	DMAC->CTRL.reg |= DMAC_CTRL_CRCENABLE;
   1b018:	4a06      	ldr	r2, [pc, #24]	; (1b034 <dma_crc_io_enable+0x84>)
   1b01a:	4b06      	ldr	r3, [pc, #24]	; (1b034 <dma_crc_io_enable+0x84>)
   1b01c:	881b      	ldrh	r3, [r3, #0]
   1b01e:	b29b      	uxth	r3, r3
   1b020:	2104      	movs	r1, #4
   1b022:	430b      	orrs	r3, r1
   1b024:	b29b      	uxth	r3, r3
   1b026:	8013      	strh	r3, [r2, #0]

	return STATUS_OK;
   1b028:	2300      	movs	r3, #0
}
   1b02a:	0018      	movs	r0, r3
   1b02c:	46bd      	mov	sp, r7
   1b02e:	b002      	add	sp, #8
   1b030:	bd80      	pop	{r7, pc}
   1b032:	46c0      	nop			; (mov r8, r8)
   1b034:	41004800 	.word	0x41004800

0001b038 <dma_crc_io_calculation>:
 *
 * \return Calculated CRC checksum value.
 */
static inline void dma_crc_io_calculation(void *buffer,
		 uint32_t total_beat_size)
{
   1b038:	b580      	push	{r7, lr}
   1b03a:	b086      	sub	sp, #24
   1b03c:	af00      	add	r7, sp, #0
   1b03e:	6078      	str	r0, [r7, #4]
   1b040:	6039      	str	r1, [r7, #0]
	uint32_t counter = total_beat_size;
   1b042:	683b      	ldr	r3, [r7, #0]
   1b044:	617b      	str	r3, [r7, #20]
	uint8_t *buffer_8;
	uint16_t *buffer_16;
	uint32_t *buffer_32;

	for (counter=0; counter<total_beat_size; counter++) {
   1b046:	2300      	movs	r3, #0
   1b048:	617b      	str	r3, [r7, #20]
   1b04a:	e037      	b.n	1b0bc <dma_crc_io_calculation+0x84>
		if (DMAC->CRCCTRL.bit.CRCBEATSIZE == CRC_BEAT_SIZE_BYTE) {
   1b04c:	4b1f      	ldr	r3, [pc, #124]	; (1b0cc <dma_crc_io_calculation+0x94>)
   1b04e:	885b      	ldrh	r3, [r3, #2]
   1b050:	079b      	lsls	r3, r3, #30
   1b052:	0f9b      	lsrs	r3, r3, #30
   1b054:	b2db      	uxtb	r3, r3
   1b056:	2b00      	cmp	r3, #0
   1b058:	d108      	bne.n	1b06c <dma_crc_io_calculation+0x34>
			buffer_8 = buffer;
   1b05a:	687b      	ldr	r3, [r7, #4]
   1b05c:	613b      	str	r3, [r7, #16]
			DMAC->CRCDATAIN.reg = buffer_8[counter];
   1b05e:	4b1b      	ldr	r3, [pc, #108]	; (1b0cc <dma_crc_io_calculation+0x94>)
   1b060:	6939      	ldr	r1, [r7, #16]
   1b062:	697a      	ldr	r2, [r7, #20]
   1b064:	188a      	adds	r2, r1, r2
   1b066:	7812      	ldrb	r2, [r2, #0]
   1b068:	605a      	str	r2, [r3, #4]
   1b06a:	e020      	b.n	1b0ae <dma_crc_io_calculation+0x76>
		} else if (DMAC->CRCCTRL.bit.CRCBEATSIZE == CRC_BEAT_SIZE_HWORD) {
   1b06c:	4b17      	ldr	r3, [pc, #92]	; (1b0cc <dma_crc_io_calculation+0x94>)
   1b06e:	885b      	ldrh	r3, [r3, #2]
   1b070:	079b      	lsls	r3, r3, #30
   1b072:	0f9b      	lsrs	r3, r3, #30
   1b074:	b2db      	uxtb	r3, r3
   1b076:	2b01      	cmp	r3, #1
   1b078:	d109      	bne.n	1b08e <dma_crc_io_calculation+0x56>
			buffer_16 = buffer;
   1b07a:	687b      	ldr	r3, [r7, #4]
   1b07c:	60fb      	str	r3, [r7, #12]
			DMAC->CRCDATAIN.reg = buffer_16[counter];
   1b07e:	4b13      	ldr	r3, [pc, #76]	; (1b0cc <dma_crc_io_calculation+0x94>)
   1b080:	697a      	ldr	r2, [r7, #20]
   1b082:	0052      	lsls	r2, r2, #1
   1b084:	68f9      	ldr	r1, [r7, #12]
   1b086:	188a      	adds	r2, r1, r2
   1b088:	8812      	ldrh	r2, [r2, #0]
   1b08a:	605a      	str	r2, [r3, #4]
   1b08c:	e00f      	b.n	1b0ae <dma_crc_io_calculation+0x76>
		} else if (DMAC->CRCCTRL.bit.CRCBEATSIZE == CRC_BEAT_SIZE_WORD) {
   1b08e:	4b0f      	ldr	r3, [pc, #60]	; (1b0cc <dma_crc_io_calculation+0x94>)
   1b090:	885b      	ldrh	r3, [r3, #2]
   1b092:	079b      	lsls	r3, r3, #30
   1b094:	0f9b      	lsrs	r3, r3, #30
   1b096:	b2db      	uxtb	r3, r3
   1b098:	2b02      	cmp	r3, #2
   1b09a:	d108      	bne.n	1b0ae <dma_crc_io_calculation+0x76>
			buffer_32 = buffer;
   1b09c:	687b      	ldr	r3, [r7, #4]
   1b09e:	60bb      	str	r3, [r7, #8]
			DMAC->CRCDATAIN.reg = buffer_32[counter];
   1b0a0:	4a0a      	ldr	r2, [pc, #40]	; (1b0cc <dma_crc_io_calculation+0x94>)
   1b0a2:	697b      	ldr	r3, [r7, #20]
   1b0a4:	009b      	lsls	r3, r3, #2
   1b0a6:	68b9      	ldr	r1, [r7, #8]
   1b0a8:	18cb      	adds	r3, r1, r3
   1b0aa:	681b      	ldr	r3, [r3, #0]
   1b0ac:	6053      	str	r3, [r2, #4]

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
   1b0ae:	46c0      	nop			; (mov r8, r8)
   1b0b0:	46c0      	nop			; (mov r8, r8)
   1b0b2:	46c0      	nop			; (mov r8, r8)
   1b0b4:	46c0      	nop			; (mov r8, r8)
	uint32_t counter = total_beat_size;
	uint8_t *buffer_8;
	uint16_t *buffer_16;
	uint32_t *buffer_32;

	for (counter=0; counter<total_beat_size; counter++) {
   1b0b6:	697b      	ldr	r3, [r7, #20]
   1b0b8:	3301      	adds	r3, #1
   1b0ba:	617b      	str	r3, [r7, #20]
   1b0bc:	697a      	ldr	r2, [r7, #20]
   1b0be:	683b      	ldr	r3, [r7, #0]
   1b0c0:	429a      	cmp	r2, r3
   1b0c2:	d3c3      	bcc.n	1b04c <dma_crc_io_calculation+0x14>
		nop();
		nop();
		nop();
		nop();
	}
}
   1b0c4:	46c0      	nop			; (mov r8, r8)
   1b0c6:	46bd      	mov	sp, r7
   1b0c8:	b006      	add	sp, #24
   1b0ca:	bd80      	pop	{r7, pc}
   1b0cc:	41004800 	.word	0x41004800

0001b0d0 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   1b0d0:	b580      	push	{r7, lr}
   1b0d2:	b084      	sub	sp, #16
   1b0d4:	af00      	add	r7, sp, #0
   1b0d6:	0002      	movs	r2, r0
   1b0d8:	1dfb      	adds	r3, r7, #7
   1b0da:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
   1b0dc:	230f      	movs	r3, #15
   1b0de:	18fb      	adds	r3, r7, r3
   1b0e0:	1dfa      	adds	r2, r7, #7
   1b0e2:	7812      	ldrb	r2, [r2, #0]
   1b0e4:	09d2      	lsrs	r2, r2, #7
   1b0e6:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
   1b0e8:	230e      	movs	r3, #14
   1b0ea:	18fb      	adds	r3, r7, r3
   1b0ec:	1dfa      	adds	r2, r7, #7
   1b0ee:	7812      	ldrb	r2, [r2, #0]
   1b0f0:	0952      	lsrs	r2, r2, #5
   1b0f2:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
   1b0f4:	4b0d      	ldr	r3, [pc, #52]	; (1b12c <system_pinmux_get_group_from_gpio_pin+0x5c>)
   1b0f6:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
   1b0f8:	230f      	movs	r3, #15
   1b0fa:	18fb      	adds	r3, r7, r3
   1b0fc:	781b      	ldrb	r3, [r3, #0]
   1b0fe:	2b00      	cmp	r3, #0
   1b100:	d10f      	bne.n	1b122 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
   1b102:	230f      	movs	r3, #15
   1b104:	18fb      	adds	r3, r7, r3
   1b106:	781b      	ldrb	r3, [r3, #0]
   1b108:	009b      	lsls	r3, r3, #2
   1b10a:	2210      	movs	r2, #16
   1b10c:	4694      	mov	ip, r2
   1b10e:	44bc      	add	ip, r7
   1b110:	4463      	add	r3, ip
   1b112:	3b08      	subs	r3, #8
   1b114:	681a      	ldr	r2, [r3, #0]
   1b116:	230e      	movs	r3, #14
   1b118:	18fb      	adds	r3, r7, r3
   1b11a:	781b      	ldrb	r3, [r3, #0]
   1b11c:	01db      	lsls	r3, r3, #7
   1b11e:	18d3      	adds	r3, r2, r3
   1b120:	e000      	b.n	1b124 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
   1b122:	2300      	movs	r3, #0
	}
}
   1b124:	0018      	movs	r0, r3
   1b126:	46bd      	mov	sp, r7
   1b128:	b004      	add	sp, #16
   1b12a:	bd80      	pop	{r7, pc}
   1b12c:	41004400 	.word	0x41004400

0001b130 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   1b130:	b580      	push	{r7, lr}
   1b132:	b082      	sub	sp, #8
   1b134:	af00      	add	r7, sp, #0
   1b136:	0002      	movs	r2, r0
   1b138:	1dfb      	adds	r3, r7, #7
   1b13a:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
   1b13c:	1dfb      	adds	r3, r7, #7
   1b13e:	781b      	ldrb	r3, [r3, #0]
   1b140:	0018      	movs	r0, r3
   1b142:	4b03      	ldr	r3, [pc, #12]	; (1b150 <port_get_group_from_gpio_pin+0x20>)
   1b144:	4798      	blx	r3
   1b146:	0003      	movs	r3, r0
}
   1b148:	0018      	movs	r0, r3
   1b14a:	46bd      	mov	sp, r7
   1b14c:	b002      	add	sp, #8
   1b14e:	bd80      	pop	{r7, pc}
   1b150:	0001b0d1 	.word	0x0001b0d1

0001b154 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
   1b154:	b580      	push	{r7, lr}
   1b156:	b084      	sub	sp, #16
   1b158:	af00      	add	r7, sp, #0
   1b15a:	0002      	movs	r2, r0
   1b15c:	1dfb      	adds	r3, r7, #7
   1b15e:	701a      	strb	r2, [r3, #0]
   1b160:	1dbb      	adds	r3, r7, #6
   1b162:	1c0a      	adds	r2, r1, #0
   1b164:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
   1b166:	1dfb      	adds	r3, r7, #7
   1b168:	781b      	ldrb	r3, [r3, #0]
   1b16a:	0018      	movs	r0, r3
   1b16c:	4b0d      	ldr	r3, [pc, #52]	; (1b1a4 <port_pin_set_output_level+0x50>)
   1b16e:	4798      	blx	r3
   1b170:	0003      	movs	r3, r0
   1b172:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   1b174:	1dfb      	adds	r3, r7, #7
   1b176:	781b      	ldrb	r3, [r3, #0]
   1b178:	221f      	movs	r2, #31
   1b17a:	4013      	ands	r3, r2
   1b17c:	2201      	movs	r2, #1
   1b17e:	409a      	lsls	r2, r3
   1b180:	0013      	movs	r3, r2
   1b182:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
   1b184:	1dbb      	adds	r3, r7, #6
   1b186:	781b      	ldrb	r3, [r3, #0]
   1b188:	2b00      	cmp	r3, #0
   1b18a:	d003      	beq.n	1b194 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
   1b18c:	68fb      	ldr	r3, [r7, #12]
   1b18e:	68ba      	ldr	r2, [r7, #8]
   1b190:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
   1b192:	e002      	b.n	1b19a <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
   1b194:	68fb      	ldr	r3, [r7, #12]
   1b196:	68ba      	ldr	r2, [r7, #8]
   1b198:	615a      	str	r2, [r3, #20]
	}
}
   1b19a:	46c0      	nop			; (mov r8, r8)
   1b19c:	46bd      	mov	sp, r7
   1b19e:	b004      	add	sp, #16
   1b1a0:	bd80      	pop	{r7, pc}
   1b1a2:	46c0      	nop			; (mov r8, r8)
   1b1a4:	0001b131 	.word	0x0001b131

0001b1a8 <rtc_calendar_get_time_defaults>:
 *
 * \param[out] time  Time structure to initialize
 */
static inline void rtc_calendar_get_time_defaults(
		struct rtc_calendar_time *const time)
{
   1b1a8:	b580      	push	{r7, lr}
   1b1aa:	b082      	sub	sp, #8
   1b1ac:	af00      	add	r7, sp, #0
   1b1ae:	6078      	str	r0, [r7, #4]
	time->second = 0;
   1b1b0:	687b      	ldr	r3, [r7, #4]
   1b1b2:	2200      	movs	r2, #0
   1b1b4:	701a      	strb	r2, [r3, #0]
	time->minute = 0;
   1b1b6:	687b      	ldr	r3, [r7, #4]
   1b1b8:	2200      	movs	r2, #0
   1b1ba:	705a      	strb	r2, [r3, #1]
	time->hour   = 0;
   1b1bc:	687b      	ldr	r3, [r7, #4]
   1b1be:	2200      	movs	r2, #0
   1b1c0:	709a      	strb	r2, [r3, #2]
	time->pm     = 0;
   1b1c2:	687b      	ldr	r3, [r7, #4]
   1b1c4:	2200      	movs	r2, #0
   1b1c6:	70da      	strb	r2, [r3, #3]
	time->day    = 1;
   1b1c8:	687b      	ldr	r3, [r7, #4]
   1b1ca:	2201      	movs	r2, #1
   1b1cc:	711a      	strb	r2, [r3, #4]
	time->month  = 1;
   1b1ce:	687b      	ldr	r3, [r7, #4]
   1b1d0:	2201      	movs	r2, #1
   1b1d2:	715a      	strb	r2, [r3, #5]
	time->year   = 2000;
   1b1d4:	687b      	ldr	r3, [r7, #4]
   1b1d6:	22fa      	movs	r2, #250	; 0xfa
   1b1d8:	00d2      	lsls	r2, r2, #3
   1b1da:	80da      	strh	r2, [r3, #6]
}
   1b1dc:	46c0      	nop			; (mov r8, r8)
   1b1de:	46bd      	mov	sp, r7
   1b1e0:	b002      	add	sp, #8
   1b1e2:	bd80      	pop	{r7, pc}

0001b1e4 <rtc_calendar_get_config_defaults>:
 *  \param[out] config  Configuration structure to be initialized to default
 *                      values
 */
static inline void rtc_calendar_get_config_defaults(
		struct rtc_calendar_config *const config)
{
   1b1e4:	b580      	push	{r7, lr}
   1b1e6:	b086      	sub	sp, #24
   1b1e8:	af00      	add	r7, sp, #0
   1b1ea:	6078      	str	r0, [r7, #4]
	/* Sanity check argument */
	Assert(config);

	/* Initialize and set time structure to default */
	struct rtc_calendar_time time;
	rtc_calendar_get_time_defaults(&time);
   1b1ec:	230c      	movs	r3, #12
   1b1ee:	18fb      	adds	r3, r7, r3
   1b1f0:	0018      	movs	r0, r3
   1b1f2:	4b23      	ldr	r3, [pc, #140]	; (1b280 <rtc_calendar_get_config_defaults+0x9c>)
   1b1f4:	4798      	blx	r3

	/* Set defaults into configuration structure */
	config->prescaler           = RTC_CALENDAR_PRESCALER_DIV_1024;
   1b1f6:	687b      	ldr	r3, [r7, #4]
   1b1f8:	22a0      	movs	r2, #160	; 0xa0
   1b1fa:	0112      	lsls	r2, r2, #4
   1b1fc:	801a      	strh	r2, [r3, #0]
	config->clear_on_match      = false;
   1b1fe:	687b      	ldr	r3, [r7, #4]
   1b200:	2200      	movs	r2, #0
   1b202:	709a      	strb	r2, [r3, #2]
#ifdef FEATURE_RTC_CONTINUOUSLY_UPDATED
	config->continuously_update = false;
   1b204:	687b      	ldr	r3, [r7, #4]
   1b206:	2200      	movs	r2, #0
   1b208:	70da      	strb	r2, [r3, #3]
#endif
	config->clock_24h           = false;
   1b20a:	687b      	ldr	r3, [r7, #4]
   1b20c:	2200      	movs	r2, #0
   1b20e:	711a      	strb	r2, [r3, #4]
	config->year_init_value     = 2000;
   1b210:	687b      	ldr	r3, [r7, #4]
   1b212:	22fa      	movs	r2, #250	; 0xfa
   1b214:	00d2      	lsls	r2, r2, #3
   1b216:	80da      	strh	r2, [r3, #6]
#if (SAML22)
	config->enable_read_sync    = true;
#endif
	for (uint8_t i = 0; i < RTC_NUM_OF_ALARMS; i++) {
   1b218:	2317      	movs	r3, #23
   1b21a:	18fb      	adds	r3, r7, r3
   1b21c:	2200      	movs	r2, #0
   1b21e:	701a      	strb	r2, [r3, #0]
   1b220:	e025      	b.n	1b26e <rtc_calendar_get_config_defaults+0x8a>
		config->alarm[i].time = time;
   1b222:	2317      	movs	r3, #23
   1b224:	18fb      	adds	r3, r7, r3
   1b226:	781a      	ldrb	r2, [r3, #0]
   1b228:	6879      	ldr	r1, [r7, #4]
   1b22a:	2008      	movs	r0, #8
   1b22c:	0013      	movs	r3, r2
   1b22e:	005b      	lsls	r3, r3, #1
   1b230:	189b      	adds	r3, r3, r2
   1b232:	009b      	lsls	r3, r3, #2
   1b234:	18cb      	adds	r3, r1, r3
   1b236:	181a      	adds	r2, r3, r0
   1b238:	230c      	movs	r3, #12
   1b23a:	18fb      	adds	r3, r7, r3
   1b23c:	0010      	movs	r0, r2
   1b23e:	0019      	movs	r1, r3
   1b240:	230a      	movs	r3, #10
   1b242:	001a      	movs	r2, r3
   1b244:	4b0f      	ldr	r3, [pc, #60]	; (1b284 <rtc_calendar_get_config_defaults+0xa0>)
   1b246:	4798      	blx	r3
		config->alarm[i].mask = RTC_CALENDAR_ALARM_MASK_YEAR;
   1b248:	2317      	movs	r3, #23
   1b24a:	18fb      	adds	r3, r7, r3
   1b24c:	781a      	ldrb	r2, [r3, #0]
   1b24e:	6879      	ldr	r1, [r7, #4]
   1b250:	0013      	movs	r3, r2
   1b252:	005b      	lsls	r3, r3, #1
   1b254:	189b      	adds	r3, r3, r2
   1b256:	009b      	lsls	r3, r3, #2
   1b258:	18cb      	adds	r3, r1, r3
   1b25a:	3312      	adds	r3, #18
   1b25c:	2206      	movs	r2, #6
   1b25e:	701a      	strb	r2, [r3, #0]
	config->clock_24h           = false;
	config->year_init_value     = 2000;
#if (SAML22)
	config->enable_read_sync    = true;
#endif
	for (uint8_t i = 0; i < RTC_NUM_OF_ALARMS; i++) {
   1b260:	2317      	movs	r3, #23
   1b262:	18fb      	adds	r3, r7, r3
   1b264:	781a      	ldrb	r2, [r3, #0]
   1b266:	2317      	movs	r3, #23
   1b268:	18fb      	adds	r3, r7, r3
   1b26a:	3201      	adds	r2, #1
   1b26c:	701a      	strb	r2, [r3, #0]
   1b26e:	2317      	movs	r3, #23
   1b270:	18fb      	adds	r3, r7, r3
   1b272:	781b      	ldrb	r3, [r3, #0]
   1b274:	2b00      	cmp	r3, #0
   1b276:	d0d4      	beq.n	1b222 <rtc_calendar_get_config_defaults+0x3e>
		config->alarm[i].time = time;
		config->alarm[i].mask = RTC_CALENDAR_ALARM_MASK_YEAR;
	}
}
   1b278:	46c0      	nop			; (mov r8, r8)
   1b27a:	46bd      	mov	sp, r7
   1b27c:	b006      	add	sp, #24
   1b27e:	bd80      	pop	{r7, pc}
   1b280:	0001b1a9 	.word	0x0001b1a9
   1b284:	0001ee9b 	.word	0x0001ee9b

0001b288 <system_reset>:
 * Resets the MCU and all associated peripherals and registers, except RTC, all 32KHz sources,
 * WDT (if ALWAYSON is set) and GCLK (if WRTLOCK is set).
 *
 */
static inline void system_reset(void)
{
   1b288:	b580      	push	{r7, lr}
   1b28a:	af00      	add	r7, sp, #0
	NVIC_SystemReset();
   1b28c:	4b02      	ldr	r3, [pc, #8]	; (1b298 <system_reset+0x10>)
   1b28e:	4798      	blx	r3
}
   1b290:	46c0      	nop			; (mov r8, r8)
   1b292:	46bd      	mov	sp, r7
   1b294:	bd80      	pop	{r7, pc}
   1b296:	46c0      	nop			; (mov r8, r8)
   1b298:	0001af2d 	.word	0x0001af2d

0001b29c <tasks_init>:
char WDay[7]={'S','M','T','W','T','F','S'};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void tasks_init(void)
{
   1b29c:	b590      	push	{r4, r7, lr}
   1b29e:	b083      	sub	sp, #12
   1b2a0:	af02      	add	r7, sp, #8
	xTaskCreate(main_task,(const char *)"Main",configMINIMAL_STACK_SIZE*3,NULL,GRAPH_TASK_PRIORITY,&xLCDTask);
   1b2a2:	2396      	movs	r3, #150	; 0x96
   1b2a4:	009a      	lsls	r2, r3, #2
   1b2a6:	4906      	ldr	r1, [pc, #24]	; (1b2c0 <tasks_init+0x24>)
   1b2a8:	4806      	ldr	r0, [pc, #24]	; (1b2c4 <tasks_init+0x28>)
   1b2aa:	4b07      	ldr	r3, [pc, #28]	; (1b2c8 <tasks_init+0x2c>)
   1b2ac:	9301      	str	r3, [sp, #4]
   1b2ae:	2301      	movs	r3, #1
   1b2b0:	9300      	str	r3, [sp, #0]
   1b2b2:	2300      	movs	r3, #0
   1b2b4:	4c05      	ldr	r4, [pc, #20]	; (1b2cc <tasks_init+0x30>)
   1b2b6:	47a0      	blx	r4
}
   1b2b8:	46c0      	nop			; (mov r8, r8)
   1b2ba:	46bd      	mov	sp, r7
   1b2bc:	b001      	add	sp, #4
   1b2be:	bd90      	pop	{r4, r7, pc}
   1b2c0:	00021cc0 	.word	0x00021cc0
   1b2c4:	0001cff5 	.word	0x0001cff5
   1b2c8:	20004de8 	.word	0x20004de8
   1b2cc:	0000ff91 	.word	0x0000ff91

0001b2d0 <vCheckFirmware>:

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void vCheckFirmware()
{
   1b2d0:	b590      	push	{r4, r7, lr}
   1b2d2:	b087      	sub	sp, #28
   1b2d4:	af00      	add	r7, sp, #0
 UINT BytesRead;
 DRESULT result;
 enum status_code error_code;
 struct dma_crc_config crc_config;
 
 result=f_open(&file_object,"0:/output.bin",FA_READ);
   1b2d6:	230f      	movs	r3, #15
   1b2d8:	18fc      	adds	r4, r7, r3
   1b2da:	4959      	ldr	r1, [pc, #356]	; (1b440 <vCheckFirmware+0x170>)
   1b2dc:	4b59      	ldr	r3, [pc, #356]	; (1b444 <vCheckFirmware+0x174>)
   1b2de:	2201      	movs	r2, #1
   1b2e0:	0018      	movs	r0, r3
   1b2e2:	4b59      	ldr	r3, [pc, #356]	; (1b448 <vCheckFirmware+0x178>)
   1b2e4:	4798      	blx	r3
   1b2e6:	0003      	movs	r3, r0
   1b2e8:	7023      	strb	r3, [r4, #0]
 if (result!=RES_OK) return;
   1b2ea:	230f      	movs	r3, #15
   1b2ec:	18fb      	adds	r3, r7, r3
   1b2ee:	781b      	ldrb	r3, [r3, #0]
   1b2f0:	2b00      	cmp	r3, #0
   1b2f2:	d000      	beq.n	1b2f6 <vCheckFirmware+0x26>
   1b2f4:	e09c      	b.n	1b430 <vCheckFirmware+0x160>
 
  /* Start the DMA CRC with I/O mode */
 DMAC->CRCCHKSUM.bit.CRCCHKSUM=0;
   1b2f6:	4b55      	ldr	r3, [pc, #340]	; (1b44c <vCheckFirmware+0x17c>)
   1b2f8:	2200      	movs	r2, #0
   1b2fa:	609a      	str	r2, [r3, #8]
 dma_crc_get_config_defaults(&crc_config);
   1b2fc:	1d3b      	adds	r3, r7, #4
   1b2fe:	0018      	movs	r0, r3
   1b300:	4b53      	ldr	r3, [pc, #332]	; (1b450 <vCheckFirmware+0x180>)
   1b302:	4798      	blx	r3
 crc_config.type = CRC_TYPE_16;
   1b304:	1d3b      	adds	r3, r7, #4
   1b306:	2200      	movs	r2, #0
   1b308:	701a      	strb	r2, [r3, #0]
 dma_crc_io_enable(&crc_config);
   1b30a:	1d3b      	adds	r3, r7, #4
   1b30c:	0018      	movs	r0, r3
   1b30e:	4b51      	ldr	r3, [pc, #324]	; (1b454 <vCheckFirmware+0x184>)
   1b310:	4798      	blx	r3
 
 uint16_t usCRC=0;
   1b312:	2316      	movs	r3, #22
   1b314:	18fb      	adds	r3, r7, r3
   1b316:	2200      	movs	r2, #0
   1b318:	801a      	strh	r2, [r3, #0]
 f_lseek(&file_object,APP_START_ADDRESS);
   1b31a:	2380      	movs	r3, #128	; 0x80
   1b31c:	021a      	lsls	r2, r3, #8
   1b31e:	4b49      	ldr	r3, [pc, #292]	; (1b444 <vCheckFirmware+0x174>)
   1b320:	0011      	movs	r1, r2
   1b322:	0018      	movs	r0, r3
   1b324:	4b4c      	ldr	r3, [pc, #304]	; (1b458 <vCheckFirmware+0x188>)
   1b326:	4798      	blx	r3
 for (uint32_t ulPageCounter=APP_START_ADDRESS;ulPageCounter<(FLASH_SIZE-EEPROM_SIZE);ulPageCounter+=NVMCTRL_ROW_SIZE)
   1b328:	2380      	movs	r3, #128	; 0x80
   1b32a:	021b      	lsls	r3, r3, #8
   1b32c:	613b      	str	r3, [r7, #16]
   1b32e:	e026      	b.n	1b37e <vCheckFirmware+0xae>
 {
  f_read(&file_object,rx_buffer,NVMCTRL_ROW_SIZE,&BytesRead);	
   1b330:	2308      	movs	r3, #8
   1b332:	18fc      	adds	r4, r7, r3
   1b334:	2380      	movs	r3, #128	; 0x80
   1b336:	005a      	lsls	r2, r3, #1
   1b338:	4948      	ldr	r1, [pc, #288]	; (1b45c <vCheckFirmware+0x18c>)
   1b33a:	4842      	ldr	r0, [pc, #264]	; (1b444 <vCheckFirmware+0x174>)
   1b33c:	0023      	movs	r3, r4
   1b33e:	4c48      	ldr	r4, [pc, #288]	; (1b460 <vCheckFirmware+0x190>)
   1b340:	47a0      	blx	r4
  if (BytesRead!=NVMCTRL_ROW_SIZE) return;
   1b342:	68ba      	ldr	r2, [r7, #8]
   1b344:	2380      	movs	r3, #128	; 0x80
   1b346:	005b      	lsls	r3, r3, #1
   1b348:	429a      	cmp	r2, r3
   1b34a:	d000      	beq.n	1b34e <vCheckFirmware+0x7e>
   1b34c:	e072      	b.n	1b434 <vCheckFirmware+0x164>
  dma_crc_io_calculation(rx_buffer,NVMCTRL_ROW_SIZE);
   1b34e:	2380      	movs	r3, #128	; 0x80
   1b350:	005a      	lsls	r2, r3, #1
   1b352:	4b42      	ldr	r3, [pc, #264]	; (1b45c <vCheckFirmware+0x18c>)
   1b354:	0011      	movs	r1, r2
   1b356:	0018      	movs	r0, r3
   1b358:	4b42      	ldr	r3, [pc, #264]	; (1b464 <vCheckFirmware+0x194>)
   1b35a:	4798      	blx	r3
  usCRC=usCrc16(rx_buffer,NVMCTRL_ROW_SIZE,usCRC);
   1b35c:	2316      	movs	r3, #22
   1b35e:	18fc      	adds	r4, r7, r3
   1b360:	2316      	movs	r3, #22
   1b362:	18fb      	adds	r3, r7, r3
   1b364:	881a      	ldrh	r2, [r3, #0]
   1b366:	2380      	movs	r3, #128	; 0x80
   1b368:	0059      	lsls	r1, r3, #1
   1b36a:	4b3c      	ldr	r3, [pc, #240]	; (1b45c <vCheckFirmware+0x18c>)
   1b36c:	0018      	movs	r0, r3
   1b36e:	4b3e      	ldr	r3, [pc, #248]	; (1b468 <vCheckFirmware+0x198>)
   1b370:	4798      	blx	r3
   1b372:	0003      	movs	r3, r0
   1b374:	8023      	strh	r3, [r4, #0]
 crc_config.type = CRC_TYPE_16;
 dma_crc_io_enable(&crc_config);
 
 uint16_t usCRC=0;
 f_lseek(&file_object,APP_START_ADDRESS);
 for (uint32_t ulPageCounter=APP_START_ADDRESS;ulPageCounter<(FLASH_SIZE-EEPROM_SIZE);ulPageCounter+=NVMCTRL_ROW_SIZE)
   1b376:	693b      	ldr	r3, [r7, #16]
   1b378:	3301      	adds	r3, #1
   1b37a:	33ff      	adds	r3, #255	; 0xff
   1b37c:	613b      	str	r3, [r7, #16]
   1b37e:	693b      	ldr	r3, [r7, #16]
   1b380:	4a3a      	ldr	r2, [pc, #232]	; (1b46c <vCheckFirmware+0x19c>)
   1b382:	4293      	cmp	r3, r2
   1b384:	d9d4      	bls.n	1b330 <vCheckFirmware+0x60>
  dma_crc_io_calculation(rx_buffer,NVMCTRL_ROW_SIZE);
  usCRC=usCrc16(rx_buffer,NVMCTRL_ROW_SIZE,usCRC);
 }
 
 
 usCRC = dma_crc_get_checksum();
   1b386:	4b3a      	ldr	r3, [pc, #232]	; (1b470 <vCheckFirmware+0x1a0>)
   1b388:	4798      	blx	r3
   1b38a:	0002      	movs	r2, r0
   1b38c:	2316      	movs	r3, #22
   1b38e:	18fb      	adds	r3, r7, r3
   1b390:	801a      	strh	r2, [r3, #0]
 dma_crc_disable();
   1b392:	4b38      	ldr	r3, [pc, #224]	; (1b474 <vCheckFirmware+0x1a4>)
   1b394:	4798      	blx	r3
 
 if (usCRC) return;
   1b396:	2316      	movs	r3, #22
   1b398:	18fb      	adds	r3, r7, r3
   1b39a:	881b      	ldrh	r3, [r3, #0]
   1b39c:	2b00      	cmp	r3, #0
   1b39e:	d14b      	bne.n	1b438 <vCheckFirmware+0x168>
 
 f_close(&file_object);
   1b3a0:	4b28      	ldr	r3, [pc, #160]	; (1b444 <vCheckFirmware+0x174>)
   1b3a2:	0018      	movs	r0, r3
   1b3a4:	4b34      	ldr	r3, [pc, #208]	; (1b478 <vCheckFirmware+0x1a8>)
   1b3a6:	4798      	blx	r3
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   1b3a8:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
   1b3aa:	f3bf 8f5f 	dmb	sy
 
 cpu_irq_disable();
   1b3ae:	4b33      	ldr	r3, [pc, #204]	; (1b47c <vCheckFirmware+0x1ac>)
   1b3b0:	2200      	movs	r2, #0
   1b3b2:	701a      	strb	r2, [r3, #0]
 
do 
{
  error_code=nvm_read_buffer(FLASH_SIZE-EEPROM_SIZE-NVMCTRL_PAGE_SIZE,rx_buffer,NVMCTRL_PAGE_SIZE);
   1b3b4:	230e      	movs	r3, #14
   1b3b6:	18fc      	adds	r4, r7, r3
   1b3b8:	4b28      	ldr	r3, [pc, #160]	; (1b45c <vCheckFirmware+0x18c>)
   1b3ba:	4831      	ldr	r0, [pc, #196]	; (1b480 <vCheckFirmware+0x1b0>)
   1b3bc:	2240      	movs	r2, #64	; 0x40
   1b3be:	0019      	movs	r1, r3
   1b3c0:	4b30      	ldr	r3, [pc, #192]	; (1b484 <vCheckFirmware+0x1b4>)
   1b3c2:	4798      	blx	r3
   1b3c4:	0003      	movs	r3, r0
   1b3c6:	7023      	strb	r3, [r4, #0]
} while (error_code == STATUS_BUSY);
   1b3c8:	230e      	movs	r3, #14
   1b3ca:	18fb      	adds	r3, r7, r3
   1b3cc:	781b      	ldrb	r3, [r3, #0]
   1b3ce:	2b05      	cmp	r3, #5
   1b3d0:	d0f0      	beq.n	1b3b4 <vCheckFirmware+0xe4>

rx_buffer[NVMCTRL_PAGE_SIZE-2]^=0xFF;
   1b3d2:	4b22      	ldr	r3, [pc, #136]	; (1b45c <vCheckFirmware+0x18c>)
   1b3d4:	223e      	movs	r2, #62	; 0x3e
   1b3d6:	5c9b      	ldrb	r3, [r3, r2]
   1b3d8:	43db      	mvns	r3, r3
   1b3da:	b2d9      	uxtb	r1, r3
   1b3dc:	4b1f      	ldr	r3, [pc, #124]	; (1b45c <vCheckFirmware+0x18c>)
   1b3de:	223e      	movs	r2, #62	; 0x3e
   1b3e0:	5499      	strb	r1, [r3, r2]
rx_buffer[NVMCTRL_PAGE_SIZE-1]^=0xFF;
   1b3e2:	4b1e      	ldr	r3, [pc, #120]	; (1b45c <vCheckFirmware+0x18c>)
   1b3e4:	223f      	movs	r2, #63	; 0x3f
   1b3e6:	5c9b      	ldrb	r3, [r3, r2]
   1b3e8:	43db      	mvns	r3, r3
   1b3ea:	b2d9      	uxtb	r1, r3
   1b3ec:	4b1b      	ldr	r3, [pc, #108]	; (1b45c <vCheckFirmware+0x18c>)
   1b3ee:	223f      	movs	r2, #63	; 0x3f
   1b3f0:	5499      	strb	r1, [r3, r2]

do
{
  error_code = nvm_erase_row(FLASH_SIZE-EEPROM_SIZE-NVMCTRL_ROW_SIZE);
   1b3f2:	230e      	movs	r3, #14
   1b3f4:	18fc      	adds	r4, r7, r3
   1b3f6:	4b24      	ldr	r3, [pc, #144]	; (1b488 <vCheckFirmware+0x1b8>)
   1b3f8:	0018      	movs	r0, r3
   1b3fa:	4b24      	ldr	r3, [pc, #144]	; (1b48c <vCheckFirmware+0x1bc>)
   1b3fc:	4798      	blx	r3
   1b3fe:	0003      	movs	r3, r0
   1b400:	7023      	strb	r3, [r4, #0]
} while (error_code == STATUS_BUSY);
   1b402:	230e      	movs	r3, #14
   1b404:	18fb      	adds	r3, r7, r3
   1b406:	781b      	ldrb	r3, [r3, #0]
   1b408:	2b05      	cmp	r3, #5
   1b40a:	d0f2      	beq.n	1b3f2 <vCheckFirmware+0x122>



do
{
	error_code=nvm_write_buffer(FLASH_SIZE-EEPROM_SIZE-NVMCTRL_PAGE_SIZE,rx_buffer,NVMCTRL_PAGE_SIZE);
   1b40c:	230e      	movs	r3, #14
   1b40e:	18fc      	adds	r4, r7, r3
   1b410:	4b12      	ldr	r3, [pc, #72]	; (1b45c <vCheckFirmware+0x18c>)
   1b412:	481b      	ldr	r0, [pc, #108]	; (1b480 <vCheckFirmware+0x1b0>)
   1b414:	2240      	movs	r2, #64	; 0x40
   1b416:	0019      	movs	r1, r3
   1b418:	4b1d      	ldr	r3, [pc, #116]	; (1b490 <vCheckFirmware+0x1c0>)
   1b41a:	4798      	blx	r3
   1b41c:	0003      	movs	r3, r0
   1b41e:	7023      	strb	r3, [r4, #0]
} while (error_code == STATUS_BUSY);	
   1b420:	230e      	movs	r3, #14
   1b422:	18fb      	adds	r3, r7, r3
   1b424:	781b      	ldrb	r3, [r3, #0]
   1b426:	2b05      	cmp	r3, #5
   1b428:	d0f0      	beq.n	1b40c <vCheckFirmware+0x13c>

 system_reset();
   1b42a:	4b1a      	ldr	r3, [pc, #104]	; (1b494 <vCheckFirmware+0x1c4>)
   1b42c:	4798      	blx	r3
   1b42e:	e004      	b.n	1b43a <vCheckFirmware+0x16a>
 DRESULT result;
 enum status_code error_code;
 struct dma_crc_config crc_config;
 
 result=f_open(&file_object,"0:/output.bin",FA_READ);
 if (result!=RES_OK) return;
   1b430:	46c0      	nop			; (mov r8, r8)
   1b432:	e002      	b.n	1b43a <vCheckFirmware+0x16a>
 uint16_t usCRC=0;
 f_lseek(&file_object,APP_START_ADDRESS);
 for (uint32_t ulPageCounter=APP_START_ADDRESS;ulPageCounter<(FLASH_SIZE-EEPROM_SIZE);ulPageCounter+=NVMCTRL_ROW_SIZE)
 {
  f_read(&file_object,rx_buffer,NVMCTRL_ROW_SIZE,&BytesRead);	
  if (BytesRead!=NVMCTRL_ROW_SIZE) return;
   1b434:	46c0      	nop			; (mov r8, r8)
   1b436:	e000      	b.n	1b43a <vCheckFirmware+0x16a>
 
 
 usCRC = dma_crc_get_checksum();
 dma_crc_disable();
 
 if (usCRC) return;
   1b438:	46c0      	nop			; (mov r8, r8)

 system_reset();
 //start_application_with_wdt();
 
 
}
   1b43a:	46bd      	mov	sp, r7
   1b43c:	b007      	add	sp, #28
   1b43e:	bd90      	pop	{r4, r7, pc}
   1b440:	00021cc8 	.word	0x00021cc8
   1b444:	2000449c 	.word	0x2000449c
   1b448:	00019b09 	.word	0x00019b09
   1b44c:	41004800 	.word	0x41004800
   1b450:	0001af49 	.word	0x0001af49
   1b454:	0001afb1 	.word	0x0001afb1
   1b458:	0001a5ed 	.word	0x0001a5ed
   1b45c:	20004be4 	.word	0x20004be4
   1b460:	00019e59 	.word	0x00019e59
   1b464:	0001b039 	.word	0x0001b039
   1b468:	0001aeb1 	.word	0x0001aeb1
   1b46c:	0003fbff 	.word	0x0003fbff
   1b470:	0001af89 	.word	0x0001af89
   1b474:	0001af65 	.word	0x0001af65
   1b478:	0001a595 	.word	0x0001a595
   1b47c:	20000051 	.word	0x20000051
   1b480:	0003fbc0 	.word	0x0003fbc0
   1b484:	0000f025 	.word	0x0000f025
   1b488:	0003fb00 	.word	0x0003fb00
   1b48c:	0000f129 	.word	0x0000f129
   1b490:	0000eed1 	.word	0x0000eed1
   1b494:	0001b289 	.word	0x0001b289

0001b498 <configure_rtc_calendar>:


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void configure_rtc_calendar(void)
{
   1b498:	b580      	push	{r7, lr}
   1b49a:	b086      	sub	sp, #24
   1b49c:	af00      	add	r7, sp, #0
	/* Initialize RTC in calendar mode. */
	struct rtc_calendar_config config_rtc_calendar;
	rtc_calendar_get_config_defaults(&config_rtc_calendar);
   1b49e:	1d3b      	adds	r3, r7, #4
   1b4a0:	0018      	movs	r0, r3
   1b4a2:	4b09      	ldr	r3, [pc, #36]	; (1b4c8 <configure_rtc_calendar+0x30>)
   1b4a4:	4798      	blx	r3
	//alarm.month  = 1;
	//alarm.day    = 1;
	//alarm.hour   = 0;
	//alarm.minute = 0;
	//alarm.second = 4;
	config_rtc_calendar.clock_24h     = true;
   1b4a6:	1d3b      	adds	r3, r7, #4
   1b4a8:	2201      	movs	r2, #1
   1b4aa:	711a      	strb	r2, [r3, #4]
	//config_rtc_calendar.alarm[0].time = alarm;
	//config_rtc_calendar.alarm[0].mask = RTC_CALENDAR_ALARM_MASK_YEAR;
	rtc_calendar_init(&rtc_instance, RTC, &config_rtc_calendar);
   1b4ac:	1d3a      	adds	r2, r7, #4
   1b4ae:	4907      	ldr	r1, [pc, #28]	; (1b4cc <configure_rtc_calendar+0x34>)
   1b4b0:	4b07      	ldr	r3, [pc, #28]	; (1b4d0 <configure_rtc_calendar+0x38>)
   1b4b2:	0018      	movs	r0, r3
   1b4b4:	4b07      	ldr	r3, [pc, #28]	; (1b4d4 <configure_rtc_calendar+0x3c>)
   1b4b6:	4798      	blx	r3
	rtc_calendar_enable(&rtc_instance);
   1b4b8:	4b05      	ldr	r3, [pc, #20]	; (1b4d0 <configure_rtc_calendar+0x38>)
   1b4ba:	0018      	movs	r0, r3
   1b4bc:	4b06      	ldr	r3, [pc, #24]	; (1b4d8 <configure_rtc_calendar+0x40>)
   1b4be:	4798      	blx	r3
	
}
   1b4c0:	46c0      	nop			; (mov r8, r8)
   1b4c2:	46bd      	mov	sp, r7
   1b4c4:	b006      	add	sp, #24
   1b4c6:	bd80      	pop	{r7, pc}
   1b4c8:	0001b1e5 	.word	0x0001b1e5
   1b4cc:	40001400 	.word	0x40001400
   1b4d0:	20004bc8 	.word	0x20004bc8
   1b4d4:	000138fd 	.word	0x000138fd
   1b4d8:	00013659 	.word	0x00013659

0001b4dc <vOpenFiles>:

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void vOpenFiles(void)
{   UINT uSize;
   1b4dc:	b5b0      	push	{r4, r5, r7, lr}
   1b4de:	b082      	sub	sp, #8
   1b4e0:	af00      	add	r7, sp, #0
	DRESULT result;
	
	result=f_open(&file_object,"0:/PrgList.bin",FA_READ);
   1b4e2:	1d3c      	adds	r4, r7, #4
   1b4e4:	49dd      	ldr	r1, [pc, #884]	; (1b85c <vOpenFiles+0x380>)
   1b4e6:	4bde      	ldr	r3, [pc, #888]	; (1b860 <vOpenFiles+0x384>)
   1b4e8:	2201      	movs	r2, #1
   1b4ea:	0018      	movs	r0, r3
   1b4ec:	4bdd      	ldr	r3, [pc, #884]	; (1b864 <vOpenFiles+0x388>)
   1b4ee:	4798      	blx	r3
   1b4f0:	0003      	movs	r3, r0
   1b4f2:	7023      	strb	r3, [r4, #0]
	if (result!=RES_OK)
   1b4f4:	1d3b      	adds	r3, r7, #4
   1b4f6:	781b      	ldrb	r3, [r3, #0]
   1b4f8:	2b00      	cmp	r3, #0
   1b4fa:	d030      	beq.n	1b55e <vOpenFiles+0x82>
	{
	 f_open(&file_object,"0:/PrgList.bin",FA_CREATE_ALWAYS | FA_WRITE);
   1b4fc:	49d7      	ldr	r1, [pc, #860]	; (1b85c <vOpenFiles+0x380>)
   1b4fe:	4bd8      	ldr	r3, [pc, #864]	; (1b860 <vOpenFiles+0x384>)
   1b500:	220a      	movs	r2, #10
   1b502:	0018      	movs	r0, r3
   1b504:	4bd7      	ldr	r3, [pc, #860]	; (1b864 <vOpenFiles+0x388>)
   1b506:	4798      	blx	r3
	 memset(xProgramList,0x00,sizeof(xProgramList));
   1b508:	4ad7      	ldr	r2, [pc, #860]	; (1b868 <vOpenFiles+0x38c>)
   1b50a:	4bd8      	ldr	r3, [pc, #864]	; (1b86c <vOpenFiles+0x390>)
   1b50c:	2100      	movs	r1, #0
   1b50e:	0018      	movs	r0, r3
   1b510:	4bd7      	ldr	r3, [pc, #860]	; (1b870 <vOpenFiles+0x394>)
   1b512:	4798      	blx	r3
	 for (uint8_t ucIndex=0x00;ucIndex<MAX_PRG;ucIndex++)	
   1b514:	1dfb      	adds	r3, r7, #7
   1b516:	2200      	movs	r2, #0
   1b518:	701a      	strb	r2, [r3, #0]
   1b51a:	e00e      	b.n	1b53a <vOpenFiles+0x5e>
	  xProgramList[ucIndex].xProgramType=P_OFF;
   1b51c:	1dfb      	adds	r3, r7, #7
   1b51e:	781a      	ldrb	r2, [r3, #0]
   1b520:	49d2      	ldr	r1, [pc, #840]	; (1b86c <vOpenFiles+0x390>)
   1b522:	0013      	movs	r3, r2
   1b524:	00db      	lsls	r3, r3, #3
   1b526:	1a9b      	subs	r3, r3, r2
   1b528:	00db      	lsls	r3, r3, #3
   1b52a:	189b      	adds	r3, r3, r2
   1b52c:	22ff      	movs	r2, #255	; 0xff
   1b52e:	545a      	strb	r2, [r3, r1]
	result=f_open(&file_object,"0:/PrgList.bin",FA_READ);
	if (result!=RES_OK)
	{
	 f_open(&file_object,"0:/PrgList.bin",FA_CREATE_ALWAYS | FA_WRITE);
	 memset(xProgramList,0x00,sizeof(xProgramList));
	 for (uint8_t ucIndex=0x00;ucIndex<MAX_PRG;ucIndex++)	
   1b530:	1dfb      	adds	r3, r7, #7
   1b532:	781a      	ldrb	r2, [r3, #0]
   1b534:	1dfb      	adds	r3, r7, #7
   1b536:	3201      	adds	r2, #1
   1b538:	701a      	strb	r2, [r3, #0]
   1b53a:	1dfb      	adds	r3, r7, #7
   1b53c:	781b      	ldrb	r3, [r3, #0]
   1b53e:	2b09      	cmp	r3, #9
   1b540:	d9ec      	bls.n	1b51c <vOpenFiles+0x40>
	  xProgramList[ucIndex].xProgramType=P_OFF;
	 result=f_write(&file_object,xProgramList,sizeof(xProgramList),&uSize);
   1b542:	1d3c      	adds	r4, r7, #4
   1b544:	003b      	movs	r3, r7
   1b546:	4ac8      	ldr	r2, [pc, #800]	; (1b868 <vOpenFiles+0x38c>)
   1b548:	49c8      	ldr	r1, [pc, #800]	; (1b86c <vOpenFiles+0x390>)
   1b54a:	48c5      	ldr	r0, [pc, #788]	; (1b860 <vOpenFiles+0x384>)
   1b54c:	4dc9      	ldr	r5, [pc, #804]	; (1b874 <vOpenFiles+0x398>)
   1b54e:	47a8      	blx	r5
   1b550:	0003      	movs	r3, r0
   1b552:	7023      	strb	r3, [r4, #0]
	 f_close(&file_object);
   1b554:	4bc2      	ldr	r3, [pc, #776]	; (1b860 <vOpenFiles+0x384>)
   1b556:	0018      	movs	r0, r3
   1b558:	4bc7      	ldr	r3, [pc, #796]	; (1b878 <vOpenFiles+0x39c>)
   1b55a:	4798      	blx	r3
   1b55c:	e009      	b.n	1b572 <vOpenFiles+0x96>
	}
	else
	{
	 f_read(&file_object,xProgramList,sizeof(xProgramList),&uSize);	
   1b55e:	003b      	movs	r3, r7
   1b560:	4ac1      	ldr	r2, [pc, #772]	; (1b868 <vOpenFiles+0x38c>)
   1b562:	49c2      	ldr	r1, [pc, #776]	; (1b86c <vOpenFiles+0x390>)
   1b564:	48be      	ldr	r0, [pc, #760]	; (1b860 <vOpenFiles+0x384>)
   1b566:	4cc5      	ldr	r4, [pc, #788]	; (1b87c <vOpenFiles+0x3a0>)
   1b568:	47a0      	blx	r4
	 f_close(&file_object);
   1b56a:	4bbd      	ldr	r3, [pc, #756]	; (1b860 <vOpenFiles+0x384>)
   1b56c:	0018      	movs	r0, r3
   1b56e:	4bc2      	ldr	r3, [pc, #776]	; (1b878 <vOpenFiles+0x39c>)
   1b570:	4798      	blx	r3
	}
	
	result=f_open(&file_object,"0:/Setup.bin",FA_READ);
   1b572:	1d3c      	adds	r4, r7, #4
   1b574:	49c2      	ldr	r1, [pc, #776]	; (1b880 <vOpenFiles+0x3a4>)
   1b576:	4bba      	ldr	r3, [pc, #744]	; (1b860 <vOpenFiles+0x384>)
   1b578:	2201      	movs	r2, #1
   1b57a:	0018      	movs	r0, r3
   1b57c:	4bb9      	ldr	r3, [pc, #740]	; (1b864 <vOpenFiles+0x388>)
   1b57e:	4798      	blx	r3
   1b580:	0003      	movs	r3, r0
   1b582:	7023      	strb	r3, [r4, #0]
	if (result!=RES_OK)
   1b584:	1d3b      	adds	r3, r7, #4
   1b586:	781b      	ldrb	r3, [r3, #0]
   1b588:	2b00      	cmp	r3, #0
   1b58a:	d075      	beq.n	1b678 <vOpenFiles+0x19c>
	{
		f_open(&file_object,"0:/Setup.bin",FA_CREATE_ALWAYS | FA_WRITE);
   1b58c:	49bc      	ldr	r1, [pc, #752]	; (1b880 <vOpenFiles+0x3a4>)
   1b58e:	4bb4      	ldr	r3, [pc, #720]	; (1b860 <vOpenFiles+0x384>)
   1b590:	220a      	movs	r2, #10
   1b592:	0018      	movs	r0, r3
   1b594:	4bb3      	ldr	r3, [pc, #716]	; (1b864 <vOpenFiles+0x388>)
   1b596:	4798      	blx	r3
	    xMachineSetup.ucIPAddr[0]=0x01;
   1b598:	4bba      	ldr	r3, [pc, #744]	; (1b884 <vOpenFiles+0x3a8>)
   1b59a:	2201      	movs	r2, #1
   1b59c:	701a      	strb	r2, [r3, #0]
	    xMachineSetup.ucIPAddr[1]=0x01;
   1b59e:	4bb9      	ldr	r3, [pc, #740]	; (1b884 <vOpenFiles+0x3a8>)
   1b5a0:	2201      	movs	r2, #1
   1b5a2:	705a      	strb	r2, [r3, #1]
	    xMachineSetup.ucIPAddr[2]=0xA8;
   1b5a4:	4bb7      	ldr	r3, [pc, #732]	; (1b884 <vOpenFiles+0x3a8>)
   1b5a6:	22a8      	movs	r2, #168	; 0xa8
   1b5a8:	709a      	strb	r2, [r3, #2]
	    xMachineSetup.ucIPAddr[3]=0xC0;
   1b5aa:	4bb6      	ldr	r3, [pc, #728]	; (1b884 <vOpenFiles+0x3a8>)
   1b5ac:	22c0      	movs	r2, #192	; 0xc0
   1b5ae:	70da      	strb	r2, [r3, #3]
	    xMachineSetup.ucLanguage=0;
   1b5b0:	4bb4      	ldr	r3, [pc, #720]	; (1b884 <vOpenFiles+0x3a8>)
   1b5b2:	2200      	movs	r2, #0
   1b5b4:	73da      	strb	r2, [r3, #15]
	    xMachineSetup.ucWEPKey[0]=0x11;
   1b5b6:	4bb3      	ldr	r3, [pc, #716]	; (1b884 <vOpenFiles+0x3a8>)
   1b5b8:	2211      	movs	r2, #17
   1b5ba:	711a      	strb	r2, [r3, #4]
	    xMachineSetup.ucWEPKey[1]=0x22;
   1b5bc:	4bb1      	ldr	r3, [pc, #708]	; (1b884 <vOpenFiles+0x3a8>)
   1b5be:	2222      	movs	r2, #34	; 0x22
   1b5c0:	715a      	strb	r2, [r3, #5]
	    xMachineSetup.ucWEPKey[2]=0x33;
   1b5c2:	4bb0      	ldr	r3, [pc, #704]	; (1b884 <vOpenFiles+0x3a8>)
   1b5c4:	2233      	movs	r2, #51	; 0x33
   1b5c6:	719a      	strb	r2, [r3, #6]
	    xMachineSetup.ucWEPKey[3]=0x44;
   1b5c8:	4bae      	ldr	r3, [pc, #696]	; (1b884 <vOpenFiles+0x3a8>)
   1b5ca:	2244      	movs	r2, #68	; 0x44
   1b5cc:	71da      	strb	r2, [r3, #7]
	    xMachineSetup.ucWEPKey[4]=0x55;
   1b5ce:	4bad      	ldr	r3, [pc, #692]	; (1b884 <vOpenFiles+0x3a8>)
   1b5d0:	2255      	movs	r2, #85	; 0x55
   1b5d2:	721a      	strb	r2, [r3, #8]
	    xMachineSetup.ulPump1=0x00;
   1b5d4:	4bab      	ldr	r3, [pc, #684]	; (1b884 <vOpenFiles+0x3a8>)
   1b5d6:	7c1a      	ldrb	r2, [r3, #16]
   1b5d8:	2100      	movs	r1, #0
   1b5da:	400a      	ands	r2, r1
   1b5dc:	741a      	strb	r2, [r3, #16]
   1b5de:	7c5a      	ldrb	r2, [r3, #17]
   1b5e0:	2100      	movs	r1, #0
   1b5e2:	400a      	ands	r2, r1
   1b5e4:	745a      	strb	r2, [r3, #17]
   1b5e6:	7c9a      	ldrb	r2, [r3, #18]
   1b5e8:	2100      	movs	r1, #0
   1b5ea:	400a      	ands	r2, r1
   1b5ec:	749a      	strb	r2, [r3, #18]
   1b5ee:	7cda      	ldrb	r2, [r3, #19]
   1b5f0:	2100      	movs	r1, #0
   1b5f2:	400a      	ands	r2, r1
   1b5f4:	74da      	strb	r2, [r3, #19]
	    xMachineSetup.ulPump2=0x00;
   1b5f6:	4ba3      	ldr	r3, [pc, #652]	; (1b884 <vOpenFiles+0x3a8>)
   1b5f8:	7d1a      	ldrb	r2, [r3, #20]
   1b5fa:	2100      	movs	r1, #0
   1b5fc:	400a      	ands	r2, r1
   1b5fe:	751a      	strb	r2, [r3, #20]
   1b600:	7d5a      	ldrb	r2, [r3, #21]
   1b602:	2100      	movs	r1, #0
   1b604:	400a      	ands	r2, r1
   1b606:	755a      	strb	r2, [r3, #21]
   1b608:	7d9a      	ldrb	r2, [r3, #22]
   1b60a:	2100      	movs	r1, #0
   1b60c:	400a      	ands	r2, r1
   1b60e:	759a      	strb	r2, [r3, #22]
   1b610:	7dda      	ldrb	r2, [r3, #23]
   1b612:	2100      	movs	r1, #0
   1b614:	400a      	ands	r2, r1
   1b616:	75da      	strb	r2, [r3, #23]
	    xMachineSetup.usRevTime=300;
   1b618:	4b9a      	ldr	r3, [pc, #616]	; (1b884 <vOpenFiles+0x3a8>)
   1b61a:	3309      	adds	r3, #9
   1b61c:	781a      	ldrb	r2, [r3, #0]
   1b61e:	2100      	movs	r1, #0
   1b620:	400a      	ands	r2, r1
   1b622:	1c11      	adds	r1, r2, #0
   1b624:	222c      	movs	r2, #44	; 0x2c
   1b626:	430a      	orrs	r2, r1
   1b628:	701a      	strb	r2, [r3, #0]
   1b62a:	785a      	ldrb	r2, [r3, #1]
   1b62c:	2100      	movs	r1, #0
   1b62e:	400a      	ands	r2, r1
   1b630:	1c11      	adds	r1, r2, #0
   1b632:	2201      	movs	r2, #1
   1b634:	430a      	orrs	r2, r1
   1b636:	705a      	strb	r2, [r3, #1]
	    xMachineSetup.xDateTime=0x00;		
   1b638:	4b92      	ldr	r3, [pc, #584]	; (1b884 <vOpenFiles+0x3a8>)
   1b63a:	330b      	adds	r3, #11
   1b63c:	781a      	ldrb	r2, [r3, #0]
   1b63e:	2100      	movs	r1, #0
   1b640:	400a      	ands	r2, r1
   1b642:	701a      	strb	r2, [r3, #0]
   1b644:	785a      	ldrb	r2, [r3, #1]
   1b646:	2100      	movs	r1, #0
   1b648:	400a      	ands	r2, r1
   1b64a:	705a      	strb	r2, [r3, #1]
   1b64c:	789a      	ldrb	r2, [r3, #2]
   1b64e:	2100      	movs	r1, #0
   1b650:	400a      	ands	r2, r1
   1b652:	709a      	strb	r2, [r3, #2]
   1b654:	78da      	ldrb	r2, [r3, #3]
   1b656:	2100      	movs	r1, #0
   1b658:	400a      	ands	r2, r1
   1b65a:	70da      	strb	r2, [r3, #3]
		result=f_write(&file_object,&xMachineSetup,sizeof(xMachineSetup),&uSize);
   1b65c:	1d3c      	adds	r4, r7, #4
   1b65e:	003b      	movs	r3, r7
   1b660:	4988      	ldr	r1, [pc, #544]	; (1b884 <vOpenFiles+0x3a8>)
   1b662:	487f      	ldr	r0, [pc, #508]	; (1b860 <vOpenFiles+0x384>)
   1b664:	222c      	movs	r2, #44	; 0x2c
   1b666:	4d83      	ldr	r5, [pc, #524]	; (1b874 <vOpenFiles+0x398>)
   1b668:	47a8      	blx	r5
   1b66a:	0003      	movs	r3, r0
   1b66c:	7023      	strb	r3, [r4, #0]
		f_close(&file_object);
   1b66e:	4b7c      	ldr	r3, [pc, #496]	; (1b860 <vOpenFiles+0x384>)
   1b670:	0018      	movs	r0, r3
   1b672:	4b81      	ldr	r3, [pc, #516]	; (1b878 <vOpenFiles+0x39c>)
   1b674:	4798      	blx	r3
   1b676:	e009      	b.n	1b68c <vOpenFiles+0x1b0>
	}
	else
	{
		f_read(&file_object,&xMachineSetup,sizeof(xMachineSetup),&uSize);
   1b678:	003b      	movs	r3, r7
   1b67a:	4982      	ldr	r1, [pc, #520]	; (1b884 <vOpenFiles+0x3a8>)
   1b67c:	4878      	ldr	r0, [pc, #480]	; (1b860 <vOpenFiles+0x384>)
   1b67e:	222c      	movs	r2, #44	; 0x2c
   1b680:	4c7e      	ldr	r4, [pc, #504]	; (1b87c <vOpenFiles+0x3a0>)
   1b682:	47a0      	blx	r4
		f_close(&file_object);
   1b684:	4b76      	ldr	r3, [pc, #472]	; (1b860 <vOpenFiles+0x384>)
   1b686:	0018      	movs	r0, r3
   1b688:	4b7b      	ldr	r3, [pc, #492]	; (1b878 <vOpenFiles+0x39c>)
   1b68a:	4798      	blx	r3
	}
	
	result=f_open(&file_object,"0:/LogTable.bin",FA_READ);
   1b68c:	1d3c      	adds	r4, r7, #4
   1b68e:	497e      	ldr	r1, [pc, #504]	; (1b888 <vOpenFiles+0x3ac>)
   1b690:	4b73      	ldr	r3, [pc, #460]	; (1b860 <vOpenFiles+0x384>)
   1b692:	2201      	movs	r2, #1
   1b694:	0018      	movs	r0, r3
   1b696:	4b73      	ldr	r3, [pc, #460]	; (1b864 <vOpenFiles+0x388>)
   1b698:	4798      	blx	r3
   1b69a:	0003      	movs	r3, r0
   1b69c:	7023      	strb	r3, [r4, #0]
	if (result!=RES_OK)
   1b69e:	1d3b      	adds	r3, r7, #4
   1b6a0:	781b      	ldrb	r3, [r3, #0]
   1b6a2:	2b00      	cmp	r3, #0
   1b6a4:	d032      	beq.n	1b70c <vOpenFiles+0x230>
	{
		f_open(&file_object,"0:/LogTable.bin",FA_CREATE_ALWAYS | FA_WRITE);
   1b6a6:	4978      	ldr	r1, [pc, #480]	; (1b888 <vOpenFiles+0x3ac>)
   1b6a8:	4b6d      	ldr	r3, [pc, #436]	; (1b860 <vOpenFiles+0x384>)
   1b6aa:	220a      	movs	r2, #10
   1b6ac:	0018      	movs	r0, r3
   1b6ae:	4b6d      	ldr	r3, [pc, #436]	; (1b864 <vOpenFiles+0x388>)
   1b6b0:	4798      	blx	r3
		memset(&xLogTable,0x00,sizeof(xLogTable));
   1b6b2:	23fa      	movs	r3, #250	; 0xfa
   1b6b4:	009a      	lsls	r2, r3, #2
   1b6b6:	4b75      	ldr	r3, [pc, #468]	; (1b88c <vOpenFiles+0x3b0>)
   1b6b8:	2100      	movs	r1, #0
   1b6ba:	0018      	movs	r0, r3
   1b6bc:	4b6c      	ldr	r3, [pc, #432]	; (1b870 <vOpenFiles+0x394>)
   1b6be:	4798      	blx	r3
		for (uint8_t ucIndex=0x00;ucIndex<MAX_LOGS;ucIndex++)
   1b6c0:	1dbb      	adds	r3, r7, #6
   1b6c2:	2200      	movs	r2, #0
   1b6c4:	701a      	strb	r2, [r3, #0]
   1b6c6:	e00d      	b.n	1b6e4 <vOpenFiles+0x208>
		 xLogTable[ucIndex].ucPrgIndex=0xFF;
   1b6c8:	1dbb      	adds	r3, r7, #6
   1b6ca:	781a      	ldrb	r2, [r3, #0]
   1b6cc:	496f      	ldr	r1, [pc, #444]	; (1b88c <vOpenFiles+0x3b0>)
   1b6ce:	0013      	movs	r3, r2
   1b6d0:	009b      	lsls	r3, r3, #2
   1b6d2:	189b      	adds	r3, r3, r2
   1b6d4:	005b      	lsls	r3, r3, #1
   1b6d6:	22ff      	movs	r2, #255	; 0xff
   1b6d8:	545a      	strb	r2, [r3, r1]
	result=f_open(&file_object,"0:/LogTable.bin",FA_READ);
	if (result!=RES_OK)
	{
		f_open(&file_object,"0:/LogTable.bin",FA_CREATE_ALWAYS | FA_WRITE);
		memset(&xLogTable,0x00,sizeof(xLogTable));
		for (uint8_t ucIndex=0x00;ucIndex<MAX_LOGS;ucIndex++)
   1b6da:	1dbb      	adds	r3, r7, #6
   1b6dc:	781a      	ldrb	r2, [r3, #0]
   1b6de:	1dbb      	adds	r3, r7, #6
   1b6e0:	3201      	adds	r2, #1
   1b6e2:	701a      	strb	r2, [r3, #0]
   1b6e4:	1dbb      	adds	r3, r7, #6
   1b6e6:	781b      	ldrb	r3, [r3, #0]
   1b6e8:	2b63      	cmp	r3, #99	; 0x63
   1b6ea:	d9ed      	bls.n	1b6c8 <vOpenFiles+0x1ec>
		 xLogTable[ucIndex].ucPrgIndex=0xFF;
		result=f_write(&file_object,&xLogTable,sizeof(xLogTable),&uSize);
   1b6ec:	1d3c      	adds	r4, r7, #4
   1b6ee:	003d      	movs	r5, r7
   1b6f0:	23fa      	movs	r3, #250	; 0xfa
   1b6f2:	009a      	lsls	r2, r3, #2
   1b6f4:	4965      	ldr	r1, [pc, #404]	; (1b88c <vOpenFiles+0x3b0>)
   1b6f6:	485a      	ldr	r0, [pc, #360]	; (1b860 <vOpenFiles+0x384>)
   1b6f8:	002b      	movs	r3, r5
   1b6fa:	4d5e      	ldr	r5, [pc, #376]	; (1b874 <vOpenFiles+0x398>)
   1b6fc:	47a8      	blx	r5
   1b6fe:	0003      	movs	r3, r0
   1b700:	7023      	strb	r3, [r4, #0]
		f_close(&file_object);
   1b702:	4b57      	ldr	r3, [pc, #348]	; (1b860 <vOpenFiles+0x384>)
   1b704:	0018      	movs	r0, r3
   1b706:	4b5c      	ldr	r3, [pc, #368]	; (1b878 <vOpenFiles+0x39c>)
   1b708:	4798      	blx	r3
   1b70a:	e00b      	b.n	1b724 <vOpenFiles+0x248>
	}
	else
	{
		f_read(&file_object,&xLogTable,sizeof(xLogTable),&uSize);
   1b70c:	003c      	movs	r4, r7
   1b70e:	23fa      	movs	r3, #250	; 0xfa
   1b710:	009a      	lsls	r2, r3, #2
   1b712:	495e      	ldr	r1, [pc, #376]	; (1b88c <vOpenFiles+0x3b0>)
   1b714:	4852      	ldr	r0, [pc, #328]	; (1b860 <vOpenFiles+0x384>)
   1b716:	0023      	movs	r3, r4
   1b718:	4c58      	ldr	r4, [pc, #352]	; (1b87c <vOpenFiles+0x3a0>)
   1b71a:	47a0      	blx	r4
		f_close(&file_object);
   1b71c:	4b50      	ldr	r3, [pc, #320]	; (1b860 <vOpenFiles+0x384>)
   1b71e:	0018      	movs	r0, r3
   1b720:	4b55      	ldr	r3, [pc, #340]	; (1b878 <vOpenFiles+0x39c>)
   1b722:	4798      	blx	r3
	 //memset(&xMachineSetup.ucSpare,0x00,sizeof(xMachineSetup.ucSpare));
	 //
	 //vSaveSetup();	
	//}		
	
	result=f_open(&file_object,"0:/Labels.bin",FA_READ);
   1b724:	1d3c      	adds	r4, r7, #4
   1b726:	495a      	ldr	r1, [pc, #360]	; (1b890 <vOpenFiles+0x3b4>)
   1b728:	4b4d      	ldr	r3, [pc, #308]	; (1b860 <vOpenFiles+0x384>)
   1b72a:	2201      	movs	r2, #1
   1b72c:	0018      	movs	r0, r3
   1b72e:	4b4d      	ldr	r3, [pc, #308]	; (1b864 <vOpenFiles+0x388>)
   1b730:	4798      	blx	r3
   1b732:	0003      	movs	r3, r0
   1b734:	7023      	strb	r3, [r4, #0]
	if (result!=RES_OK)
   1b736:	1d3b      	adds	r3, r7, #4
   1b738:	781b      	ldrb	r3, [r3, #0]
   1b73a:	2b00      	cmp	r3, #0
   1b73c:	d022      	beq.n	1b784 <vOpenFiles+0x2a8>
	{
		f_open(&file_object,"0:/Labels.bin",FA_CREATE_ALWAYS | FA_WRITE);
   1b73e:	4954      	ldr	r1, [pc, #336]	; (1b890 <vOpenFiles+0x3b4>)
   1b740:	4b47      	ldr	r3, [pc, #284]	; (1b860 <vOpenFiles+0x384>)
   1b742:	220a      	movs	r2, #10
   1b744:	0018      	movs	r0, r3
   1b746:	4b47      	ldr	r3, [pc, #284]	; (1b864 <vOpenFiles+0x388>)
   1b748:	4798      	blx	r3
		for (uint8_t ucIndex=0;ucIndex<MAX_LANGUAGE;ucIndex++)
   1b74a:	1d7b      	adds	r3, r7, #5
   1b74c:	2200      	movs	r2, #0
   1b74e:	701a      	strb	r2, [r3, #0]
   1b750:	e00f      	b.n	1b772 <vOpenFiles+0x296>
		 result=f_write(&file_object,&LCDlabels,sizeof(LCDlabels),&uSize); 
   1b752:	1d3c      	adds	r4, r7, #4
   1b754:	003d      	movs	r5, r7
   1b756:	23f0      	movs	r3, #240	; 0xf0
   1b758:	009a      	lsls	r2, r3, #2
   1b75a:	494e      	ldr	r1, [pc, #312]	; (1b894 <vOpenFiles+0x3b8>)
   1b75c:	4840      	ldr	r0, [pc, #256]	; (1b860 <vOpenFiles+0x384>)
   1b75e:	002b      	movs	r3, r5
   1b760:	4d44      	ldr	r5, [pc, #272]	; (1b874 <vOpenFiles+0x398>)
   1b762:	47a8      	blx	r5
   1b764:	0003      	movs	r3, r0
   1b766:	7023      	strb	r3, [r4, #0]
	
	result=f_open(&file_object,"0:/Labels.bin",FA_READ);
	if (result!=RES_OK)
	{
		f_open(&file_object,"0:/Labels.bin",FA_CREATE_ALWAYS | FA_WRITE);
		for (uint8_t ucIndex=0;ucIndex<MAX_LANGUAGE;ucIndex++)
   1b768:	1d7b      	adds	r3, r7, #5
   1b76a:	781a      	ldrb	r2, [r3, #0]
   1b76c:	1d7b      	adds	r3, r7, #5
   1b76e:	3201      	adds	r2, #1
   1b770:	701a      	strb	r2, [r3, #0]
   1b772:	1d7b      	adds	r3, r7, #5
   1b774:	781b      	ldrb	r3, [r3, #0]
   1b776:	2b09      	cmp	r3, #9
   1b778:	d9eb      	bls.n	1b752 <vOpenFiles+0x276>
		 result=f_write(&file_object,&LCDlabels,sizeof(LCDlabels),&uSize); 
		f_close(&file_object);
   1b77a:	4b39      	ldr	r3, [pc, #228]	; (1b860 <vOpenFiles+0x384>)
   1b77c:	0018      	movs	r0, r3
   1b77e:	4b3e      	ldr	r3, [pc, #248]	; (1b878 <vOpenFiles+0x39c>)
   1b780:	4798      	blx	r3
   1b782:	e018      	b.n	1b7b6 <vOpenFiles+0x2da>
	}
	else
	{
		//Aggiungere Offset Lingua
		f_lseek(&file_object,(uint32_t)xMachineSetup.ucLanguage*sizeof(LCDlabels));
   1b784:	4b3f      	ldr	r3, [pc, #252]	; (1b884 <vOpenFiles+0x3a8>)
   1b786:	7bdb      	ldrb	r3, [r3, #15]
   1b788:	001a      	movs	r2, r3
   1b78a:	0013      	movs	r3, r2
   1b78c:	011b      	lsls	r3, r3, #4
   1b78e:	1a9b      	subs	r3, r3, r2
   1b790:	019b      	lsls	r3, r3, #6
   1b792:	001a      	movs	r2, r3
   1b794:	4b32      	ldr	r3, [pc, #200]	; (1b860 <vOpenFiles+0x384>)
   1b796:	0011      	movs	r1, r2
   1b798:	0018      	movs	r0, r3
   1b79a:	4b3f      	ldr	r3, [pc, #252]	; (1b898 <vOpenFiles+0x3bc>)
   1b79c:	4798      	blx	r3
		f_read(&file_object,&LCDlabels,sizeof(LCDlabels),&uSize);
   1b79e:	003c      	movs	r4, r7
   1b7a0:	23f0      	movs	r3, #240	; 0xf0
   1b7a2:	009a      	lsls	r2, r3, #2
   1b7a4:	493b      	ldr	r1, [pc, #236]	; (1b894 <vOpenFiles+0x3b8>)
   1b7a6:	482e      	ldr	r0, [pc, #184]	; (1b860 <vOpenFiles+0x384>)
   1b7a8:	0023      	movs	r3, r4
   1b7aa:	4c34      	ldr	r4, [pc, #208]	; (1b87c <vOpenFiles+0x3a0>)
   1b7ac:	47a0      	blx	r4
		f_close(&file_object);
   1b7ae:	4b2c      	ldr	r3, [pc, #176]	; (1b860 <vOpenFiles+0x384>)
   1b7b0:	0018      	movs	r0, r3
   1b7b2:	4b31      	ldr	r3, [pc, #196]	; (1b878 <vOpenFiles+0x39c>)
   1b7b4:	4798      	blx	r3
	}	
	
	result=f_open(&file_object,"0:/RunTime.bin",FA_READ);
   1b7b6:	1d3c      	adds	r4, r7, #4
   1b7b8:	4938      	ldr	r1, [pc, #224]	; (1b89c <vOpenFiles+0x3c0>)
   1b7ba:	4b29      	ldr	r3, [pc, #164]	; (1b860 <vOpenFiles+0x384>)
   1b7bc:	2201      	movs	r2, #1
   1b7be:	0018      	movs	r0, r3
   1b7c0:	4b28      	ldr	r3, [pc, #160]	; (1b864 <vOpenFiles+0x388>)
   1b7c2:	4798      	blx	r3
   1b7c4:	0003      	movs	r3, r0
   1b7c6:	7023      	strb	r3, [r4, #0]
	if (result!=RES_OK)
   1b7c8:	1d3b      	adds	r3, r7, #4
   1b7ca:	781b      	ldrb	r3, [r3, #0]
   1b7cc:	2b00      	cmp	r3, #0
   1b7ce:	d013      	beq.n	1b7f8 <vOpenFiles+0x31c>
	{
		f_open(&file_object,"0:/RunTime.bin",FA_CREATE_ALWAYS | FA_WRITE);
   1b7d0:	4932      	ldr	r1, [pc, #200]	; (1b89c <vOpenFiles+0x3c0>)
   1b7d2:	4b23      	ldr	r3, [pc, #140]	; (1b860 <vOpenFiles+0x384>)
   1b7d4:	220a      	movs	r2, #10
   1b7d6:	0018      	movs	r0, r3
   1b7d8:	4b22      	ldr	r3, [pc, #136]	; (1b864 <vOpenFiles+0x388>)
   1b7da:	4798      	blx	r3
		result=f_write(&file_object,&ulMachineWorkTime,sizeof(ulMachineWorkTime),&uSize);
   1b7dc:	1d3c      	adds	r4, r7, #4
   1b7de:	003b      	movs	r3, r7
   1b7e0:	492f      	ldr	r1, [pc, #188]	; (1b8a0 <vOpenFiles+0x3c4>)
   1b7e2:	481f      	ldr	r0, [pc, #124]	; (1b860 <vOpenFiles+0x384>)
   1b7e4:	2204      	movs	r2, #4
   1b7e6:	4d23      	ldr	r5, [pc, #140]	; (1b874 <vOpenFiles+0x398>)
   1b7e8:	47a8      	blx	r5
   1b7ea:	0003      	movs	r3, r0
   1b7ec:	7023      	strb	r3, [r4, #0]
		f_close(&file_object);
   1b7ee:	4b1c      	ldr	r3, [pc, #112]	; (1b860 <vOpenFiles+0x384>)
   1b7f0:	0018      	movs	r0, r3
   1b7f2:	4b21      	ldr	r3, [pc, #132]	; (1b878 <vOpenFiles+0x39c>)
   1b7f4:	4798      	blx	r3
   1b7f6:	e009      	b.n	1b80c <vOpenFiles+0x330>
	}
	else
	{
		f_read(&file_object,&ulMachineWorkTime,sizeof(ulMachineWorkTime),&uSize);
   1b7f8:	003b      	movs	r3, r7
   1b7fa:	4929      	ldr	r1, [pc, #164]	; (1b8a0 <vOpenFiles+0x3c4>)
   1b7fc:	4818      	ldr	r0, [pc, #96]	; (1b860 <vOpenFiles+0x384>)
   1b7fe:	2204      	movs	r2, #4
   1b800:	4c1e      	ldr	r4, [pc, #120]	; (1b87c <vOpenFiles+0x3a0>)
   1b802:	47a0      	blx	r4
		f_close(&file_object);
   1b804:	4b16      	ldr	r3, [pc, #88]	; (1b860 <vOpenFiles+0x384>)
   1b806:	0018      	movs	r0, r3
   1b808:	4b1b      	ldr	r3, [pc, #108]	; (1b878 <vOpenFiles+0x39c>)
   1b80a:	4798      	blx	r3
	}
	
	result=f_open(&file_object,"0:/TagList.bin",FA_READ);
   1b80c:	1d3c      	adds	r4, r7, #4
   1b80e:	4925      	ldr	r1, [pc, #148]	; (1b8a4 <vOpenFiles+0x3c8>)
   1b810:	4b13      	ldr	r3, [pc, #76]	; (1b860 <vOpenFiles+0x384>)
   1b812:	2201      	movs	r2, #1
   1b814:	0018      	movs	r0, r3
   1b816:	4b13      	ldr	r3, [pc, #76]	; (1b864 <vOpenFiles+0x388>)
   1b818:	4798      	blx	r3
   1b81a:	0003      	movs	r3, r0
   1b81c:	7023      	strb	r3, [r4, #0]
	if (result!=RES_OK)
   1b81e:	1d3b      	adds	r3, r7, #4
   1b820:	781b      	ldrb	r3, [r3, #0]
   1b822:	2b00      	cmp	r3, #0
   1b824:	d042      	beq.n	1b8ac <vOpenFiles+0x3d0>
	{
		f_open(&file_object,"0:/TagList.bin",FA_CREATE_ALWAYS | FA_WRITE);
   1b826:	491f      	ldr	r1, [pc, #124]	; (1b8a4 <vOpenFiles+0x3c8>)
   1b828:	4b0d      	ldr	r3, [pc, #52]	; (1b860 <vOpenFiles+0x384>)
   1b82a:	220a      	movs	r2, #10
   1b82c:	0018      	movs	r0, r3
   1b82e:	4b0d      	ldr	r3, [pc, #52]	; (1b864 <vOpenFiles+0x388>)
   1b830:	4798      	blx	r3
		memset(&xTags,0x00,sizeof(xTags));
   1b832:	4b1d      	ldr	r3, [pc, #116]	; (1b8a8 <vOpenFiles+0x3cc>)
   1b834:	22b4      	movs	r2, #180	; 0xb4
   1b836:	2100      	movs	r1, #0
   1b838:	0018      	movs	r0, r3
   1b83a:	4b0d      	ldr	r3, [pc, #52]	; (1b870 <vOpenFiles+0x394>)
   1b83c:	4798      	blx	r3
		result=f_write(&file_object,&xTags,sizeof(xTags),&uSize);
   1b83e:	1d3c      	adds	r4, r7, #4
   1b840:	003b      	movs	r3, r7
   1b842:	4919      	ldr	r1, [pc, #100]	; (1b8a8 <vOpenFiles+0x3cc>)
   1b844:	4806      	ldr	r0, [pc, #24]	; (1b860 <vOpenFiles+0x384>)
   1b846:	22b4      	movs	r2, #180	; 0xb4
   1b848:	4d0a      	ldr	r5, [pc, #40]	; (1b874 <vOpenFiles+0x398>)
   1b84a:	47a8      	blx	r5
   1b84c:	0003      	movs	r3, r0
   1b84e:	7023      	strb	r3, [r4, #0]
		f_close(&file_object);
   1b850:	4b03      	ldr	r3, [pc, #12]	; (1b860 <vOpenFiles+0x384>)
   1b852:	0018      	movs	r0, r3
   1b854:	4b08      	ldr	r3, [pc, #32]	; (1b878 <vOpenFiles+0x39c>)
   1b856:	4798      	blx	r3
   1b858:	e032      	b.n	1b8c0 <vOpenFiles+0x3e4>
   1b85a:	46c0      	nop			; (mov r8, r8)
   1b85c:	00021cd8 	.word	0x00021cd8
   1b860:	2000449c 	.word	0x2000449c
   1b864:	00019b09 	.word	0x00019b09
   1b868:	0000023a 	.word	0x0000023a
   1b86c:	200046ec 	.word	0x200046ec
   1b870:	0001eead 	.word	0x0001eead
   1b874:	0001a101 	.word	0x0001a101
   1b878:	0001a595 	.word	0x0001a595
   1b87c:	00019e59 	.word	0x00019e59
   1b880:	00021ce8 	.word	0x00021ce8
   1b884:	20004a78 	.word	0x20004a78
   1b888:	00021cf8 	.word	0x00021cf8
   1b88c:	20003e48 	.word	0x20003e48
   1b890:	00021d08 	.word	0x00021d08
   1b894:	20000054 	.word	0x20000054
   1b898:	0001a5ed 	.word	0x0001a5ed
   1b89c:	00021d18 	.word	0x00021d18
   1b8a0:	20004aa8 	.word	0x20004aa8
   1b8a4:	00021d28 	.word	0x00021d28
   1b8a8:	20004928 	.word	0x20004928
	}
	else
	{
		f_read(&file_object,&xTags,sizeof(xTags),&uSize);
   1b8ac:	003b      	movs	r3, r7
   1b8ae:	4908      	ldr	r1, [pc, #32]	; (1b8d0 <vOpenFiles+0x3f4>)
   1b8b0:	4808      	ldr	r0, [pc, #32]	; (1b8d4 <vOpenFiles+0x3f8>)
   1b8b2:	22b4      	movs	r2, #180	; 0xb4
   1b8b4:	4c08      	ldr	r4, [pc, #32]	; (1b8d8 <vOpenFiles+0x3fc>)
   1b8b6:	47a0      	blx	r4
		f_close(&file_object);
   1b8b8:	4b06      	ldr	r3, [pc, #24]	; (1b8d4 <vOpenFiles+0x3f8>)
   1b8ba:	0018      	movs	r0, r3
   1b8bc:	4b07      	ldr	r3, [pc, #28]	; (1b8dc <vOpenFiles+0x400>)
   1b8be:	4798      	blx	r3
	}
	
	f_mkdir("Logs");
   1b8c0:	4b07      	ldr	r3, [pc, #28]	; (1b8e0 <vOpenFiles+0x404>)
   1b8c2:	0018      	movs	r0, r3
   1b8c4:	4b07      	ldr	r3, [pc, #28]	; (1b8e4 <vOpenFiles+0x408>)
   1b8c6:	4798      	blx	r3
	
}
   1b8c8:	46c0      	nop			; (mov r8, r8)
   1b8ca:	46bd      	mov	sp, r7
   1b8cc:	b002      	add	sp, #8
   1b8ce:	bdb0      	pop	{r4, r5, r7, pc}
   1b8d0:	20004928 	.word	0x20004928
   1b8d4:	2000449c 	.word	0x2000449c
   1b8d8:	00019e59 	.word	0x00019e59
   1b8dc:	0001a595 	.word	0x0001a595
   1b8e0:	00021d38 	.word	0x00021d38
   1b8e4:	0001aa55 	.word	0x0001aa55

0001b8e8 <vMainScreen>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void vMainScreen(uint16_t counter,struct rtc_calendar_time *ptime)
{   //unsigned char ucPixels=((unsigned short)40*perc)/100;
   1b8e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b8ea:	b08d      	sub	sp, #52	; 0x34
   1b8ec:	af06      	add	r7, sp, #24
   1b8ee:	0002      	movs	r2, r0
   1b8f0:	60b9      	str	r1, [r7, #8]
   1b8f2:	230e      	movs	r3, #14
   1b8f4:	18fb      	adds	r3, r7, r3
   1b8f6:	801a      	strh	r2, [r3, #0]
	unsigned char ucPixels=counter % (16*5+1);
   1b8f8:	230e      	movs	r3, #14
   1b8fa:	18fb      	adds	r3, r7, r3
   1b8fc:	881a      	ldrh	r2, [r3, #0]
   1b8fe:	4b51      	ldr	r3, [pc, #324]	; (1ba44 <vMainScreen+0x15c>)
   1b900:	2151      	movs	r1, #81	; 0x51
   1b902:	0010      	movs	r0, r2
   1b904:	4798      	blx	r3
   1b906:	000b      	movs	r3, r1
   1b908:	b29a      	uxth	r2, r3
   1b90a:	230f      	movs	r3, #15
   1b90c:	2108      	movs	r1, #8
   1b90e:	468c      	mov	ip, r1
   1b910:	44bc      	add	ip, r7
   1b912:	4463      	add	r3, ip
   1b914:	701a      	strb	r2, [r3, #0]
	unsigned char ucBOX=ucPixels/5;
   1b916:	230e      	movs	r3, #14
   1b918:	2208      	movs	r2, #8
   1b91a:	18ba      	adds	r2, r7, r2
   1b91c:	18d4      	adds	r4, r2, r3
   1b91e:	230f      	movs	r3, #15
   1b920:	2208      	movs	r2, #8
   1b922:	4694      	mov	ip, r2
   1b924:	44bc      	add	ip, r7
   1b926:	4463      	add	r3, ip
   1b928:	781a      	ldrb	r2, [r3, #0]
   1b92a:	4b47      	ldr	r3, [pc, #284]	; (1ba48 <vMainScreen+0x160>)
   1b92c:	2105      	movs	r1, #5
   1b92e:	0010      	movs	r0, r2
   1b930:	4798      	blx	r3
   1b932:	0003      	movs	r3, r0
   1b934:	7023      	strb	r3, [r4, #0]
	unsigned char ucFract=ucPixels%5;
   1b936:	230d      	movs	r3, #13
   1b938:	2208      	movs	r2, #8
   1b93a:	18ba      	adds	r2, r7, r2
   1b93c:	18d4      	adds	r4, r2, r3
   1b93e:	230f      	movs	r3, #15
   1b940:	2208      	movs	r2, #8
   1b942:	4694      	mov	ip, r2
   1b944:	44bc      	add	ip, r7
   1b946:	4463      	add	r3, ip
   1b948:	781a      	ldrb	r2, [r3, #0]
   1b94a:	4b3e      	ldr	r3, [pc, #248]	; (1ba44 <vMainScreen+0x15c>)
   1b94c:	2105      	movs	r1, #5
   1b94e:	0010      	movs	r0, r2
   1b950:	4798      	blx	r3
   1b952:	000b      	movs	r3, r1
   1b954:	7023      	strb	r3, [r4, #0]
	
    memset(LCDData,0x00,sizeof(LCDData));
   1b956:	4b3d      	ldr	r3, [pc, #244]	; (1ba4c <vMainScreen+0x164>)
   1b958:	2222      	movs	r2, #34	; 0x22
   1b95a:	2100      	movs	r1, #0
   1b95c:	0018      	movs	r0, r3
   1b95e:	4b3c      	ldr	r3, [pc, #240]	; (1ba50 <vMainScreen+0x168>)
   1b960:	4798      	blx	r3
	//ptime->minute,ptime->day,ptime->month,ptime->year-2000,WDay[ptime->weekday]);
	
	//sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
	//ptime->minute,ptime->second,ptime->month,ptime->year-2000,WDay[ptime->weekday]);

	sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
   1b962:	68bb      	ldr	r3, [r7, #8]
   1b964:	789b      	ldrb	r3, [r3, #2]
   1b966:	607b      	str	r3, [r7, #4]
   1b968:	68bb      	ldr	r3, [r7, #8]
   1b96a:	781b      	ldrb	r3, [r3, #0]
   1b96c:	001a      	movs	r2, r3
   1b96e:	2301      	movs	r3, #1
   1b970:	4013      	ands	r3, r2
   1b972:	d001      	beq.n	1b978 <vMainScreen+0x90>
   1b974:	2120      	movs	r1, #32
   1b976:	e000      	b.n	1b97a <vMainScreen+0x92>
   1b978:	213a      	movs	r1, #58	; 0x3a
	ptime->minute,ptime->second,ptime->month,ptime->year-2000,(xValidTAG) ? 'T' : ' ');
   1b97a:	68bb      	ldr	r3, [r7, #8]
   1b97c:	785b      	ldrb	r3, [r3, #1]
	//ptime->minute,ptime->day,ptime->month,ptime->year-2000,WDay[ptime->weekday]);
	
	//sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
	//ptime->minute,ptime->second,ptime->month,ptime->year-2000,WDay[ptime->weekday]);

	sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
   1b97e:	001d      	movs	r5, r3
	ptime->minute,ptime->second,ptime->month,ptime->year-2000,(xValidTAG) ? 'T' : ' ');
   1b980:	68bb      	ldr	r3, [r7, #8]
   1b982:	781b      	ldrb	r3, [r3, #0]
	//ptime->minute,ptime->day,ptime->month,ptime->year-2000,WDay[ptime->weekday]);
	
	//sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
	//ptime->minute,ptime->second,ptime->month,ptime->year-2000,WDay[ptime->weekday]);

	sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
   1b984:	001e      	movs	r6, r3
	ptime->minute,ptime->second,ptime->month,ptime->year-2000,(xValidTAG) ? 'T' : ' ');
   1b986:	68bb      	ldr	r3, [r7, #8]
   1b988:	795b      	ldrb	r3, [r3, #5]
	//ptime->minute,ptime->day,ptime->month,ptime->year-2000,WDay[ptime->weekday]);
	
	//sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
	//ptime->minute,ptime->second,ptime->month,ptime->year-2000,WDay[ptime->weekday]);

	sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
   1b98a:	469c      	mov	ip, r3
	ptime->minute,ptime->second,ptime->month,ptime->year-2000,(xValidTAG) ? 'T' : ' ');
   1b98c:	68bb      	ldr	r3, [r7, #8]
   1b98e:	88db      	ldrh	r3, [r3, #6]
	//ptime->minute,ptime->day,ptime->month,ptime->year-2000,WDay[ptime->weekday]);
	
	//sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
	//ptime->minute,ptime->second,ptime->month,ptime->year-2000,WDay[ptime->weekday]);

	sprintf(LCDData[0],LCDlabels[2],ptime->hour,(ptime->second & 0x01) ? ' ' : ':',
   1b990:	4a30      	ldr	r2, [pc, #192]	; (1ba54 <vMainScreen+0x16c>)
   1b992:	189a      	adds	r2, r3, r2
   1b994:	4b30      	ldr	r3, [pc, #192]	; (1ba58 <vMainScreen+0x170>)
   1b996:	781b      	ldrb	r3, [r3, #0]
   1b998:	2b00      	cmp	r3, #0
   1b99a:	d001      	beq.n	1b9a0 <vMainScreen+0xb8>
   1b99c:	2354      	movs	r3, #84	; 0x54
   1b99e:	e000      	b.n	1b9a2 <vMainScreen+0xba>
   1b9a0:	2320      	movs	r3, #32
   1b9a2:	4c2e      	ldr	r4, [pc, #184]	; (1ba5c <vMainScreen+0x174>)
   1b9a4:	4829      	ldr	r0, [pc, #164]	; (1ba4c <vMainScreen+0x164>)
   1b9a6:	9304      	str	r3, [sp, #16]
   1b9a8:	9203      	str	r2, [sp, #12]
   1b9aa:	4663      	mov	r3, ip
   1b9ac:	9302      	str	r3, [sp, #8]
   1b9ae:	9601      	str	r6, [sp, #4]
   1b9b0:	9500      	str	r5, [sp, #0]
   1b9b2:	000b      	movs	r3, r1
   1b9b4:	687a      	ldr	r2, [r7, #4]
   1b9b6:	0021      	movs	r1, r4
   1b9b8:	4c29      	ldr	r4, [pc, #164]	; (1ba60 <vMainScreen+0x178>)
   1b9ba:	47a0      	blx	r4
	//if ((!((uint16_t)T)) && (!((uint16_t)(T*10)%10)))
	//{
	 //return;	
	//}
	
	sprintf(LCDData[1],LCDlabels[3],(uint16_t)H,((uint16_t)(H*10))%10,(uint16_t)T,((uint16_t)(T*10))%10);
   1b9bc:	4b29      	ldr	r3, [pc, #164]	; (1ba64 <vMainScreen+0x17c>)
   1b9be:	681a      	ldr	r2, [r3, #0]
   1b9c0:	4b29      	ldr	r3, [pc, #164]	; (1ba68 <vMainScreen+0x180>)
   1b9c2:	1c10      	adds	r0, r2, #0
   1b9c4:	4798      	blx	r3
   1b9c6:	0003      	movs	r3, r0
   1b9c8:	b29b      	uxth	r3, r3
   1b9ca:	001d      	movs	r5, r3
   1b9cc:	4b25      	ldr	r3, [pc, #148]	; (1ba64 <vMainScreen+0x17c>)
   1b9ce:	681a      	ldr	r2, [r3, #0]
   1b9d0:	4b26      	ldr	r3, [pc, #152]	; (1ba6c <vMainScreen+0x184>)
   1b9d2:	4927      	ldr	r1, [pc, #156]	; (1ba70 <vMainScreen+0x188>)
   1b9d4:	1c10      	adds	r0, r2, #0
   1b9d6:	4798      	blx	r3
   1b9d8:	1c03      	adds	r3, r0, #0
   1b9da:	1c1a      	adds	r2, r3, #0
   1b9dc:	4b22      	ldr	r3, [pc, #136]	; (1ba68 <vMainScreen+0x180>)
   1b9de:	1c10      	adds	r0, r2, #0
   1b9e0:	4798      	blx	r3
   1b9e2:	0003      	movs	r3, r0
   1b9e4:	b29a      	uxth	r2, r3
   1b9e6:	4b17      	ldr	r3, [pc, #92]	; (1ba44 <vMainScreen+0x15c>)
   1b9e8:	210a      	movs	r1, #10
   1b9ea:	0010      	movs	r0, r2
   1b9ec:	4798      	blx	r3
   1b9ee:	000b      	movs	r3, r1
   1b9f0:	b29b      	uxth	r3, r3
   1b9f2:	001e      	movs	r6, r3
   1b9f4:	4b1f      	ldr	r3, [pc, #124]	; (1ba74 <vMainScreen+0x18c>)
   1b9f6:	681a      	ldr	r2, [r3, #0]
   1b9f8:	4b1b      	ldr	r3, [pc, #108]	; (1ba68 <vMainScreen+0x180>)
   1b9fa:	1c10      	adds	r0, r2, #0
   1b9fc:	4798      	blx	r3
   1b9fe:	0003      	movs	r3, r0
   1ba00:	b29b      	uxth	r3, r3
   1ba02:	001c      	movs	r4, r3
   1ba04:	4b1b      	ldr	r3, [pc, #108]	; (1ba74 <vMainScreen+0x18c>)
   1ba06:	681a      	ldr	r2, [r3, #0]
   1ba08:	4b18      	ldr	r3, [pc, #96]	; (1ba6c <vMainScreen+0x184>)
   1ba0a:	4919      	ldr	r1, [pc, #100]	; (1ba70 <vMainScreen+0x188>)
   1ba0c:	1c10      	adds	r0, r2, #0
   1ba0e:	4798      	blx	r3
   1ba10:	1c03      	adds	r3, r0, #0
   1ba12:	1c1a      	adds	r2, r3, #0
   1ba14:	4b14      	ldr	r3, [pc, #80]	; (1ba68 <vMainScreen+0x180>)
   1ba16:	1c10      	adds	r0, r2, #0
   1ba18:	4798      	blx	r3
   1ba1a:	0003      	movs	r3, r0
   1ba1c:	b29a      	uxth	r2, r3
   1ba1e:	4b09      	ldr	r3, [pc, #36]	; (1ba44 <vMainScreen+0x15c>)
   1ba20:	210a      	movs	r1, #10
   1ba22:	0010      	movs	r0, r2
   1ba24:	4798      	blx	r3
   1ba26:	000b      	movs	r3, r1
   1ba28:	b29b      	uxth	r3, r3
   1ba2a:	4913      	ldr	r1, [pc, #76]	; (1ba78 <vMainScreen+0x190>)
   1ba2c:	4813      	ldr	r0, [pc, #76]	; (1ba7c <vMainScreen+0x194>)
   1ba2e:	9301      	str	r3, [sp, #4]
   1ba30:	9400      	str	r4, [sp, #0]
   1ba32:	0033      	movs	r3, r6
   1ba34:	002a      	movs	r2, r5
   1ba36:	4c0a      	ldr	r4, [pc, #40]	; (1ba60 <vMainScreen+0x178>)
   1ba38:	47a0      	blx	r4
}
   1ba3a:	46c0      	nop			; (mov r8, r8)
   1ba3c:	46bd      	mov	sp, r7
   1ba3e:	b007      	add	sp, #28
   1ba40:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1ba42:	46c0      	nop			; (mov r8, r8)
   1ba44:	0001d591 	.word	0x0001d591
   1ba48:	0001d485 	.word	0x0001d485
   1ba4c:	20004aac 	.word	0x20004aac
   1ba50:	0001eead 	.word	0x0001eead
   1ba54:	fffff830 	.word	0xfffff830
   1ba58:	20004a24 	.word	0x20004a24
   1ba5c:	20000094 	.word	0x20000094
   1ba60:	0001f4a9 	.word	0x0001f4a9
   1ba64:	20004de4 	.word	0x20004de4
   1ba68:	0001d809 	.word	0x0001d809
   1ba6c:	0001dca5 	.word	0x0001dca5
   1ba70:	41200000 	.word	0x41200000
   1ba74:	20004be0 	.word	0x20004be0
   1ba78:	200000b4 	.word	0x200000b4
   1ba7c:	20004abd 	.word	0x20004abd

0001ba80 <vPrgScreen>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void vPrgScreen(uint8_t perc)
{   unsigned char ucPixels=((unsigned short)35*perc)/100+1;
   1ba80:	b590      	push	{r4, r7, lr}
   1ba82:	b08f      	sub	sp, #60	; 0x3c
   1ba84:	af02      	add	r7, sp, #8
   1ba86:	0002      	movs	r2, r0
   1ba88:	1dfb      	adds	r3, r7, #7
   1ba8a:	701a      	strb	r2, [r3, #0]
   1ba8c:	1dfb      	adds	r3, r7, #7
   1ba8e:	781a      	ldrb	r2, [r3, #0]
   1ba90:	0013      	movs	r3, r2
   1ba92:	009b      	lsls	r3, r3, #2
   1ba94:	189b      	adds	r3, r3, r2
   1ba96:	00da      	lsls	r2, r3, #3
   1ba98:	1ad2      	subs	r2, r2, r3
   1ba9a:	4beb      	ldr	r3, [pc, #940]	; (1be48 <vPrgScreen+0x3c8>)
   1ba9c:	2164      	movs	r1, #100	; 0x64
   1ba9e:	0010      	movs	r0, r2
   1baa0:	4798      	blx	r3
   1baa2:	0003      	movs	r3, r0
   1baa4:	b2da      	uxtb	r2, r3
   1baa6:	232e      	movs	r3, #46	; 0x2e
   1baa8:	18fb      	adds	r3, r7, r3
   1baaa:	3201      	adds	r2, #1
   1baac:	701a      	strb	r2, [r3, #0]
	//unsigned char ucPixels=counter % (16*5+1);
	unsigned char ucBOX=ucPixels/5;
   1baae:	232d      	movs	r3, #45	; 0x2d
   1bab0:	18fc      	adds	r4, r7, r3
   1bab2:	232e      	movs	r3, #46	; 0x2e
   1bab4:	18fb      	adds	r3, r7, r3
   1bab6:	781a      	ldrb	r2, [r3, #0]
   1bab8:	4be4      	ldr	r3, [pc, #912]	; (1be4c <vPrgScreen+0x3cc>)
   1baba:	2105      	movs	r1, #5
   1babc:	0010      	movs	r0, r2
   1babe:	4798      	blx	r3
   1bac0:	0003      	movs	r3, r0
   1bac2:	7023      	strb	r3, [r4, #0]
	unsigned char ucFract=ucPixels%5;
   1bac4:	232c      	movs	r3, #44	; 0x2c
   1bac6:	18fc      	adds	r4, r7, r3
   1bac8:	232e      	movs	r3, #46	; 0x2e
   1baca:	18fb      	adds	r3, r7, r3
   1bacc:	781a      	ldrb	r2, [r3, #0]
   1bace:	4be0      	ldr	r3, [pc, #896]	; (1be50 <vPrgScreen+0x3d0>)
   1bad0:	2105      	movs	r1, #5
   1bad2:	0010      	movs	r0, r2
   1bad4:	4798      	blx	r3
   1bad6:	000b      	movs	r3, r1
   1bad8:	7023      	strb	r3, [r4, #0]
	
    memset(LCDData,0x00,sizeof(LCDData));
   1bada:	4bde      	ldr	r3, [pc, #888]	; (1be54 <vPrgScreen+0x3d4>)
   1badc:	2222      	movs	r2, #34	; 0x22
   1bade:	2100      	movs	r1, #0
   1bae0:	0018      	movs	r0, r3
   1bae2:	4bdd      	ldr	r3, [pc, #884]	; (1be58 <vPrgScreen+0x3d8>)
   1bae4:	4798      	blx	r3
	sprintf(LCDData[0],"%s",xProgramList[ucActiveIndex].cPrgName);
   1bae6:	4bdd      	ldr	r3, [pc, #884]	; (1be5c <vPrgScreen+0x3dc>)
   1bae8:	781b      	ldrb	r3, [r3, #0]
   1baea:	001a      	movs	r2, r3
   1baec:	0013      	movs	r3, r2
   1baee:	00db      	lsls	r3, r3, #3
   1baf0:	1a9b      	subs	r3, r3, r2
   1baf2:	00db      	lsls	r3, r3, #3
   1baf4:	189b      	adds	r3, r3, r2
   1baf6:	4ada      	ldr	r2, [pc, #872]	; (1be60 <vPrgScreen+0x3e0>)
   1baf8:	189b      	adds	r3, r3, r2
   1bafa:	1c5a      	adds	r2, r3, #1
   1bafc:	4bd5      	ldr	r3, [pc, #852]	; (1be54 <vPrgScreen+0x3d4>)
   1bafe:	0011      	movs	r1, r2
   1bb00:	0018      	movs	r0, r3
   1bb02:	4bd8      	ldr	r3, [pc, #864]	; (1be64 <vPrgScreen+0x3e4>)
   1bb04:	4798      	blx	r3
	
	switch (xProgramSequence)
   1bb06:	4bd8      	ldr	r3, [pc, #864]	; (1be68 <vPrgScreen+0x3e8>)
   1bb08:	781b      	ldrb	r3, [r3, #0]
   1bb0a:	2b07      	cmp	r3, #7
   1bb0c:	d900      	bls.n	1bb10 <vPrgScreen+0x90>
   1bb0e:	e162      	b.n	1bdd6 <vPrgScreen+0x356>
   1bb10:	009a      	lsls	r2, r3, #2
   1bb12:	4bd6      	ldr	r3, [pc, #856]	; (1be6c <vPrgScreen+0x3ec>)
   1bb14:	18d3      	adds	r3, r2, r3
   1bb16:	681b      	ldr	r3, [r3, #0]
   1bb18:	469f      	mov	pc, r3
	{	
	 case TS:
	 {
      time_t xResTime=xProgramList[ucActiveIndex].usTs-xElapTime;
   1bb1a:	4bd0      	ldr	r3, [pc, #832]	; (1be5c <vPrgScreen+0x3dc>)
   1bb1c:	781b      	ldrb	r3, [r3, #0]
   1bb1e:	001a      	movs	r2, r3
   1bb20:	49cf      	ldr	r1, [pc, #828]	; (1be60 <vPrgScreen+0x3e0>)
   1bb22:	0013      	movs	r3, r2
   1bb24:	00db      	lsls	r3, r3, #3
   1bb26:	1a9b      	subs	r3, r3, r2
   1bb28:	00db      	lsls	r3, r3, #3
   1bb2a:	189b      	adds	r3, r3, r2
   1bb2c:	18cb      	adds	r3, r1, r3
   1bb2e:	3310      	adds	r3, #16
   1bb30:	795a      	ldrb	r2, [r3, #5]
   1bb32:	799b      	ldrb	r3, [r3, #6]
   1bb34:	021b      	lsls	r3, r3, #8
   1bb36:	4313      	orrs	r3, r2
   1bb38:	b29b      	uxth	r3, r3
   1bb3a:	001a      	movs	r2, r3
   1bb3c:	4bcc      	ldr	r3, [pc, #816]	; (1be70 <vPrgScreen+0x3f0>)
   1bb3e:	681b      	ldr	r3, [r3, #0]
   1bb40:	1ad3      	subs	r3, r2, r3
   1bb42:	62bb      	str	r3, [r7, #40]	; 0x28
      sprintf(&LCDData[1][0],"%02d:%02d %s",(uint16_t)xResTime/60,(uint16_t)xResTime%60,"Ts"); 
   1bb44:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1bb46:	041b      	lsls	r3, r3, #16
   1bb48:	0c1a      	lsrs	r2, r3, #16
   1bb4a:	4bbf      	ldr	r3, [pc, #764]	; (1be48 <vPrgScreen+0x3c8>)
   1bb4c:	213c      	movs	r1, #60	; 0x3c
   1bb4e:	0010      	movs	r0, r2
   1bb50:	4798      	blx	r3
   1bb52:	0003      	movs	r3, r0
   1bb54:	001c      	movs	r4, r3
   1bb56:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1bb58:	041b      	lsls	r3, r3, #16
   1bb5a:	0c1a      	lsrs	r2, r3, #16
   1bb5c:	4bc5      	ldr	r3, [pc, #788]	; (1be74 <vPrgScreen+0x3f4>)
   1bb5e:	213c      	movs	r1, #60	; 0x3c
   1bb60:	0010      	movs	r0, r2
   1bb62:	4798      	blx	r3
   1bb64:	000b      	movs	r3, r1
   1bb66:	001a      	movs	r2, r3
   1bb68:	49c3      	ldr	r1, [pc, #780]	; (1be78 <vPrgScreen+0x3f8>)
   1bb6a:	48c4      	ldr	r0, [pc, #784]	; (1be7c <vPrgScreen+0x3fc>)
   1bb6c:	4bc4      	ldr	r3, [pc, #784]	; (1be80 <vPrgScreen+0x400>)
   1bb6e:	9300      	str	r3, [sp, #0]
   1bb70:	0013      	movs	r3, r2
   1bb72:	0022      	movs	r2, r4
   1bb74:	4cc3      	ldr	r4, [pc, #780]	; (1be84 <vPrgScreen+0x404>)
   1bb76:	47a0      	blx	r4
	 }
	 break; 
   1bb78:	e12e      	b.n	1bdd8 <vPrgScreen+0x358>
	 case TI:
	 {
      time_t xResTime=xProgramList[ucActiveIndex].usTi-xElapTime;
   1bb7a:	4bb8      	ldr	r3, [pc, #736]	; (1be5c <vPrgScreen+0x3dc>)
   1bb7c:	781b      	ldrb	r3, [r3, #0]
   1bb7e:	001a      	movs	r2, r3
   1bb80:	49b7      	ldr	r1, [pc, #732]	; (1be60 <vPrgScreen+0x3e0>)
   1bb82:	0013      	movs	r3, r2
   1bb84:	00db      	lsls	r3, r3, #3
   1bb86:	1a9b      	subs	r3, r3, r2
   1bb88:	00db      	lsls	r3, r3, #3
   1bb8a:	189b      	adds	r3, r3, r2
   1bb8c:	18cb      	adds	r3, r1, r3
   1bb8e:	3310      	adds	r3, #16
   1bb90:	79da      	ldrb	r2, [r3, #7]
   1bb92:	7a1b      	ldrb	r3, [r3, #8]
   1bb94:	021b      	lsls	r3, r3, #8
   1bb96:	4313      	orrs	r3, r2
   1bb98:	b29b      	uxth	r3, r3
   1bb9a:	001a      	movs	r2, r3
   1bb9c:	4bb4      	ldr	r3, [pc, #720]	; (1be70 <vPrgScreen+0x3f0>)
   1bb9e:	681b      	ldr	r3, [r3, #0]
   1bba0:	1ad3      	subs	r3, r2, r3
   1bba2:	627b      	str	r3, [r7, #36]	; 0x24
      sprintf(&LCDData[1][0],"%02d:%02d %s",(uint16_t)xResTime/60,(uint16_t)xResTime%60,"Ti"); 
   1bba4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1bba6:	041b      	lsls	r3, r3, #16
   1bba8:	0c1a      	lsrs	r2, r3, #16
   1bbaa:	4ba7      	ldr	r3, [pc, #668]	; (1be48 <vPrgScreen+0x3c8>)
   1bbac:	213c      	movs	r1, #60	; 0x3c
   1bbae:	0010      	movs	r0, r2
   1bbb0:	4798      	blx	r3
   1bbb2:	0003      	movs	r3, r0
   1bbb4:	001c      	movs	r4, r3
   1bbb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1bbb8:	041b      	lsls	r3, r3, #16
   1bbba:	0c1a      	lsrs	r2, r3, #16
   1bbbc:	4bad      	ldr	r3, [pc, #692]	; (1be74 <vPrgScreen+0x3f4>)
   1bbbe:	213c      	movs	r1, #60	; 0x3c
   1bbc0:	0010      	movs	r0, r2
   1bbc2:	4798      	blx	r3
   1bbc4:	000b      	movs	r3, r1
   1bbc6:	001a      	movs	r2, r3
   1bbc8:	49ab      	ldr	r1, [pc, #684]	; (1be78 <vPrgScreen+0x3f8>)
   1bbca:	48ac      	ldr	r0, [pc, #688]	; (1be7c <vPrgScreen+0x3fc>)
   1bbcc:	4bae      	ldr	r3, [pc, #696]	; (1be88 <vPrgScreen+0x408>)
   1bbce:	9300      	str	r3, [sp, #0]
   1bbd0:	0013      	movs	r3, r2
   1bbd2:	0022      	movs	r2, r4
   1bbd4:	4cab      	ldr	r4, [pc, #684]	; (1be84 <vPrgScreen+0x404>)
   1bbd6:	47a0      	blx	r4
	 }
	 break; 
   1bbd8:	e0fe      	b.n	1bdd8 <vPrgScreen+0x358>
	 case TFP:
	 {
      time_t xResTime=xProgramList[ucActiveIndex].usTfp-xElapTime;
   1bbda:	4ba0      	ldr	r3, [pc, #640]	; (1be5c <vPrgScreen+0x3dc>)
   1bbdc:	781b      	ldrb	r3, [r3, #0]
   1bbde:	001a      	movs	r2, r3
   1bbe0:	499f      	ldr	r1, [pc, #636]	; (1be60 <vPrgScreen+0x3e0>)
   1bbe2:	0013      	movs	r3, r2
   1bbe4:	00db      	lsls	r3, r3, #3
   1bbe6:	1a9b      	subs	r3, r3, r2
   1bbe8:	00db      	lsls	r3, r3, #3
   1bbea:	189b      	adds	r3, r3, r2
   1bbec:	18cb      	adds	r3, r1, r3
   1bbee:	3318      	adds	r3, #24
   1bbf0:	785a      	ldrb	r2, [r3, #1]
   1bbf2:	789b      	ldrb	r3, [r3, #2]
   1bbf4:	021b      	lsls	r3, r3, #8
   1bbf6:	4313      	orrs	r3, r2
   1bbf8:	b29b      	uxth	r3, r3
   1bbfa:	001a      	movs	r2, r3
   1bbfc:	4b9c      	ldr	r3, [pc, #624]	; (1be70 <vPrgScreen+0x3f0>)
   1bbfe:	681b      	ldr	r3, [r3, #0]
   1bc00:	1ad3      	subs	r3, r2, r3
   1bc02:	623b      	str	r3, [r7, #32]
	  memset (LCDData,0x00,sizeof(LCDData));
   1bc04:	4b93      	ldr	r3, [pc, #588]	; (1be54 <vPrgScreen+0x3d4>)
   1bc06:	2222      	movs	r2, #34	; 0x22
   1bc08:	2100      	movs	r1, #0
   1bc0a:	0018      	movs	r0, r3
   1bc0c:	4b92      	ldr	r3, [pc, #584]	; (1be58 <vPrgScreen+0x3d8>)
   1bc0e:	4798      	blx	r3
	  sprintf(LCDData[0],"%s",LCDlabels[4]);
   1bc10:	4a9e      	ldr	r2, [pc, #632]	; (1be8c <vPrgScreen+0x40c>)
   1bc12:	4b90      	ldr	r3, [pc, #576]	; (1be54 <vPrgScreen+0x3d4>)
   1bc14:	0011      	movs	r1, r2
   1bc16:	0018      	movs	r0, r3
   1bc18:	4b92      	ldr	r3, [pc, #584]	; (1be64 <vPrgScreen+0x3e4>)
   1bc1a:	4798      	blx	r3
      sprintf(&LCDData[1][0],"%02d:%02d %s",(uint16_t)xResTime/60,(uint16_t)xResTime%60,"Tf"); 
   1bc1c:	6a3b      	ldr	r3, [r7, #32]
   1bc1e:	041b      	lsls	r3, r3, #16
   1bc20:	0c1a      	lsrs	r2, r3, #16
   1bc22:	4b89      	ldr	r3, [pc, #548]	; (1be48 <vPrgScreen+0x3c8>)
   1bc24:	213c      	movs	r1, #60	; 0x3c
   1bc26:	0010      	movs	r0, r2
   1bc28:	4798      	blx	r3
   1bc2a:	0003      	movs	r3, r0
   1bc2c:	001c      	movs	r4, r3
   1bc2e:	6a3b      	ldr	r3, [r7, #32]
   1bc30:	041b      	lsls	r3, r3, #16
   1bc32:	0c1a      	lsrs	r2, r3, #16
   1bc34:	4b8f      	ldr	r3, [pc, #572]	; (1be74 <vPrgScreen+0x3f4>)
   1bc36:	213c      	movs	r1, #60	; 0x3c
   1bc38:	0010      	movs	r0, r2
   1bc3a:	4798      	blx	r3
   1bc3c:	000b      	movs	r3, r1
   1bc3e:	001a      	movs	r2, r3
   1bc40:	498d      	ldr	r1, [pc, #564]	; (1be78 <vPrgScreen+0x3f8>)
   1bc42:	488e      	ldr	r0, [pc, #568]	; (1be7c <vPrgScreen+0x3fc>)
   1bc44:	4b92      	ldr	r3, [pc, #584]	; (1be90 <vPrgScreen+0x410>)
   1bc46:	9300      	str	r3, [sp, #0]
   1bc48:	0013      	movs	r3, r2
   1bc4a:	0022      	movs	r2, r4
   1bc4c:	4c8d      	ldr	r4, [pc, #564]	; (1be84 <vPrgScreen+0x404>)
   1bc4e:	47a0      	blx	r4
	 }
	 break; 
   1bc50:	e0c2      	b.n	1bdd8 <vPrgScreen+0x358>
	 case TP:
	 {
      time_t xResTime=xProgramList[ucActiveIndex].usTp-xElapTime;
   1bc52:	4b82      	ldr	r3, [pc, #520]	; (1be5c <vPrgScreen+0x3dc>)
   1bc54:	781b      	ldrb	r3, [r3, #0]
   1bc56:	001a      	movs	r2, r3
   1bc58:	4981      	ldr	r1, [pc, #516]	; (1be60 <vPrgScreen+0x3e0>)
   1bc5a:	0013      	movs	r3, r2
   1bc5c:	00db      	lsls	r3, r3, #3
   1bc5e:	1a9b      	subs	r3, r3, r2
   1bc60:	00db      	lsls	r3, r3, #3
   1bc62:	189b      	adds	r3, r3, r2
   1bc64:	18cb      	adds	r3, r1, r3
   1bc66:	3318      	adds	r3, #24
   1bc68:	78da      	ldrb	r2, [r3, #3]
   1bc6a:	791b      	ldrb	r3, [r3, #4]
   1bc6c:	021b      	lsls	r3, r3, #8
   1bc6e:	4313      	orrs	r3, r2
   1bc70:	b29b      	uxth	r3, r3
   1bc72:	001a      	movs	r2, r3
   1bc74:	4b7e      	ldr	r3, [pc, #504]	; (1be70 <vPrgScreen+0x3f0>)
   1bc76:	681b      	ldr	r3, [r3, #0]
   1bc78:	1ad3      	subs	r3, r2, r3
   1bc7a:	61fb      	str	r3, [r7, #28]
      sprintf(&LCDData[1][0],"%02d:%02d %s",(uint16_t)xResTime/60,(uint16_t)xResTime%60,"Tp"); 
   1bc7c:	69fb      	ldr	r3, [r7, #28]
   1bc7e:	041b      	lsls	r3, r3, #16
   1bc80:	0c1a      	lsrs	r2, r3, #16
   1bc82:	4b71      	ldr	r3, [pc, #452]	; (1be48 <vPrgScreen+0x3c8>)
   1bc84:	213c      	movs	r1, #60	; 0x3c
   1bc86:	0010      	movs	r0, r2
   1bc88:	4798      	blx	r3
   1bc8a:	0003      	movs	r3, r0
   1bc8c:	001c      	movs	r4, r3
   1bc8e:	69fb      	ldr	r3, [r7, #28]
   1bc90:	041b      	lsls	r3, r3, #16
   1bc92:	0c1a      	lsrs	r2, r3, #16
   1bc94:	4b77      	ldr	r3, [pc, #476]	; (1be74 <vPrgScreen+0x3f4>)
   1bc96:	213c      	movs	r1, #60	; 0x3c
   1bc98:	0010      	movs	r0, r2
   1bc9a:	4798      	blx	r3
   1bc9c:	000b      	movs	r3, r1
   1bc9e:	001a      	movs	r2, r3
   1bca0:	4975      	ldr	r1, [pc, #468]	; (1be78 <vPrgScreen+0x3f8>)
   1bca2:	4876      	ldr	r0, [pc, #472]	; (1be7c <vPrgScreen+0x3fc>)
   1bca4:	4b7b      	ldr	r3, [pc, #492]	; (1be94 <vPrgScreen+0x414>)
   1bca6:	9300      	str	r3, [sp, #0]
   1bca8:	0013      	movs	r3, r2
   1bcaa:	0022      	movs	r2, r4
   1bcac:	4c75      	ldr	r4, [pc, #468]	; (1be84 <vPrgScreen+0x404>)
   1bcae:	47a0      	blx	r4
	 }
	 break; 
   1bcb0:	e092      	b.n	1bdd8 <vPrgScreen+0x358>
	 case TA:
	 {
		 time_t xResTime=xProgramList[ucActiveIndex].usTa-xElapTime;
   1bcb2:	4b6a      	ldr	r3, [pc, #424]	; (1be5c <vPrgScreen+0x3dc>)
   1bcb4:	781b      	ldrb	r3, [r3, #0]
   1bcb6:	001a      	movs	r2, r3
   1bcb8:	4969      	ldr	r1, [pc, #420]	; (1be60 <vPrgScreen+0x3e0>)
   1bcba:	0013      	movs	r3, r2
   1bcbc:	00db      	lsls	r3, r3, #3
   1bcbe:	1a9b      	subs	r3, r3, r2
   1bcc0:	00db      	lsls	r3, r3, #3
   1bcc2:	189b      	adds	r3, r3, r2
   1bcc4:	18cb      	adds	r3, r1, r3
   1bcc6:	3318      	adds	r3, #24
   1bcc8:	79da      	ldrb	r2, [r3, #7]
   1bcca:	7a1b      	ldrb	r3, [r3, #8]
   1bccc:	021b      	lsls	r3, r3, #8
   1bcce:	4313      	orrs	r3, r2
   1bcd0:	b29b      	uxth	r3, r3
   1bcd2:	001a      	movs	r2, r3
   1bcd4:	4b66      	ldr	r3, [pc, #408]	; (1be70 <vPrgScreen+0x3f0>)
   1bcd6:	681b      	ldr	r3, [r3, #0]
   1bcd8:	1ad3      	subs	r3, r2, r3
   1bcda:	61bb      	str	r3, [r7, #24]
		 sprintf(&LCDData[1][0],"%02d:%02d %s",(uint16_t)xResTime/60,(uint16_t)xResTime%60,"Ta");
   1bcdc:	69bb      	ldr	r3, [r7, #24]
   1bcde:	041b      	lsls	r3, r3, #16
   1bce0:	0c1a      	lsrs	r2, r3, #16
   1bce2:	4b59      	ldr	r3, [pc, #356]	; (1be48 <vPrgScreen+0x3c8>)
   1bce4:	213c      	movs	r1, #60	; 0x3c
   1bce6:	0010      	movs	r0, r2
   1bce8:	4798      	blx	r3
   1bcea:	0003      	movs	r3, r0
   1bcec:	001c      	movs	r4, r3
   1bcee:	69bb      	ldr	r3, [r7, #24]
   1bcf0:	041b      	lsls	r3, r3, #16
   1bcf2:	0c1a      	lsrs	r2, r3, #16
   1bcf4:	4b5f      	ldr	r3, [pc, #380]	; (1be74 <vPrgScreen+0x3f4>)
   1bcf6:	213c      	movs	r1, #60	; 0x3c
   1bcf8:	0010      	movs	r0, r2
   1bcfa:	4798      	blx	r3
   1bcfc:	000b      	movs	r3, r1
   1bcfe:	001a      	movs	r2, r3
   1bd00:	495d      	ldr	r1, [pc, #372]	; (1be78 <vPrgScreen+0x3f8>)
   1bd02:	485e      	ldr	r0, [pc, #376]	; (1be7c <vPrgScreen+0x3fc>)
   1bd04:	4b64      	ldr	r3, [pc, #400]	; (1be98 <vPrgScreen+0x418>)
   1bd06:	9300      	str	r3, [sp, #0]
   1bd08:	0013      	movs	r3, r2
   1bd0a:	0022      	movs	r2, r4
   1bd0c:	4c5d      	ldr	r4, [pc, #372]	; (1be84 <vPrgScreen+0x404>)
   1bd0e:	47a0      	blx	r4
	 }
	 break;
   1bd10:	e062      	b.n	1bdd8 <vPrgScreen+0x358>
	 case TW1:
	 {
		 time_t xResTime=14*60-xElapTime;
   1bd12:	4b57      	ldr	r3, [pc, #348]	; (1be70 <vPrgScreen+0x3f0>)
   1bd14:	681b      	ldr	r3, [r3, #0]
   1bd16:	22d2      	movs	r2, #210	; 0xd2
   1bd18:	0092      	lsls	r2, r2, #2
   1bd1a:	1ad3      	subs	r3, r2, r3
   1bd1c:	617b      	str	r3, [r7, #20]
		 sprintf(&LCDData[1][0],"%02d:%02d %s",(uint16_t)xResTime/60,(uint16_t)xResTime%60,"W1");
   1bd1e:	697b      	ldr	r3, [r7, #20]
   1bd20:	041b      	lsls	r3, r3, #16
   1bd22:	0c1a      	lsrs	r2, r3, #16
   1bd24:	4b48      	ldr	r3, [pc, #288]	; (1be48 <vPrgScreen+0x3c8>)
   1bd26:	213c      	movs	r1, #60	; 0x3c
   1bd28:	0010      	movs	r0, r2
   1bd2a:	4798      	blx	r3
   1bd2c:	0003      	movs	r3, r0
   1bd2e:	001c      	movs	r4, r3
   1bd30:	697b      	ldr	r3, [r7, #20]
   1bd32:	041b      	lsls	r3, r3, #16
   1bd34:	0c1a      	lsrs	r2, r3, #16
   1bd36:	4b4f      	ldr	r3, [pc, #316]	; (1be74 <vPrgScreen+0x3f4>)
   1bd38:	213c      	movs	r1, #60	; 0x3c
   1bd3a:	0010      	movs	r0, r2
   1bd3c:	4798      	blx	r3
   1bd3e:	000b      	movs	r3, r1
   1bd40:	001a      	movs	r2, r3
   1bd42:	494d      	ldr	r1, [pc, #308]	; (1be78 <vPrgScreen+0x3f8>)
   1bd44:	484d      	ldr	r0, [pc, #308]	; (1be7c <vPrgScreen+0x3fc>)
   1bd46:	4b55      	ldr	r3, [pc, #340]	; (1be9c <vPrgScreen+0x41c>)
   1bd48:	9300      	str	r3, [sp, #0]
   1bd4a:	0013      	movs	r3, r2
   1bd4c:	0022      	movs	r2, r4
   1bd4e:	4c4d      	ldr	r4, [pc, #308]	; (1be84 <vPrgScreen+0x404>)
   1bd50:	47a0      	blx	r4
	 }
	 break;
   1bd52:	e041      	b.n	1bdd8 <vPrgScreen+0x358>
	 case TW2:
	 {
		 time_t xResTime=7*60-xElapTime;
   1bd54:	4b46      	ldr	r3, [pc, #280]	; (1be70 <vPrgScreen+0x3f0>)
   1bd56:	681b      	ldr	r3, [r3, #0]
   1bd58:	22d2      	movs	r2, #210	; 0xd2
   1bd5a:	0052      	lsls	r2, r2, #1
   1bd5c:	1ad3      	subs	r3, r2, r3
   1bd5e:	613b      	str	r3, [r7, #16]
		 sprintf(&LCDData[1][0],"%02d:%02d %s",(uint16_t)xResTime/60,(uint16_t)xResTime%60,"W2");
   1bd60:	693b      	ldr	r3, [r7, #16]
   1bd62:	041b      	lsls	r3, r3, #16
   1bd64:	0c1a      	lsrs	r2, r3, #16
   1bd66:	4b38      	ldr	r3, [pc, #224]	; (1be48 <vPrgScreen+0x3c8>)
   1bd68:	213c      	movs	r1, #60	; 0x3c
   1bd6a:	0010      	movs	r0, r2
   1bd6c:	4798      	blx	r3
   1bd6e:	0003      	movs	r3, r0
   1bd70:	001c      	movs	r4, r3
   1bd72:	693b      	ldr	r3, [r7, #16]
   1bd74:	041b      	lsls	r3, r3, #16
   1bd76:	0c1a      	lsrs	r2, r3, #16
   1bd78:	4b3e      	ldr	r3, [pc, #248]	; (1be74 <vPrgScreen+0x3f4>)
   1bd7a:	213c      	movs	r1, #60	; 0x3c
   1bd7c:	0010      	movs	r0, r2
   1bd7e:	4798      	blx	r3
   1bd80:	000b      	movs	r3, r1
   1bd82:	001a      	movs	r2, r3
   1bd84:	493c      	ldr	r1, [pc, #240]	; (1be78 <vPrgScreen+0x3f8>)
   1bd86:	483d      	ldr	r0, [pc, #244]	; (1be7c <vPrgScreen+0x3fc>)
   1bd88:	4b45      	ldr	r3, [pc, #276]	; (1bea0 <vPrgScreen+0x420>)
   1bd8a:	9300      	str	r3, [sp, #0]
   1bd8c:	0013      	movs	r3, r2
   1bd8e:	0022      	movs	r2, r4
   1bd90:	4c3c      	ldr	r4, [pc, #240]	; (1be84 <vPrgScreen+0x404>)
   1bd92:	47a0      	blx	r4
	 }
	 break;
   1bd94:	e020      	b.n	1bdd8 <vPrgScreen+0x358>
	 case TIW:
	 {
		 time_t xResTime=60-xElapTime;
   1bd96:	4b36      	ldr	r3, [pc, #216]	; (1be70 <vPrgScreen+0x3f0>)
   1bd98:	681b      	ldr	r3, [r3, #0]
   1bd9a:	223c      	movs	r2, #60	; 0x3c
   1bd9c:	1ad3      	subs	r3, r2, r3
   1bd9e:	60fb      	str	r3, [r7, #12]
		 sprintf(&LCDData[1][0],"%02d:%02d %s",(uint16_t)xResTime/60,(uint16_t)xResTime%60,"Wi");
   1bda0:	68fb      	ldr	r3, [r7, #12]
   1bda2:	041b      	lsls	r3, r3, #16
   1bda4:	0c1a      	lsrs	r2, r3, #16
   1bda6:	4b28      	ldr	r3, [pc, #160]	; (1be48 <vPrgScreen+0x3c8>)
   1bda8:	213c      	movs	r1, #60	; 0x3c
   1bdaa:	0010      	movs	r0, r2
   1bdac:	4798      	blx	r3
   1bdae:	0003      	movs	r3, r0
   1bdb0:	001c      	movs	r4, r3
   1bdb2:	68fb      	ldr	r3, [r7, #12]
   1bdb4:	041b      	lsls	r3, r3, #16
   1bdb6:	0c1a      	lsrs	r2, r3, #16
   1bdb8:	4b2e      	ldr	r3, [pc, #184]	; (1be74 <vPrgScreen+0x3f4>)
   1bdba:	213c      	movs	r1, #60	; 0x3c
   1bdbc:	0010      	movs	r0, r2
   1bdbe:	4798      	blx	r3
   1bdc0:	000b      	movs	r3, r1
   1bdc2:	001a      	movs	r2, r3
   1bdc4:	492c      	ldr	r1, [pc, #176]	; (1be78 <vPrgScreen+0x3f8>)
   1bdc6:	482d      	ldr	r0, [pc, #180]	; (1be7c <vPrgScreen+0x3fc>)
   1bdc8:	4b36      	ldr	r3, [pc, #216]	; (1bea4 <vPrgScreen+0x424>)
   1bdca:	9300      	str	r3, [sp, #0]
   1bdcc:	0013      	movs	r3, r2
   1bdce:	0022      	movs	r2, r4
   1bdd0:	4c2c      	ldr	r4, [pc, #176]	; (1be84 <vPrgScreen+0x404>)
   1bdd2:	47a0      	blx	r4
	 }
	 break;
   1bdd4:	e000      	b.n	1bdd8 <vPrgScreen+0x358>
	 default: break;
   1bdd6:	46c0      	nop			; (mov r8, r8)
	}
	
	if (ucPixels>35) ucPixels=35;
   1bdd8:	232e      	movs	r3, #46	; 0x2e
   1bdda:	18fb      	adds	r3, r7, r3
   1bddc:	781b      	ldrb	r3, [r3, #0]
   1bdde:	2b23      	cmp	r3, #35	; 0x23
   1bde0:	d903      	bls.n	1bdea <vPrgScreen+0x36a>
   1bde2:	232e      	movs	r3, #46	; 0x2e
   1bde4:	18fb      	adds	r3, r7, r3
   1bde6:	2223      	movs	r2, #35	; 0x23
   1bde8:	701a      	strb	r2, [r3, #0]
	for (uint8_t ucIndex=0x00;ucIndex<ucBOX;ucIndex++)
   1bdea:	232f      	movs	r3, #47	; 0x2f
   1bdec:	18fb      	adds	r3, r7, r3
   1bdee:	2200      	movs	r2, #0
   1bdf0:	701a      	strb	r2, [r3, #0]
   1bdf2:	e00e      	b.n	1be12 <vPrgScreen+0x392>
	LCDData[1][9+ucIndex]=5;
   1bdf4:	232f      	movs	r3, #47	; 0x2f
   1bdf6:	18fb      	adds	r3, r7, r3
   1bdf8:	781b      	ldrb	r3, [r3, #0]
   1bdfa:	3309      	adds	r3, #9
   1bdfc:	4a15      	ldr	r2, [pc, #84]	; (1be54 <vPrgScreen+0x3d4>)
   1bdfe:	18d3      	adds	r3, r2, r3
   1be00:	2205      	movs	r2, #5
   1be02:	745a      	strb	r2, [r3, #17]
	 break;
	 default: break;
	}
	
	if (ucPixels>35) ucPixels=35;
	for (uint8_t ucIndex=0x00;ucIndex<ucBOX;ucIndex++)
   1be04:	232f      	movs	r3, #47	; 0x2f
   1be06:	18fb      	adds	r3, r7, r3
   1be08:	781a      	ldrb	r2, [r3, #0]
   1be0a:	232f      	movs	r3, #47	; 0x2f
   1be0c:	18fb      	adds	r3, r7, r3
   1be0e:	3201      	adds	r2, #1
   1be10:	701a      	strb	r2, [r3, #0]
   1be12:	232f      	movs	r3, #47	; 0x2f
   1be14:	18fa      	adds	r2, r7, r3
   1be16:	232d      	movs	r3, #45	; 0x2d
   1be18:	18fb      	adds	r3, r7, r3
   1be1a:	7812      	ldrb	r2, [r2, #0]
   1be1c:	781b      	ldrb	r3, [r3, #0]
   1be1e:	429a      	cmp	r2, r3
   1be20:	d3e8      	bcc.n	1bdf4 <vPrgScreen+0x374>
	LCDData[1][9+ucIndex]=5;
	if (ucFract) LCDData[1][9+ucBOX]=ucFract;
   1be22:	232c      	movs	r3, #44	; 0x2c
   1be24:	18fb      	adds	r3, r7, r3
   1be26:	781b      	ldrb	r3, [r3, #0]
   1be28:	2b00      	cmp	r3, #0
   1be2a:	d009      	beq.n	1be40 <vPrgScreen+0x3c0>
   1be2c:	232d      	movs	r3, #45	; 0x2d
   1be2e:	18fb      	adds	r3, r7, r3
   1be30:	781b      	ldrb	r3, [r3, #0]
   1be32:	3309      	adds	r3, #9
   1be34:	4a07      	ldr	r2, [pc, #28]	; (1be54 <vPrgScreen+0x3d4>)
   1be36:	18d3      	adds	r3, r2, r3
   1be38:	222c      	movs	r2, #44	; 0x2c
   1be3a:	18ba      	adds	r2, r7, r2
   1be3c:	7812      	ldrb	r2, [r2, #0]
   1be3e:	745a      	strb	r2, [r3, #17]
	

}
   1be40:	46c0      	nop			; (mov r8, r8)
   1be42:	46bd      	mov	sp, r7
   1be44:	b00d      	add	sp, #52	; 0x34
   1be46:	bd90      	pop	{r4, r7, pc}
   1be48:	0001d599 	.word	0x0001d599
   1be4c:	0001d485 	.word	0x0001d485
   1be50:	0001d591 	.word	0x0001d591
   1be54:	20004aac 	.word	0x20004aac
   1be58:	0001eead 	.word	0x0001eead
   1be5c:	20004bd4 	.word	0x20004bd4
   1be60:	200046ec 	.word	0x200046ec
   1be64:	0001f4ed 	.word	0x0001f4ed
   1be68:	20004a72 	.word	0x20004a72
   1be6c:	00021da8 	.word	0x00021da8
   1be70:	20004a60 	.word	0x20004a60
   1be74:	0001d765 	.word	0x0001d765
   1be78:	00021d40 	.word	0x00021d40
   1be7c:	20004abd 	.word	0x20004abd
   1be80:	00021d50 	.word	0x00021d50
   1be84:	0001f4a9 	.word	0x0001f4a9
   1be88:	00021d54 	.word	0x00021d54
   1be8c:	200000d4 	.word	0x200000d4
   1be90:	00021d58 	.word	0x00021d58
   1be94:	00021d5c 	.word	0x00021d5c
   1be98:	00021d60 	.word	0x00021d60
   1be9c:	00021d64 	.word	0x00021d64
   1bea0:	00021d68 	.word	0x00021d68
   1bea4:	00021d6c 	.word	0x00021d6c

0001bea8 <ucSeekLogPos>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static uint8_t ucSeekLogPos(void)
{   time_t OlderLog=LONG_MAX;
   1bea8:	b580      	push	{r7, lr}
   1beaa:	b082      	sub	sp, #8
   1beac:	af00      	add	r7, sp, #0
   1beae:	4b2c      	ldr	r3, [pc, #176]	; (1bf60 <ucSeekLogPos+0xb8>)
   1beb0:	607b      	str	r3, [r7, #4]
	uint8_t ucOlderIndex=0;
   1beb2:	1cfb      	adds	r3, r7, #3
   1beb4:	2200      	movs	r2, #0
   1beb6:	701a      	strb	r2, [r3, #0]
	
	for (uint8_t ucIndex=0x00;ucIndex<MAX_LOGS;ucIndex++)
   1beb8:	1cbb      	adds	r3, r7, #2
   1beba:	2200      	movs	r2, #0
   1bebc:	701a      	strb	r2, [r3, #0]
   1bebe:	e044      	b.n	1bf4a <ucSeekLogPos+0xa2>
	{
	 if (xLogTable[ucIndex].ucPrgIndex==0xFF) return ucIndex;
   1bec0:	1cbb      	adds	r3, r7, #2
   1bec2:	781a      	ldrb	r2, [r3, #0]
   1bec4:	4927      	ldr	r1, [pc, #156]	; (1bf64 <ucSeekLogPos+0xbc>)
   1bec6:	0013      	movs	r3, r2
   1bec8:	009b      	lsls	r3, r3, #2
   1beca:	189b      	adds	r3, r3, r2
   1becc:	005b      	lsls	r3, r3, #1
   1bece:	5c5b      	ldrb	r3, [r3, r1]
   1bed0:	2bff      	cmp	r3, #255	; 0xff
   1bed2:	d102      	bne.n	1beda <ucSeekLogPos+0x32>
   1bed4:	1cbb      	adds	r3, r7, #2
   1bed6:	781b      	ldrb	r3, [r3, #0]
   1bed8:	e03d      	b.n	1bf56 <ucSeekLogPos+0xae>
	 if (xLogTable[ucIndex].xDateTime<OlderLog) 
   1beda:	1cbb      	adds	r3, r7, #2
   1bedc:	7819      	ldrb	r1, [r3, #0]
   1bede:	4a21      	ldr	r2, [pc, #132]	; (1bf64 <ucSeekLogPos+0xbc>)
   1bee0:	000b      	movs	r3, r1
   1bee2:	009b      	lsls	r3, r3, #2
   1bee4:	185b      	adds	r3, r3, r1
   1bee6:	005b      	lsls	r3, r3, #1
   1bee8:	18d1      	adds	r1, r2, r3
   1beea:	7849      	ldrb	r1, [r1, #1]
   1beec:	18d0      	adds	r0, r2, r3
   1beee:	7880      	ldrb	r0, [r0, #2]
   1bef0:	0200      	lsls	r0, r0, #8
   1bef2:	4301      	orrs	r1, r0
   1bef4:	18d0      	adds	r0, r2, r3
   1bef6:	78c0      	ldrb	r0, [r0, #3]
   1bef8:	0400      	lsls	r0, r0, #16
   1befa:	4301      	orrs	r1, r0
   1befc:	18d3      	adds	r3, r2, r3
   1befe:	791b      	ldrb	r3, [r3, #4]
   1bf00:	061b      	lsls	r3, r3, #24
   1bf02:	430b      	orrs	r3, r1
   1bf04:	1e1a      	subs	r2, r3, #0
   1bf06:	687b      	ldr	r3, [r7, #4]
   1bf08:	429a      	cmp	r2, r3
   1bf0a:	da19      	bge.n	1bf40 <ucSeekLogPos+0x98>
	 {
	   OlderLog=xLogTable[ucIndex].xDateTime;
   1bf0c:	1cbb      	adds	r3, r7, #2
   1bf0e:	7819      	ldrb	r1, [r3, #0]
   1bf10:	4a14      	ldr	r2, [pc, #80]	; (1bf64 <ucSeekLogPos+0xbc>)
   1bf12:	000b      	movs	r3, r1
   1bf14:	009b      	lsls	r3, r3, #2
   1bf16:	185b      	adds	r3, r3, r1
   1bf18:	005b      	lsls	r3, r3, #1
   1bf1a:	18d1      	adds	r1, r2, r3
   1bf1c:	7849      	ldrb	r1, [r1, #1]
   1bf1e:	18d0      	adds	r0, r2, r3
   1bf20:	7880      	ldrb	r0, [r0, #2]
   1bf22:	0200      	lsls	r0, r0, #8
   1bf24:	4301      	orrs	r1, r0
   1bf26:	18d0      	adds	r0, r2, r3
   1bf28:	78c0      	ldrb	r0, [r0, #3]
   1bf2a:	0400      	lsls	r0, r0, #16
   1bf2c:	4301      	orrs	r1, r0
   1bf2e:	18d3      	adds	r3, r2, r3
   1bf30:	791b      	ldrb	r3, [r3, #4]
   1bf32:	061b      	lsls	r3, r3, #24
   1bf34:	430b      	orrs	r3, r1
   1bf36:	607b      	str	r3, [r7, #4]
	   ucOlderIndex=ucIndex;
   1bf38:	1cfb      	adds	r3, r7, #3
   1bf3a:	1cba      	adds	r2, r7, #2
   1bf3c:	7812      	ldrb	r2, [r2, #0]
   1bf3e:	701a      	strb	r2, [r3, #0]

static uint8_t ucSeekLogPos(void)
{   time_t OlderLog=LONG_MAX;
	uint8_t ucOlderIndex=0;
	
	for (uint8_t ucIndex=0x00;ucIndex<MAX_LOGS;ucIndex++)
   1bf40:	1cbb      	adds	r3, r7, #2
   1bf42:	781a      	ldrb	r2, [r3, #0]
   1bf44:	1cbb      	adds	r3, r7, #2
   1bf46:	3201      	adds	r2, #1
   1bf48:	701a      	strb	r2, [r3, #0]
   1bf4a:	1cbb      	adds	r3, r7, #2
   1bf4c:	781b      	ldrb	r3, [r3, #0]
   1bf4e:	2b63      	cmp	r3, #99	; 0x63
   1bf50:	d9b6      	bls.n	1bec0 <ucSeekLogPos+0x18>
	   OlderLog=xLogTable[ucIndex].xDateTime;
	   ucOlderIndex=ucIndex;
	 }
	}
	
	return ucOlderIndex;
   1bf52:	1cfb      	adds	r3, r7, #3
   1bf54:	781b      	ldrb	r3, [r3, #0]
}
   1bf56:	0018      	movs	r0, r3
   1bf58:	46bd      	mov	sp, r7
   1bf5a:	b002      	add	sp, #8
   1bf5c:	bd80      	pop	{r7, pc}
   1bf5e:	46c0      	nop			; (mov r8, r8)
   1bf60:	7fffffff 	.word	0x7fffffff
   1bf64:	20003e48 	.word	0x20003e48

0001bf68 <xCheckPrograms>:


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool xCheckPrograms(uint8_t *ucPrgIndex)
{
   1bf68:	b5b0      	push	{r4, r5, r7, lr}
   1bf6a:	b084      	sub	sp, #16
   1bf6c:	af00      	add	r7, sp, #0
   1bf6e:	6078      	str	r0, [r7, #4]
 UINT uSize;
 DRESULT result;	

 for (uint8_t ucIndex=0;ucIndex<MAX_PRG;ucIndex++)
   1bf70:	230f      	movs	r3, #15
   1bf72:	18fb      	adds	r3, r7, r3
   1bf74:	2200      	movs	r2, #0
   1bf76:	701a      	strb	r2, [r3, #0]
   1bf78:	e28a      	b.n	1c490 <xCheckPrograms+0x528>
 {
  if ((xProgramList[ucIndex].xProgramType==P_OFF) || (!xProgramList[ucIndex].xStartTime)) continue;
   1bf7a:	230f      	movs	r3, #15
   1bf7c:	18fb      	adds	r3, r7, r3
   1bf7e:	781a      	ldrb	r2, [r3, #0]
   1bf80:	498e      	ldr	r1, [pc, #568]	; (1c1bc <xCheckPrograms+0x254>)
   1bf82:	0013      	movs	r3, r2
   1bf84:	00db      	lsls	r3, r3, #3
   1bf86:	1a9b      	subs	r3, r3, r2
   1bf88:	00db      	lsls	r3, r3, #3
   1bf8a:	189b      	adds	r3, r3, r2
   1bf8c:	5c5b      	ldrb	r3, [r3, r1]
   1bf8e:	2bff      	cmp	r3, #255	; 0xff
   1bf90:	d100      	bne.n	1bf94 <xCheckPrograms+0x2c>
   1bf92:	e275      	b.n	1c480 <xCheckPrograms+0x518>
   1bf94:	230f      	movs	r3, #15
   1bf96:	18fb      	adds	r3, r7, r3
   1bf98:	781a      	ldrb	r2, [r3, #0]
   1bf9a:	4988      	ldr	r1, [pc, #544]	; (1c1bc <xCheckPrograms+0x254>)
   1bf9c:	0013      	movs	r3, r2
   1bf9e:	00db      	lsls	r3, r3, #3
   1bfa0:	1a9b      	subs	r3, r3, r2
   1bfa2:	00db      	lsls	r3, r3, #3
   1bfa4:	189b      	adds	r3, r3, r2
   1bfa6:	18cb      	adds	r3, r1, r3
   1bfa8:	3310      	adds	r3, #16
   1bfaa:	785a      	ldrb	r2, [r3, #1]
   1bfac:	7899      	ldrb	r1, [r3, #2]
   1bfae:	0209      	lsls	r1, r1, #8
   1bfb0:	430a      	orrs	r2, r1
   1bfb2:	78d9      	ldrb	r1, [r3, #3]
   1bfb4:	0409      	lsls	r1, r1, #16
   1bfb6:	430a      	orrs	r2, r1
   1bfb8:	791b      	ldrb	r3, [r3, #4]
   1bfba:	061b      	lsls	r3, r3, #24
   1bfbc:	4313      	orrs	r3, r2
   1bfbe:	d100      	bne.n	1bfc2 <xCheckPrograms+0x5a>
   1bfc0:	e25e      	b.n	1c480 <xCheckPrograms+0x518>
  if ((xProgramList[ucIndex].xStartTime<xMasterTime) && ((xMasterTime-xProgramList[ucIndex].xStartTime)<PRGDELTATIME))
   1bfc2:	230f      	movs	r3, #15
   1bfc4:	18fb      	adds	r3, r7, r3
   1bfc6:	781a      	ldrb	r2, [r3, #0]
   1bfc8:	497c      	ldr	r1, [pc, #496]	; (1c1bc <xCheckPrograms+0x254>)
   1bfca:	0013      	movs	r3, r2
   1bfcc:	00db      	lsls	r3, r3, #3
   1bfce:	1a9b      	subs	r3, r3, r2
   1bfd0:	00db      	lsls	r3, r3, #3
   1bfd2:	189b      	adds	r3, r3, r2
   1bfd4:	18cb      	adds	r3, r1, r3
   1bfd6:	3310      	adds	r3, #16
   1bfd8:	785a      	ldrb	r2, [r3, #1]
   1bfda:	7899      	ldrb	r1, [r3, #2]
   1bfdc:	0209      	lsls	r1, r1, #8
   1bfde:	430a      	orrs	r2, r1
   1bfe0:	78d9      	ldrb	r1, [r3, #3]
   1bfe2:	0409      	lsls	r1, r1, #16
   1bfe4:	430a      	orrs	r2, r1
   1bfe6:	791b      	ldrb	r3, [r3, #4]
   1bfe8:	061b      	lsls	r3, r3, #24
   1bfea:	4313      	orrs	r3, r2
   1bfec:	1e1a      	subs	r2, r3, #0
   1bfee:	4b74      	ldr	r3, [pc, #464]	; (1c1c0 <xCheckPrograms+0x258>)
   1bff0:	681b      	ldr	r3, [r3, #0]
   1bff2:	429a      	cmp	r2, r3
   1bff4:	db00      	blt.n	1bff8 <xCheckPrograms+0x90>
   1bff6:	e244      	b.n	1c482 <xCheckPrograms+0x51a>
   1bff8:	4b71      	ldr	r3, [pc, #452]	; (1c1c0 <xCheckPrograms+0x258>)
   1bffa:	6819      	ldr	r1, [r3, #0]
   1bffc:	230f      	movs	r3, #15
   1bffe:	18fb      	adds	r3, r7, r3
   1c000:	781a      	ldrb	r2, [r3, #0]
   1c002:	486e      	ldr	r0, [pc, #440]	; (1c1bc <xCheckPrograms+0x254>)
   1c004:	0013      	movs	r3, r2
   1c006:	00db      	lsls	r3, r3, #3
   1c008:	1a9b      	subs	r3, r3, r2
   1c00a:	00db      	lsls	r3, r3, #3
   1c00c:	189b      	adds	r3, r3, r2
   1c00e:	18c3      	adds	r3, r0, r3
   1c010:	3310      	adds	r3, #16
   1c012:	785a      	ldrb	r2, [r3, #1]
   1c014:	7898      	ldrb	r0, [r3, #2]
   1c016:	0200      	lsls	r0, r0, #8
   1c018:	4302      	orrs	r2, r0
   1c01a:	78d8      	ldrb	r0, [r3, #3]
   1c01c:	0400      	lsls	r0, r0, #16
   1c01e:	4302      	orrs	r2, r0
   1c020:	791b      	ldrb	r3, [r3, #4]
   1c022:	061b      	lsls	r3, r3, #24
   1c024:	4313      	orrs	r3, r2
   1c026:	1acb      	subs	r3, r1, r3
   1c028:	2b09      	cmp	r3, #9
   1c02a:	dd00      	ble.n	1c02e <xCheckPrograms+0xc6>
   1c02c:	e229      	b.n	1c482 <xCheckPrograms+0x51a>
  {
	*ucPrgIndex=ucIndex;
   1c02e:	687b      	ldr	r3, [r7, #4]
   1c030:	220f      	movs	r2, #15
   1c032:	18ba      	adds	r2, r7, r2
   1c034:	7812      	ldrb	r2, [r2, #0]
   1c036:	701a      	strb	r2, [r3, #0]
	
	switch (xProgramList[ucIndex].xProgramType)
   1c038:	230f      	movs	r3, #15
   1c03a:	18fb      	adds	r3, r7, r3
   1c03c:	781a      	ldrb	r2, [r3, #0]
   1c03e:	495f      	ldr	r1, [pc, #380]	; (1c1bc <xCheckPrograms+0x254>)
   1c040:	0013      	movs	r3, r2
   1c042:	00db      	lsls	r3, r3, #3
   1c044:	1a9b      	subs	r3, r3, r2
   1c046:	00db      	lsls	r3, r3, #3
   1c048:	189b      	adds	r3, r3, r2
   1c04a:	5c5b      	ldrb	r3, [r3, r1]
   1c04c:	2b01      	cmp	r3, #1
   1c04e:	d047      	beq.n	1c0e0 <xCheckPrograms+0x178>
   1c050:	dc02      	bgt.n	1c058 <xCheckPrograms+0xf0>
   1c052:	2b00      	cmp	r3, #0
   1c054:	d006      	beq.n	1c064 <xCheckPrograms+0xfc>
   1c056:	e12c      	b.n	1c2b2 <xCheckPrograms+0x34a>
   1c058:	2b02      	cmp	r3, #2
   1c05a:	d003      	beq.n	1c064 <xCheckPrograms+0xfc>
   1c05c:	2b03      	cmp	r3, #3
   1c05e:	d100      	bne.n	1c062 <xCheckPrograms+0xfa>
   1c060:	e0ba      	b.n	1c1d8 <xCheckPrograms+0x270>
   1c062:	e126      	b.n	1c2b2 <xCheckPrograms+0x34a>
	{
	 case P_STD:
	 case P_WASH:
	 
	 xProgramStartTime=xProgramList[ucIndex].xStartTime;
   1c064:	230f      	movs	r3, #15
   1c066:	18fb      	adds	r3, r7, r3
   1c068:	781a      	ldrb	r2, [r3, #0]
   1c06a:	4954      	ldr	r1, [pc, #336]	; (1c1bc <xCheckPrograms+0x254>)
   1c06c:	0013      	movs	r3, r2
   1c06e:	00db      	lsls	r3, r3, #3
   1c070:	1a9b      	subs	r3, r3, r2
   1c072:	00db      	lsls	r3, r3, #3
   1c074:	189b      	adds	r3, r3, r2
   1c076:	18cb      	adds	r3, r1, r3
   1c078:	3310      	adds	r3, #16
   1c07a:	785a      	ldrb	r2, [r3, #1]
   1c07c:	7899      	ldrb	r1, [r3, #2]
   1c07e:	0209      	lsls	r1, r1, #8
   1c080:	430a      	orrs	r2, r1
   1c082:	78d9      	ldrb	r1, [r3, #3]
   1c084:	0409      	lsls	r1, r1, #16
   1c086:	430a      	orrs	r2, r1
   1c088:	791b      	ldrb	r3, [r3, #4]
   1c08a:	061b      	lsls	r3, r3, #24
   1c08c:	4313      	orrs	r3, r2
   1c08e:	001a      	movs	r2, r3
   1c090:	4b4c      	ldr	r3, [pc, #304]	; (1c1c4 <xCheckPrograms+0x25c>)
   1c092:	601a      	str	r2, [r3, #0]
	 xProgramList[ucIndex].xStartTime=0;
   1c094:	230f      	movs	r3, #15
   1c096:	18fb      	adds	r3, r7, r3
   1c098:	781a      	ldrb	r2, [r3, #0]
   1c09a:	4948      	ldr	r1, [pc, #288]	; (1c1bc <xCheckPrograms+0x254>)
   1c09c:	0013      	movs	r3, r2
   1c09e:	00db      	lsls	r3, r3, #3
   1c0a0:	1a9b      	subs	r3, r3, r2
   1c0a2:	00db      	lsls	r3, r3, #3
   1c0a4:	189b      	adds	r3, r3, r2
   1c0a6:	18cb      	adds	r3, r1, r3
   1c0a8:	3310      	adds	r3, #16
   1c0aa:	3301      	adds	r3, #1
   1c0ac:	781a      	ldrb	r2, [r3, #0]
   1c0ae:	2100      	movs	r1, #0
   1c0b0:	400a      	ands	r2, r1
   1c0b2:	701a      	strb	r2, [r3, #0]
   1c0b4:	785a      	ldrb	r2, [r3, #1]
   1c0b6:	2100      	movs	r1, #0
   1c0b8:	400a      	ands	r2, r1
   1c0ba:	705a      	strb	r2, [r3, #1]
   1c0bc:	789a      	ldrb	r2, [r3, #2]
   1c0be:	2100      	movs	r1, #0
   1c0c0:	400a      	ands	r2, r1
   1c0c2:	709a      	strb	r2, [r3, #2]
   1c0c4:	78da      	ldrb	r2, [r3, #3]
   1c0c6:	2100      	movs	r1, #0
   1c0c8:	400a      	ands	r2, r1
   1c0ca:	70da      	strb	r2, [r3, #3]
	 xProgramSequence=TS;
   1c0cc:	4b3e      	ldr	r3, [pc, #248]	; (1c1c8 <xCheckPrograms+0x260>)
   1c0ce:	2200      	movs	r2, #0
   1c0d0:	701a      	strb	r2, [r3, #0]
	 ucLogPos=ucSeekLogPos();
   1c0d2:	4b3e      	ldr	r3, [pc, #248]	; (1c1cc <xCheckPrograms+0x264>)
   1c0d4:	4798      	blx	r3
   1c0d6:	0003      	movs	r3, r0
   1c0d8:	001a      	movs	r2, r3
   1c0da:	4b3d      	ldr	r3, [pc, #244]	; (1c1d0 <xCheckPrograms+0x268>)
   1c0dc:	701a      	strb	r2, [r3, #0]
	 
	 break;
   1c0de:	e0e8      	b.n	1c2b2 <xCheckPrograms+0x34a>
	 
	 case P_WEEK:
	 
	 xProgramStartTime=xProgramList[ucIndex].xStartTime;
   1c0e0:	230f      	movs	r3, #15
   1c0e2:	18fb      	adds	r3, r7, r3
   1c0e4:	781a      	ldrb	r2, [r3, #0]
   1c0e6:	4935      	ldr	r1, [pc, #212]	; (1c1bc <xCheckPrograms+0x254>)
   1c0e8:	0013      	movs	r3, r2
   1c0ea:	00db      	lsls	r3, r3, #3
   1c0ec:	1a9b      	subs	r3, r3, r2
   1c0ee:	00db      	lsls	r3, r3, #3
   1c0f0:	189b      	adds	r3, r3, r2
   1c0f2:	18cb      	adds	r3, r1, r3
   1c0f4:	3310      	adds	r3, #16
   1c0f6:	785a      	ldrb	r2, [r3, #1]
   1c0f8:	7899      	ldrb	r1, [r3, #2]
   1c0fa:	0209      	lsls	r1, r1, #8
   1c0fc:	430a      	orrs	r2, r1
   1c0fe:	78d9      	ldrb	r1, [r3, #3]
   1c100:	0409      	lsls	r1, r1, #16
   1c102:	430a      	orrs	r2, r1
   1c104:	791b      	ldrb	r3, [r3, #4]
   1c106:	061b      	lsls	r3, r3, #24
   1c108:	4313      	orrs	r3, r2
   1c10a:	001a      	movs	r2, r3
   1c10c:	4b2d      	ldr	r3, [pc, #180]	; (1c1c4 <xCheckPrograms+0x25c>)
   1c10e:	601a      	str	r2, [r3, #0]
	 xProgramList[ucIndex].xStartTime+=24*3600*7;
   1c110:	230f      	movs	r3, #15
   1c112:	18fb      	adds	r3, r7, r3
   1c114:	7819      	ldrb	r1, [r3, #0]
   1c116:	230f      	movs	r3, #15
   1c118:	18fb      	adds	r3, r7, r3
   1c11a:	781a      	ldrb	r2, [r3, #0]
   1c11c:	4827      	ldr	r0, [pc, #156]	; (1c1bc <xCheckPrograms+0x254>)
   1c11e:	0013      	movs	r3, r2
   1c120:	00db      	lsls	r3, r3, #3
   1c122:	1a9b      	subs	r3, r3, r2
   1c124:	00db      	lsls	r3, r3, #3
   1c126:	189b      	adds	r3, r3, r2
   1c128:	18c3      	adds	r3, r0, r3
   1c12a:	3310      	adds	r3, #16
   1c12c:	785a      	ldrb	r2, [r3, #1]
   1c12e:	7898      	ldrb	r0, [r3, #2]
   1c130:	0200      	lsls	r0, r0, #8
   1c132:	4302      	orrs	r2, r0
   1c134:	78d8      	ldrb	r0, [r3, #3]
   1c136:	0400      	lsls	r0, r0, #16
   1c138:	4302      	orrs	r2, r0
   1c13a:	791b      	ldrb	r3, [r3, #4]
   1c13c:	061b      	lsls	r3, r3, #24
   1c13e:	4313      	orrs	r3, r2
   1c140:	4a24      	ldr	r2, [pc, #144]	; (1c1d4 <xCheckPrograms+0x26c>)
   1c142:	189a      	adds	r2, r3, r2
   1c144:	481d      	ldr	r0, [pc, #116]	; (1c1bc <xCheckPrograms+0x254>)
   1c146:	000b      	movs	r3, r1
   1c148:	00db      	lsls	r3, r3, #3
   1c14a:	1a5b      	subs	r3, r3, r1
   1c14c:	00db      	lsls	r3, r3, #3
   1c14e:	185b      	adds	r3, r3, r1
   1c150:	18c3      	adds	r3, r0, r3
   1c152:	3310      	adds	r3, #16
   1c154:	3301      	adds	r3, #1
   1c156:	21ff      	movs	r1, #255	; 0xff
   1c158:	4011      	ands	r1, r2
   1c15a:	000c      	movs	r4, r1
   1c15c:	7819      	ldrb	r1, [r3, #0]
   1c15e:	2000      	movs	r0, #0
   1c160:	4001      	ands	r1, r0
   1c162:	1c08      	adds	r0, r1, #0
   1c164:	1c21      	adds	r1, r4, #0
   1c166:	4301      	orrs	r1, r0
   1c168:	7019      	strb	r1, [r3, #0]
   1c16a:	0a11      	lsrs	r1, r2, #8
   1c16c:	20ff      	movs	r0, #255	; 0xff
   1c16e:	4001      	ands	r1, r0
   1c170:	000c      	movs	r4, r1
   1c172:	7859      	ldrb	r1, [r3, #1]
   1c174:	2000      	movs	r0, #0
   1c176:	4001      	ands	r1, r0
   1c178:	1c08      	adds	r0, r1, #0
   1c17a:	1c21      	adds	r1, r4, #0
   1c17c:	4301      	orrs	r1, r0
   1c17e:	7059      	strb	r1, [r3, #1]
   1c180:	0c11      	lsrs	r1, r2, #16
   1c182:	20ff      	movs	r0, #255	; 0xff
   1c184:	4001      	ands	r1, r0
   1c186:	000c      	movs	r4, r1
   1c188:	7899      	ldrb	r1, [r3, #2]
   1c18a:	2000      	movs	r0, #0
   1c18c:	4001      	ands	r1, r0
   1c18e:	1c08      	adds	r0, r1, #0
   1c190:	1c21      	adds	r1, r4, #0
   1c192:	4301      	orrs	r1, r0
   1c194:	7099      	strb	r1, [r3, #2]
   1c196:	0e10      	lsrs	r0, r2, #24
   1c198:	78da      	ldrb	r2, [r3, #3]
   1c19a:	2100      	movs	r1, #0
   1c19c:	400a      	ands	r2, r1
   1c19e:	1c11      	adds	r1, r2, #0
   1c1a0:	1c02      	adds	r2, r0, #0
   1c1a2:	430a      	orrs	r2, r1
   1c1a4:	70da      	strb	r2, [r3, #3]
	 xProgramSequence=TS;
   1c1a6:	4b08      	ldr	r3, [pc, #32]	; (1c1c8 <xCheckPrograms+0x260>)
   1c1a8:	2200      	movs	r2, #0
   1c1aa:	701a      	strb	r2, [r3, #0]
	 ucLogPos=ucSeekLogPos();
   1c1ac:	4b07      	ldr	r3, [pc, #28]	; (1c1cc <xCheckPrograms+0x264>)
   1c1ae:	4798      	blx	r3
   1c1b0:	0003      	movs	r3, r0
   1c1b2:	001a      	movs	r2, r3
   1c1b4:	4b06      	ldr	r3, [pc, #24]	; (1c1d0 <xCheckPrograms+0x268>)
   1c1b6:	701a      	strb	r2, [r3, #0]
	 	 
	 break;	
   1c1b8:	e07b      	b.n	1c2b2 <xCheckPrograms+0x34a>
   1c1ba:	46c0      	nop			; (mov r8, r8)
   1c1bc:	200046ec 	.word	0x200046ec
   1c1c0:	200049e0 	.word	0x200049e0
   1c1c4:	20003e10 	.word	0x20003e10
   1c1c8:	20004a72 	.word	0x20004a72
   1c1cc:	0001bea9 	.word	0x0001bea9
   1c1d0:	20004a5c 	.word	0x20004a5c
   1c1d4:	00093a80 	.word	0x00093a80
	 
	 case P_DAY:
	 
	 xProgramStartTime=xProgramList[ucIndex].xStartTime;
   1c1d8:	230f      	movs	r3, #15
   1c1da:	18fb      	adds	r3, r7, r3
   1c1dc:	781a      	ldrb	r2, [r3, #0]
   1c1de:	49f4      	ldr	r1, [pc, #976]	; (1c5b0 <xCheckPrograms+0x648>)
   1c1e0:	0013      	movs	r3, r2
   1c1e2:	00db      	lsls	r3, r3, #3
   1c1e4:	1a9b      	subs	r3, r3, r2
   1c1e6:	00db      	lsls	r3, r3, #3
   1c1e8:	189b      	adds	r3, r3, r2
   1c1ea:	18cb      	adds	r3, r1, r3
   1c1ec:	3310      	adds	r3, #16
   1c1ee:	785a      	ldrb	r2, [r3, #1]
   1c1f0:	7899      	ldrb	r1, [r3, #2]
   1c1f2:	0209      	lsls	r1, r1, #8
   1c1f4:	430a      	orrs	r2, r1
   1c1f6:	78d9      	ldrb	r1, [r3, #3]
   1c1f8:	0409      	lsls	r1, r1, #16
   1c1fa:	430a      	orrs	r2, r1
   1c1fc:	791b      	ldrb	r3, [r3, #4]
   1c1fe:	061b      	lsls	r3, r3, #24
   1c200:	4313      	orrs	r3, r2
   1c202:	001a      	movs	r2, r3
   1c204:	4beb      	ldr	r3, [pc, #940]	; (1c5b4 <xCheckPrograms+0x64c>)
   1c206:	601a      	str	r2, [r3, #0]
	 xProgramList[ucIndex].xStartTime+=24*3600;
   1c208:	230f      	movs	r3, #15
   1c20a:	18fb      	adds	r3, r7, r3
   1c20c:	7819      	ldrb	r1, [r3, #0]
   1c20e:	230f      	movs	r3, #15
   1c210:	18fb      	adds	r3, r7, r3
   1c212:	781a      	ldrb	r2, [r3, #0]
   1c214:	48e6      	ldr	r0, [pc, #920]	; (1c5b0 <xCheckPrograms+0x648>)
   1c216:	0013      	movs	r3, r2
   1c218:	00db      	lsls	r3, r3, #3
   1c21a:	1a9b      	subs	r3, r3, r2
   1c21c:	00db      	lsls	r3, r3, #3
   1c21e:	189b      	adds	r3, r3, r2
   1c220:	18c3      	adds	r3, r0, r3
   1c222:	3310      	adds	r3, #16
   1c224:	785a      	ldrb	r2, [r3, #1]
   1c226:	7898      	ldrb	r0, [r3, #2]
   1c228:	0200      	lsls	r0, r0, #8
   1c22a:	4302      	orrs	r2, r0
   1c22c:	78d8      	ldrb	r0, [r3, #3]
   1c22e:	0400      	lsls	r0, r0, #16
   1c230:	4302      	orrs	r2, r0
   1c232:	791b      	ldrb	r3, [r3, #4]
   1c234:	061b      	lsls	r3, r3, #24
   1c236:	4313      	orrs	r3, r2
   1c238:	4adf      	ldr	r2, [pc, #892]	; (1c5b8 <xCheckPrograms+0x650>)
   1c23a:	189a      	adds	r2, r3, r2
   1c23c:	48dc      	ldr	r0, [pc, #880]	; (1c5b0 <xCheckPrograms+0x648>)
   1c23e:	000b      	movs	r3, r1
   1c240:	00db      	lsls	r3, r3, #3
   1c242:	1a5b      	subs	r3, r3, r1
   1c244:	00db      	lsls	r3, r3, #3
   1c246:	185b      	adds	r3, r3, r1
   1c248:	18c3      	adds	r3, r0, r3
   1c24a:	3310      	adds	r3, #16
   1c24c:	3301      	adds	r3, #1
   1c24e:	21ff      	movs	r1, #255	; 0xff
   1c250:	4011      	ands	r1, r2
   1c252:	000c      	movs	r4, r1
   1c254:	7819      	ldrb	r1, [r3, #0]
   1c256:	2000      	movs	r0, #0
   1c258:	4001      	ands	r1, r0
   1c25a:	1c08      	adds	r0, r1, #0
   1c25c:	1c21      	adds	r1, r4, #0
   1c25e:	4301      	orrs	r1, r0
   1c260:	7019      	strb	r1, [r3, #0]
   1c262:	0a11      	lsrs	r1, r2, #8
   1c264:	20ff      	movs	r0, #255	; 0xff
   1c266:	4001      	ands	r1, r0
   1c268:	000c      	movs	r4, r1
   1c26a:	7859      	ldrb	r1, [r3, #1]
   1c26c:	2000      	movs	r0, #0
   1c26e:	4001      	ands	r1, r0
   1c270:	1c08      	adds	r0, r1, #0
   1c272:	1c21      	adds	r1, r4, #0
   1c274:	4301      	orrs	r1, r0
   1c276:	7059      	strb	r1, [r3, #1]
   1c278:	0c11      	lsrs	r1, r2, #16
   1c27a:	20ff      	movs	r0, #255	; 0xff
   1c27c:	4001      	ands	r1, r0
   1c27e:	000c      	movs	r4, r1
   1c280:	7899      	ldrb	r1, [r3, #2]
   1c282:	2000      	movs	r0, #0
   1c284:	4001      	ands	r1, r0
   1c286:	1c08      	adds	r0, r1, #0
   1c288:	1c21      	adds	r1, r4, #0
   1c28a:	4301      	orrs	r1, r0
   1c28c:	7099      	strb	r1, [r3, #2]
   1c28e:	0e10      	lsrs	r0, r2, #24
   1c290:	78da      	ldrb	r2, [r3, #3]
   1c292:	2100      	movs	r1, #0
   1c294:	400a      	ands	r2, r1
   1c296:	1c11      	adds	r1, r2, #0
   1c298:	1c02      	adds	r2, r0, #0
   1c29a:	430a      	orrs	r2, r1
   1c29c:	70da      	strb	r2, [r3, #3]
	 xProgramSequence=TS;
   1c29e:	4bc7      	ldr	r3, [pc, #796]	; (1c5bc <xCheckPrograms+0x654>)
   1c2a0:	2200      	movs	r2, #0
   1c2a2:	701a      	strb	r2, [r3, #0]
	 ucLogPos=ucSeekLogPos();
   1c2a4:	4bc6      	ldr	r3, [pc, #792]	; (1c5c0 <xCheckPrograms+0x658>)
   1c2a6:	4798      	blx	r3
   1c2a8:	0003      	movs	r3, r0
   1c2aa:	001a      	movs	r2, r3
   1c2ac:	4bc5      	ldr	r3, [pc, #788]	; (1c5c4 <xCheckPrograms+0x65c>)
   1c2ae:	701a      	strb	r2, [r3, #0]
	
	 break;
   1c2b0:	46c0      	nop			; (mov r8, r8)
	}
	
	xLogTable[ucLogPos].ucPrgIndex=ucIndex;
   1c2b2:	4bc4      	ldr	r3, [pc, #784]	; (1c5c4 <xCheckPrograms+0x65c>)
   1c2b4:	781b      	ldrb	r3, [r3, #0]
   1c2b6:	0019      	movs	r1, r3
   1c2b8:	4ac3      	ldr	r2, [pc, #780]	; (1c5c8 <xCheckPrograms+0x660>)
   1c2ba:	000b      	movs	r3, r1
   1c2bc:	009b      	lsls	r3, r3, #2
   1c2be:	185b      	adds	r3, r3, r1
   1c2c0:	005b      	lsls	r3, r3, #1
   1c2c2:	210f      	movs	r1, #15
   1c2c4:	1879      	adds	r1, r7, r1
   1c2c6:	7809      	ldrb	r1, [r1, #0]
   1c2c8:	5499      	strb	r1, [r3, r2]
	xLogTable[ucLogPos].xDateTime=xProgramStartTime;
   1c2ca:	4bbe      	ldr	r3, [pc, #760]	; (1c5c4 <xCheckPrograms+0x65c>)
   1c2cc:	781b      	ldrb	r3, [r3, #0]
   1c2ce:	0018      	movs	r0, r3
   1c2d0:	4bb8      	ldr	r3, [pc, #736]	; (1c5b4 <xCheckPrograms+0x64c>)
   1c2d2:	681a      	ldr	r2, [r3, #0]
   1c2d4:	49bc      	ldr	r1, [pc, #752]	; (1c5c8 <xCheckPrograms+0x660>)
   1c2d6:	0003      	movs	r3, r0
   1c2d8:	009b      	lsls	r3, r3, #2
   1c2da:	181b      	adds	r3, r3, r0
   1c2dc:	005b      	lsls	r3, r3, #1
   1c2de:	18cb      	adds	r3, r1, r3
   1c2e0:	3301      	adds	r3, #1
   1c2e2:	21ff      	movs	r1, #255	; 0xff
   1c2e4:	4011      	ands	r1, r2
   1c2e6:	000c      	movs	r4, r1
   1c2e8:	7819      	ldrb	r1, [r3, #0]
   1c2ea:	2000      	movs	r0, #0
   1c2ec:	4001      	ands	r1, r0
   1c2ee:	1c08      	adds	r0, r1, #0
   1c2f0:	1c21      	adds	r1, r4, #0
   1c2f2:	4301      	orrs	r1, r0
   1c2f4:	7019      	strb	r1, [r3, #0]
   1c2f6:	0a11      	lsrs	r1, r2, #8
   1c2f8:	20ff      	movs	r0, #255	; 0xff
   1c2fa:	4001      	ands	r1, r0
   1c2fc:	000c      	movs	r4, r1
   1c2fe:	7859      	ldrb	r1, [r3, #1]
   1c300:	2000      	movs	r0, #0
   1c302:	4001      	ands	r1, r0
   1c304:	1c08      	adds	r0, r1, #0
   1c306:	1c21      	adds	r1, r4, #0
   1c308:	4301      	orrs	r1, r0
   1c30a:	7059      	strb	r1, [r3, #1]
   1c30c:	0c11      	lsrs	r1, r2, #16
   1c30e:	20ff      	movs	r0, #255	; 0xff
   1c310:	4001      	ands	r1, r0
   1c312:	000c      	movs	r4, r1
   1c314:	7899      	ldrb	r1, [r3, #2]
   1c316:	2000      	movs	r0, #0
   1c318:	4001      	ands	r1, r0
   1c31a:	1c08      	adds	r0, r1, #0
   1c31c:	1c21      	adds	r1, r4, #0
   1c31e:	4301      	orrs	r1, r0
   1c320:	7099      	strb	r1, [r3, #2]
   1c322:	0e10      	lsrs	r0, r2, #24
   1c324:	78da      	ldrb	r2, [r3, #3]
   1c326:	2100      	movs	r1, #0
   1c328:	400a      	ands	r2, r1
   1c32a:	1c11      	adds	r1, r2, #0
   1c32c:	1c02      	adds	r2, r0, #0
   1c32e:	430a      	orrs	r2, r1
   1c330:	70da      	strb	r2, [r3, #3]
	xLogTable[ucLogPos].ucLogPages=((xProgramList[ucIndex].usTp/xProgramList[ucIndex].usTr)/MAX_REC_PAGE)+1;
   1c332:	4ba4      	ldr	r3, [pc, #656]	; (1c5c4 <xCheckPrograms+0x65c>)
   1c334:	781b      	ldrb	r3, [r3, #0]
   1c336:	001c      	movs	r4, r3
   1c338:	230f      	movs	r3, #15
   1c33a:	18fb      	adds	r3, r7, r3
   1c33c:	781a      	ldrb	r2, [r3, #0]
   1c33e:	499c      	ldr	r1, [pc, #624]	; (1c5b0 <xCheckPrograms+0x648>)
   1c340:	0013      	movs	r3, r2
   1c342:	00db      	lsls	r3, r3, #3
   1c344:	1a9b      	subs	r3, r3, r2
   1c346:	00db      	lsls	r3, r3, #3
   1c348:	189b      	adds	r3, r3, r2
   1c34a:	18cb      	adds	r3, r1, r3
   1c34c:	3318      	adds	r3, #24
   1c34e:	78da      	ldrb	r2, [r3, #3]
   1c350:	791b      	ldrb	r3, [r3, #4]
   1c352:	021b      	lsls	r3, r3, #8
   1c354:	4313      	orrs	r3, r2
   1c356:	b298      	uxth	r0, r3
   1c358:	230f      	movs	r3, #15
   1c35a:	18fb      	adds	r3, r7, r3
   1c35c:	781a      	ldrb	r2, [r3, #0]
   1c35e:	4994      	ldr	r1, [pc, #592]	; (1c5b0 <xCheckPrograms+0x648>)
   1c360:	0013      	movs	r3, r2
   1c362:	00db      	lsls	r3, r3, #3
   1c364:	1a9b      	subs	r3, r3, r2
   1c366:	00db      	lsls	r3, r3, #3
   1c368:	189b      	adds	r3, r3, r2
   1c36a:	18cb      	adds	r3, r1, r3
   1c36c:	3318      	adds	r3, #24
   1c36e:	795a      	ldrb	r2, [r3, #5]
   1c370:	799b      	ldrb	r3, [r3, #6]
   1c372:	021b      	lsls	r3, r3, #8
   1c374:	4313      	orrs	r3, r2
   1c376:	b29a      	uxth	r2, r3
   1c378:	4b94      	ldr	r3, [pc, #592]	; (1c5cc <xCheckPrograms+0x664>)
   1c37a:	0011      	movs	r1, r2
   1c37c:	4798      	blx	r3
   1c37e:	0003      	movs	r3, r0
   1c380:	b29a      	uxth	r2, r3
   1c382:	4b92      	ldr	r3, [pc, #584]	; (1c5cc <xCheckPrograms+0x664>)
   1c384:	2132      	movs	r1, #50	; 0x32
   1c386:	0010      	movs	r0, r2
   1c388:	4798      	blx	r3
   1c38a:	0003      	movs	r3, r0
   1c38c:	b29b      	uxth	r3, r3
   1c38e:	b2db      	uxtb	r3, r3
   1c390:	3301      	adds	r3, #1
   1c392:	b2d9      	uxtb	r1, r3
   1c394:	4a8c      	ldr	r2, [pc, #560]	; (1c5c8 <xCheckPrograms+0x660>)
   1c396:	0023      	movs	r3, r4
   1c398:	009b      	lsls	r3, r3, #2
   1c39a:	191b      	adds	r3, r3, r4
   1c39c:	005b      	lsls	r3, r3, #1
   1c39e:	18d3      	adds	r3, r2, r3
   1c3a0:	3305      	adds	r3, #5
   1c3a2:	1c0a      	adds	r2, r1, #0
   1c3a4:	701a      	strb	r2, [r3, #0]
	
	f_open(&file_object,"0:/PrgList.bin",FA_WRITE);
   1c3a6:	498a      	ldr	r1, [pc, #552]	; (1c5d0 <xCheckPrograms+0x668>)
   1c3a8:	4b8a      	ldr	r3, [pc, #552]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c3aa:	2202      	movs	r2, #2
   1c3ac:	0018      	movs	r0, r3
   1c3ae:	4b8a      	ldr	r3, [pc, #552]	; (1c5d8 <xCheckPrograms+0x670>)
   1c3b0:	4798      	blx	r3
	f_lseek(&file_object,sizeof(xProgram)*ucIndex);
   1c3b2:	230f      	movs	r3, #15
   1c3b4:	18fb      	adds	r3, r7, r3
   1c3b6:	781a      	ldrb	r2, [r3, #0]
   1c3b8:	0013      	movs	r3, r2
   1c3ba:	00db      	lsls	r3, r3, #3
   1c3bc:	1a9b      	subs	r3, r3, r2
   1c3be:	00db      	lsls	r3, r3, #3
   1c3c0:	189a      	adds	r2, r3, r2
   1c3c2:	4b84      	ldr	r3, [pc, #528]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c3c4:	0011      	movs	r1, r2
   1c3c6:	0018      	movs	r0, r3
   1c3c8:	4b84      	ldr	r3, [pc, #528]	; (1c5dc <xCheckPrograms+0x674>)
   1c3ca:	4798      	blx	r3
	result=f_write(&file_object,&xProgramList[ucIndex],sizeof(xProgram),&uSize);
   1c3cc:	230f      	movs	r3, #15
   1c3ce:	18fb      	adds	r3, r7, r3
   1c3d0:	781a      	ldrb	r2, [r3, #0]
   1c3d2:	0013      	movs	r3, r2
   1c3d4:	00db      	lsls	r3, r3, #3
   1c3d6:	1a9b      	subs	r3, r3, r2
   1c3d8:	00db      	lsls	r3, r3, #3
   1c3da:	189b      	adds	r3, r3, r2
   1c3dc:	4a74      	ldr	r2, [pc, #464]	; (1c5b0 <xCheckPrograms+0x648>)
   1c3de:	1899      	adds	r1, r3, r2
   1c3e0:	230d      	movs	r3, #13
   1c3e2:	18fc      	adds	r4, r7, r3
   1c3e4:	2308      	movs	r3, #8
   1c3e6:	18fb      	adds	r3, r7, r3
   1c3e8:	487a      	ldr	r0, [pc, #488]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c3ea:	2239      	movs	r2, #57	; 0x39
   1c3ec:	4d7c      	ldr	r5, [pc, #496]	; (1c5e0 <xCheckPrograms+0x678>)
   1c3ee:	47a8      	blx	r5
   1c3f0:	0003      	movs	r3, r0
   1c3f2:	7023      	strb	r3, [r4, #0]
	f_close(&file_object);
   1c3f4:	4b77      	ldr	r3, [pc, #476]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c3f6:	0018      	movs	r0, r3
   1c3f8:	4b7a      	ldr	r3, [pc, #488]	; (1c5e4 <xCheckPrograms+0x67c>)
   1c3fa:	4798      	blx	r3
	
	f_open(&file_object,"0:/LogTable.bin",FA_WRITE);
   1c3fc:	497a      	ldr	r1, [pc, #488]	; (1c5e8 <xCheckPrograms+0x680>)
   1c3fe:	4b75      	ldr	r3, [pc, #468]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c400:	2202      	movs	r2, #2
   1c402:	0018      	movs	r0, r3
   1c404:	4b74      	ldr	r3, [pc, #464]	; (1c5d8 <xCheckPrograms+0x670>)
   1c406:	4798      	blx	r3
	f_lseek(&file_object,sizeof(xLogTb)*ucLogPos);
   1c408:	4b6e      	ldr	r3, [pc, #440]	; (1c5c4 <xCheckPrograms+0x65c>)
   1c40a:	781b      	ldrb	r3, [r3, #0]
   1c40c:	001a      	movs	r2, r3
   1c40e:	0013      	movs	r3, r2
   1c410:	009b      	lsls	r3, r3, #2
   1c412:	189b      	adds	r3, r3, r2
   1c414:	005b      	lsls	r3, r3, #1
   1c416:	001a      	movs	r2, r3
   1c418:	4b6e      	ldr	r3, [pc, #440]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c41a:	0011      	movs	r1, r2
   1c41c:	0018      	movs	r0, r3
   1c41e:	4b6f      	ldr	r3, [pc, #444]	; (1c5dc <xCheckPrograms+0x674>)
   1c420:	4798      	blx	r3
	result=f_write(&file_object,&xLogTable[ucLogPos],sizeof(xLogTb),&uSize);
   1c422:	4b68      	ldr	r3, [pc, #416]	; (1c5c4 <xCheckPrograms+0x65c>)
   1c424:	781b      	ldrb	r3, [r3, #0]
   1c426:	001a      	movs	r2, r3
   1c428:	0013      	movs	r3, r2
   1c42a:	009b      	lsls	r3, r3, #2
   1c42c:	189b      	adds	r3, r3, r2
   1c42e:	005b      	lsls	r3, r3, #1
   1c430:	4a65      	ldr	r2, [pc, #404]	; (1c5c8 <xCheckPrograms+0x660>)
   1c432:	1899      	adds	r1, r3, r2
   1c434:	230d      	movs	r3, #13
   1c436:	18fc      	adds	r4, r7, r3
   1c438:	2308      	movs	r3, #8
   1c43a:	18fb      	adds	r3, r7, r3
   1c43c:	4865      	ldr	r0, [pc, #404]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c43e:	220a      	movs	r2, #10
   1c440:	4d67      	ldr	r5, [pc, #412]	; (1c5e0 <xCheckPrograms+0x678>)
   1c442:	47a8      	blx	r5
   1c444:	0003      	movs	r3, r0
   1c446:	7023      	strb	r3, [r4, #0]
	f_close(&file_object);	
   1c448:	4b62      	ldr	r3, [pc, #392]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c44a:	0018      	movs	r0, r3
   1c44c:	4b65      	ldr	r3, [pc, #404]	; (1c5e4 <xCheckPrograms+0x67c>)
   1c44e:	4798      	blx	r3
	
	sprintf(TempString,"0:/Logs/Log%03d.bin",ucLogPos);
   1c450:	4b5c      	ldr	r3, [pc, #368]	; (1c5c4 <xCheckPrograms+0x65c>)
   1c452:	781b      	ldrb	r3, [r3, #0]
   1c454:	001a      	movs	r2, r3
   1c456:	4965      	ldr	r1, [pc, #404]	; (1c5ec <xCheckPrograms+0x684>)
   1c458:	4b65      	ldr	r3, [pc, #404]	; (1c5f0 <xCheckPrograms+0x688>)
   1c45a:	0018      	movs	r0, r3
   1c45c:	4b65      	ldr	r3, [pc, #404]	; (1c5f4 <xCheckPrograms+0x68c>)
   1c45e:	4798      	blx	r3
	f_unlink(TempString);
   1c460:	4b63      	ldr	r3, [pc, #396]	; (1c5f0 <xCheckPrograms+0x688>)
   1c462:	0018      	movs	r0, r3
   1c464:	4b64      	ldr	r3, [pc, #400]	; (1c5f8 <xCheckPrograms+0x690>)
   1c466:	4798      	blx	r3
	f_open(&file_object,TempString,FA_CREATE_ALWAYS | FA_WRITE);
   1c468:	4961      	ldr	r1, [pc, #388]	; (1c5f0 <xCheckPrograms+0x688>)
   1c46a:	4b5a      	ldr	r3, [pc, #360]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c46c:	220a      	movs	r2, #10
   1c46e:	0018      	movs	r0, r3
   1c470:	4b59      	ldr	r3, [pc, #356]	; (1c5d8 <xCheckPrograms+0x670>)
   1c472:	4798      	blx	r3
	f_close(&file_object);	
   1c474:	4b57      	ldr	r3, [pc, #348]	; (1c5d4 <xCheckPrograms+0x66c>)
   1c476:	0018      	movs	r0, r3
   1c478:	4b5a      	ldr	r3, [pc, #360]	; (1c5e4 <xCheckPrograms+0x67c>)
   1c47a:	4798      	blx	r3
	
	return true;  
   1c47c:	2301      	movs	r3, #1
   1c47e:	e1b4      	b.n	1c7ea <xCheckPrograms+0x882>
 UINT uSize;
 DRESULT result;	

 for (uint8_t ucIndex=0;ucIndex<MAX_PRG;ucIndex++)
 {
  if ((xProgramList[ucIndex].xProgramType==P_OFF) || (!xProgramList[ucIndex].xStartTime)) continue;
   1c480:	46c0      	nop			; (mov r8, r8)
static bool xCheckPrograms(uint8_t *ucPrgIndex)
{
 UINT uSize;
 DRESULT result;	

 for (uint8_t ucIndex=0;ucIndex<MAX_PRG;ucIndex++)
   1c482:	230f      	movs	r3, #15
   1c484:	18fb      	adds	r3, r7, r3
   1c486:	781a      	ldrb	r2, [r3, #0]
   1c488:	230f      	movs	r3, #15
   1c48a:	18fb      	adds	r3, r7, r3
   1c48c:	3201      	adds	r2, #1
   1c48e:	701a      	strb	r2, [r3, #0]
   1c490:	230f      	movs	r3, #15
   1c492:	18fb      	adds	r3, r7, r3
   1c494:	781b      	ldrb	r3, [r3, #0]
   1c496:	2b09      	cmp	r3, #9
   1c498:	d800      	bhi.n	1c49c <xCheckPrograms+0x534>
   1c49a:	e56e      	b.n	1bf7a <xCheckPrograms+0x12>
  }
  
 }
 
 //controlla se seve aggiornare i programmi week o day nel caso la macchina fosse spenta
 for (uint8_t ucIndex=0;ucIndex<MAX_PRG;ucIndex++)
   1c49c:	230e      	movs	r3, #14
   1c49e:	18fb      	adds	r3, r7, r3
   1c4a0:	2200      	movs	r2, #0
   1c4a2:	701a      	strb	r2, [r3, #0]
   1c4a4:	e19a      	b.n	1c7dc <xCheckPrograms+0x874>
 if ((xProgramList[ucIndex].xProgramType==P_WEEK) || (xProgramList[ucIndex].xProgramType==P_DAY))
   1c4a6:	230e      	movs	r3, #14
   1c4a8:	18fb      	adds	r3, r7, r3
   1c4aa:	781a      	ldrb	r2, [r3, #0]
   1c4ac:	4940      	ldr	r1, [pc, #256]	; (1c5b0 <xCheckPrograms+0x648>)
   1c4ae:	0013      	movs	r3, r2
   1c4b0:	00db      	lsls	r3, r3, #3
   1c4b2:	1a9b      	subs	r3, r3, r2
   1c4b4:	00db      	lsls	r3, r3, #3
   1c4b6:	189b      	adds	r3, r3, r2
   1c4b8:	5c5b      	ldrb	r3, [r3, r1]
   1c4ba:	2b01      	cmp	r3, #1
   1c4bc:	d00c      	beq.n	1c4d8 <xCheckPrograms+0x570>
   1c4be:	230e      	movs	r3, #14
   1c4c0:	18fb      	adds	r3, r7, r3
   1c4c2:	781a      	ldrb	r2, [r3, #0]
   1c4c4:	493a      	ldr	r1, [pc, #232]	; (1c5b0 <xCheckPrograms+0x648>)
   1c4c6:	0013      	movs	r3, r2
   1c4c8:	00db      	lsls	r3, r3, #3
   1c4ca:	1a9b      	subs	r3, r3, r2
   1c4cc:	00db      	lsls	r3, r3, #3
   1c4ce:	189b      	adds	r3, r3, r2
   1c4d0:	5c5b      	ldrb	r3, [r3, r1]
   1c4d2:	2b03      	cmp	r3, #3
   1c4d4:	d000      	beq.n	1c4d8 <xCheckPrograms+0x570>
   1c4d6:	e17a      	b.n	1c7ce <xCheckPrograms+0x866>
 {
   if ((xProgramList[ucIndex].xProgramType==P_OFF) || (!xProgramList[ucIndex].xStartTime)) continue;	
   1c4d8:	230e      	movs	r3, #14
   1c4da:	18fb      	adds	r3, r7, r3
   1c4dc:	781a      	ldrb	r2, [r3, #0]
   1c4de:	4934      	ldr	r1, [pc, #208]	; (1c5b0 <xCheckPrograms+0x648>)
   1c4e0:	0013      	movs	r3, r2
   1c4e2:	00db      	lsls	r3, r3, #3
   1c4e4:	1a9b      	subs	r3, r3, r2
   1c4e6:	00db      	lsls	r3, r3, #3
   1c4e8:	189b      	adds	r3, r3, r2
   1c4ea:	5c5b      	ldrb	r3, [r3, r1]
   1c4ec:	2bff      	cmp	r3, #255	; 0xff
   1c4ee:	d100      	bne.n	1c4f2 <xCheckPrograms+0x58a>
   1c4f0:	e16c      	b.n	1c7cc <xCheckPrograms+0x864>
   1c4f2:	230e      	movs	r3, #14
   1c4f4:	18fb      	adds	r3, r7, r3
   1c4f6:	781a      	ldrb	r2, [r3, #0]
   1c4f8:	492d      	ldr	r1, [pc, #180]	; (1c5b0 <xCheckPrograms+0x648>)
   1c4fa:	0013      	movs	r3, r2
   1c4fc:	00db      	lsls	r3, r3, #3
   1c4fe:	1a9b      	subs	r3, r3, r2
   1c500:	00db      	lsls	r3, r3, #3
   1c502:	189b      	adds	r3, r3, r2
   1c504:	18cb      	adds	r3, r1, r3
   1c506:	3310      	adds	r3, #16
   1c508:	785a      	ldrb	r2, [r3, #1]
   1c50a:	7899      	ldrb	r1, [r3, #2]
   1c50c:	0209      	lsls	r1, r1, #8
   1c50e:	430a      	orrs	r2, r1
   1c510:	78d9      	ldrb	r1, [r3, #3]
   1c512:	0409      	lsls	r1, r1, #16
   1c514:	430a      	orrs	r2, r1
   1c516:	791b      	ldrb	r3, [r3, #4]
   1c518:	061b      	lsls	r3, r3, #24
   1c51a:	4313      	orrs	r3, r2
   1c51c:	d100      	bne.n	1c520 <xCheckPrograms+0x5b8>
   1c51e:	e155      	b.n	1c7cc <xCheckPrograms+0x864>
   if ((xMasterTime>xProgramList[ucIndex].xStartTime) && ((xMasterTime-xProgramList[ucIndex].xStartTime)>=PRGDELTATIME))
   1c520:	230e      	movs	r3, #14
   1c522:	18fb      	adds	r3, r7, r3
   1c524:	781a      	ldrb	r2, [r3, #0]
   1c526:	4922      	ldr	r1, [pc, #136]	; (1c5b0 <xCheckPrograms+0x648>)
   1c528:	0013      	movs	r3, r2
   1c52a:	00db      	lsls	r3, r3, #3
   1c52c:	1a9b      	subs	r3, r3, r2
   1c52e:	00db      	lsls	r3, r3, #3
   1c530:	189b      	adds	r3, r3, r2
   1c532:	18cb      	adds	r3, r1, r3
   1c534:	3310      	adds	r3, #16
   1c536:	785a      	ldrb	r2, [r3, #1]
   1c538:	7899      	ldrb	r1, [r3, #2]
   1c53a:	0209      	lsls	r1, r1, #8
   1c53c:	430a      	orrs	r2, r1
   1c53e:	78d9      	ldrb	r1, [r3, #3]
   1c540:	0409      	lsls	r1, r1, #16
   1c542:	430a      	orrs	r2, r1
   1c544:	791b      	ldrb	r3, [r3, #4]
   1c546:	061b      	lsls	r3, r3, #24
   1c548:	4313      	orrs	r3, r2
   1c54a:	1e1a      	subs	r2, r3, #0
   1c54c:	4b2b      	ldr	r3, [pc, #172]	; (1c5fc <xCheckPrograms+0x694>)
   1c54e:	681b      	ldr	r3, [r3, #0]
   1c550:	429a      	cmp	r2, r3
   1c552:	db00      	blt.n	1c556 <xCheckPrograms+0x5ee>
   1c554:	e13b      	b.n	1c7ce <xCheckPrograms+0x866>
   1c556:	4b29      	ldr	r3, [pc, #164]	; (1c5fc <xCheckPrograms+0x694>)
   1c558:	6819      	ldr	r1, [r3, #0]
   1c55a:	230e      	movs	r3, #14
   1c55c:	18fb      	adds	r3, r7, r3
   1c55e:	781a      	ldrb	r2, [r3, #0]
   1c560:	4813      	ldr	r0, [pc, #76]	; (1c5b0 <xCheckPrograms+0x648>)
   1c562:	0013      	movs	r3, r2
   1c564:	00db      	lsls	r3, r3, #3
   1c566:	1a9b      	subs	r3, r3, r2
   1c568:	00db      	lsls	r3, r3, #3
   1c56a:	189b      	adds	r3, r3, r2
   1c56c:	18c3      	adds	r3, r0, r3
   1c56e:	3310      	adds	r3, #16
   1c570:	785a      	ldrb	r2, [r3, #1]
   1c572:	7898      	ldrb	r0, [r3, #2]
   1c574:	0200      	lsls	r0, r0, #8
   1c576:	4302      	orrs	r2, r0
   1c578:	78d8      	ldrb	r0, [r3, #3]
   1c57a:	0400      	lsls	r0, r0, #16
   1c57c:	4302      	orrs	r2, r0
   1c57e:	791b      	ldrb	r3, [r3, #4]
   1c580:	061b      	lsls	r3, r3, #24
   1c582:	4313      	orrs	r3, r2
   1c584:	1acb      	subs	r3, r1, r3
   1c586:	2b09      	cmp	r3, #9
   1c588:	dc00      	bgt.n	1c58c <xCheckPrograms+0x624>
   1c58a:	e120      	b.n	1c7ce <xCheckPrograms+0x866>
   {
    switch (xProgramList[ucIndex].xProgramType)
   1c58c:	230e      	movs	r3, #14
   1c58e:	18fb      	adds	r3, r7, r3
   1c590:	781a      	ldrb	r2, [r3, #0]
   1c592:	4907      	ldr	r1, [pc, #28]	; (1c5b0 <xCheckPrograms+0x648>)
   1c594:	0013      	movs	r3, r2
   1c596:	00db      	lsls	r3, r3, #3
   1c598:	1a9b      	subs	r3, r3, r2
   1c59a:	00db      	lsls	r3, r3, #3
   1c59c:	189b      	adds	r3, r3, r2
   1c59e:	5c5b      	ldrb	r3, [r3, r1]
   1c5a0:	2b01      	cmp	r3, #1
   1c5a2:	d033      	beq.n	1c60c <xCheckPrograms+0x6a4>
   1c5a4:	dc2c      	bgt.n	1c600 <xCheckPrograms+0x698>
   1c5a6:	2b00      	cmp	r3, #0
   1c5a8:	d100      	bne.n	1c5ac <xCheckPrograms+0x644>
   1c5aa:	e0c7      	b.n	1c73c <xCheckPrograms+0x7d4>
   1c5ac:	e0e2      	b.n	1c774 <xCheckPrograms+0x80c>
   1c5ae:	46c0      	nop			; (mov r8, r8)
   1c5b0:	200046ec 	.word	0x200046ec
   1c5b4:	20003e10 	.word	0x20003e10
   1c5b8:	00015180 	.word	0x00015180
   1c5bc:	20004a72 	.word	0x20004a72
   1c5c0:	0001bea9 	.word	0x0001bea9
   1c5c4:	20004a5c 	.word	0x20004a5c
   1c5c8:	20003e48 	.word	0x20003e48
   1c5cc:	0001d485 	.word	0x0001d485
   1c5d0:	00021cd8 	.word	0x00021cd8
   1c5d4:	2000449c 	.word	0x2000449c
   1c5d8:	00019b09 	.word	0x00019b09
   1c5dc:	0001a5ed 	.word	0x0001a5ed
   1c5e0:	0001a101 	.word	0x0001a101
   1c5e4:	0001a595 	.word	0x0001a595
   1c5e8:	00021cf8 	.word	0x00021cf8
   1c5ec:	00021d70 	.word	0x00021d70
   1c5f0:	20004480 	.word	0x20004480
   1c5f4:	0001f4a9 	.word	0x0001f4a9
   1c5f8:	0001a88d 	.word	0x0001a88d
   1c5fc:	200049e0 	.word	0x200049e0
   1c600:	2b02      	cmp	r3, #2
   1c602:	d100      	bne.n	1c606 <xCheckPrograms+0x69e>
   1c604:	e09a      	b.n	1c73c <xCheckPrograms+0x7d4>
   1c606:	2b03      	cmp	r3, #3
   1c608:	d04c      	beq.n	1c6a4 <xCheckPrograms+0x73c>
   1c60a:	e0b3      	b.n	1c774 <xCheckPrograms+0x80c>
	{
	 case P_WEEK: xProgramList[ucIndex].xStartTime+=24*3600*7;break;
   1c60c:	230e      	movs	r3, #14
   1c60e:	18fb      	adds	r3, r7, r3
   1c610:	7819      	ldrb	r1, [r3, #0]
   1c612:	230e      	movs	r3, #14
   1c614:	18fb      	adds	r3, r7, r3
   1c616:	781a      	ldrb	r2, [r3, #0]
   1c618:	4876      	ldr	r0, [pc, #472]	; (1c7f4 <xCheckPrograms+0x88c>)
   1c61a:	0013      	movs	r3, r2
   1c61c:	00db      	lsls	r3, r3, #3
   1c61e:	1a9b      	subs	r3, r3, r2
   1c620:	00db      	lsls	r3, r3, #3
   1c622:	189b      	adds	r3, r3, r2
   1c624:	18c3      	adds	r3, r0, r3
   1c626:	3310      	adds	r3, #16
   1c628:	785a      	ldrb	r2, [r3, #1]
   1c62a:	7898      	ldrb	r0, [r3, #2]
   1c62c:	0200      	lsls	r0, r0, #8
   1c62e:	4302      	orrs	r2, r0
   1c630:	78d8      	ldrb	r0, [r3, #3]
   1c632:	0400      	lsls	r0, r0, #16
   1c634:	4302      	orrs	r2, r0
   1c636:	791b      	ldrb	r3, [r3, #4]
   1c638:	061b      	lsls	r3, r3, #24
   1c63a:	4313      	orrs	r3, r2
   1c63c:	4a6e      	ldr	r2, [pc, #440]	; (1c7f8 <xCheckPrograms+0x890>)
   1c63e:	189a      	adds	r2, r3, r2
   1c640:	486c      	ldr	r0, [pc, #432]	; (1c7f4 <xCheckPrograms+0x88c>)
   1c642:	000b      	movs	r3, r1
   1c644:	00db      	lsls	r3, r3, #3
   1c646:	1a5b      	subs	r3, r3, r1
   1c648:	00db      	lsls	r3, r3, #3
   1c64a:	185b      	adds	r3, r3, r1
   1c64c:	18c3      	adds	r3, r0, r3
   1c64e:	3310      	adds	r3, #16
   1c650:	3301      	adds	r3, #1
   1c652:	21ff      	movs	r1, #255	; 0xff
   1c654:	4011      	ands	r1, r2
   1c656:	000c      	movs	r4, r1
   1c658:	7819      	ldrb	r1, [r3, #0]
   1c65a:	2000      	movs	r0, #0
   1c65c:	4001      	ands	r1, r0
   1c65e:	1c08      	adds	r0, r1, #0
   1c660:	1c21      	adds	r1, r4, #0
   1c662:	4301      	orrs	r1, r0
   1c664:	7019      	strb	r1, [r3, #0]
   1c666:	0a11      	lsrs	r1, r2, #8
   1c668:	20ff      	movs	r0, #255	; 0xff
   1c66a:	4001      	ands	r1, r0
   1c66c:	000c      	movs	r4, r1
   1c66e:	7859      	ldrb	r1, [r3, #1]
   1c670:	2000      	movs	r0, #0
   1c672:	4001      	ands	r1, r0
   1c674:	1c08      	adds	r0, r1, #0
   1c676:	1c21      	adds	r1, r4, #0
   1c678:	4301      	orrs	r1, r0
   1c67a:	7059      	strb	r1, [r3, #1]
   1c67c:	0c11      	lsrs	r1, r2, #16
   1c67e:	20ff      	movs	r0, #255	; 0xff
   1c680:	4001      	ands	r1, r0
   1c682:	000c      	movs	r4, r1
   1c684:	7899      	ldrb	r1, [r3, #2]
   1c686:	2000      	movs	r0, #0
   1c688:	4001      	ands	r1, r0
   1c68a:	1c08      	adds	r0, r1, #0
   1c68c:	1c21      	adds	r1, r4, #0
   1c68e:	4301      	orrs	r1, r0
   1c690:	7099      	strb	r1, [r3, #2]
   1c692:	0e10      	lsrs	r0, r2, #24
   1c694:	78da      	ldrb	r2, [r3, #3]
   1c696:	2100      	movs	r1, #0
   1c698:	400a      	ands	r2, r1
   1c69a:	1c11      	adds	r1, r2, #0
   1c69c:	1c02      	adds	r2, r0, #0
   1c69e:	430a      	orrs	r2, r1
   1c6a0:	70da      	strb	r2, [r3, #3]
   1c6a2:	e067      	b.n	1c774 <xCheckPrograms+0x80c>
	 case P_DAY:  xProgramList[ucIndex].xStartTime+=24*3600;break;
   1c6a4:	230e      	movs	r3, #14
   1c6a6:	18fb      	adds	r3, r7, r3
   1c6a8:	7819      	ldrb	r1, [r3, #0]
   1c6aa:	230e      	movs	r3, #14
   1c6ac:	18fb      	adds	r3, r7, r3
   1c6ae:	781a      	ldrb	r2, [r3, #0]
   1c6b0:	4850      	ldr	r0, [pc, #320]	; (1c7f4 <xCheckPrograms+0x88c>)
   1c6b2:	0013      	movs	r3, r2
   1c6b4:	00db      	lsls	r3, r3, #3
   1c6b6:	1a9b      	subs	r3, r3, r2
   1c6b8:	00db      	lsls	r3, r3, #3
   1c6ba:	189b      	adds	r3, r3, r2
   1c6bc:	18c3      	adds	r3, r0, r3
   1c6be:	3310      	adds	r3, #16
   1c6c0:	785a      	ldrb	r2, [r3, #1]
   1c6c2:	7898      	ldrb	r0, [r3, #2]
   1c6c4:	0200      	lsls	r0, r0, #8
   1c6c6:	4302      	orrs	r2, r0
   1c6c8:	78d8      	ldrb	r0, [r3, #3]
   1c6ca:	0400      	lsls	r0, r0, #16
   1c6cc:	4302      	orrs	r2, r0
   1c6ce:	791b      	ldrb	r3, [r3, #4]
   1c6d0:	061b      	lsls	r3, r3, #24
   1c6d2:	4313      	orrs	r3, r2
   1c6d4:	4a49      	ldr	r2, [pc, #292]	; (1c7fc <xCheckPrograms+0x894>)
   1c6d6:	189a      	adds	r2, r3, r2
   1c6d8:	4846      	ldr	r0, [pc, #280]	; (1c7f4 <xCheckPrograms+0x88c>)
   1c6da:	000b      	movs	r3, r1
   1c6dc:	00db      	lsls	r3, r3, #3
   1c6de:	1a5b      	subs	r3, r3, r1
   1c6e0:	00db      	lsls	r3, r3, #3
   1c6e2:	185b      	adds	r3, r3, r1
   1c6e4:	18c3      	adds	r3, r0, r3
   1c6e6:	3310      	adds	r3, #16
   1c6e8:	3301      	adds	r3, #1
   1c6ea:	21ff      	movs	r1, #255	; 0xff
   1c6ec:	4011      	ands	r1, r2
   1c6ee:	000c      	movs	r4, r1
   1c6f0:	7819      	ldrb	r1, [r3, #0]
   1c6f2:	2000      	movs	r0, #0
   1c6f4:	4001      	ands	r1, r0
   1c6f6:	1c08      	adds	r0, r1, #0
   1c6f8:	1c21      	adds	r1, r4, #0
   1c6fa:	4301      	orrs	r1, r0
   1c6fc:	7019      	strb	r1, [r3, #0]
   1c6fe:	0a11      	lsrs	r1, r2, #8
   1c700:	20ff      	movs	r0, #255	; 0xff
   1c702:	4001      	ands	r1, r0
   1c704:	000c      	movs	r4, r1
   1c706:	7859      	ldrb	r1, [r3, #1]
   1c708:	2000      	movs	r0, #0
   1c70a:	4001      	ands	r1, r0
   1c70c:	1c08      	adds	r0, r1, #0
   1c70e:	1c21      	adds	r1, r4, #0
   1c710:	4301      	orrs	r1, r0
   1c712:	7059      	strb	r1, [r3, #1]
   1c714:	0c11      	lsrs	r1, r2, #16
   1c716:	20ff      	movs	r0, #255	; 0xff
   1c718:	4001      	ands	r1, r0
   1c71a:	000c      	movs	r4, r1
   1c71c:	7899      	ldrb	r1, [r3, #2]
   1c71e:	2000      	movs	r0, #0
   1c720:	4001      	ands	r1, r0
   1c722:	1c08      	adds	r0, r1, #0
   1c724:	1c21      	adds	r1, r4, #0
   1c726:	4301      	orrs	r1, r0
   1c728:	7099      	strb	r1, [r3, #2]
   1c72a:	0e10      	lsrs	r0, r2, #24
   1c72c:	78da      	ldrb	r2, [r3, #3]
   1c72e:	2100      	movs	r1, #0
   1c730:	400a      	ands	r2, r1
   1c732:	1c11      	adds	r1, r2, #0
   1c734:	1c02      	adds	r2, r0, #0
   1c736:	430a      	orrs	r2, r1
   1c738:	70da      	strb	r2, [r3, #3]
   1c73a:	e01b      	b.n	1c774 <xCheckPrograms+0x80c>
	 case P_STD:
	 case P_WASH: xProgramList[ucIndex].xStartTime=0;
   1c73c:	230e      	movs	r3, #14
   1c73e:	18fb      	adds	r3, r7, r3
   1c740:	781a      	ldrb	r2, [r3, #0]
   1c742:	492c      	ldr	r1, [pc, #176]	; (1c7f4 <xCheckPrograms+0x88c>)
   1c744:	0013      	movs	r3, r2
   1c746:	00db      	lsls	r3, r3, #3
   1c748:	1a9b      	subs	r3, r3, r2
   1c74a:	00db      	lsls	r3, r3, #3
   1c74c:	189b      	adds	r3, r3, r2
   1c74e:	18cb      	adds	r3, r1, r3
   1c750:	3310      	adds	r3, #16
   1c752:	3301      	adds	r3, #1
   1c754:	781a      	ldrb	r2, [r3, #0]
   1c756:	2100      	movs	r1, #0
   1c758:	400a      	ands	r2, r1
   1c75a:	701a      	strb	r2, [r3, #0]
   1c75c:	785a      	ldrb	r2, [r3, #1]
   1c75e:	2100      	movs	r1, #0
   1c760:	400a      	ands	r2, r1
   1c762:	705a      	strb	r2, [r3, #1]
   1c764:	789a      	ldrb	r2, [r3, #2]
   1c766:	2100      	movs	r1, #0
   1c768:	400a      	ands	r2, r1
   1c76a:	709a      	strb	r2, [r3, #2]
   1c76c:	78da      	ldrb	r2, [r3, #3]
   1c76e:	2100      	movs	r1, #0
   1c770:	400a      	ands	r2, r1
   1c772:	70da      	strb	r2, [r3, #3]
	}
		 
	f_open(&file_object,"0:/PrgList.bin",FA_WRITE);
   1c774:	4922      	ldr	r1, [pc, #136]	; (1c800 <xCheckPrograms+0x898>)
   1c776:	4b23      	ldr	r3, [pc, #140]	; (1c804 <xCheckPrograms+0x89c>)
   1c778:	2202      	movs	r2, #2
   1c77a:	0018      	movs	r0, r3
   1c77c:	4b22      	ldr	r3, [pc, #136]	; (1c808 <xCheckPrograms+0x8a0>)
   1c77e:	4798      	blx	r3
	f_lseek(&file_object,sizeof(xProgram)*ucIndex);
   1c780:	230e      	movs	r3, #14
   1c782:	18fb      	adds	r3, r7, r3
   1c784:	781a      	ldrb	r2, [r3, #0]
   1c786:	0013      	movs	r3, r2
   1c788:	00db      	lsls	r3, r3, #3
   1c78a:	1a9b      	subs	r3, r3, r2
   1c78c:	00db      	lsls	r3, r3, #3
   1c78e:	189a      	adds	r2, r3, r2
   1c790:	4b1c      	ldr	r3, [pc, #112]	; (1c804 <xCheckPrograms+0x89c>)
   1c792:	0011      	movs	r1, r2
   1c794:	0018      	movs	r0, r3
   1c796:	4b1d      	ldr	r3, [pc, #116]	; (1c80c <xCheckPrograms+0x8a4>)
   1c798:	4798      	blx	r3
	result=f_write(&file_object,&xProgramList[ucIndex],sizeof(xProgram),&uSize);
   1c79a:	230e      	movs	r3, #14
   1c79c:	18fb      	adds	r3, r7, r3
   1c79e:	781a      	ldrb	r2, [r3, #0]
   1c7a0:	0013      	movs	r3, r2
   1c7a2:	00db      	lsls	r3, r3, #3
   1c7a4:	1a9b      	subs	r3, r3, r2
   1c7a6:	00db      	lsls	r3, r3, #3
   1c7a8:	189b      	adds	r3, r3, r2
   1c7aa:	4a12      	ldr	r2, [pc, #72]	; (1c7f4 <xCheckPrograms+0x88c>)
   1c7ac:	1899      	adds	r1, r3, r2
   1c7ae:	230d      	movs	r3, #13
   1c7b0:	18fc      	adds	r4, r7, r3
   1c7b2:	2308      	movs	r3, #8
   1c7b4:	18fb      	adds	r3, r7, r3
   1c7b6:	4813      	ldr	r0, [pc, #76]	; (1c804 <xCheckPrograms+0x89c>)
   1c7b8:	2239      	movs	r2, #57	; 0x39
   1c7ba:	4d15      	ldr	r5, [pc, #84]	; (1c810 <xCheckPrograms+0x8a8>)
   1c7bc:	47a8      	blx	r5
   1c7be:	0003      	movs	r3, r0
   1c7c0:	7023      	strb	r3, [r4, #0]
	f_close(&file_object);	 
   1c7c2:	4b10      	ldr	r3, [pc, #64]	; (1c804 <xCheckPrograms+0x89c>)
   1c7c4:	0018      	movs	r0, r3
   1c7c6:	4b13      	ldr	r3, [pc, #76]	; (1c814 <xCheckPrograms+0x8ac>)
   1c7c8:	4798      	blx	r3
   1c7ca:	e000      	b.n	1c7ce <xCheckPrograms+0x866>
 
 //controlla se seve aggiornare i programmi week o day nel caso la macchina fosse spenta
 for (uint8_t ucIndex=0;ucIndex<MAX_PRG;ucIndex++)
 if ((xProgramList[ucIndex].xProgramType==P_WEEK) || (xProgramList[ucIndex].xProgramType==P_DAY))
 {
   if ((xProgramList[ucIndex].xProgramType==P_OFF) || (!xProgramList[ucIndex].xStartTime)) continue;	
   1c7cc:	46c0      	nop			; (mov r8, r8)
  }
  
 }
 
 //controlla se seve aggiornare i programmi week o day nel caso la macchina fosse spenta
 for (uint8_t ucIndex=0;ucIndex<MAX_PRG;ucIndex++)
   1c7ce:	230e      	movs	r3, #14
   1c7d0:	18fb      	adds	r3, r7, r3
   1c7d2:	781a      	ldrb	r2, [r3, #0]
   1c7d4:	230e      	movs	r3, #14
   1c7d6:	18fb      	adds	r3, r7, r3
   1c7d8:	3201      	adds	r2, #1
   1c7da:	701a      	strb	r2, [r3, #0]
   1c7dc:	230e      	movs	r3, #14
   1c7de:	18fb      	adds	r3, r7, r3
   1c7e0:	781b      	ldrb	r3, [r3, #0]
   1c7e2:	2b09      	cmp	r3, #9
   1c7e4:	d800      	bhi.n	1c7e8 <xCheckPrograms+0x880>
   1c7e6:	e65e      	b.n	1c4a6 <xCheckPrograms+0x53e>
	result=f_write(&file_object,&xProgramList[ucIndex],sizeof(xProgram),&uSize);
	f_close(&file_object);	 
   }
 } 
	
 return false;
   1c7e8:	2300      	movs	r3, #0
 
}
   1c7ea:	0018      	movs	r0, r3
   1c7ec:	46bd      	mov	sp, r7
   1c7ee:	b004      	add	sp, #16
   1c7f0:	bdb0      	pop	{r4, r5, r7, pc}
   1c7f2:	46c0      	nop			; (mov r8, r8)
   1c7f4:	200046ec 	.word	0x200046ec
   1c7f8:	00093a80 	.word	0x00093a80
   1c7fc:	00015180 	.word	0x00015180
   1c800:	00021cd8 	.word	0x00021cd8
   1c804:	2000449c 	.word	0x2000449c
   1c808:	00019b09 	.word	0x00019b09
   1c80c:	0001a5ed 	.word	0x0001a5ed
   1c810:	0001a101 	.word	0x0001a101
   1c814:	0001a595 	.word	0x0001a595

0001c818 <vWriteLog>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void vWriteLog(time_t xETime)
{
   1c818:	b5b0      	push	{r4, r5, r7, lr}
   1c81a:	b088      	sub	sp, #32
   1c81c:	af00      	add	r7, sp, #0
   1c81e:	6078      	str	r0, [r7, #4]
 UINT uSize;
 DRESULT result;
 xLogData xTempLogData;
 static time_t LastRecTime=0;
 
 if (!(xETime % xProgramList[ucActiveIndex].usTr))	
   1c820:	4b56      	ldr	r3, [pc, #344]	; (1c97c <vWriteLog+0x164>)
   1c822:	781b      	ldrb	r3, [r3, #0]
   1c824:	001a      	movs	r2, r3
   1c826:	4956      	ldr	r1, [pc, #344]	; (1c980 <vWriteLog+0x168>)
   1c828:	0013      	movs	r3, r2
   1c82a:	00db      	lsls	r3, r3, #3
   1c82c:	1a9b      	subs	r3, r3, r2
   1c82e:	00db      	lsls	r3, r3, #3
   1c830:	189b      	adds	r3, r3, r2
   1c832:	18cb      	adds	r3, r1, r3
   1c834:	3318      	adds	r3, #24
   1c836:	795a      	ldrb	r2, [r3, #5]
   1c838:	799b      	ldrb	r3, [r3, #6]
   1c83a:	021b      	lsls	r3, r3, #8
   1c83c:	4313      	orrs	r3, r2
   1c83e:	b29b      	uxth	r3, r3
   1c840:	0019      	movs	r1, r3
   1c842:	687a      	ldr	r2, [r7, #4]
   1c844:	4b4f      	ldr	r3, [pc, #316]	; (1c984 <vWriteLog+0x16c>)
   1c846:	0010      	movs	r0, r2
   1c848:	4798      	blx	r3
   1c84a:	1e0b      	subs	r3, r1, #0
   1c84c:	d000      	beq.n	1c850 <vWriteLog+0x38>
   1c84e:	e092      	b.n	1c976 <vWriteLog+0x15e>
 {
  if (LastRecTime==xETime) return;
   1c850:	4b4d      	ldr	r3, [pc, #308]	; (1c988 <vWriteLog+0x170>)
   1c852:	681a      	ldr	r2, [r3, #0]
   1c854:	687b      	ldr	r3, [r7, #4]
   1c856:	429a      	cmp	r2, r3
   1c858:	d100      	bne.n	1c85c <vWriteLog+0x44>
   1c85a:	e08b      	b.n	1c974 <vWriteLog+0x15c>
  LastRecTime=xETime;
   1c85c:	4b4a      	ldr	r3, [pc, #296]	; (1c988 <vWriteLog+0x170>)
   1c85e:	687a      	ldr	r2, [r7, #4]
   1c860:	601a      	str	r2, [r3, #0]
  xTempLogData.xDateTime=xMasterTime;
   1c862:	4b4a      	ldr	r3, [pc, #296]	; (1c98c <vWriteLog+0x174>)
   1c864:	681a      	ldr	r2, [r3, #0]
   1c866:	2308      	movs	r3, #8
   1c868:	18fb      	adds	r3, r7, r3
   1c86a:	601a      	str	r2, [r3, #0]
  xTempLogData.xMachineState=xMachineState;
   1c86c:	4b48      	ldr	r3, [pc, #288]	; (1c990 <vWriteLog+0x178>)
   1c86e:	781a      	ldrb	r2, [r3, #0]
   1c870:	2308      	movs	r3, #8
   1c872:	18fb      	adds	r3, r7, r3
   1c874:	711a      	strb	r2, [r3, #4]
  xTempLogData.usTemp=(uint16_t)(T*10);
   1c876:	4b47      	ldr	r3, [pc, #284]	; (1c994 <vWriteLog+0x17c>)
   1c878:	681a      	ldr	r2, [r3, #0]
   1c87a:	4b47      	ldr	r3, [pc, #284]	; (1c998 <vWriteLog+0x180>)
   1c87c:	4947      	ldr	r1, [pc, #284]	; (1c99c <vWriteLog+0x184>)
   1c87e:	1c10      	adds	r0, r2, #0
   1c880:	4798      	blx	r3
   1c882:	1c03      	adds	r3, r0, #0
   1c884:	1c1a      	adds	r2, r3, #0
   1c886:	4b46      	ldr	r3, [pc, #280]	; (1c9a0 <vWriteLog+0x188>)
   1c888:	1c10      	adds	r0, r2, #0
   1c88a:	4798      	blx	r3
   1c88c:	0003      	movs	r3, r0
   1c88e:	b29a      	uxth	r2, r3
   1c890:	2308      	movs	r3, #8
   1c892:	18fb      	adds	r3, r7, r3
   1c894:	3305      	adds	r3, #5
   1c896:	21ff      	movs	r1, #255	; 0xff
   1c898:	4011      	ands	r1, r2
   1c89a:	000c      	movs	r4, r1
   1c89c:	7819      	ldrb	r1, [r3, #0]
   1c89e:	2000      	movs	r0, #0
   1c8a0:	4001      	ands	r1, r0
   1c8a2:	1c08      	adds	r0, r1, #0
   1c8a4:	1c21      	adds	r1, r4, #0
   1c8a6:	4301      	orrs	r1, r0
   1c8a8:	7019      	strb	r1, [r3, #0]
   1c8aa:	0a12      	lsrs	r2, r2, #8
   1c8ac:	b290      	uxth	r0, r2
   1c8ae:	785a      	ldrb	r2, [r3, #1]
   1c8b0:	2100      	movs	r1, #0
   1c8b2:	400a      	ands	r2, r1
   1c8b4:	1c11      	adds	r1, r2, #0
   1c8b6:	1c02      	adds	r2, r0, #0
   1c8b8:	430a      	orrs	r2, r1
   1c8ba:	705a      	strb	r2, [r3, #1]
  xTempLogData.usH=(uint16_t)(H*10);
   1c8bc:	4b39      	ldr	r3, [pc, #228]	; (1c9a4 <vWriteLog+0x18c>)
   1c8be:	681a      	ldr	r2, [r3, #0]
   1c8c0:	4b35      	ldr	r3, [pc, #212]	; (1c998 <vWriteLog+0x180>)
   1c8c2:	4936      	ldr	r1, [pc, #216]	; (1c99c <vWriteLog+0x184>)
   1c8c4:	1c10      	adds	r0, r2, #0
   1c8c6:	4798      	blx	r3
   1c8c8:	1c03      	adds	r3, r0, #0
   1c8ca:	1c1a      	adds	r2, r3, #0
   1c8cc:	4b34      	ldr	r3, [pc, #208]	; (1c9a0 <vWriteLog+0x188>)
   1c8ce:	1c10      	adds	r0, r2, #0
   1c8d0:	4798      	blx	r3
   1c8d2:	0003      	movs	r3, r0
   1c8d4:	b29a      	uxth	r2, r3
   1c8d6:	2308      	movs	r3, #8
   1c8d8:	18fb      	adds	r3, r7, r3
   1c8da:	3307      	adds	r3, #7
   1c8dc:	21ff      	movs	r1, #255	; 0xff
   1c8de:	4011      	ands	r1, r2
   1c8e0:	000c      	movs	r4, r1
   1c8e2:	7819      	ldrb	r1, [r3, #0]
   1c8e4:	2000      	movs	r0, #0
   1c8e6:	4001      	ands	r1, r0
   1c8e8:	1c08      	adds	r0, r1, #0
   1c8ea:	1c21      	adds	r1, r4, #0
   1c8ec:	4301      	orrs	r1, r0
   1c8ee:	7019      	strb	r1, [r3, #0]
   1c8f0:	0a12      	lsrs	r2, r2, #8
   1c8f2:	b290      	uxth	r0, r2
   1c8f4:	785a      	ldrb	r2, [r3, #1]
   1c8f6:	2100      	movs	r1, #0
   1c8f8:	400a      	ands	r2, r1
   1c8fa:	1c11      	adds	r1, r2, #0
   1c8fc:	1c02      	adds	r2, r0, #0
   1c8fe:	430a      	orrs	r2, r1
   1c900:	705a      	strb	r2, [r3, #1]
  xTempLogData.usWRKTime=0x00;
   1c902:	2308      	movs	r3, #8
   1c904:	18fb      	adds	r3, r7, r3
   1c906:	3309      	adds	r3, #9
   1c908:	781a      	ldrb	r2, [r3, #0]
   1c90a:	2100      	movs	r1, #0
   1c90c:	400a      	ands	r2, r1
   1c90e:	701a      	strb	r2, [r3, #0]
   1c910:	785a      	ldrb	r2, [r3, #1]
   1c912:	2100      	movs	r1, #0
   1c914:	400a      	ands	r2, r1
   1c916:	705a      	strb	r2, [r3, #1]
  memset(&xTempLogData.ucSpare,0x00,sizeof(xTempLogData.ucSpare));
   1c918:	2308      	movs	r3, #8
   1c91a:	18fb      	adds	r3, r7, r3
   1c91c:	330b      	adds	r3, #11
   1c91e:	2205      	movs	r2, #5
   1c920:	2100      	movs	r1, #0
   1c922:	0018      	movs	r0, r3
   1c924:	4b20      	ldr	r3, [pc, #128]	; (1c9a8 <vWriteLog+0x190>)
   1c926:	4798      	blx	r3

  sprintf(TempString,"0:/Logs/Log%03d.bin",ucLogPos);
   1c928:	4b20      	ldr	r3, [pc, #128]	; (1c9ac <vWriteLog+0x194>)
   1c92a:	781b      	ldrb	r3, [r3, #0]
   1c92c:	001a      	movs	r2, r3
   1c92e:	4920      	ldr	r1, [pc, #128]	; (1c9b0 <vWriteLog+0x198>)
   1c930:	4b20      	ldr	r3, [pc, #128]	; (1c9b4 <vWriteLog+0x19c>)
   1c932:	0018      	movs	r0, r3
   1c934:	4b20      	ldr	r3, [pc, #128]	; (1c9b8 <vWriteLog+0x1a0>)
   1c936:	4798      	blx	r3
  f_open(&file_object,TempString,FA_WRITE);
   1c938:	491e      	ldr	r1, [pc, #120]	; (1c9b4 <vWriteLog+0x19c>)
   1c93a:	4b20      	ldr	r3, [pc, #128]	; (1c9bc <vWriteLog+0x1a4>)
   1c93c:	2202      	movs	r2, #2
   1c93e:	0018      	movs	r0, r3
   1c940:	4b1f      	ldr	r3, [pc, #124]	; (1c9c0 <vWriteLog+0x1a8>)
   1c942:	4798      	blx	r3
  f_lseek(&file_object,f_size(&file_object));
   1c944:	4b1d      	ldr	r3, [pc, #116]	; (1c9bc <vWriteLog+0x1a4>)
   1c946:	68da      	ldr	r2, [r3, #12]
   1c948:	4b1c      	ldr	r3, [pc, #112]	; (1c9bc <vWriteLog+0x1a4>)
   1c94a:	0011      	movs	r1, r2
   1c94c:	0018      	movs	r0, r3
   1c94e:	4b1d      	ldr	r3, [pc, #116]	; (1c9c4 <vWriteLog+0x1ac>)
   1c950:	4798      	blx	r3
  result=f_write(&file_object,&xTempLogData,sizeof(xLogData),&uSize);
   1c952:	231f      	movs	r3, #31
   1c954:	18fc      	adds	r4, r7, r3
   1c956:	2318      	movs	r3, #24
   1c958:	18fb      	adds	r3, r7, r3
   1c95a:	2208      	movs	r2, #8
   1c95c:	18b9      	adds	r1, r7, r2
   1c95e:	4817      	ldr	r0, [pc, #92]	; (1c9bc <vWriteLog+0x1a4>)
   1c960:	2210      	movs	r2, #16
   1c962:	4d19      	ldr	r5, [pc, #100]	; (1c9c8 <vWriteLog+0x1b0>)
   1c964:	47a8      	blx	r5
   1c966:	0003      	movs	r3, r0
   1c968:	7023      	strb	r3, [r4, #0]
  f_close(&file_object);	  
   1c96a:	4b14      	ldr	r3, [pc, #80]	; (1c9bc <vWriteLog+0x1a4>)
   1c96c:	0018      	movs	r0, r3
   1c96e:	4b17      	ldr	r3, [pc, #92]	; (1c9cc <vWriteLog+0x1b4>)
   1c970:	4798      	blx	r3
   1c972:	e000      	b.n	1c976 <vWriteLog+0x15e>
 xLogData xTempLogData;
 static time_t LastRecTime=0;
 
 if (!(xETime % xProgramList[ucActiveIndex].usTr))	
 {
  if (LastRecTime==xETime) return;
   1c974:	46c0      	nop			; (mov r8, r8)
  f_lseek(&file_object,f_size(&file_object));
  result=f_write(&file_object,&xTempLogData,sizeof(xLogData),&uSize);
  f_close(&file_object);	  
 }
	
}
   1c976:	46bd      	mov	sp, r7
   1c978:	b008      	add	sp, #32
   1c97a:	bdb0      	pop	{r4, r5, r7, pc}
   1c97c:	20004bd4 	.word	0x20004bd4
   1c980:	200046ec 	.word	0x200046ec
   1c984:	0001d765 	.word	0x0001d765
   1c988:	20003090 	.word	0x20003090
   1c98c:	200049e0 	.word	0x200049e0
   1c990:	20004aa4 	.word	0x20004aa4
   1c994:	20004be0 	.word	0x20004be0
   1c998:	0001dca5 	.word	0x0001dca5
   1c99c:	41200000 	.word	0x41200000
   1c9a0:	0001d809 	.word	0x0001d809
   1c9a4:	20004de4 	.word	0x20004de4
   1c9a8:	0001eead 	.word	0x0001eead
   1c9ac:	20004a5c 	.word	0x20004a5c
   1c9b0:	00021d70 	.word	0x00021d70
   1c9b4:	20004480 	.word	0x20004480
   1c9b8:	0001f4a9 	.word	0x0001f4a9
   1c9bc:	2000449c 	.word	0x2000449c
   1c9c0:	00019b09 	.word	0x00019b09
   1c9c4:	0001a5ed 	.word	0x0001a5ed
   1c9c8:	0001a101 	.word	0x0001a101
   1c9cc:	0001a595 	.word	0x0001a595

0001c9d0 <vDecreaseTime>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


static void vDecreaseTime(time_t xETime)
{
   1c9d0:	b5b0      	push	{r4, r5, r7, lr}
   1c9d2:	b084      	sub	sp, #16
   1c9d4:	af00      	add	r7, sp, #0
   1c9d6:	6078      	str	r0, [r7, #4]
 UINT uSize;
 DRESULT result;	
	
 if (!(xETime % 60))	
   1c9d8:	687a      	ldr	r2, [r7, #4]
   1c9da:	4b16      	ldr	r3, [pc, #88]	; (1ca34 <vDecreaseTime+0x64>)
   1c9dc:	213c      	movs	r1, #60	; 0x3c
   1c9de:	0010      	movs	r0, r2
   1c9e0:	4798      	blx	r3
   1c9e2:	1e0b      	subs	r3, r1, #0
   1c9e4:	d121      	bne.n	1ca2a <vDecreaseTime+0x5a>
 {
  if (ulMachineWorkTime) 
   1c9e6:	4b14      	ldr	r3, [pc, #80]	; (1ca38 <vDecreaseTime+0x68>)
   1c9e8:	681b      	ldr	r3, [r3, #0]
   1c9ea:	2b00      	cmp	r3, #0
   1c9ec:	d01a      	beq.n	1ca24 <vDecreaseTime+0x54>
  {
   ulMachineWorkTime--;  
   1c9ee:	4b12      	ldr	r3, [pc, #72]	; (1ca38 <vDecreaseTime+0x68>)
   1c9f0:	681b      	ldr	r3, [r3, #0]
   1c9f2:	1e5a      	subs	r2, r3, #1
   1c9f4:	4b10      	ldr	r3, [pc, #64]	; (1ca38 <vDecreaseTime+0x68>)
   1c9f6:	601a      	str	r2, [r3, #0]
   f_open(&file_object,"0:/RunTime.bin",FA_CREATE_ALWAYS | FA_WRITE);
   1c9f8:	4910      	ldr	r1, [pc, #64]	; (1ca3c <vDecreaseTime+0x6c>)
   1c9fa:	4b11      	ldr	r3, [pc, #68]	; (1ca40 <vDecreaseTime+0x70>)
   1c9fc:	220a      	movs	r2, #10
   1c9fe:	0018      	movs	r0, r3
   1ca00:	4b10      	ldr	r3, [pc, #64]	; (1ca44 <vDecreaseTime+0x74>)
   1ca02:	4798      	blx	r3
   result=f_write(&file_object,&ulMachineWorkTime,sizeof(ulMachineWorkTime),&uSize);
   1ca04:	230f      	movs	r3, #15
   1ca06:	18fc      	adds	r4, r7, r3
   1ca08:	2308      	movs	r3, #8
   1ca0a:	18fb      	adds	r3, r7, r3
   1ca0c:	490a      	ldr	r1, [pc, #40]	; (1ca38 <vDecreaseTime+0x68>)
   1ca0e:	480c      	ldr	r0, [pc, #48]	; (1ca40 <vDecreaseTime+0x70>)
   1ca10:	2204      	movs	r2, #4
   1ca12:	4d0d      	ldr	r5, [pc, #52]	; (1ca48 <vDecreaseTime+0x78>)
   1ca14:	47a8      	blx	r5
   1ca16:	0003      	movs	r3, r0
   1ca18:	7023      	strb	r3, [r4, #0]
   f_close(&file_object);
   1ca1a:	4b09      	ldr	r3, [pc, #36]	; (1ca40 <vDecreaseTime+0x70>)
   1ca1c:	0018      	movs	r0, r3
   1ca1e:	4b0b      	ldr	r3, [pc, #44]	; (1ca4c <vDecreaseTime+0x7c>)
   1ca20:	4798      	blx	r3
  }
  else xMachineState=REVISION;
 }
	
}
   1ca22:	e002      	b.n	1ca2a <vDecreaseTime+0x5a>
   ulMachineWorkTime--;  
   f_open(&file_object,"0:/RunTime.bin",FA_CREATE_ALWAYS | FA_WRITE);
   result=f_write(&file_object,&ulMachineWorkTime,sizeof(ulMachineWorkTime),&uSize);
   f_close(&file_object);
  }
  else xMachineState=REVISION;
   1ca24:	4b0a      	ldr	r3, [pc, #40]	; (1ca50 <vDecreaseTime+0x80>)
   1ca26:	2203      	movs	r2, #3
   1ca28:	701a      	strb	r2, [r3, #0]
 }
	
}
   1ca2a:	46c0      	nop			; (mov r8, r8)
   1ca2c:	46bd      	mov	sp, r7
   1ca2e:	b004      	add	sp, #16
   1ca30:	bdb0      	pop	{r4, r5, r7, pc}
   1ca32:	46c0      	nop			; (mov r8, r8)
   1ca34:	0001d765 	.word	0x0001d765
   1ca38:	20004aa8 	.word	0x20004aa8
   1ca3c:	00021d18 	.word	0x00021d18
   1ca40:	2000449c 	.word	0x2000449c
   1ca44:	00019b09 	.word	0x00019b09
   1ca48:	0001a101 	.word	0x0001a101
   1ca4c:	0001a595 	.word	0x0001a595
   1ca50:	20004aa4 	.word	0x20004aa4

0001ca54 <vCardError>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void vCardError(void)
{
   1ca54:	b580      	push	{r7, lr}
   1ca56:	af00      	add	r7, sp, #0
  memset(LCDData,0x00,sizeof(LCDData));
   1ca58:	4b0b      	ldr	r3, [pc, #44]	; (1ca88 <vCardError+0x34>)
   1ca5a:	2222      	movs	r2, #34	; 0x22
   1ca5c:	2100      	movs	r1, #0
   1ca5e:	0018      	movs	r0, r3
   1ca60:	4b0a      	ldr	r3, [pc, #40]	; (1ca8c <vCardError+0x38>)
   1ca62:	4798      	blx	r3
  sprintf(&LCDData[0][0],LCDlabels[0]);
   1ca64:	4a0a      	ldr	r2, [pc, #40]	; (1ca90 <vCardError+0x3c>)
   1ca66:	4b08      	ldr	r3, [pc, #32]	; (1ca88 <vCardError+0x34>)
   1ca68:	0011      	movs	r1, r2
   1ca6a:	0018      	movs	r0, r3
   1ca6c:	4b09      	ldr	r3, [pc, #36]	; (1ca94 <vCardError+0x40>)
   1ca6e:	4798      	blx	r3
  sprintf(&LCDData[1][0],LCDlabels[1]);
   1ca70:	4a09      	ldr	r2, [pc, #36]	; (1ca98 <vCardError+0x44>)
   1ca72:	4b0a      	ldr	r3, [pc, #40]	; (1ca9c <vCardError+0x48>)
   1ca74:	0011      	movs	r1, r2
   1ca76:	0018      	movs	r0, r3
   1ca78:	4b06      	ldr	r3, [pc, #24]	; (1ca94 <vCardError+0x40>)
   1ca7a:	4798      	blx	r3
  vLCDUpdate();
   1ca7c:	4b08      	ldr	r3, [pc, #32]	; (1caa0 <vCardError+0x4c>)
   1ca7e:	4798      	blx	r3
}
   1ca80:	46c0      	nop			; (mov r8, r8)
   1ca82:	46bd      	mov	sp, r7
   1ca84:	bd80      	pop	{r7, pc}
   1ca86:	46c0      	nop			; (mov r8, r8)
   1ca88:	20004aac 	.word	0x20004aac
   1ca8c:	0001eead 	.word	0x0001eead
   1ca90:	20000054 	.word	0x20000054
   1ca94:	0001f4a9 	.word	0x0001f4a9
   1ca98:	20000074 	.word	0x20000074
   1ca9c:	20004abd 	.word	0x20004abd
   1caa0:	0000d3bd 	.word	0x0000d3bd

0001caa4 <vSTDPRogram>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void vSTDPRogram(void)
{
   1caa4:	b580      	push	{r7, lr}
   1caa6:	af00      	add	r7, sp, #0
	  switch (xProgramSequence)
   1caa8:	4bb5      	ldr	r3, [pc, #724]	; (1cd80 <vSTDPRogram+0x2dc>)
   1caaa:	781b      	ldrb	r3, [r3, #0]
   1caac:	2b04      	cmp	r3, #4
   1caae:	d900      	bls.n	1cab2 <vSTDPRogram+0xe>
   1cab0:	e157      	b.n	1cd62 <vSTDPRogram+0x2be>
   1cab2:	009a      	lsls	r2, r3, #2
   1cab4:	4bb3      	ldr	r3, [pc, #716]	; (1cd84 <vSTDPRogram+0x2e0>)
   1cab6:	18d3      	adds	r3, r2, r3
   1cab8:	681b      	ldr	r3, [r3, #0]
   1caba:	469f      	mov	pc, r3
	  {
	   case TS:
	   
	   if (xElapTime & 0x01) port_pin_set_output_level(RELAY_2,true);
   1cabc:	4bb2      	ldr	r3, [pc, #712]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cabe:	681b      	ldr	r3, [r3, #0]
   1cac0:	2201      	movs	r2, #1
   1cac2:	4013      	ands	r3, r2
   1cac4:	d004      	beq.n	1cad0 <vSTDPRogram+0x2c>
   1cac6:	2101      	movs	r1, #1
   1cac8:	2015      	movs	r0, #21
   1caca:	4bb0      	ldr	r3, [pc, #704]	; (1cd8c <vSTDPRogram+0x2e8>)
   1cacc:	4798      	blx	r3
   1cace:	e003      	b.n	1cad8 <vSTDPRogram+0x34>
	    else port_pin_set_output_level(RELAY_2,false);
   1cad0:	2100      	movs	r1, #0
   1cad2:	2015      	movs	r0, #21
   1cad4:	4bad      	ldr	r3, [pc, #692]	; (1cd8c <vSTDPRogram+0x2e8>)
   1cad6:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/xProgramList[ucActiveIndex].usTs);
   1cad8:	4bab      	ldr	r3, [pc, #684]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cada:	681b      	ldr	r3, [r3, #0]
   1cadc:	2264      	movs	r2, #100	; 0x64
   1cade:	435a      	muls	r2, r3
   1cae0:	0010      	movs	r0, r2
   1cae2:	4bab      	ldr	r3, [pc, #684]	; (1cd90 <vSTDPRogram+0x2ec>)
   1cae4:	781b      	ldrb	r3, [r3, #0]
   1cae6:	001a      	movs	r2, r3
   1cae8:	49aa      	ldr	r1, [pc, #680]	; (1cd94 <vSTDPRogram+0x2f0>)
   1caea:	0013      	movs	r3, r2
   1caec:	00db      	lsls	r3, r3, #3
   1caee:	1a9b      	subs	r3, r3, r2
   1caf0:	00db      	lsls	r3, r3, #3
   1caf2:	189b      	adds	r3, r3, r2
   1caf4:	18cb      	adds	r3, r1, r3
   1caf6:	3310      	adds	r3, #16
   1caf8:	795a      	ldrb	r2, [r3, #5]
   1cafa:	799b      	ldrb	r3, [r3, #6]
   1cafc:	021b      	lsls	r3, r3, #8
   1cafe:	4313      	orrs	r3, r2
   1cb00:	b29b      	uxth	r3, r3
   1cb02:	001a      	movs	r2, r3
   1cb04:	4ba4      	ldr	r3, [pc, #656]	; (1cd98 <vSTDPRogram+0x2f4>)
   1cb06:	0011      	movs	r1, r2
   1cb08:	4798      	blx	r3
   1cb0a:	0003      	movs	r3, r0
   1cb0c:	b2db      	uxtb	r3, r3
   1cb0e:	0018      	movs	r0, r3
   1cb10:	4ba2      	ldr	r3, [pc, #648]	; (1cd9c <vSTDPRogram+0x2f8>)
   1cb12:	4798      	blx	r3
	   
	   if (xElapTime>=xProgramList[ucActiveIndex].usTs) 
   1cb14:	4b9e      	ldr	r3, [pc, #632]	; (1cd90 <vSTDPRogram+0x2ec>)
   1cb16:	781b      	ldrb	r3, [r3, #0]
   1cb18:	001a      	movs	r2, r3
   1cb1a:	499e      	ldr	r1, [pc, #632]	; (1cd94 <vSTDPRogram+0x2f0>)
   1cb1c:	0013      	movs	r3, r2
   1cb1e:	00db      	lsls	r3, r3, #3
   1cb20:	1a9b      	subs	r3, r3, r2
   1cb22:	00db      	lsls	r3, r3, #3
   1cb24:	189b      	adds	r3, r3, r2
   1cb26:	18cb      	adds	r3, r1, r3
   1cb28:	3310      	adds	r3, #16
   1cb2a:	795a      	ldrb	r2, [r3, #5]
   1cb2c:	799b      	ldrb	r3, [r3, #6]
   1cb2e:	021b      	lsls	r3, r3, #8
   1cb30:	4313      	orrs	r3, r2
   1cb32:	b29b      	uxth	r3, r3
   1cb34:	1e1a      	subs	r2, r3, #0
   1cb36:	4b94      	ldr	r3, [pc, #592]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cb38:	681b      	ldr	r3, [r3, #0]
   1cb3a:	429a      	cmp	r2, r3
   1cb3c:	dd00      	ble.n	1cb40 <vSTDPRogram+0x9c>
   1cb3e:	e112      	b.n	1cd66 <vSTDPRogram+0x2c2>
	   {
		xProgramSequence=TI; 
   1cb40:	4b8f      	ldr	r3, [pc, #572]	; (1cd80 <vSTDPRogram+0x2dc>)
   1cb42:	2201      	movs	r2, #1
   1cb44:	701a      	strb	r2, [r3, #0]
		xProgramStartTime=xMasterTime;
   1cb46:	4b96      	ldr	r3, [pc, #600]	; (1cda0 <vSTDPRogram+0x2fc>)
   1cb48:	681a      	ldr	r2, [r3, #0]
   1cb4a:	4b96      	ldr	r3, [pc, #600]	; (1cda4 <vSTDPRogram+0x300>)
   1cb4c:	601a      	str	r2, [r3, #0]
	   }
	   
	   break;
   1cb4e:	e10a      	b.n	1cd66 <vSTDPRogram+0x2c2>
	   
	   case TI:
	   
	   port_pin_set_output_level(RELAY_1,true);
   1cb50:	2101      	movs	r1, #1
   1cb52:	2014      	movs	r0, #20
   1cb54:	4b8d      	ldr	r3, [pc, #564]	; (1cd8c <vSTDPRogram+0x2e8>)
   1cb56:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/xProgramList[ucActiveIndex].usTi);
   1cb58:	4b8b      	ldr	r3, [pc, #556]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cb5a:	681b      	ldr	r3, [r3, #0]
   1cb5c:	2264      	movs	r2, #100	; 0x64
   1cb5e:	435a      	muls	r2, r3
   1cb60:	0010      	movs	r0, r2
   1cb62:	4b8b      	ldr	r3, [pc, #556]	; (1cd90 <vSTDPRogram+0x2ec>)
   1cb64:	781b      	ldrb	r3, [r3, #0]
   1cb66:	001a      	movs	r2, r3
   1cb68:	498a      	ldr	r1, [pc, #552]	; (1cd94 <vSTDPRogram+0x2f0>)
   1cb6a:	0013      	movs	r3, r2
   1cb6c:	00db      	lsls	r3, r3, #3
   1cb6e:	1a9b      	subs	r3, r3, r2
   1cb70:	00db      	lsls	r3, r3, #3
   1cb72:	189b      	adds	r3, r3, r2
   1cb74:	18cb      	adds	r3, r1, r3
   1cb76:	3310      	adds	r3, #16
   1cb78:	79da      	ldrb	r2, [r3, #7]
   1cb7a:	7a1b      	ldrb	r3, [r3, #8]
   1cb7c:	021b      	lsls	r3, r3, #8
   1cb7e:	4313      	orrs	r3, r2
   1cb80:	b29b      	uxth	r3, r3
   1cb82:	001a      	movs	r2, r3
   1cb84:	4b84      	ldr	r3, [pc, #528]	; (1cd98 <vSTDPRogram+0x2f4>)
   1cb86:	0011      	movs	r1, r2
   1cb88:	4798      	blx	r3
   1cb8a:	0003      	movs	r3, r0
   1cb8c:	b2db      	uxtb	r3, r3
   1cb8e:	0018      	movs	r0, r3
   1cb90:	4b82      	ldr	r3, [pc, #520]	; (1cd9c <vSTDPRogram+0x2f8>)
   1cb92:	4798      	blx	r3
	   
	   if (xElapTime>=xProgramList[ucActiveIndex].usTi) 
   1cb94:	4b7e      	ldr	r3, [pc, #504]	; (1cd90 <vSTDPRogram+0x2ec>)
   1cb96:	781b      	ldrb	r3, [r3, #0]
   1cb98:	001a      	movs	r2, r3
   1cb9a:	497e      	ldr	r1, [pc, #504]	; (1cd94 <vSTDPRogram+0x2f0>)
   1cb9c:	0013      	movs	r3, r2
   1cb9e:	00db      	lsls	r3, r3, #3
   1cba0:	1a9b      	subs	r3, r3, r2
   1cba2:	00db      	lsls	r3, r3, #3
   1cba4:	189b      	adds	r3, r3, r2
   1cba6:	18cb      	adds	r3, r1, r3
   1cba8:	3310      	adds	r3, #16
   1cbaa:	79da      	ldrb	r2, [r3, #7]
   1cbac:	7a1b      	ldrb	r3, [r3, #8]
   1cbae:	021b      	lsls	r3, r3, #8
   1cbb0:	4313      	orrs	r3, r2
   1cbb2:	b29b      	uxth	r3, r3
   1cbb4:	1e1a      	subs	r2, r3, #0
   1cbb6:	4b74      	ldr	r3, [pc, #464]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cbb8:	681b      	ldr	r3, [r3, #0]
   1cbba:	429a      	cmp	r2, r3
   1cbbc:	dd00      	ble.n	1cbc0 <vSTDPRogram+0x11c>
   1cbbe:	e0d4      	b.n	1cd6a <vSTDPRogram+0x2c6>
	   {
		xProgramSequence=TFP; 
   1cbc0:	4b6f      	ldr	r3, [pc, #444]	; (1cd80 <vSTDPRogram+0x2dc>)
   1cbc2:	2202      	movs	r2, #2
   1cbc4:	701a      	strb	r2, [r3, #0]
		xProgramStartTime=xMasterTime;
   1cbc6:	4b76      	ldr	r3, [pc, #472]	; (1cda0 <vSTDPRogram+0x2fc>)
   1cbc8:	681a      	ldr	r2, [r3, #0]
   1cbca:	4b76      	ldr	r3, [pc, #472]	; (1cda4 <vSTDPRogram+0x300>)
   1cbcc:	601a      	str	r2, [r3, #0]
	   }
	   
	   break;
   1cbce:	e0cc      	b.n	1cd6a <vSTDPRogram+0x2c6>
	   
	   case TFP:
	   
	   port_pin_set_output_level(RELAY_1,false);
   1cbd0:	2100      	movs	r1, #0
   1cbd2:	2014      	movs	r0, #20
   1cbd4:	4b6d      	ldr	r3, [pc, #436]	; (1cd8c <vSTDPRogram+0x2e8>)
   1cbd6:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/xProgramList[ucActiveIndex].usTfp);
   1cbd8:	4b6b      	ldr	r3, [pc, #428]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cbda:	681b      	ldr	r3, [r3, #0]
   1cbdc:	2264      	movs	r2, #100	; 0x64
   1cbde:	435a      	muls	r2, r3
   1cbe0:	0010      	movs	r0, r2
   1cbe2:	4b6b      	ldr	r3, [pc, #428]	; (1cd90 <vSTDPRogram+0x2ec>)
   1cbe4:	781b      	ldrb	r3, [r3, #0]
   1cbe6:	001a      	movs	r2, r3
   1cbe8:	496a      	ldr	r1, [pc, #424]	; (1cd94 <vSTDPRogram+0x2f0>)
   1cbea:	0013      	movs	r3, r2
   1cbec:	00db      	lsls	r3, r3, #3
   1cbee:	1a9b      	subs	r3, r3, r2
   1cbf0:	00db      	lsls	r3, r3, #3
   1cbf2:	189b      	adds	r3, r3, r2
   1cbf4:	18cb      	adds	r3, r1, r3
   1cbf6:	3318      	adds	r3, #24
   1cbf8:	785a      	ldrb	r2, [r3, #1]
   1cbfa:	789b      	ldrb	r3, [r3, #2]
   1cbfc:	021b      	lsls	r3, r3, #8
   1cbfe:	4313      	orrs	r3, r2
   1cc00:	b29b      	uxth	r3, r3
   1cc02:	001a      	movs	r2, r3
   1cc04:	4b64      	ldr	r3, [pc, #400]	; (1cd98 <vSTDPRogram+0x2f4>)
   1cc06:	0011      	movs	r1, r2
   1cc08:	4798      	blx	r3
   1cc0a:	0003      	movs	r3, r0
   1cc0c:	b2db      	uxtb	r3, r3
   1cc0e:	0018      	movs	r0, r3
   1cc10:	4b62      	ldr	r3, [pc, #392]	; (1cd9c <vSTDPRogram+0x2f8>)
   1cc12:	4798      	blx	r3
	   
	   if (xElapTime>=xProgramList[ucActiveIndex].usTfp) 
   1cc14:	4b5e      	ldr	r3, [pc, #376]	; (1cd90 <vSTDPRogram+0x2ec>)
   1cc16:	781b      	ldrb	r3, [r3, #0]
   1cc18:	001a      	movs	r2, r3
   1cc1a:	495e      	ldr	r1, [pc, #376]	; (1cd94 <vSTDPRogram+0x2f0>)
   1cc1c:	0013      	movs	r3, r2
   1cc1e:	00db      	lsls	r3, r3, #3
   1cc20:	1a9b      	subs	r3, r3, r2
   1cc22:	00db      	lsls	r3, r3, #3
   1cc24:	189b      	adds	r3, r3, r2
   1cc26:	18cb      	adds	r3, r1, r3
   1cc28:	3318      	adds	r3, #24
   1cc2a:	785a      	ldrb	r2, [r3, #1]
   1cc2c:	789b      	ldrb	r3, [r3, #2]
   1cc2e:	021b      	lsls	r3, r3, #8
   1cc30:	4313      	orrs	r3, r2
   1cc32:	b29b      	uxth	r3, r3
   1cc34:	1e1a      	subs	r2, r3, #0
   1cc36:	4b54      	ldr	r3, [pc, #336]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cc38:	681b      	ldr	r3, [r3, #0]
   1cc3a:	429a      	cmp	r2, r3
   1cc3c:	dd00      	ble.n	1cc40 <vSTDPRogram+0x19c>
   1cc3e:	e096      	b.n	1cd6e <vSTDPRogram+0x2ca>
	   {
		xProgramSequence=TP; 
   1cc40:	4b4f      	ldr	r3, [pc, #316]	; (1cd80 <vSTDPRogram+0x2dc>)
   1cc42:	2203      	movs	r2, #3
   1cc44:	701a      	strb	r2, [r3, #0]
		xProgramStartTime=xMasterTime;
   1cc46:	4b56      	ldr	r3, [pc, #344]	; (1cda0 <vSTDPRogram+0x2fc>)
   1cc48:	681a      	ldr	r2, [r3, #0]
   1cc4a:	4b56      	ldr	r3, [pc, #344]	; (1cda4 <vSTDPRogram+0x300>)
   1cc4c:	601a      	str	r2, [r3, #0]
	   }
	   
	   break;
   1cc4e:	e08e      	b.n	1cd6e <vSTDPRogram+0x2ca>
		  
	   case TP:
		  
	   port_pin_set_output_level(RELAY_1,true);
   1cc50:	2101      	movs	r1, #1
   1cc52:	2014      	movs	r0, #20
   1cc54:	4b4d      	ldr	r3, [pc, #308]	; (1cd8c <vSTDPRogram+0x2e8>)
   1cc56:	4798      	blx	r3
	   vWriteLog(xElapTime);
   1cc58:	4b4b      	ldr	r3, [pc, #300]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cc5a:	681b      	ldr	r3, [r3, #0]
   1cc5c:	0018      	movs	r0, r3
   1cc5e:	4b52      	ldr	r3, [pc, #328]	; (1cda8 <vSTDPRogram+0x304>)
   1cc60:	4798      	blx	r3
	   vDecreaseTime(xElapTime);
   1cc62:	4b49      	ldr	r3, [pc, #292]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cc64:	681b      	ldr	r3, [r3, #0]
   1cc66:	0018      	movs	r0, r3
   1cc68:	4b50      	ldr	r3, [pc, #320]	; (1cdac <vSTDPRogram+0x308>)
   1cc6a:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/xProgramList[ucActiveIndex].usTp);
   1cc6c:	4b46      	ldr	r3, [pc, #280]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cc6e:	681b      	ldr	r3, [r3, #0]
   1cc70:	2264      	movs	r2, #100	; 0x64
   1cc72:	435a      	muls	r2, r3
   1cc74:	0010      	movs	r0, r2
   1cc76:	4b46      	ldr	r3, [pc, #280]	; (1cd90 <vSTDPRogram+0x2ec>)
   1cc78:	781b      	ldrb	r3, [r3, #0]
   1cc7a:	001a      	movs	r2, r3
   1cc7c:	4945      	ldr	r1, [pc, #276]	; (1cd94 <vSTDPRogram+0x2f0>)
   1cc7e:	0013      	movs	r3, r2
   1cc80:	00db      	lsls	r3, r3, #3
   1cc82:	1a9b      	subs	r3, r3, r2
   1cc84:	00db      	lsls	r3, r3, #3
   1cc86:	189b      	adds	r3, r3, r2
   1cc88:	18cb      	adds	r3, r1, r3
   1cc8a:	3318      	adds	r3, #24
   1cc8c:	78da      	ldrb	r2, [r3, #3]
   1cc8e:	791b      	ldrb	r3, [r3, #4]
   1cc90:	021b      	lsls	r3, r3, #8
   1cc92:	4313      	orrs	r3, r2
   1cc94:	b29b      	uxth	r3, r3
   1cc96:	001a      	movs	r2, r3
   1cc98:	4b3f      	ldr	r3, [pc, #252]	; (1cd98 <vSTDPRogram+0x2f4>)
   1cc9a:	0011      	movs	r1, r2
   1cc9c:	4798      	blx	r3
   1cc9e:	0003      	movs	r3, r0
   1cca0:	b2db      	uxtb	r3, r3
   1cca2:	0018      	movs	r0, r3
   1cca4:	4b3d      	ldr	r3, [pc, #244]	; (1cd9c <vSTDPRogram+0x2f8>)
   1cca6:	4798      	blx	r3
	  
	   if (xElapTime>=xProgramList[ucActiveIndex].usTp) 
   1cca8:	4b39      	ldr	r3, [pc, #228]	; (1cd90 <vSTDPRogram+0x2ec>)
   1ccaa:	781b      	ldrb	r3, [r3, #0]
   1ccac:	001a      	movs	r2, r3
   1ccae:	4939      	ldr	r1, [pc, #228]	; (1cd94 <vSTDPRogram+0x2f0>)
   1ccb0:	0013      	movs	r3, r2
   1ccb2:	00db      	lsls	r3, r3, #3
   1ccb4:	1a9b      	subs	r3, r3, r2
   1ccb6:	00db      	lsls	r3, r3, #3
   1ccb8:	189b      	adds	r3, r3, r2
   1ccba:	18cb      	adds	r3, r1, r3
   1ccbc:	3318      	adds	r3, #24
   1ccbe:	78da      	ldrb	r2, [r3, #3]
   1ccc0:	791b      	ldrb	r3, [r3, #4]
   1ccc2:	021b      	lsls	r3, r3, #8
   1ccc4:	4313      	orrs	r3, r2
   1ccc6:	b29b      	uxth	r3, r3
   1ccc8:	1e1a      	subs	r2, r3, #0
   1ccca:	4b2f      	ldr	r3, [pc, #188]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cccc:	681b      	ldr	r3, [r3, #0]
   1ccce:	429a      	cmp	r2, r3
   1ccd0:	dc4f      	bgt.n	1cd72 <vSTDPRogram+0x2ce>
	   {
		xProgramSequence=TA;
   1ccd2:	4b2b      	ldr	r3, [pc, #172]	; (1cd80 <vSTDPRogram+0x2dc>)
   1ccd4:	2204      	movs	r2, #4
   1ccd6:	701a      	strb	r2, [r3, #0]
		xProgramStartTime=xMasterTime;
   1ccd8:	4b31      	ldr	r3, [pc, #196]	; (1cda0 <vSTDPRogram+0x2fc>)
   1ccda:	681a      	ldr	r2, [r3, #0]
   1ccdc:	4b31      	ldr	r3, [pc, #196]	; (1cda4 <vSTDPRogram+0x300>)
   1ccde:	601a      	str	r2, [r3, #0]
	   }
	  
	   break;
   1cce0:	e047      	b.n	1cd72 <vSTDPRogram+0x2ce>
	   
	   case TA:
	   
	   port_pin_set_output_level(RELAY_1,true);
   1cce2:	2101      	movs	r1, #1
   1cce4:	2014      	movs	r0, #20
   1cce6:	4b29      	ldr	r3, [pc, #164]	; (1cd8c <vSTDPRogram+0x2e8>)
   1cce8:	4798      	blx	r3
	   vWriteLog(xElapTime);
   1ccea:	4b27      	ldr	r3, [pc, #156]	; (1cd88 <vSTDPRogram+0x2e4>)
   1ccec:	681b      	ldr	r3, [r3, #0]
   1ccee:	0018      	movs	r0, r3
   1ccf0:	4b2d      	ldr	r3, [pc, #180]	; (1cda8 <vSTDPRogram+0x304>)
   1ccf2:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/xProgramList[ucActiveIndex].usTa);
   1ccf4:	4b24      	ldr	r3, [pc, #144]	; (1cd88 <vSTDPRogram+0x2e4>)
   1ccf6:	681b      	ldr	r3, [r3, #0]
   1ccf8:	2264      	movs	r2, #100	; 0x64
   1ccfa:	435a      	muls	r2, r3
   1ccfc:	0010      	movs	r0, r2
   1ccfe:	4b24      	ldr	r3, [pc, #144]	; (1cd90 <vSTDPRogram+0x2ec>)
   1cd00:	781b      	ldrb	r3, [r3, #0]
   1cd02:	001a      	movs	r2, r3
   1cd04:	4923      	ldr	r1, [pc, #140]	; (1cd94 <vSTDPRogram+0x2f0>)
   1cd06:	0013      	movs	r3, r2
   1cd08:	00db      	lsls	r3, r3, #3
   1cd0a:	1a9b      	subs	r3, r3, r2
   1cd0c:	00db      	lsls	r3, r3, #3
   1cd0e:	189b      	adds	r3, r3, r2
   1cd10:	18cb      	adds	r3, r1, r3
   1cd12:	3318      	adds	r3, #24
   1cd14:	79da      	ldrb	r2, [r3, #7]
   1cd16:	7a1b      	ldrb	r3, [r3, #8]
   1cd18:	021b      	lsls	r3, r3, #8
   1cd1a:	4313      	orrs	r3, r2
   1cd1c:	b29b      	uxth	r3, r3
   1cd1e:	001a      	movs	r2, r3
   1cd20:	4b1d      	ldr	r3, [pc, #116]	; (1cd98 <vSTDPRogram+0x2f4>)
   1cd22:	0011      	movs	r1, r2
   1cd24:	4798      	blx	r3
   1cd26:	0003      	movs	r3, r0
   1cd28:	b2db      	uxtb	r3, r3
   1cd2a:	0018      	movs	r0, r3
   1cd2c:	4b1b      	ldr	r3, [pc, #108]	; (1cd9c <vSTDPRogram+0x2f8>)
   1cd2e:	4798      	blx	r3
	   
	   if (xElapTime>=xProgramList[ucActiveIndex].usTa) xMachineState=STOP;
   1cd30:	4b17      	ldr	r3, [pc, #92]	; (1cd90 <vSTDPRogram+0x2ec>)
   1cd32:	781b      	ldrb	r3, [r3, #0]
   1cd34:	001a      	movs	r2, r3
   1cd36:	4917      	ldr	r1, [pc, #92]	; (1cd94 <vSTDPRogram+0x2f0>)
   1cd38:	0013      	movs	r3, r2
   1cd3a:	00db      	lsls	r3, r3, #3
   1cd3c:	1a9b      	subs	r3, r3, r2
   1cd3e:	00db      	lsls	r3, r3, #3
   1cd40:	189b      	adds	r3, r3, r2
   1cd42:	18cb      	adds	r3, r1, r3
   1cd44:	3318      	adds	r3, #24
   1cd46:	79da      	ldrb	r2, [r3, #7]
   1cd48:	7a1b      	ldrb	r3, [r3, #8]
   1cd4a:	021b      	lsls	r3, r3, #8
   1cd4c:	4313      	orrs	r3, r2
   1cd4e:	b29b      	uxth	r3, r3
   1cd50:	1e1a      	subs	r2, r3, #0
   1cd52:	4b0d      	ldr	r3, [pc, #52]	; (1cd88 <vSTDPRogram+0x2e4>)
   1cd54:	681b      	ldr	r3, [r3, #0]
   1cd56:	429a      	cmp	r2, r3
   1cd58:	dc0d      	bgt.n	1cd76 <vSTDPRogram+0x2d2>
   1cd5a:	4b15      	ldr	r3, [pc, #84]	; (1cdb0 <vSTDPRogram+0x30c>)
   1cd5c:	2200      	movs	r2, #0
   1cd5e:	701a      	strb	r2, [r3, #0]
	   
	   break;
   1cd60:	e009      	b.n	1cd76 <vSTDPRogram+0x2d2>
	   
	   default: break;
   1cd62:	46c0      	nop			; (mov r8, r8)
   1cd64:	e008      	b.n	1cd78 <vSTDPRogram+0x2d4>
	   {
		xProgramSequence=TI; 
		xProgramStartTime=xMasterTime;
	   }
	   
	   break;
   1cd66:	46c0      	nop			; (mov r8, r8)
   1cd68:	e006      	b.n	1cd78 <vSTDPRogram+0x2d4>
	   {
		xProgramSequence=TFP; 
		xProgramStartTime=xMasterTime;
	   }
	   
	   break;
   1cd6a:	46c0      	nop			; (mov r8, r8)
   1cd6c:	e004      	b.n	1cd78 <vSTDPRogram+0x2d4>
	   {
		xProgramSequence=TP; 
		xProgramStartTime=xMasterTime;
	   }
	   
	   break;
   1cd6e:	46c0      	nop			; (mov r8, r8)
   1cd70:	e002      	b.n	1cd78 <vSTDPRogram+0x2d4>
	   {
		xProgramSequence=TA;
		xProgramStartTime=xMasterTime;
	   }
	  
	   break;
   1cd72:	46c0      	nop			; (mov r8, r8)
   1cd74:	e000      	b.n	1cd78 <vSTDPRogram+0x2d4>
	   vWriteLog(xElapTime);
	   vPrgScreen(100*xElapTime/xProgramList[ucActiveIndex].usTa);
	   
	   if (xElapTime>=xProgramList[ucActiveIndex].usTa) xMachineState=STOP;
	   
	   break;
   1cd76:	46c0      	nop			; (mov r8, r8)
	   
	   default: break;
	  
	  }
	 
}
   1cd78:	46c0      	nop			; (mov r8, r8)
   1cd7a:	46bd      	mov	sp, r7
   1cd7c:	bd80      	pop	{r7, pc}
   1cd7e:	46c0      	nop			; (mov r8, r8)
   1cd80:	20004a72 	.word	0x20004a72
   1cd84:	00021dc8 	.word	0x00021dc8
   1cd88:	20004a60 	.word	0x20004a60
   1cd8c:	0001b155 	.word	0x0001b155
   1cd90:	20004bd4 	.word	0x20004bd4
   1cd94:	200046ec 	.word	0x200046ec
   1cd98:	0001d599 	.word	0x0001d599
   1cd9c:	0001ba81 	.word	0x0001ba81
   1cda0:	200049e0 	.word	0x200049e0
   1cda4:	20003e10 	.word	0x20003e10
   1cda8:	0001c819 	.word	0x0001c819
   1cdac:	0001c9d1 	.word	0x0001c9d1
   1cdb0:	20004aa4 	.word	0x20004aa4

0001cdb4 <vWASHPRG>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void vWASHPRG(void)
{
   1cdb4:	b580      	push	{r7, lr}
   1cdb6:	af00      	add	r7, sp, #0
	  switch (xProgramSequence)
   1cdb8:	4b81      	ldr	r3, [pc, #516]	; (1cfc0 <vWASHPRG+0x20c>)
   1cdba:	781b      	ldrb	r3, [r3, #0]
   1cdbc:	2b07      	cmp	r3, #7
   1cdbe:	d900      	bls.n	1cdc2 <vWASHPRG+0xe>
   1cdc0:	e0f0      	b.n	1cfa4 <vWASHPRG+0x1f0>
   1cdc2:	009a      	lsls	r2, r3, #2
   1cdc4:	4b7f      	ldr	r3, [pc, #508]	; (1cfc4 <vWASHPRG+0x210>)
   1cdc6:	18d3      	adds	r3, r2, r3
   1cdc8:	681b      	ldr	r3, [r3, #0]
   1cdca:	469f      	mov	pc, r3
	  {
	   case TS:
	   
	   if (xElapTime & 0x01) port_pin_set_output_level(RELAY_2,true);
   1cdcc:	4b7e      	ldr	r3, [pc, #504]	; (1cfc8 <vWASHPRG+0x214>)
   1cdce:	681b      	ldr	r3, [r3, #0]
   1cdd0:	2201      	movs	r2, #1
   1cdd2:	4013      	ands	r3, r2
   1cdd4:	d004      	beq.n	1cde0 <vWASHPRG+0x2c>
   1cdd6:	2101      	movs	r1, #1
   1cdd8:	2015      	movs	r0, #21
   1cdda:	4b7c      	ldr	r3, [pc, #496]	; (1cfcc <vWASHPRG+0x218>)
   1cddc:	4798      	blx	r3
   1cdde:	e003      	b.n	1cde8 <vWASHPRG+0x34>
	    else port_pin_set_output_level(RELAY_2,false);
   1cde0:	2100      	movs	r1, #0
   1cde2:	2015      	movs	r0, #21
   1cde4:	4b79      	ldr	r3, [pc, #484]	; (1cfcc <vWASHPRG+0x218>)
   1cde6:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/xProgramList[ucActiveIndex].usTs);
   1cde8:	4b77      	ldr	r3, [pc, #476]	; (1cfc8 <vWASHPRG+0x214>)
   1cdea:	681b      	ldr	r3, [r3, #0]
   1cdec:	2264      	movs	r2, #100	; 0x64
   1cdee:	435a      	muls	r2, r3
   1cdf0:	0010      	movs	r0, r2
   1cdf2:	4b77      	ldr	r3, [pc, #476]	; (1cfd0 <vWASHPRG+0x21c>)
   1cdf4:	781b      	ldrb	r3, [r3, #0]
   1cdf6:	001a      	movs	r2, r3
   1cdf8:	4976      	ldr	r1, [pc, #472]	; (1cfd4 <vWASHPRG+0x220>)
   1cdfa:	0013      	movs	r3, r2
   1cdfc:	00db      	lsls	r3, r3, #3
   1cdfe:	1a9b      	subs	r3, r3, r2
   1ce00:	00db      	lsls	r3, r3, #3
   1ce02:	189b      	adds	r3, r3, r2
   1ce04:	18cb      	adds	r3, r1, r3
   1ce06:	3310      	adds	r3, #16
   1ce08:	795a      	ldrb	r2, [r3, #5]
   1ce0a:	799b      	ldrb	r3, [r3, #6]
   1ce0c:	021b      	lsls	r3, r3, #8
   1ce0e:	4313      	orrs	r3, r2
   1ce10:	b29b      	uxth	r3, r3
   1ce12:	001a      	movs	r2, r3
   1ce14:	4b70      	ldr	r3, [pc, #448]	; (1cfd8 <vWASHPRG+0x224>)
   1ce16:	0011      	movs	r1, r2
   1ce18:	4798      	blx	r3
   1ce1a:	0003      	movs	r3, r0
   1ce1c:	b2db      	uxtb	r3, r3
   1ce1e:	0018      	movs	r0, r3
   1ce20:	4b6e      	ldr	r3, [pc, #440]	; (1cfdc <vWASHPRG+0x228>)
   1ce22:	4798      	blx	r3
	   
	   if (xElapTime>=xProgramList[ucActiveIndex].usTs) 
   1ce24:	4b6a      	ldr	r3, [pc, #424]	; (1cfd0 <vWASHPRG+0x21c>)
   1ce26:	781b      	ldrb	r3, [r3, #0]
   1ce28:	001a      	movs	r2, r3
   1ce2a:	496a      	ldr	r1, [pc, #424]	; (1cfd4 <vWASHPRG+0x220>)
   1ce2c:	0013      	movs	r3, r2
   1ce2e:	00db      	lsls	r3, r3, #3
   1ce30:	1a9b      	subs	r3, r3, r2
   1ce32:	00db      	lsls	r3, r3, #3
   1ce34:	189b      	adds	r3, r3, r2
   1ce36:	18cb      	adds	r3, r1, r3
   1ce38:	3310      	adds	r3, #16
   1ce3a:	795a      	ldrb	r2, [r3, #5]
   1ce3c:	799b      	ldrb	r3, [r3, #6]
   1ce3e:	021b      	lsls	r3, r3, #8
   1ce40:	4313      	orrs	r3, r2
   1ce42:	b29b      	uxth	r3, r3
   1ce44:	1e1a      	subs	r2, r3, #0
   1ce46:	4b60      	ldr	r3, [pc, #384]	; (1cfc8 <vWASHPRG+0x214>)
   1ce48:	681b      	ldr	r3, [r3, #0]
   1ce4a:	429a      	cmp	r2, r3
   1ce4c:	dd00      	ble.n	1ce50 <vWASHPRG+0x9c>
   1ce4e:	e0ab      	b.n	1cfa8 <vWASHPRG+0x1f4>
	   {
		xProgramSequence=TW1; 
   1ce50:	4b5b      	ldr	r3, [pc, #364]	; (1cfc0 <vWASHPRG+0x20c>)
   1ce52:	2206      	movs	r2, #6
   1ce54:	701a      	strb	r2, [r3, #0]
		xProgramStartTime=xMasterTime;
   1ce56:	4b62      	ldr	r3, [pc, #392]	; (1cfe0 <vWASHPRG+0x22c>)
   1ce58:	681a      	ldr	r2, [r3, #0]
   1ce5a:	4b62      	ldr	r3, [pc, #392]	; (1cfe4 <vWASHPRG+0x230>)
   1ce5c:	601a      	str	r2, [r3, #0]
	   }
	   
	   break;
   1ce5e:	e0a3      	b.n	1cfa8 <vWASHPRG+0x1f4>
	   
	   case TW1:
	   
	   port_pin_set_output_level(RELAY_1,true);
   1ce60:	2101      	movs	r1, #1
   1ce62:	2014      	movs	r0, #20
   1ce64:	4b59      	ldr	r3, [pc, #356]	; (1cfcc <vWASHPRG+0x218>)
   1ce66:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/(14*60));
   1ce68:	4b57      	ldr	r3, [pc, #348]	; (1cfc8 <vWASHPRG+0x214>)
   1ce6a:	681b      	ldr	r3, [r3, #0]
   1ce6c:	2264      	movs	r2, #100	; 0x64
   1ce6e:	435a      	muls	r2, r3
   1ce70:	0010      	movs	r0, r2
   1ce72:	4b59      	ldr	r3, [pc, #356]	; (1cfd8 <vWASHPRG+0x224>)
   1ce74:	22d2      	movs	r2, #210	; 0xd2
   1ce76:	0091      	lsls	r1, r2, #2
   1ce78:	4798      	blx	r3
   1ce7a:	0003      	movs	r3, r0
   1ce7c:	b2db      	uxtb	r3, r3
   1ce7e:	0018      	movs	r0, r3
   1ce80:	4b56      	ldr	r3, [pc, #344]	; (1cfdc <vWASHPRG+0x228>)
   1ce82:	4798      	blx	r3
	   
	   if (xElapTime>=(14*60)) 
   1ce84:	4b50      	ldr	r3, [pc, #320]	; (1cfc8 <vWASHPRG+0x214>)
   1ce86:	681b      	ldr	r3, [r3, #0]
   1ce88:	4a57      	ldr	r2, [pc, #348]	; (1cfe8 <vWASHPRG+0x234>)
   1ce8a:	4293      	cmp	r3, r2
   1ce8c:	dc00      	bgt.n	1ce90 <vWASHPRG+0xdc>
   1ce8e:	e08d      	b.n	1cfac <vWASHPRG+0x1f8>
	   {
		xProgramSequence=TIW; 
   1ce90:	4b4b      	ldr	r3, [pc, #300]	; (1cfc0 <vWASHPRG+0x20c>)
   1ce92:	2205      	movs	r2, #5
   1ce94:	701a      	strb	r2, [r3, #0]
		xProgramStartTime=xMasterTime;
   1ce96:	4b52      	ldr	r3, [pc, #328]	; (1cfe0 <vWASHPRG+0x22c>)
   1ce98:	681a      	ldr	r2, [r3, #0]
   1ce9a:	4b52      	ldr	r3, [pc, #328]	; (1cfe4 <vWASHPRG+0x230>)
   1ce9c:	601a      	str	r2, [r3, #0]
	   }
	   
	   break;
   1ce9e:	e085      	b.n	1cfac <vWASHPRG+0x1f8>
	   
	   case TIW:
	   
	   port_pin_set_output_level(RELAY_1,false);
   1cea0:	2100      	movs	r1, #0
   1cea2:	2014      	movs	r0, #20
   1cea4:	4b49      	ldr	r3, [pc, #292]	; (1cfcc <vWASHPRG+0x218>)
   1cea6:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/60);
   1cea8:	4b47      	ldr	r3, [pc, #284]	; (1cfc8 <vWASHPRG+0x214>)
   1ceaa:	681b      	ldr	r3, [r3, #0]
   1ceac:	2264      	movs	r2, #100	; 0x64
   1ceae:	435a      	muls	r2, r3
   1ceb0:	4b49      	ldr	r3, [pc, #292]	; (1cfd8 <vWASHPRG+0x224>)
   1ceb2:	213c      	movs	r1, #60	; 0x3c
   1ceb4:	0010      	movs	r0, r2
   1ceb6:	4798      	blx	r3
   1ceb8:	0003      	movs	r3, r0
   1ceba:	b2db      	uxtb	r3, r3
   1cebc:	0018      	movs	r0, r3
   1cebe:	4b47      	ldr	r3, [pc, #284]	; (1cfdc <vWASHPRG+0x228>)
   1cec0:	4798      	blx	r3
	   
	   if (xElapTime>=60) 
   1cec2:	4b41      	ldr	r3, [pc, #260]	; (1cfc8 <vWASHPRG+0x214>)
   1cec4:	681b      	ldr	r3, [r3, #0]
   1cec6:	2b3b      	cmp	r3, #59	; 0x3b
   1cec8:	dd72      	ble.n	1cfb0 <vWASHPRG+0x1fc>
	   {
		xProgramSequence=TW2; 
   1ceca:	4b3d      	ldr	r3, [pc, #244]	; (1cfc0 <vWASHPRG+0x20c>)
   1cecc:	2207      	movs	r2, #7
   1cece:	701a      	strb	r2, [r3, #0]
		xProgramStartTime=xMasterTime;
   1ced0:	4b43      	ldr	r3, [pc, #268]	; (1cfe0 <vWASHPRG+0x22c>)
   1ced2:	681a      	ldr	r2, [r3, #0]
   1ced4:	4b43      	ldr	r3, [pc, #268]	; (1cfe4 <vWASHPRG+0x230>)
   1ced6:	601a      	str	r2, [r3, #0]
	   }
	   
	   break;
   1ced8:	e06a      	b.n	1cfb0 <vWASHPRG+0x1fc>
		  
	   case TW2:
		  
	   port_pin_set_output_level(RELAY_1,true);
   1ceda:	2101      	movs	r1, #1
   1cedc:	2014      	movs	r0, #20
   1cede:	4b3b      	ldr	r3, [pc, #236]	; (1cfcc <vWASHPRG+0x218>)
   1cee0:	4798      	blx	r3
	   vWriteLog(xElapTime);
   1cee2:	4b39      	ldr	r3, [pc, #228]	; (1cfc8 <vWASHPRG+0x214>)
   1cee4:	681b      	ldr	r3, [r3, #0]
   1cee6:	0018      	movs	r0, r3
   1cee8:	4b40      	ldr	r3, [pc, #256]	; (1cfec <vWASHPRG+0x238>)
   1ceea:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/(7*60));
   1ceec:	4b36      	ldr	r3, [pc, #216]	; (1cfc8 <vWASHPRG+0x214>)
   1ceee:	681b      	ldr	r3, [r3, #0]
   1cef0:	2264      	movs	r2, #100	; 0x64
   1cef2:	435a      	muls	r2, r3
   1cef4:	0010      	movs	r0, r2
   1cef6:	4b38      	ldr	r3, [pc, #224]	; (1cfd8 <vWASHPRG+0x224>)
   1cef8:	22d2      	movs	r2, #210	; 0xd2
   1cefa:	0051      	lsls	r1, r2, #1
   1cefc:	4798      	blx	r3
   1cefe:	0003      	movs	r3, r0
   1cf00:	b2db      	uxtb	r3, r3
   1cf02:	0018      	movs	r0, r3
   1cf04:	4b35      	ldr	r3, [pc, #212]	; (1cfdc <vWASHPRG+0x228>)
   1cf06:	4798      	blx	r3
	  
	   if (xElapTime>=(7*60)) 
   1cf08:	4b2f      	ldr	r3, [pc, #188]	; (1cfc8 <vWASHPRG+0x214>)
   1cf0a:	681a      	ldr	r2, [r3, #0]
   1cf0c:	23a4      	movs	r3, #164	; 0xa4
   1cf0e:	33ff      	adds	r3, #255	; 0xff
   1cf10:	429a      	cmp	r2, r3
   1cf12:	dd4f      	ble.n	1cfb4 <vWASHPRG+0x200>
	   {
		xProgramSequence=TA;
   1cf14:	4b2a      	ldr	r3, [pc, #168]	; (1cfc0 <vWASHPRG+0x20c>)
   1cf16:	2204      	movs	r2, #4
   1cf18:	701a      	strb	r2, [r3, #0]
		xProgramStartTime=xMasterTime;
   1cf1a:	4b31      	ldr	r3, [pc, #196]	; (1cfe0 <vWASHPRG+0x22c>)
   1cf1c:	681a      	ldr	r2, [r3, #0]
   1cf1e:	4b31      	ldr	r3, [pc, #196]	; (1cfe4 <vWASHPRG+0x230>)
   1cf20:	601a      	str	r2, [r3, #0]
	   }
	  
	   break;
   1cf22:	e047      	b.n	1cfb4 <vWASHPRG+0x200>
	   
	   case TA:
	   
	   port_pin_set_output_level(RELAY_1,true);
   1cf24:	2101      	movs	r1, #1
   1cf26:	2014      	movs	r0, #20
   1cf28:	4b28      	ldr	r3, [pc, #160]	; (1cfcc <vWASHPRG+0x218>)
   1cf2a:	4798      	blx	r3
	   vWriteLog(xElapTime);
   1cf2c:	4b26      	ldr	r3, [pc, #152]	; (1cfc8 <vWASHPRG+0x214>)
   1cf2e:	681b      	ldr	r3, [r3, #0]
   1cf30:	0018      	movs	r0, r3
   1cf32:	4b2e      	ldr	r3, [pc, #184]	; (1cfec <vWASHPRG+0x238>)
   1cf34:	4798      	blx	r3
	   vPrgScreen(100*xElapTime/xProgramList[ucActiveIndex].usTa);
   1cf36:	4b24      	ldr	r3, [pc, #144]	; (1cfc8 <vWASHPRG+0x214>)
   1cf38:	681b      	ldr	r3, [r3, #0]
   1cf3a:	2264      	movs	r2, #100	; 0x64
   1cf3c:	435a      	muls	r2, r3
   1cf3e:	0010      	movs	r0, r2
   1cf40:	4b23      	ldr	r3, [pc, #140]	; (1cfd0 <vWASHPRG+0x21c>)
   1cf42:	781b      	ldrb	r3, [r3, #0]
   1cf44:	001a      	movs	r2, r3
   1cf46:	4923      	ldr	r1, [pc, #140]	; (1cfd4 <vWASHPRG+0x220>)
   1cf48:	0013      	movs	r3, r2
   1cf4a:	00db      	lsls	r3, r3, #3
   1cf4c:	1a9b      	subs	r3, r3, r2
   1cf4e:	00db      	lsls	r3, r3, #3
   1cf50:	189b      	adds	r3, r3, r2
   1cf52:	18cb      	adds	r3, r1, r3
   1cf54:	3318      	adds	r3, #24
   1cf56:	79da      	ldrb	r2, [r3, #7]
   1cf58:	7a1b      	ldrb	r3, [r3, #8]
   1cf5a:	021b      	lsls	r3, r3, #8
   1cf5c:	4313      	orrs	r3, r2
   1cf5e:	b29b      	uxth	r3, r3
   1cf60:	001a      	movs	r2, r3
   1cf62:	4b1d      	ldr	r3, [pc, #116]	; (1cfd8 <vWASHPRG+0x224>)
   1cf64:	0011      	movs	r1, r2
   1cf66:	4798      	blx	r3
   1cf68:	0003      	movs	r3, r0
   1cf6a:	b2db      	uxtb	r3, r3
   1cf6c:	0018      	movs	r0, r3
   1cf6e:	4b1b      	ldr	r3, [pc, #108]	; (1cfdc <vWASHPRG+0x228>)
   1cf70:	4798      	blx	r3
	   
	   if (xElapTime>=xProgramList[ucActiveIndex].usTa) xMachineState=STOP;
   1cf72:	4b17      	ldr	r3, [pc, #92]	; (1cfd0 <vWASHPRG+0x21c>)
   1cf74:	781b      	ldrb	r3, [r3, #0]
   1cf76:	001a      	movs	r2, r3
   1cf78:	4916      	ldr	r1, [pc, #88]	; (1cfd4 <vWASHPRG+0x220>)
   1cf7a:	0013      	movs	r3, r2
   1cf7c:	00db      	lsls	r3, r3, #3
   1cf7e:	1a9b      	subs	r3, r3, r2
   1cf80:	00db      	lsls	r3, r3, #3
   1cf82:	189b      	adds	r3, r3, r2
   1cf84:	18cb      	adds	r3, r1, r3
   1cf86:	3318      	adds	r3, #24
   1cf88:	79da      	ldrb	r2, [r3, #7]
   1cf8a:	7a1b      	ldrb	r3, [r3, #8]
   1cf8c:	021b      	lsls	r3, r3, #8
   1cf8e:	4313      	orrs	r3, r2
   1cf90:	b29b      	uxth	r3, r3
   1cf92:	1e1a      	subs	r2, r3, #0
   1cf94:	4b0c      	ldr	r3, [pc, #48]	; (1cfc8 <vWASHPRG+0x214>)
   1cf96:	681b      	ldr	r3, [r3, #0]
   1cf98:	429a      	cmp	r2, r3
   1cf9a:	dc0d      	bgt.n	1cfb8 <vWASHPRG+0x204>
   1cf9c:	4b14      	ldr	r3, [pc, #80]	; (1cff0 <vWASHPRG+0x23c>)
   1cf9e:	2200      	movs	r2, #0
   1cfa0:	701a      	strb	r2, [r3, #0]
	   
	   break;
   1cfa2:	e009      	b.n	1cfb8 <vWASHPRG+0x204>
	   
	   default: break;
   1cfa4:	46c0      	nop			; (mov r8, r8)
   1cfa6:	e008      	b.n	1cfba <vWASHPRG+0x206>
	   {
		xProgramSequence=TW1; 
		xProgramStartTime=xMasterTime;
	   }
	   
	   break;
   1cfa8:	46c0      	nop			; (mov r8, r8)
   1cfaa:	e006      	b.n	1cfba <vWASHPRG+0x206>
	   {
		xProgramSequence=TIW; 
		xProgramStartTime=xMasterTime;
	   }
	   
	   break;
   1cfac:	46c0      	nop			; (mov r8, r8)
   1cfae:	e004      	b.n	1cfba <vWASHPRG+0x206>
	   {
		xProgramSequence=TW2; 
		xProgramStartTime=xMasterTime;
	   }
	   
	   break;
   1cfb0:	46c0      	nop			; (mov r8, r8)
   1cfb2:	e002      	b.n	1cfba <vWASHPRG+0x206>
	   {
		xProgramSequence=TA;
		xProgramStartTime=xMasterTime;
	   }
	  
	   break;
   1cfb4:	46c0      	nop			; (mov r8, r8)
   1cfb6:	e000      	b.n	1cfba <vWASHPRG+0x206>
	   vWriteLog(xElapTime);
	   vPrgScreen(100*xElapTime/xProgramList[ucActiveIndex].usTa);
	   
	   if (xElapTime>=xProgramList[ucActiveIndex].usTa) xMachineState=STOP;
	   
	   break;
   1cfb8:	46c0      	nop			; (mov r8, r8)
	   
	   default: break;
	  
	  }
	 	
}
   1cfba:	46c0      	nop			; (mov r8, r8)
   1cfbc:	46bd      	mov	sp, r7
   1cfbe:	bd80      	pop	{r7, pc}
   1cfc0:	20004a72 	.word	0x20004a72
   1cfc4:	00021ddc 	.word	0x00021ddc
   1cfc8:	20004a60 	.word	0x20004a60
   1cfcc:	0001b155 	.word	0x0001b155
   1cfd0:	20004bd4 	.word	0x20004bd4
   1cfd4:	200046ec 	.word	0x200046ec
   1cfd8:	0001d599 	.word	0x0001d599
   1cfdc:	0001ba81 	.word	0x0001ba81
   1cfe0:	200049e0 	.word	0x200049e0
   1cfe4:	20003e10 	.word	0x20003e10
   1cfe8:	00000347 	.word	0x00000347
   1cfec:	0001c819 	.word	0x0001c819
   1cff0:	20004aa4 	.word	0x20004aa4

0001cff4 <main_task>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void main_task(void *params)
{   //uint8_t page_address=0;
   1cff4:	b590      	push	{r4, r7, lr}
   1cff6:	b085      	sub	sp, #20
   1cff8:	af00      	add	r7, sp, #0
   1cffa:	6078      	str	r0, [r7, #4]
	uint16_t counter=0;
   1cffc:	230c      	movs	r3, #12
   1cffe:	18fb      	adds	r3, r7, r3
   1d000:	2200      	movs	r2, #0
   1d002:	801a      	strh	r2, [r3, #0]
	uint8_t tempPrescaler=0;
   1d004:	230f      	movs	r3, #15
   1d006:	18fb      	adds	r3, r7, r3
   1d008:	2200      	movs	r2, #0
   1d00a:	701a      	strb	r2, [r3, #0]

	memset(LCDData,0x00,sizeof(LCDData));
   1d00c:	4b88      	ldr	r3, [pc, #544]	; (1d230 <main_task+0x23c>)
   1d00e:	2222      	movs	r2, #34	; 0x22
   1d010:	2100      	movs	r1, #0
   1d012:	0018      	movs	r0, r3
   1d014:	4b87      	ldr	r3, [pc, #540]	; (1d234 <main_task+0x240>)
   1d016:	4798      	blx	r3
	
    sprintf(&LCDData[0][0],"   NOCOSYSTEM");
   1d018:	4a85      	ldr	r2, [pc, #532]	; (1d230 <main_task+0x23c>)
   1d01a:	4b87      	ldr	r3, [pc, #540]	; (1d238 <main_task+0x244>)
   1d01c:	0010      	movs	r0, r2
   1d01e:	0019      	movs	r1, r3
   1d020:	230e      	movs	r3, #14
   1d022:	001a      	movs	r2, r3
   1d024:	4b85      	ldr	r3, [pc, #532]	; (1d23c <main_task+0x248>)
   1d026:	4798      	blx	r3
    sprintf(&LCDData[1][0],"    MEDIBIOS");
   1d028:	4a85      	ldr	r2, [pc, #532]	; (1d240 <main_task+0x24c>)
   1d02a:	4b86      	ldr	r3, [pc, #536]	; (1d244 <main_task+0x250>)
   1d02c:	0010      	movs	r0, r2
   1d02e:	0019      	movs	r1, r3
   1d030:	230d      	movs	r3, #13
   1d032:	001a      	movs	r2, r3
   1d034:	4b81      	ldr	r3, [pc, #516]	; (1d23c <main_task+0x248>)
   1d036:	4798      	blx	r3
    vLCDUpdate();
   1d038:	4b83      	ldr	r3, [pc, #524]	; (1d248 <main_task+0x254>)
   1d03a:	4798      	blx	r3

    for (uint8_t ucIndex=0x00;ucIndex<0x14;ucIndex++)
   1d03c:	230e      	movs	r3, #14
   1d03e:	18fb      	adds	r3, r7, r3
   1d040:	2200      	movs	r2, #0
   1d042:	701a      	strb	r2, [r3, #0]
   1d044:	e00e      	b.n	1d064 <main_task+0x70>
    {
	 if (sd_mmc_test_unit_ready(0)==CTRL_GOOD) break;
   1d046:	2000      	movs	r0, #0
   1d048:	4b80      	ldr	r3, [pc, #512]	; (1d24c <main_task+0x258>)
   1d04a:	4798      	blx	r3
   1d04c:	1e03      	subs	r3, r0, #0
   1d04e:	d00f      	beq.n	1d070 <main_task+0x7c>
	 vTaskDelay(TASK_DELAY_MS(100));
   1d050:	2064      	movs	r0, #100	; 0x64
   1d052:	4b7f      	ldr	r3, [pc, #508]	; (1d250 <main_task+0x25c>)
   1d054:	4798      	blx	r3
	
    sprintf(&LCDData[0][0],"   NOCOSYSTEM");
    sprintf(&LCDData[1][0],"    MEDIBIOS");
    vLCDUpdate();

    for (uint8_t ucIndex=0x00;ucIndex<0x14;ucIndex++)
   1d056:	230e      	movs	r3, #14
   1d058:	18fb      	adds	r3, r7, r3
   1d05a:	781a      	ldrb	r2, [r3, #0]
   1d05c:	230e      	movs	r3, #14
   1d05e:	18fb      	adds	r3, r7, r3
   1d060:	3201      	adds	r2, #1
   1d062:	701a      	strb	r2, [r3, #0]
   1d064:	230e      	movs	r3, #14
   1d066:	18fb      	adds	r3, r7, r3
   1d068:	781b      	ldrb	r3, [r3, #0]
   1d06a:	2b13      	cmp	r3, #19
   1d06c:	d9eb      	bls.n	1d046 <main_task+0x52>
   1d06e:	e000      	b.n	1d072 <main_task+0x7e>
    {
	 if (sd_mmc_test_unit_ready(0)==CTRL_GOOD) break;
   1d070:	46c0      	nop			; (mov r8, r8)
	 vTaskDelay(TASK_DELAY_MS(100));
    }
	vTaskDelay(TASK_DELAY_MS(1500));
   1d072:	4b78      	ldr	r3, [pc, #480]	; (1d254 <main_task+0x260>)
   1d074:	0018      	movs	r0, r3
   1d076:	4b76      	ldr	r3, [pc, #472]	; (1d250 <main_task+0x25c>)
   1d078:	4798      	blx	r3
			
	Retry:
    while (sd_mmc_test_unit_ready(0)!=CTRL_GOOD) 
   1d07a:	e004      	b.n	1d086 <main_task+0x92>
	{
	  vCardError();
   1d07c:	4b76      	ldr	r3, [pc, #472]	; (1d258 <main_task+0x264>)
   1d07e:	4798      	blx	r3
	  vTaskDelay(TASK_DELAY_MS(100));	
   1d080:	2064      	movs	r0, #100	; 0x64
   1d082:	4b73      	ldr	r3, [pc, #460]	; (1d250 <main_task+0x25c>)
   1d084:	4798      	blx	r3
	 vTaskDelay(TASK_DELAY_MS(100));
    }
	vTaskDelay(TASK_DELAY_MS(1500));
			
	Retry:
    while (sd_mmc_test_unit_ready(0)!=CTRL_GOOD) 
   1d086:	2000      	movs	r0, #0
   1d088:	4b70      	ldr	r3, [pc, #448]	; (1d24c <main_task+0x258>)
   1d08a:	4798      	blx	r3
   1d08c:	1e03      	subs	r3, r0, #0
   1d08e:	d1f5      	bne.n	1d07c <main_task+0x88>
	{
	  vCardError();
	  vTaskDelay(TASK_DELAY_MS(100));	
	}
	memset(&fs, 0, sizeof(FATFS));
   1d090:	238c      	movs	r3, #140	; 0x8c
   1d092:	009a      	lsls	r2, r3, #2
   1d094:	4b71      	ldr	r3, [pc, #452]	; (1d25c <main_task+0x268>)
   1d096:	2100      	movs	r1, #0
   1d098:	0018      	movs	r0, r3
   1d09a:	4b66      	ldr	r3, [pc, #408]	; (1d234 <main_task+0x240>)
   1d09c:	4798      	blx	r3
	FRESULT r = f_mount(&fs, "0:", 1);
   1d09e:	230b      	movs	r3, #11
   1d0a0:	18fc      	adds	r4, r7, r3
   1d0a2:	496f      	ldr	r1, [pc, #444]	; (1d260 <main_task+0x26c>)
   1d0a4:	4b6d      	ldr	r3, [pc, #436]	; (1d25c <main_task+0x268>)
   1d0a6:	2201      	movs	r2, #1
   1d0a8:	0018      	movs	r0, r3
   1d0aa:	4b6e      	ldr	r3, [pc, #440]	; (1d264 <main_task+0x270>)
   1d0ac:	4798      	blx	r3
   1d0ae:	0003      	movs	r3, r0
   1d0b0:	7023      	strb	r3, [r4, #0]
	if (r==FR_INVALID_DRIVE)
   1d0b2:	230b      	movs	r3, #11
   1d0b4:	18fb      	adds	r3, r7, r3
   1d0b6:	781b      	ldrb	r3, [r3, #0]
   1d0b8:	2b0b      	cmp	r3, #11
   1d0ba:	d10c      	bne.n	1d0d6 <main_task+0xe2>
	{
	 while (sd_mmc_check(0)!=CTRL_NO_PRESENT) 
   1d0bc:	e004      	b.n	1d0c8 <main_task+0xd4>
	 {
	  vCardError();
   1d0be:	4b66      	ldr	r3, [pc, #408]	; (1d258 <main_task+0x264>)
   1d0c0:	4798      	blx	r3
	  
	  vTaskDelay(TASK_DELAY_MS(100));
   1d0c2:	2064      	movs	r0, #100	; 0x64
   1d0c4:	4b62      	ldr	r3, [pc, #392]	; (1d250 <main_task+0x25c>)
   1d0c6:	4798      	blx	r3
	}
	memset(&fs, 0, sizeof(FATFS));
	FRESULT r = f_mount(&fs, "0:", 1);
	if (r==FR_INVALID_DRIVE)
	{
	 while (sd_mmc_check(0)!=CTRL_NO_PRESENT) 
   1d0c8:	2000      	movs	r0, #0
   1d0ca:	4b67      	ldr	r3, [pc, #412]	; (1d268 <main_task+0x274>)
   1d0cc:	4798      	blx	r3
   1d0ce:	1e03      	subs	r3, r0, #0
   1d0d0:	2b02      	cmp	r3, #2
   1d0d2:	d1f4      	bne.n	1d0be <main_task+0xca>
	 {
	  vCardError();
	  
	  vTaskDelay(TASK_DELAY_MS(100));
	 }
	 goto Retry;
   1d0d4:	e7d1      	b.n	1d07a <main_task+0x86>
	}
		

	vCheckFirmware();
   1d0d6:	4b65      	ldr	r3, [pc, #404]	; (1d26c <main_task+0x278>)
   1d0d8:	4798      	blx	r3
	vOpenFiles();
   1d0da:	4b65      	ldr	r3, [pc, #404]	; (1d270 <main_task+0x27c>)
   1d0dc:	4798      	blx	r3
	
	configure_rtc_calendar();
   1d0de:	4b65      	ldr	r3, [pc, #404]	; (1d274 <main_task+0x280>)
   1d0e0:	4798      	blx	r3
	vInitRC522SPI();
   1d0e2:	4b65      	ldr	r3, [pc, #404]	; (1d278 <main_task+0x284>)
   1d0e4:	4798      	blx	r3
    vInitRDM6300();
   1d0e6:	4b65      	ldr	r3, [pc, #404]	; (1d27c <main_task+0x288>)
   1d0e8:	4798      	blx	r3
	MFRC522_PCD_Init();
   1d0ea:	4b65      	ldr	r3, [pc, #404]	; (1d280 <main_task+0x28c>)
   1d0ec:	4798      	blx	r3

    
    RTCRead();
   1d0ee:	4b65      	ldr	r3, [pc, #404]	; (1d284 <main_task+0x290>)
   1d0f0:	4798      	blx	r3
	
	if (!ulMachineWorkTime) xMachineState=REVISION;
   1d0f2:	4b65      	ldr	r3, [pc, #404]	; (1d288 <main_task+0x294>)
   1d0f4:	681b      	ldr	r3, [r3, #0]
   1d0f6:	2b00      	cmp	r3, #0
   1d0f8:	d102      	bne.n	1d100 <main_task+0x10c>
   1d0fa:	4b64      	ldr	r3, [pc, #400]	; (1d28c <main_task+0x298>)
   1d0fc:	2203      	movs	r2, #3
   1d0fe:	701a      	strb	r2, [r3, #0]
	
	vTaskResume(xRFIDTask);
   1d100:	4b63      	ldr	r3, [pc, #396]	; (1d290 <main_task+0x29c>)
   1d102:	681b      	ldr	r3, [r3, #0]
   1d104:	0018      	movs	r0, r3
   1d106:	4b63      	ldr	r3, [pc, #396]	; (1d294 <main_task+0x2a0>)
   1d108:	4798      	blx	r3

	while (1)
	{
	 vTaskDelay(TASK_DELAY_MS(50));
   1d10a:	2032      	movs	r0, #50	; 0x32
   1d10c:	4b50      	ldr	r3, [pc, #320]	; (1d250 <main_task+0x25c>)
   1d10e:	4798      	blx	r3
	 
	 switch (xMachineState)
   1d110:	4b5e      	ldr	r3, [pc, #376]	; (1d28c <main_task+0x298>)
   1d112:	781b      	ldrb	r3, [r3, #0]
   1d114:	2b01      	cmp	r3, #1
   1d116:	d01a      	beq.n	1d14e <main_task+0x15a>
   1d118:	2b02      	cmp	r3, #2
   1d11a:	d031      	beq.n	1d180 <main_task+0x18c>
   1d11c:	2b00      	cmp	r3, #0
   1d11e:	d000      	beq.n	1d122 <main_task+0x12e>
	  
	  case ALARM:
	  
	  break;
	  
	  default: break;	  
   1d120:	e031      	b.n	1d186 <main_task+0x192>
	 
	 switch (xMachineState)
	 {
	  case STOP:
	  
	  port_pin_set_output_level(RELAY_1,false);
   1d122:	2100      	movs	r1, #0
   1d124:	2014      	movs	r0, #20
   1d126:	4b5c      	ldr	r3, [pc, #368]	; (1d298 <main_task+0x2a4>)
   1d128:	4798      	blx	r3
	  vMainScreen(counter,&Machinetime);
   1d12a:	4a5c      	ldr	r2, [pc, #368]	; (1d29c <main_task+0x2a8>)
   1d12c:	230c      	movs	r3, #12
   1d12e:	18fb      	adds	r3, r7, r3
   1d130:	881b      	ldrh	r3, [r3, #0]
   1d132:	0011      	movs	r1, r2
   1d134:	0018      	movs	r0, r3
   1d136:	4b5a      	ldr	r3, [pc, #360]	; (1d2a0 <main_task+0x2ac>)
   1d138:	4798      	blx	r3
	  if (xCheckPrograms(&ucActiveIndex)) xMachineState=RUN;
   1d13a:	4b5a      	ldr	r3, [pc, #360]	; (1d2a4 <main_task+0x2b0>)
   1d13c:	0018      	movs	r0, r3
   1d13e:	4b5a      	ldr	r3, [pc, #360]	; (1d2a8 <main_task+0x2b4>)
   1d140:	4798      	blx	r3
   1d142:	1e03      	subs	r3, r0, #0
   1d144:	d01e      	beq.n	1d184 <main_task+0x190>
   1d146:	4b51      	ldr	r3, [pc, #324]	; (1d28c <main_task+0x298>)
   1d148:	2201      	movs	r2, #1
   1d14a:	701a      	strb	r2, [r3, #0]
	
	  break;
   1d14c:	e01a      	b.n	1d184 <main_task+0x190>
	  
	  case RUN:
	  
	  xElapTime=xMasterTime-xProgramStartTime;
   1d14e:	4b57      	ldr	r3, [pc, #348]	; (1d2ac <main_task+0x2b8>)
   1d150:	681a      	ldr	r2, [r3, #0]
   1d152:	4b57      	ldr	r3, [pc, #348]	; (1d2b0 <main_task+0x2bc>)
   1d154:	681b      	ldr	r3, [r3, #0]
   1d156:	1ad2      	subs	r2, r2, r3
   1d158:	4b56      	ldr	r3, [pc, #344]	; (1d2b4 <main_task+0x2c0>)
   1d15a:	601a      	str	r2, [r3, #0]
	  
      if (xProgramList[ucActiveIndex].xProgramType==P_WASH) vWASHPRG();
   1d15c:	4b51      	ldr	r3, [pc, #324]	; (1d2a4 <main_task+0x2b0>)
   1d15e:	781b      	ldrb	r3, [r3, #0]
   1d160:	001a      	movs	r2, r3
   1d162:	4955      	ldr	r1, [pc, #340]	; (1d2b8 <main_task+0x2c4>)
   1d164:	0013      	movs	r3, r2
   1d166:	00db      	lsls	r3, r3, #3
   1d168:	1a9b      	subs	r3, r3, r2
   1d16a:	00db      	lsls	r3, r3, #3
   1d16c:	189b      	adds	r3, r3, r2
   1d16e:	5c5b      	ldrb	r3, [r3, r1]
   1d170:	2b02      	cmp	r3, #2
   1d172:	d102      	bne.n	1d17a <main_task+0x186>
   1d174:	4b51      	ldr	r3, [pc, #324]	; (1d2bc <main_task+0x2c8>)
   1d176:	4798      	blx	r3
	  else vSTDPRogram();

	  break;
   1d178:	e005      	b.n	1d186 <main_task+0x192>
	  case RUN:
	  
	  xElapTime=xMasterTime-xProgramStartTime;
	  
      if (xProgramList[ucActiveIndex].xProgramType==P_WASH) vWASHPRG();
	  else vSTDPRogram();
   1d17a:	4b51      	ldr	r3, [pc, #324]	; (1d2c0 <main_task+0x2cc>)
   1d17c:	4798      	blx	r3

	  break;
   1d17e:	e002      	b.n	1d186 <main_task+0x192>
	  
	  case ALARM:
	  
	  break;
   1d180:	46c0      	nop			; (mov r8, r8)
   1d182:	e000      	b.n	1d186 <main_task+0x192>
	  
	  port_pin_set_output_level(RELAY_1,false);
	  vMainScreen(counter,&Machinetime);
	  if (xCheckPrograms(&ucActiveIndex)) xMachineState=RUN;
	
	  break;
   1d184:	46c0      	nop			; (mov r8, r8)
	  
	  default: break;	  
     }
	 
	 //
	 tempPrescaler=(tempPrescaler+0x01) % 60;
   1d186:	230f      	movs	r3, #15
   1d188:	18fb      	adds	r3, r7, r3
   1d18a:	781b      	ldrb	r3, [r3, #0]
   1d18c:	1c5a      	adds	r2, r3, #1
   1d18e:	4b4d      	ldr	r3, [pc, #308]	; (1d2c4 <main_task+0x2d0>)
   1d190:	213c      	movs	r1, #60	; 0x3c
   1d192:	0010      	movs	r0, r2
   1d194:	4798      	blx	r3
   1d196:	000b      	movs	r3, r1
   1d198:	001a      	movs	r2, r3
   1d19a:	230f      	movs	r3, #15
   1d19c:	18fb      	adds	r3, r7, r3
   1d19e:	701a      	strb	r2, [r3, #0]
	 if (!tempPrescaler)
   1d1a0:	230f      	movs	r3, #15
   1d1a2:	18fb      	adds	r3, r7, r3
   1d1a4:	781b      	ldrb	r3, [r3, #0]
   1d1a6:	2b00      	cmp	r3, #0
   1d1a8:	d105      	bne.n	1d1b6 <main_task+0x1c2>
	   //xTagRECV=false;  
	   //sprintf(&LCDData[0][3],"   %02X%02X%02X%02X%02X",rdm_buffer[0],rdm_buffer[1],rdm_buffer[2],rdm_buffer[3],rdm_buffer[4]);
	   //vLCDUpdate();
	    //vTaskDelay(TASK_DELAY_MS(3000));
	  //}
	  vReadTHAll (&T,&H);
   1d1aa:	4a47      	ldr	r2, [pc, #284]	; (1d2c8 <main_task+0x2d4>)
   1d1ac:	4b47      	ldr	r3, [pc, #284]	; (1d2cc <main_task+0x2d8>)
   1d1ae:	0011      	movs	r1, r2
   1d1b0:	0018      	movs	r0, r3
   1d1b2:	4b47      	ldr	r3, [pc, #284]	; (1d2d0 <main_task+0x2dc>)
   1d1b4:	4798      	blx	r3
	 }
	 
	 vLCDUpdate();
   1d1b6:	4b24      	ldr	r3, [pc, #144]	; (1d248 <main_task+0x254>)
   1d1b8:	4798      	blx	r3
	 rtc_calendar_get_time(&rtc_instance, &Machinetime);
   1d1ba:	4a38      	ldr	r2, [pc, #224]	; (1d29c <main_task+0x2a8>)
   1d1bc:	4b45      	ldr	r3, [pc, #276]	; (1d2d4 <main_task+0x2e0>)
   1d1be:	0011      	movs	r1, r2
   1d1c0:	0018      	movs	r0, r3
   1d1c2:	4b45      	ldr	r3, [pc, #276]	; (1d2d8 <main_task+0x2e4>)
   1d1c4:	4798      	blx	r3
	 timeinfo.tm_year = Machinetime.year - 1900;
   1d1c6:	4b35      	ldr	r3, [pc, #212]	; (1d29c <main_task+0x2a8>)
   1d1c8:	88db      	ldrh	r3, [r3, #6]
   1d1ca:	4a44      	ldr	r2, [pc, #272]	; (1d2dc <main_task+0x2e8>)
   1d1cc:	189a      	adds	r2, r3, r2
   1d1ce:	4b44      	ldr	r3, [pc, #272]	; (1d2e0 <main_task+0x2ec>)
   1d1d0:	615a      	str	r2, [r3, #20]
	 timeinfo.tm_mon  = Machinetime.month -1;
   1d1d2:	4b32      	ldr	r3, [pc, #200]	; (1d29c <main_task+0x2a8>)
   1d1d4:	795b      	ldrb	r3, [r3, #5]
   1d1d6:	1e5a      	subs	r2, r3, #1
   1d1d8:	4b41      	ldr	r3, [pc, #260]	; (1d2e0 <main_task+0x2ec>)
   1d1da:	611a      	str	r2, [r3, #16]
	 timeinfo.tm_mday = Machinetime.day;
   1d1dc:	4b2f      	ldr	r3, [pc, #188]	; (1d29c <main_task+0x2a8>)
   1d1de:	791b      	ldrb	r3, [r3, #4]
   1d1e0:	001a      	movs	r2, r3
   1d1e2:	4b3f      	ldr	r3, [pc, #252]	; (1d2e0 <main_task+0x2ec>)
   1d1e4:	60da      	str	r2, [r3, #12]
	 timeinfo.tm_hour = Machinetime.hour;
   1d1e6:	4b2d      	ldr	r3, [pc, #180]	; (1d29c <main_task+0x2a8>)
   1d1e8:	789b      	ldrb	r3, [r3, #2]
   1d1ea:	001a      	movs	r2, r3
   1d1ec:	4b3c      	ldr	r3, [pc, #240]	; (1d2e0 <main_task+0x2ec>)
   1d1ee:	609a      	str	r2, [r3, #8]
     timeinfo.tm_min  = Machinetime.minute;
   1d1f0:	4b2a      	ldr	r3, [pc, #168]	; (1d29c <main_task+0x2a8>)
   1d1f2:	785b      	ldrb	r3, [r3, #1]
   1d1f4:	001a      	movs	r2, r3
   1d1f6:	4b3a      	ldr	r3, [pc, #232]	; (1d2e0 <main_task+0x2ec>)
   1d1f8:	605a      	str	r2, [r3, #4]
	 timeinfo.tm_sec = Machinetime.second; 
   1d1fa:	4b28      	ldr	r3, [pc, #160]	; (1d29c <main_task+0x2a8>)
   1d1fc:	781b      	ldrb	r3, [r3, #0]
   1d1fe:	001a      	movs	r2, r3
   1d200:	4b37      	ldr	r3, [pc, #220]	; (1d2e0 <main_task+0x2ec>)
   1d202:	601a      	str	r2, [r3, #0]
	 xMasterTime = mktime(&timeinfo);
   1d204:	4b36      	ldr	r3, [pc, #216]	; (1d2e0 <main_task+0x2ec>)
   1d206:	0018      	movs	r0, r3
   1d208:	4b36      	ldr	r3, [pc, #216]	; (1d2e4 <main_task+0x2f0>)
   1d20a:	4798      	blx	r3
   1d20c:	0002      	movs	r2, r0
   1d20e:	4b27      	ldr	r3, [pc, #156]	; (1d2ac <main_task+0x2b8>)
   1d210:	601a      	str	r2, [r3, #0]
	 timeinfTmp = localtime ( &xMasterTime );
   1d212:	4b26      	ldr	r3, [pc, #152]	; (1d2ac <main_task+0x2b8>)
   1d214:	0018      	movs	r0, r3
   1d216:	4b34      	ldr	r3, [pc, #208]	; (1d2e8 <main_task+0x2f4>)
   1d218:	4798      	blx	r3
   1d21a:	0002      	movs	r2, r0
   1d21c:	4b33      	ldr	r3, [pc, #204]	; (1d2ec <main_task+0x2f8>)
   1d21e:	601a      	str	r2, [r3, #0]
	 Machinetime.weekday = timeinfTmp->tm_wday;
   1d220:	4b32      	ldr	r3, [pc, #200]	; (1d2ec <main_task+0x2f8>)
   1d222:	681b      	ldr	r3, [r3, #0]
   1d224:	699b      	ldr	r3, [r3, #24]
   1d226:	b2da      	uxtb	r2, r3
   1d228:	4b1c      	ldr	r3, [pc, #112]	; (1d29c <main_task+0x2a8>)
   1d22a:	721a      	strb	r2, [r3, #8]
	 
	 
	}   
   1d22c:	e76d      	b.n	1d10a <main_task+0x116>
   1d22e:	46c0      	nop			; (mov r8, r8)
   1d230:	20004aac 	.word	0x20004aac
   1d234:	0001eead 	.word	0x0001eead
   1d238:	00021d84 	.word	0x00021d84
   1d23c:	0001ee9b 	.word	0x0001ee9b
   1d240:	20004abd 	.word	0x20004abd
   1d244:	00021d94 	.word	0x00021d94
   1d248:	0000d3bd 	.word	0x0000d3bd
   1d24c:	000121a5 	.word	0x000121a5
   1d250:	000101fd 	.word	0x000101fd
   1d254:	000005dc 	.word	0x000005dc
   1d258:	0001ca55 	.word	0x0001ca55
   1d25c:	20004250 	.word	0x20004250
   1d260:	00021da4 	.word	0x00021da4
   1d264:	00019a6d 	.word	0x00019a6d
   1d268:	00011d19 	.word	0x00011d19
   1d26c:	0001b2d1 	.word	0x0001b2d1
   1d270:	0001b4dd 	.word	0x0001b4dd
   1d274:	0001b499 	.word	0x0001b499
   1d278:	0000c829 	.word	0x0000c829
   1d27c:	0000c669 	.word	0x0000c669
   1d280:	0000ca29 	.word	0x0000ca29
   1d284:	0000d7d5 	.word	0x0000d7d5
   1d288:	20004aa8 	.word	0x20004aa8
   1d28c:	20004aa4 	.word	0x20004aa4
   1d290:	20004a34 	.word	0x20004a34
   1d294:	00010451 	.word	0x00010451
   1d298:	0001b155 	.word	0x0001b155
   1d29c:	20004a68 	.word	0x20004a68
   1d2a0:	0001b8e9 	.word	0x0001b8e9
   1d2a4:	20004bd4 	.word	0x20004bd4
   1d2a8:	0001bf69 	.word	0x0001bf69
   1d2ac:	200049e0 	.word	0x200049e0
   1d2b0:	20003e10 	.word	0x20003e10
   1d2b4:	20004a60 	.word	0x20004a60
   1d2b8:	200046ec 	.word	0x200046ec
   1d2bc:	0001cdb5 	.word	0x0001cdb5
   1d2c0:	0001caa5 	.word	0x0001caa5
   1d2c4:	0001d765 	.word	0x0001d765
   1d2c8:	20004de4 	.word	0x20004de4
   1d2cc:	20004be0 	.word	0x20004be0
   1d2d0:	0000bf9d 	.word	0x0000bf9d
   1d2d4:	20004bc8 	.word	0x20004bc8
   1d2d8:	000139d5 	.word	0x000139d5
   1d2dc:	fffff894 	.word	0xfffff894
   1d2e0:	200046c0 	.word	0x200046c0
   1d2e4:	0001f055 	.word	0x0001f055
   1d2e8:	0001ec51 	.word	0x0001ec51
   1d2ec:	20004bdc 	.word	0x20004bdc

0001d2f0 <nvm_get_config_defaults>:
 * \param[out] config  Configuration structure to initialize to default values
 *
 */
static inline void nvm_get_config_defaults(
		struct nvm_config *const config)
{
   1d2f0:	b580      	push	{r7, lr}
   1d2f2:	b082      	sub	sp, #8
   1d2f4:	af00      	add	r7, sp, #0
   1d2f6:	6078      	str	r0, [r7, #4]
	/* Sanity check the parameters */
	Assert(config);

	/* Write the default configuration for the NVM configuration */
	config->sleep_power_mode  = NVM_SLEEP_POWER_MODE_WAKEONACCESS;
   1d2f8:	687b      	ldr	r3, [r7, #4]
   1d2fa:	2200      	movs	r2, #0
   1d2fc:	701a      	strb	r2, [r3, #0]
	config->manual_page_write = true;
   1d2fe:	687b      	ldr	r3, [r7, #4]
   1d300:	2201      	movs	r2, #1
   1d302:	705a      	strb	r2, [r3, #1]
	config->wait_states       = NVMCTRL->CTRLB.bit.RWS;
   1d304:	4b08      	ldr	r3, [pc, #32]	; (1d328 <nvm_get_config_defaults+0x38>)
   1d306:	685b      	ldr	r3, [r3, #4]
   1d308:	06db      	lsls	r3, r3, #27
   1d30a:	0f1b      	lsrs	r3, r3, #28
   1d30c:	b2db      	uxtb	r3, r3
   1d30e:	001a      	movs	r2, r3
   1d310:	687b      	ldr	r3, [r7, #4]
   1d312:	709a      	strb	r2, [r3, #2]
	config->disable_cache     = false;
   1d314:	687b      	ldr	r3, [r7, #4]
   1d316:	2200      	movs	r2, #0
   1d318:	70da      	strb	r2, [r3, #3]
#if (SAMC20) || (SAMC21)
	config->disable_rww_cache = false;
#endif
	config->cache_readmode    = NVM_CACHE_READMODE_NO_MISS_PENALTY;
   1d31a:	687b      	ldr	r3, [r7, #4]
   1d31c:	2200      	movs	r2, #0
   1d31e:	711a      	strb	r2, [r3, #4]
}
   1d320:	46c0      	nop			; (mov r8, r8)
   1d322:	46bd      	mov	sp, r7
   1d324:	b002      	add	sp, #8
   1d326:	bd80      	pop	{r7, pc}
   1d328:	41004000 	.word	0x41004000

0001d32c <wdt_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void wdt_get_config_defaults(
		struct wdt_conf *const config)
{
   1d32c:	b580      	push	{r7, lr}
   1d32e:	b082      	sub	sp, #8
   1d330:	af00      	add	r7, sp, #0
   1d332:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->always_on            = false;
   1d334:	687b      	ldr	r3, [r7, #4]
   1d336:	2200      	movs	r2, #0
   1d338:	701a      	strb	r2, [r3, #0]
	config->enable               = true;
   1d33a:	687b      	ldr	r3, [r7, #4]
   1d33c:	2201      	movs	r2, #1
   1d33e:	705a      	strb	r2, [r3, #1]
#if !(SAML21) && !(SAML22) && !(SAMC20) && !(SAMC21)
	config->clock_source         = GCLK_GENERATOR_4;
   1d340:	687b      	ldr	r3, [r7, #4]
   1d342:	2204      	movs	r2, #4
   1d344:	709a      	strb	r2, [r3, #2]
#endif
	config->timeout_period       = WDT_PERIOD_16384CLK;
   1d346:	687b      	ldr	r3, [r7, #4]
   1d348:	220c      	movs	r2, #12
   1d34a:	70da      	strb	r2, [r3, #3]
	config->window_period        = WDT_PERIOD_NONE;
   1d34c:	687b      	ldr	r3, [r7, #4]
   1d34e:	2200      	movs	r2, #0
   1d350:	711a      	strb	r2, [r3, #4]
	config->early_warning_period = WDT_PERIOD_NONE;
   1d352:	687b      	ldr	r3, [r7, #4]
   1d354:	2200      	movs	r2, #0
   1d356:	715a      	strb	r2, [r3, #5]
}
   1d358:	46c0      	nop			; (mov r8, r8)
   1d35a:	46bd      	mov	sp, r7
   1d35c:	b002      	add	sp, #8
   1d35e:	bd80      	pop	{r7, pc}

0001d360 <configure_wdt>:


////////////////////////////////////////////////////////////////////////////////////////

static void configure_wdt(void)
{
   1d360:	b580      	push	{r7, lr}
   1d362:	b082      	sub	sp, #8
   1d364:	af00      	add	r7, sp, #0
    /* Create a new configuration structure for the Watchdog settings and fill
     * with the default module settings. */
    struct wdt_conf config_wdt;
    wdt_get_config_defaults(&config_wdt);
   1d366:	003b      	movs	r3, r7
   1d368:	0018      	movs	r0, r3
   1d36a:	4b09      	ldr	r3, [pc, #36]	; (1d390 <configure_wdt+0x30>)
   1d36c:	4798      	blx	r3
    /* Set the Watchdog configuration settings */
    config_wdt.always_on      = false;
   1d36e:	003b      	movs	r3, r7
   1d370:	2200      	movs	r2, #0
   1d372:	701a      	strb	r2, [r3, #0]
    config_wdt.clock_source   = GCLK_GENERATOR_1;
   1d374:	003b      	movs	r3, r7
   1d376:	2201      	movs	r2, #1
   1d378:	709a      	strb	r2, [r3, #2]
    config_wdt.timeout_period = WDT_PERIOD_16384CLK;
   1d37a:	003b      	movs	r3, r7
   1d37c:	220c      	movs	r2, #12
   1d37e:	70da      	strb	r2, [r3, #3]
    /* Initialize and enable the Watchdog with the user settings */
    wdt_set_config(&config_wdt);
   1d380:	003b      	movs	r3, r7
   1d382:	0018      	movs	r0, r3
   1d384:	4b03      	ldr	r3, [pc, #12]	; (1d394 <configure_wdt+0x34>)
   1d386:	4798      	blx	r3
}
   1d388:	46c0      	nop			; (mov r8, r8)
   1d38a:	46bd      	mov	sp, r7
   1d38c:	b002      	add	sp, #8
   1d38e:	bd80      	pop	{r7, pc}
   1d390:	0001d32d 	.word	0x0001d32d
   1d394:	0000f82d 	.word	0x0000f82d

0001d398 <set_fuses>:
//}

///////////////////////////////////////////////////////////////////////////////////////

static void set_fuses(void)
{struct nvm_fusebits fuses;
   1d398:	b580      	push	{r7, lr}
   1d39a:	b084      	sub	sp, #16
   1d39c:	af00      	add	r7, sp, #0
	
 nvm_get_fuses(&fuses);
   1d39e:	003b      	movs	r3, r7
   1d3a0:	0018      	movs	r0, r3
   1d3a2:	4b10      	ldr	r3, [pc, #64]	; (1d3e4 <set_fuses+0x4c>)
   1d3a4:	4798      	blx	r3
 
#ifdef DEBUG
 
  if ((fuses.eeprom_size!=4) || (fuses.bootloader_size!=7) || (fuses.lockbits!=0xFFFF))
   1d3a6:	003b      	movs	r3, r7
   1d3a8:	785b      	ldrb	r3, [r3, #1]
   1d3aa:	2b04      	cmp	r3, #4
   1d3ac:	d108      	bne.n	1d3c0 <set_fuses+0x28>
   1d3ae:	003b      	movs	r3, r7
   1d3b0:	781b      	ldrb	r3, [r3, #0]
   1d3b2:	2b07      	cmp	r3, #7
   1d3b4:	d104      	bne.n	1d3c0 <set_fuses+0x28>
   1d3b6:	003b      	movs	r3, r7
   1d3b8:	899b      	ldrh	r3, [r3, #12]
   1d3ba:	4a0b      	ldr	r2, [pc, #44]	; (1d3e8 <set_fuses+0x50>)
   1d3bc:	4293      	cmp	r3, r2
   1d3be:	d00d      	beq.n	1d3dc <set_fuses+0x44>
 {
  fuses.eeprom_size=4;
   1d3c0:	003b      	movs	r3, r7
   1d3c2:	2204      	movs	r2, #4
   1d3c4:	705a      	strb	r2, [r3, #1]
  fuses.bootloader_size=7;
   1d3c6:	003b      	movs	r3, r7
   1d3c8:	2207      	movs	r2, #7
   1d3ca:	701a      	strb	r2, [r3, #0]
  fuses.lockbits=0xFFFF;
   1d3cc:	003b      	movs	r3, r7
   1d3ce:	2201      	movs	r2, #1
   1d3d0:	4252      	negs	r2, r2
   1d3d2:	819a      	strh	r2, [r3, #12]
  nvm_set_fuses(&fuses);
   1d3d4:	003b      	movs	r3, r7
   1d3d6:	0018      	movs	r0, r3
   1d3d8:	4b04      	ldr	r3, [pc, #16]	; (1d3ec <set_fuses+0x54>)
   1d3da:	4798      	blx	r3
  system_reset();
 }
 
 #endif
	
}
   1d3dc:	46c0      	nop			; (mov r8, r8)
   1d3de:	46bd      	mov	sp, r7
   1d3e0:	b004      	add	sp, #16
   1d3e2:	bd80      	pop	{r7, pc}
   1d3e4:	0000f2d5 	.word	0x0000f2d5
   1d3e8:	0000ffff 	.word	0x0000ffff
   1d3ec:	0000f365 	.word	0x0000f365

0001d3f0 <main>:
 * \brief Application entry point.
 *
 * \return Unused (ANSI-C compatibility).
 */
int main(void)
{   
   1d3f0:	b580      	push	{r7, lr}
   1d3f2:	b082      	sub	sp, #8
   1d3f4:	af00      	add	r7, sp, #0
	//struct dma_resource example_resource;

    //system_board_init();
    //port_pin_set_output_level(DEBUG_PIN,true);

	system_init();
   1d3f6:	4b15      	ldr	r3, [pc, #84]	; (1d44c <main+0x5c>)
   1d3f8:	4798      	blx	r3
	xPowerDown=false;
   1d3fa:	4b15      	ldr	r3, [pc, #84]	; (1d450 <main+0x60>)
   1d3fc:	2200      	movs	r2, #0
   1d3fe:	701a      	strb	r2, [r3, #0]
	
	lcd_init();
   1d400:	4b14      	ldr	r3, [pc, #80]	; (1d454 <main+0x64>)
   1d402:	4798      	blx	r3
	nm_bsp_init();
   1d404:	4b14      	ldr	r3, [pc, #80]	; (1d458 <main+0x68>)
   1d406:	4798      	blx	r3
	
	/* Initialize SD MMC stack */
    nm_bsp_init();	
   1d408:	4b13      	ldr	r3, [pc, #76]	; (1d458 <main+0x68>)
   1d40a:	4798      	blx	r3
	
    sd_mmc_init();
   1d40c:	4b13      	ldr	r3, [pc, #76]	; (1d45c <main+0x6c>)
   1d40e:	4798      	blx	r3
	DHT_Init();
   1d410:	4b13      	ldr	r3, [pc, #76]	; (1d460 <main+0x70>)
   1d412:	4798      	blx	r3

	
    struct nvm_config nvm_cfg;
    nvm_get_config_defaults(&nvm_cfg);
   1d414:	003b      	movs	r3, r7
   1d416:	0018      	movs	r0, r3
   1d418:	4b12      	ldr	r3, [pc, #72]	; (1d464 <main+0x74>)
   1d41a:	4798      	blx	r3
	nvm_cfg.manual_page_write=false;
   1d41c:	003b      	movs	r3, r7
   1d41e:	2200      	movs	r2, #0
   1d420:	705a      	strb	r2, [r3, #1]
    nvm_set_config(&nvm_cfg);
   1d422:	003b      	movs	r3, r7
   1d424:	0018      	movs	r0, r3
   1d426:	4b10      	ldr	r3, [pc, #64]	; (1d468 <main+0x78>)
   1d428:	4798      	blx	r3
	

    set_fuses();	
   1d42a:	4b10      	ldr	r3, [pc, #64]	; (1d46c <main+0x7c>)
   1d42c:	4798      	blx	r3

    configure_wdt();
   1d42e:	4b10      	ldr	r3, [pc, #64]	; (1d470 <main+0x80>)
   1d430:	4798      	blx	r3
	//configure_eeprom();
	
	tasks_init();
   1d432:	4b10      	ldr	r3, [pc, #64]	; (1d474 <main+0x84>)
   1d434:	4798      	blx	r3
	vCreateRFIDTask();
   1d436:	4b10      	ldr	r3, [pc, #64]	; (1d478 <main+0x88>)
   1d438:	4798      	blx	r3
	vCreateWincTask();
   1d43a:	4b10      	ldr	r3, [pc, #64]	; (1d47c <main+0x8c>)
   1d43c:	4798      	blx	r3
	
	// ..and let FreeRTOS run tasks!
	vTaskStartScheduler();
   1d43e:	4b10      	ldr	r3, [pc, #64]	; (1d480 <main+0x90>)
   1d440:	4798      	blx	r3
   1d442:	2300      	movs	r3, #0
	
}
   1d444:	0018      	movs	r0, r3
   1d446:	46bd      	mov	sp, r7
   1d448:	b002      	add	sp, #8
   1d44a:	bd80      	pop	{r7, pc}
   1d44c:	00016d5d 	.word	0x00016d5d
   1d450:	20004bd0 	.word	0x20004bd0
   1d454:	0000d05d 	.word	0x0000d05d
   1d458:	00008299 	.word	0x00008299
   1d45c:	00011cc5 	.word	0x00011cc5
   1d460:	0000bf5d 	.word	0x0000bf5d
   1d464:	0001d2f1 	.word	0x0001d2f1
   1d468:	0000ecd1 	.word	0x0000ecd1
   1d46c:	0001d399 	.word	0x0001d399
   1d470:	0001d361 	.word	0x0001d361
   1d474:	0001b29d 	.word	0x0001b29d
   1d478:	0000c715 	.word	0x0000c715
   1d47c:	0000da09 	.word	0x0000da09
   1d480:	000104f1 	.word	0x000104f1

0001d484 <__aeabi_uidiv>:
   1d484:	2200      	movs	r2, #0
   1d486:	0843      	lsrs	r3, r0, #1
   1d488:	428b      	cmp	r3, r1
   1d48a:	d374      	bcc.n	1d576 <__aeabi_uidiv+0xf2>
   1d48c:	0903      	lsrs	r3, r0, #4
   1d48e:	428b      	cmp	r3, r1
   1d490:	d35f      	bcc.n	1d552 <__aeabi_uidiv+0xce>
   1d492:	0a03      	lsrs	r3, r0, #8
   1d494:	428b      	cmp	r3, r1
   1d496:	d344      	bcc.n	1d522 <__aeabi_uidiv+0x9e>
   1d498:	0b03      	lsrs	r3, r0, #12
   1d49a:	428b      	cmp	r3, r1
   1d49c:	d328      	bcc.n	1d4f0 <__aeabi_uidiv+0x6c>
   1d49e:	0c03      	lsrs	r3, r0, #16
   1d4a0:	428b      	cmp	r3, r1
   1d4a2:	d30d      	bcc.n	1d4c0 <__aeabi_uidiv+0x3c>
   1d4a4:	22ff      	movs	r2, #255	; 0xff
   1d4a6:	0209      	lsls	r1, r1, #8
   1d4a8:	ba12      	rev	r2, r2
   1d4aa:	0c03      	lsrs	r3, r0, #16
   1d4ac:	428b      	cmp	r3, r1
   1d4ae:	d302      	bcc.n	1d4b6 <__aeabi_uidiv+0x32>
   1d4b0:	1212      	asrs	r2, r2, #8
   1d4b2:	0209      	lsls	r1, r1, #8
   1d4b4:	d065      	beq.n	1d582 <__aeabi_uidiv+0xfe>
   1d4b6:	0b03      	lsrs	r3, r0, #12
   1d4b8:	428b      	cmp	r3, r1
   1d4ba:	d319      	bcc.n	1d4f0 <__aeabi_uidiv+0x6c>
   1d4bc:	e000      	b.n	1d4c0 <__aeabi_uidiv+0x3c>
   1d4be:	0a09      	lsrs	r1, r1, #8
   1d4c0:	0bc3      	lsrs	r3, r0, #15
   1d4c2:	428b      	cmp	r3, r1
   1d4c4:	d301      	bcc.n	1d4ca <__aeabi_uidiv+0x46>
   1d4c6:	03cb      	lsls	r3, r1, #15
   1d4c8:	1ac0      	subs	r0, r0, r3
   1d4ca:	4152      	adcs	r2, r2
   1d4cc:	0b83      	lsrs	r3, r0, #14
   1d4ce:	428b      	cmp	r3, r1
   1d4d0:	d301      	bcc.n	1d4d6 <__aeabi_uidiv+0x52>
   1d4d2:	038b      	lsls	r3, r1, #14
   1d4d4:	1ac0      	subs	r0, r0, r3
   1d4d6:	4152      	adcs	r2, r2
   1d4d8:	0b43      	lsrs	r3, r0, #13
   1d4da:	428b      	cmp	r3, r1
   1d4dc:	d301      	bcc.n	1d4e2 <__aeabi_uidiv+0x5e>
   1d4de:	034b      	lsls	r3, r1, #13
   1d4e0:	1ac0      	subs	r0, r0, r3
   1d4e2:	4152      	adcs	r2, r2
   1d4e4:	0b03      	lsrs	r3, r0, #12
   1d4e6:	428b      	cmp	r3, r1
   1d4e8:	d301      	bcc.n	1d4ee <__aeabi_uidiv+0x6a>
   1d4ea:	030b      	lsls	r3, r1, #12
   1d4ec:	1ac0      	subs	r0, r0, r3
   1d4ee:	4152      	adcs	r2, r2
   1d4f0:	0ac3      	lsrs	r3, r0, #11
   1d4f2:	428b      	cmp	r3, r1
   1d4f4:	d301      	bcc.n	1d4fa <__aeabi_uidiv+0x76>
   1d4f6:	02cb      	lsls	r3, r1, #11
   1d4f8:	1ac0      	subs	r0, r0, r3
   1d4fa:	4152      	adcs	r2, r2
   1d4fc:	0a83      	lsrs	r3, r0, #10
   1d4fe:	428b      	cmp	r3, r1
   1d500:	d301      	bcc.n	1d506 <__aeabi_uidiv+0x82>
   1d502:	028b      	lsls	r3, r1, #10
   1d504:	1ac0      	subs	r0, r0, r3
   1d506:	4152      	adcs	r2, r2
   1d508:	0a43      	lsrs	r3, r0, #9
   1d50a:	428b      	cmp	r3, r1
   1d50c:	d301      	bcc.n	1d512 <__aeabi_uidiv+0x8e>
   1d50e:	024b      	lsls	r3, r1, #9
   1d510:	1ac0      	subs	r0, r0, r3
   1d512:	4152      	adcs	r2, r2
   1d514:	0a03      	lsrs	r3, r0, #8
   1d516:	428b      	cmp	r3, r1
   1d518:	d301      	bcc.n	1d51e <__aeabi_uidiv+0x9a>
   1d51a:	020b      	lsls	r3, r1, #8
   1d51c:	1ac0      	subs	r0, r0, r3
   1d51e:	4152      	adcs	r2, r2
   1d520:	d2cd      	bcs.n	1d4be <__aeabi_uidiv+0x3a>
   1d522:	09c3      	lsrs	r3, r0, #7
   1d524:	428b      	cmp	r3, r1
   1d526:	d301      	bcc.n	1d52c <__aeabi_uidiv+0xa8>
   1d528:	01cb      	lsls	r3, r1, #7
   1d52a:	1ac0      	subs	r0, r0, r3
   1d52c:	4152      	adcs	r2, r2
   1d52e:	0983      	lsrs	r3, r0, #6
   1d530:	428b      	cmp	r3, r1
   1d532:	d301      	bcc.n	1d538 <__aeabi_uidiv+0xb4>
   1d534:	018b      	lsls	r3, r1, #6
   1d536:	1ac0      	subs	r0, r0, r3
   1d538:	4152      	adcs	r2, r2
   1d53a:	0943      	lsrs	r3, r0, #5
   1d53c:	428b      	cmp	r3, r1
   1d53e:	d301      	bcc.n	1d544 <__aeabi_uidiv+0xc0>
   1d540:	014b      	lsls	r3, r1, #5
   1d542:	1ac0      	subs	r0, r0, r3
   1d544:	4152      	adcs	r2, r2
   1d546:	0903      	lsrs	r3, r0, #4
   1d548:	428b      	cmp	r3, r1
   1d54a:	d301      	bcc.n	1d550 <__aeabi_uidiv+0xcc>
   1d54c:	010b      	lsls	r3, r1, #4
   1d54e:	1ac0      	subs	r0, r0, r3
   1d550:	4152      	adcs	r2, r2
   1d552:	08c3      	lsrs	r3, r0, #3
   1d554:	428b      	cmp	r3, r1
   1d556:	d301      	bcc.n	1d55c <__aeabi_uidiv+0xd8>
   1d558:	00cb      	lsls	r3, r1, #3
   1d55a:	1ac0      	subs	r0, r0, r3
   1d55c:	4152      	adcs	r2, r2
   1d55e:	0883      	lsrs	r3, r0, #2
   1d560:	428b      	cmp	r3, r1
   1d562:	d301      	bcc.n	1d568 <__aeabi_uidiv+0xe4>
   1d564:	008b      	lsls	r3, r1, #2
   1d566:	1ac0      	subs	r0, r0, r3
   1d568:	4152      	adcs	r2, r2
   1d56a:	0843      	lsrs	r3, r0, #1
   1d56c:	428b      	cmp	r3, r1
   1d56e:	d301      	bcc.n	1d574 <__aeabi_uidiv+0xf0>
   1d570:	004b      	lsls	r3, r1, #1
   1d572:	1ac0      	subs	r0, r0, r3
   1d574:	4152      	adcs	r2, r2
   1d576:	1a41      	subs	r1, r0, r1
   1d578:	d200      	bcs.n	1d57c <__aeabi_uidiv+0xf8>
   1d57a:	4601      	mov	r1, r0
   1d57c:	4152      	adcs	r2, r2
   1d57e:	4610      	mov	r0, r2
   1d580:	4770      	bx	lr
   1d582:	e7ff      	b.n	1d584 <__aeabi_uidiv+0x100>
   1d584:	b501      	push	{r0, lr}
   1d586:	2000      	movs	r0, #0
   1d588:	f000 f8f0 	bl	1d76c <__aeabi_idiv0>
   1d58c:	bd02      	pop	{r1, pc}
   1d58e:	46c0      	nop			; (mov r8, r8)

0001d590 <__aeabi_uidivmod>:
   1d590:	2900      	cmp	r1, #0
   1d592:	d0f7      	beq.n	1d584 <__aeabi_uidiv+0x100>
   1d594:	e776      	b.n	1d484 <__aeabi_uidiv>
   1d596:	4770      	bx	lr

0001d598 <__aeabi_idiv>:
   1d598:	4603      	mov	r3, r0
   1d59a:	430b      	orrs	r3, r1
   1d59c:	d47f      	bmi.n	1d69e <__aeabi_idiv+0x106>
   1d59e:	2200      	movs	r2, #0
   1d5a0:	0843      	lsrs	r3, r0, #1
   1d5a2:	428b      	cmp	r3, r1
   1d5a4:	d374      	bcc.n	1d690 <__aeabi_idiv+0xf8>
   1d5a6:	0903      	lsrs	r3, r0, #4
   1d5a8:	428b      	cmp	r3, r1
   1d5aa:	d35f      	bcc.n	1d66c <__aeabi_idiv+0xd4>
   1d5ac:	0a03      	lsrs	r3, r0, #8
   1d5ae:	428b      	cmp	r3, r1
   1d5b0:	d344      	bcc.n	1d63c <__aeabi_idiv+0xa4>
   1d5b2:	0b03      	lsrs	r3, r0, #12
   1d5b4:	428b      	cmp	r3, r1
   1d5b6:	d328      	bcc.n	1d60a <__aeabi_idiv+0x72>
   1d5b8:	0c03      	lsrs	r3, r0, #16
   1d5ba:	428b      	cmp	r3, r1
   1d5bc:	d30d      	bcc.n	1d5da <__aeabi_idiv+0x42>
   1d5be:	22ff      	movs	r2, #255	; 0xff
   1d5c0:	0209      	lsls	r1, r1, #8
   1d5c2:	ba12      	rev	r2, r2
   1d5c4:	0c03      	lsrs	r3, r0, #16
   1d5c6:	428b      	cmp	r3, r1
   1d5c8:	d302      	bcc.n	1d5d0 <__aeabi_idiv+0x38>
   1d5ca:	1212      	asrs	r2, r2, #8
   1d5cc:	0209      	lsls	r1, r1, #8
   1d5ce:	d065      	beq.n	1d69c <__aeabi_idiv+0x104>
   1d5d0:	0b03      	lsrs	r3, r0, #12
   1d5d2:	428b      	cmp	r3, r1
   1d5d4:	d319      	bcc.n	1d60a <__aeabi_idiv+0x72>
   1d5d6:	e000      	b.n	1d5da <__aeabi_idiv+0x42>
   1d5d8:	0a09      	lsrs	r1, r1, #8
   1d5da:	0bc3      	lsrs	r3, r0, #15
   1d5dc:	428b      	cmp	r3, r1
   1d5de:	d301      	bcc.n	1d5e4 <__aeabi_idiv+0x4c>
   1d5e0:	03cb      	lsls	r3, r1, #15
   1d5e2:	1ac0      	subs	r0, r0, r3
   1d5e4:	4152      	adcs	r2, r2
   1d5e6:	0b83      	lsrs	r3, r0, #14
   1d5e8:	428b      	cmp	r3, r1
   1d5ea:	d301      	bcc.n	1d5f0 <__aeabi_idiv+0x58>
   1d5ec:	038b      	lsls	r3, r1, #14
   1d5ee:	1ac0      	subs	r0, r0, r3
   1d5f0:	4152      	adcs	r2, r2
   1d5f2:	0b43      	lsrs	r3, r0, #13
   1d5f4:	428b      	cmp	r3, r1
   1d5f6:	d301      	bcc.n	1d5fc <__aeabi_idiv+0x64>
   1d5f8:	034b      	lsls	r3, r1, #13
   1d5fa:	1ac0      	subs	r0, r0, r3
   1d5fc:	4152      	adcs	r2, r2
   1d5fe:	0b03      	lsrs	r3, r0, #12
   1d600:	428b      	cmp	r3, r1
   1d602:	d301      	bcc.n	1d608 <__aeabi_idiv+0x70>
   1d604:	030b      	lsls	r3, r1, #12
   1d606:	1ac0      	subs	r0, r0, r3
   1d608:	4152      	adcs	r2, r2
   1d60a:	0ac3      	lsrs	r3, r0, #11
   1d60c:	428b      	cmp	r3, r1
   1d60e:	d301      	bcc.n	1d614 <__aeabi_idiv+0x7c>
   1d610:	02cb      	lsls	r3, r1, #11
   1d612:	1ac0      	subs	r0, r0, r3
   1d614:	4152      	adcs	r2, r2
   1d616:	0a83      	lsrs	r3, r0, #10
   1d618:	428b      	cmp	r3, r1
   1d61a:	d301      	bcc.n	1d620 <__aeabi_idiv+0x88>
   1d61c:	028b      	lsls	r3, r1, #10
   1d61e:	1ac0      	subs	r0, r0, r3
   1d620:	4152      	adcs	r2, r2
   1d622:	0a43      	lsrs	r3, r0, #9
   1d624:	428b      	cmp	r3, r1
   1d626:	d301      	bcc.n	1d62c <__aeabi_idiv+0x94>
   1d628:	024b      	lsls	r3, r1, #9
   1d62a:	1ac0      	subs	r0, r0, r3
   1d62c:	4152      	adcs	r2, r2
   1d62e:	0a03      	lsrs	r3, r0, #8
   1d630:	428b      	cmp	r3, r1
   1d632:	d301      	bcc.n	1d638 <__aeabi_idiv+0xa0>
   1d634:	020b      	lsls	r3, r1, #8
   1d636:	1ac0      	subs	r0, r0, r3
   1d638:	4152      	adcs	r2, r2
   1d63a:	d2cd      	bcs.n	1d5d8 <__aeabi_idiv+0x40>
   1d63c:	09c3      	lsrs	r3, r0, #7
   1d63e:	428b      	cmp	r3, r1
   1d640:	d301      	bcc.n	1d646 <__aeabi_idiv+0xae>
   1d642:	01cb      	lsls	r3, r1, #7
   1d644:	1ac0      	subs	r0, r0, r3
   1d646:	4152      	adcs	r2, r2
   1d648:	0983      	lsrs	r3, r0, #6
   1d64a:	428b      	cmp	r3, r1
   1d64c:	d301      	bcc.n	1d652 <__aeabi_idiv+0xba>
   1d64e:	018b      	lsls	r3, r1, #6
   1d650:	1ac0      	subs	r0, r0, r3
   1d652:	4152      	adcs	r2, r2
   1d654:	0943      	lsrs	r3, r0, #5
   1d656:	428b      	cmp	r3, r1
   1d658:	d301      	bcc.n	1d65e <__aeabi_idiv+0xc6>
   1d65a:	014b      	lsls	r3, r1, #5
   1d65c:	1ac0      	subs	r0, r0, r3
   1d65e:	4152      	adcs	r2, r2
   1d660:	0903      	lsrs	r3, r0, #4
   1d662:	428b      	cmp	r3, r1
   1d664:	d301      	bcc.n	1d66a <__aeabi_idiv+0xd2>
   1d666:	010b      	lsls	r3, r1, #4
   1d668:	1ac0      	subs	r0, r0, r3
   1d66a:	4152      	adcs	r2, r2
   1d66c:	08c3      	lsrs	r3, r0, #3
   1d66e:	428b      	cmp	r3, r1
   1d670:	d301      	bcc.n	1d676 <__aeabi_idiv+0xde>
   1d672:	00cb      	lsls	r3, r1, #3
   1d674:	1ac0      	subs	r0, r0, r3
   1d676:	4152      	adcs	r2, r2
   1d678:	0883      	lsrs	r3, r0, #2
   1d67a:	428b      	cmp	r3, r1
   1d67c:	d301      	bcc.n	1d682 <__aeabi_idiv+0xea>
   1d67e:	008b      	lsls	r3, r1, #2
   1d680:	1ac0      	subs	r0, r0, r3
   1d682:	4152      	adcs	r2, r2
   1d684:	0843      	lsrs	r3, r0, #1
   1d686:	428b      	cmp	r3, r1
   1d688:	d301      	bcc.n	1d68e <__aeabi_idiv+0xf6>
   1d68a:	004b      	lsls	r3, r1, #1
   1d68c:	1ac0      	subs	r0, r0, r3
   1d68e:	4152      	adcs	r2, r2
   1d690:	1a41      	subs	r1, r0, r1
   1d692:	d200      	bcs.n	1d696 <__aeabi_idiv+0xfe>
   1d694:	4601      	mov	r1, r0
   1d696:	4152      	adcs	r2, r2
   1d698:	4610      	mov	r0, r2
   1d69a:	4770      	bx	lr
   1d69c:	e05d      	b.n	1d75a <__aeabi_idiv+0x1c2>
   1d69e:	0fca      	lsrs	r2, r1, #31
   1d6a0:	d000      	beq.n	1d6a4 <__aeabi_idiv+0x10c>
   1d6a2:	4249      	negs	r1, r1
   1d6a4:	1003      	asrs	r3, r0, #32
   1d6a6:	d300      	bcc.n	1d6aa <__aeabi_idiv+0x112>
   1d6a8:	4240      	negs	r0, r0
   1d6aa:	4053      	eors	r3, r2
   1d6ac:	2200      	movs	r2, #0
   1d6ae:	469c      	mov	ip, r3
   1d6b0:	0903      	lsrs	r3, r0, #4
   1d6b2:	428b      	cmp	r3, r1
   1d6b4:	d32d      	bcc.n	1d712 <__aeabi_idiv+0x17a>
   1d6b6:	0a03      	lsrs	r3, r0, #8
   1d6b8:	428b      	cmp	r3, r1
   1d6ba:	d312      	bcc.n	1d6e2 <__aeabi_idiv+0x14a>
   1d6bc:	22fc      	movs	r2, #252	; 0xfc
   1d6be:	0189      	lsls	r1, r1, #6
   1d6c0:	ba12      	rev	r2, r2
   1d6c2:	0a03      	lsrs	r3, r0, #8
   1d6c4:	428b      	cmp	r3, r1
   1d6c6:	d30c      	bcc.n	1d6e2 <__aeabi_idiv+0x14a>
   1d6c8:	0189      	lsls	r1, r1, #6
   1d6ca:	1192      	asrs	r2, r2, #6
   1d6cc:	428b      	cmp	r3, r1
   1d6ce:	d308      	bcc.n	1d6e2 <__aeabi_idiv+0x14a>
   1d6d0:	0189      	lsls	r1, r1, #6
   1d6d2:	1192      	asrs	r2, r2, #6
   1d6d4:	428b      	cmp	r3, r1
   1d6d6:	d304      	bcc.n	1d6e2 <__aeabi_idiv+0x14a>
   1d6d8:	0189      	lsls	r1, r1, #6
   1d6da:	d03a      	beq.n	1d752 <__aeabi_idiv+0x1ba>
   1d6dc:	1192      	asrs	r2, r2, #6
   1d6de:	e000      	b.n	1d6e2 <__aeabi_idiv+0x14a>
   1d6e0:	0989      	lsrs	r1, r1, #6
   1d6e2:	09c3      	lsrs	r3, r0, #7
   1d6e4:	428b      	cmp	r3, r1
   1d6e6:	d301      	bcc.n	1d6ec <__aeabi_idiv+0x154>
   1d6e8:	01cb      	lsls	r3, r1, #7
   1d6ea:	1ac0      	subs	r0, r0, r3
   1d6ec:	4152      	adcs	r2, r2
   1d6ee:	0983      	lsrs	r3, r0, #6
   1d6f0:	428b      	cmp	r3, r1
   1d6f2:	d301      	bcc.n	1d6f8 <__aeabi_idiv+0x160>
   1d6f4:	018b      	lsls	r3, r1, #6
   1d6f6:	1ac0      	subs	r0, r0, r3
   1d6f8:	4152      	adcs	r2, r2
   1d6fa:	0943      	lsrs	r3, r0, #5
   1d6fc:	428b      	cmp	r3, r1
   1d6fe:	d301      	bcc.n	1d704 <__aeabi_idiv+0x16c>
   1d700:	014b      	lsls	r3, r1, #5
   1d702:	1ac0      	subs	r0, r0, r3
   1d704:	4152      	adcs	r2, r2
   1d706:	0903      	lsrs	r3, r0, #4
   1d708:	428b      	cmp	r3, r1
   1d70a:	d301      	bcc.n	1d710 <__aeabi_idiv+0x178>
   1d70c:	010b      	lsls	r3, r1, #4
   1d70e:	1ac0      	subs	r0, r0, r3
   1d710:	4152      	adcs	r2, r2
   1d712:	08c3      	lsrs	r3, r0, #3
   1d714:	428b      	cmp	r3, r1
   1d716:	d301      	bcc.n	1d71c <__aeabi_idiv+0x184>
   1d718:	00cb      	lsls	r3, r1, #3
   1d71a:	1ac0      	subs	r0, r0, r3
   1d71c:	4152      	adcs	r2, r2
   1d71e:	0883      	lsrs	r3, r0, #2
   1d720:	428b      	cmp	r3, r1
   1d722:	d301      	bcc.n	1d728 <__aeabi_idiv+0x190>
   1d724:	008b      	lsls	r3, r1, #2
   1d726:	1ac0      	subs	r0, r0, r3
   1d728:	4152      	adcs	r2, r2
   1d72a:	d2d9      	bcs.n	1d6e0 <__aeabi_idiv+0x148>
   1d72c:	0843      	lsrs	r3, r0, #1
   1d72e:	428b      	cmp	r3, r1
   1d730:	d301      	bcc.n	1d736 <__aeabi_idiv+0x19e>
   1d732:	004b      	lsls	r3, r1, #1
   1d734:	1ac0      	subs	r0, r0, r3
   1d736:	4152      	adcs	r2, r2
   1d738:	1a41      	subs	r1, r0, r1
   1d73a:	d200      	bcs.n	1d73e <__aeabi_idiv+0x1a6>
   1d73c:	4601      	mov	r1, r0
   1d73e:	4663      	mov	r3, ip
   1d740:	4152      	adcs	r2, r2
   1d742:	105b      	asrs	r3, r3, #1
   1d744:	4610      	mov	r0, r2
   1d746:	d301      	bcc.n	1d74c <__aeabi_idiv+0x1b4>
   1d748:	4240      	negs	r0, r0
   1d74a:	2b00      	cmp	r3, #0
   1d74c:	d500      	bpl.n	1d750 <__aeabi_idiv+0x1b8>
   1d74e:	4249      	negs	r1, r1
   1d750:	4770      	bx	lr
   1d752:	4663      	mov	r3, ip
   1d754:	105b      	asrs	r3, r3, #1
   1d756:	d300      	bcc.n	1d75a <__aeabi_idiv+0x1c2>
   1d758:	4240      	negs	r0, r0
   1d75a:	b501      	push	{r0, lr}
   1d75c:	2000      	movs	r0, #0
   1d75e:	f000 f805 	bl	1d76c <__aeabi_idiv0>
   1d762:	bd02      	pop	{r1, pc}

0001d764 <__aeabi_idivmod>:
   1d764:	2900      	cmp	r1, #0
   1d766:	d0f8      	beq.n	1d75a <__aeabi_idiv+0x1c2>
   1d768:	e716      	b.n	1d598 <__aeabi_idiv>
   1d76a:	4770      	bx	lr

0001d76c <__aeabi_idiv0>:
   1d76c:	4770      	bx	lr
   1d76e:	46c0      	nop			; (mov r8, r8)

0001d770 <__aeabi_uldivmod>:
   1d770:	2b00      	cmp	r3, #0
   1d772:	d111      	bne.n	1d798 <__aeabi_uldivmod+0x28>
   1d774:	2a00      	cmp	r2, #0
   1d776:	d10f      	bne.n	1d798 <__aeabi_uldivmod+0x28>
   1d778:	2900      	cmp	r1, #0
   1d77a:	d100      	bne.n	1d77e <__aeabi_uldivmod+0xe>
   1d77c:	2800      	cmp	r0, #0
   1d77e:	d002      	beq.n	1d786 <__aeabi_uldivmod+0x16>
   1d780:	2100      	movs	r1, #0
   1d782:	43c9      	mvns	r1, r1
   1d784:	1c08      	adds	r0, r1, #0
   1d786:	b407      	push	{r0, r1, r2}
   1d788:	4802      	ldr	r0, [pc, #8]	; (1d794 <__aeabi_uldivmod+0x24>)
   1d78a:	a102      	add	r1, pc, #8	; (adr r1, 1d794 <__aeabi_uldivmod+0x24>)
   1d78c:	1840      	adds	r0, r0, r1
   1d78e:	9002      	str	r0, [sp, #8]
   1d790:	bd03      	pop	{r0, r1, pc}
   1d792:	46c0      	nop			; (mov r8, r8)
   1d794:	ffffffd9 	.word	0xffffffd9
   1d798:	b403      	push	{r0, r1}
   1d79a:	4668      	mov	r0, sp
   1d79c:	b501      	push	{r0, lr}
   1d79e:	9802      	ldr	r0, [sp, #8]
   1d7a0:	f000 f84a 	bl	1d838 <__udivmoddi4>
   1d7a4:	9b01      	ldr	r3, [sp, #4]
   1d7a6:	469e      	mov	lr, r3
   1d7a8:	b002      	add	sp, #8
   1d7aa:	bc0c      	pop	{r2, r3}
   1d7ac:	4770      	bx	lr
   1d7ae:	46c0      	nop			; (mov r8, r8)

0001d7b0 <__aeabi_lmul>:
   1d7b0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d7b2:	464f      	mov	r7, r9
   1d7b4:	4646      	mov	r6, r8
   1d7b6:	b4c0      	push	{r6, r7}
   1d7b8:	0416      	lsls	r6, r2, #16
   1d7ba:	0c36      	lsrs	r6, r6, #16
   1d7bc:	4699      	mov	r9, r3
   1d7be:	0033      	movs	r3, r6
   1d7c0:	0405      	lsls	r5, r0, #16
   1d7c2:	0c2c      	lsrs	r4, r5, #16
   1d7c4:	0c07      	lsrs	r7, r0, #16
   1d7c6:	0c15      	lsrs	r5, r2, #16
   1d7c8:	4363      	muls	r3, r4
   1d7ca:	437e      	muls	r6, r7
   1d7cc:	436f      	muls	r7, r5
   1d7ce:	4365      	muls	r5, r4
   1d7d0:	0c1c      	lsrs	r4, r3, #16
   1d7d2:	19ad      	adds	r5, r5, r6
   1d7d4:	1964      	adds	r4, r4, r5
   1d7d6:	469c      	mov	ip, r3
   1d7d8:	42a6      	cmp	r6, r4
   1d7da:	d903      	bls.n	1d7e4 <__aeabi_lmul+0x34>
   1d7dc:	2380      	movs	r3, #128	; 0x80
   1d7de:	025b      	lsls	r3, r3, #9
   1d7e0:	4698      	mov	r8, r3
   1d7e2:	4447      	add	r7, r8
   1d7e4:	4663      	mov	r3, ip
   1d7e6:	0c25      	lsrs	r5, r4, #16
   1d7e8:	19ef      	adds	r7, r5, r7
   1d7ea:	041d      	lsls	r5, r3, #16
   1d7ec:	464b      	mov	r3, r9
   1d7ee:	434a      	muls	r2, r1
   1d7f0:	4343      	muls	r3, r0
   1d7f2:	0c2d      	lsrs	r5, r5, #16
   1d7f4:	0424      	lsls	r4, r4, #16
   1d7f6:	1964      	adds	r4, r4, r5
   1d7f8:	1899      	adds	r1, r3, r2
   1d7fa:	19c9      	adds	r1, r1, r7
   1d7fc:	0020      	movs	r0, r4
   1d7fe:	bc0c      	pop	{r2, r3}
   1d800:	4690      	mov	r8, r2
   1d802:	4699      	mov	r9, r3
   1d804:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d806:	46c0      	nop			; (mov r8, r8)

0001d808 <__aeabi_f2uiz>:
   1d808:	219e      	movs	r1, #158	; 0x9e
   1d80a:	b510      	push	{r4, lr}
   1d80c:	05c9      	lsls	r1, r1, #23
   1d80e:	1c04      	adds	r4, r0, #0
   1d810:	f001 f914 	bl	1ea3c <__aeabi_fcmpge>
   1d814:	2800      	cmp	r0, #0
   1d816:	d103      	bne.n	1d820 <__aeabi_f2uiz+0x18>
   1d818:	1c20      	adds	r0, r4, #0
   1d81a:	f000 fcdd 	bl	1e1d8 <__aeabi_f2iz>
   1d81e:	bd10      	pop	{r4, pc}
   1d820:	219e      	movs	r1, #158	; 0x9e
   1d822:	1c20      	adds	r0, r4, #0
   1d824:	05c9      	lsls	r1, r1, #23
   1d826:	f000 fb51 	bl	1decc <__aeabi_fsub>
   1d82a:	f000 fcd5 	bl	1e1d8 <__aeabi_f2iz>
   1d82e:	2380      	movs	r3, #128	; 0x80
   1d830:	061b      	lsls	r3, r3, #24
   1d832:	469c      	mov	ip, r3
   1d834:	4460      	add	r0, ip
   1d836:	e7f2      	b.n	1d81e <__aeabi_f2uiz+0x16>

0001d838 <__udivmoddi4>:
   1d838:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d83a:	464d      	mov	r5, r9
   1d83c:	4656      	mov	r6, sl
   1d83e:	4644      	mov	r4, r8
   1d840:	465f      	mov	r7, fp
   1d842:	b4f0      	push	{r4, r5, r6, r7}
   1d844:	4692      	mov	sl, r2
   1d846:	b083      	sub	sp, #12
   1d848:	0004      	movs	r4, r0
   1d84a:	000d      	movs	r5, r1
   1d84c:	4699      	mov	r9, r3
   1d84e:	428b      	cmp	r3, r1
   1d850:	d82f      	bhi.n	1d8b2 <__udivmoddi4+0x7a>
   1d852:	d02c      	beq.n	1d8ae <__udivmoddi4+0x76>
   1d854:	4649      	mov	r1, r9
   1d856:	4650      	mov	r0, sl
   1d858:	f001 f918 	bl	1ea8c <__clzdi2>
   1d85c:	0029      	movs	r1, r5
   1d85e:	0006      	movs	r6, r0
   1d860:	0020      	movs	r0, r4
   1d862:	f001 f913 	bl	1ea8c <__clzdi2>
   1d866:	1a33      	subs	r3, r6, r0
   1d868:	4698      	mov	r8, r3
   1d86a:	3b20      	subs	r3, #32
   1d86c:	469b      	mov	fp, r3
   1d86e:	d500      	bpl.n	1d872 <__udivmoddi4+0x3a>
   1d870:	e074      	b.n	1d95c <__udivmoddi4+0x124>
   1d872:	4653      	mov	r3, sl
   1d874:	465a      	mov	r2, fp
   1d876:	4093      	lsls	r3, r2
   1d878:	001f      	movs	r7, r3
   1d87a:	4653      	mov	r3, sl
   1d87c:	4642      	mov	r2, r8
   1d87e:	4093      	lsls	r3, r2
   1d880:	001e      	movs	r6, r3
   1d882:	42af      	cmp	r7, r5
   1d884:	d829      	bhi.n	1d8da <__udivmoddi4+0xa2>
   1d886:	d026      	beq.n	1d8d6 <__udivmoddi4+0x9e>
   1d888:	465b      	mov	r3, fp
   1d88a:	1ba4      	subs	r4, r4, r6
   1d88c:	41bd      	sbcs	r5, r7
   1d88e:	2b00      	cmp	r3, #0
   1d890:	da00      	bge.n	1d894 <__udivmoddi4+0x5c>
   1d892:	e079      	b.n	1d988 <__udivmoddi4+0x150>
   1d894:	2200      	movs	r2, #0
   1d896:	2300      	movs	r3, #0
   1d898:	9200      	str	r2, [sp, #0]
   1d89a:	9301      	str	r3, [sp, #4]
   1d89c:	2301      	movs	r3, #1
   1d89e:	465a      	mov	r2, fp
   1d8a0:	4093      	lsls	r3, r2
   1d8a2:	9301      	str	r3, [sp, #4]
   1d8a4:	2301      	movs	r3, #1
   1d8a6:	4642      	mov	r2, r8
   1d8a8:	4093      	lsls	r3, r2
   1d8aa:	9300      	str	r3, [sp, #0]
   1d8ac:	e019      	b.n	1d8e2 <__udivmoddi4+0xaa>
   1d8ae:	4282      	cmp	r2, r0
   1d8b0:	d9d0      	bls.n	1d854 <__udivmoddi4+0x1c>
   1d8b2:	2200      	movs	r2, #0
   1d8b4:	2300      	movs	r3, #0
   1d8b6:	9200      	str	r2, [sp, #0]
   1d8b8:	9301      	str	r3, [sp, #4]
   1d8ba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1d8bc:	2b00      	cmp	r3, #0
   1d8be:	d001      	beq.n	1d8c4 <__udivmoddi4+0x8c>
   1d8c0:	601c      	str	r4, [r3, #0]
   1d8c2:	605d      	str	r5, [r3, #4]
   1d8c4:	9800      	ldr	r0, [sp, #0]
   1d8c6:	9901      	ldr	r1, [sp, #4]
   1d8c8:	b003      	add	sp, #12
   1d8ca:	bc3c      	pop	{r2, r3, r4, r5}
   1d8cc:	4690      	mov	r8, r2
   1d8ce:	4699      	mov	r9, r3
   1d8d0:	46a2      	mov	sl, r4
   1d8d2:	46ab      	mov	fp, r5
   1d8d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d8d6:	42a3      	cmp	r3, r4
   1d8d8:	d9d6      	bls.n	1d888 <__udivmoddi4+0x50>
   1d8da:	2200      	movs	r2, #0
   1d8dc:	2300      	movs	r3, #0
   1d8de:	9200      	str	r2, [sp, #0]
   1d8e0:	9301      	str	r3, [sp, #4]
   1d8e2:	4643      	mov	r3, r8
   1d8e4:	2b00      	cmp	r3, #0
   1d8e6:	d0e8      	beq.n	1d8ba <__udivmoddi4+0x82>
   1d8e8:	07fb      	lsls	r3, r7, #31
   1d8ea:	0872      	lsrs	r2, r6, #1
   1d8ec:	431a      	orrs	r2, r3
   1d8ee:	4646      	mov	r6, r8
   1d8f0:	087b      	lsrs	r3, r7, #1
   1d8f2:	e00e      	b.n	1d912 <__udivmoddi4+0xda>
   1d8f4:	42ab      	cmp	r3, r5
   1d8f6:	d101      	bne.n	1d8fc <__udivmoddi4+0xc4>
   1d8f8:	42a2      	cmp	r2, r4
   1d8fa:	d80c      	bhi.n	1d916 <__udivmoddi4+0xde>
   1d8fc:	1aa4      	subs	r4, r4, r2
   1d8fe:	419d      	sbcs	r5, r3
   1d900:	2001      	movs	r0, #1
   1d902:	1924      	adds	r4, r4, r4
   1d904:	416d      	adcs	r5, r5
   1d906:	2100      	movs	r1, #0
   1d908:	3e01      	subs	r6, #1
   1d90a:	1824      	adds	r4, r4, r0
   1d90c:	414d      	adcs	r5, r1
   1d90e:	2e00      	cmp	r6, #0
   1d910:	d006      	beq.n	1d920 <__udivmoddi4+0xe8>
   1d912:	42ab      	cmp	r3, r5
   1d914:	d9ee      	bls.n	1d8f4 <__udivmoddi4+0xbc>
   1d916:	3e01      	subs	r6, #1
   1d918:	1924      	adds	r4, r4, r4
   1d91a:	416d      	adcs	r5, r5
   1d91c:	2e00      	cmp	r6, #0
   1d91e:	d1f8      	bne.n	1d912 <__udivmoddi4+0xda>
   1d920:	465b      	mov	r3, fp
   1d922:	9800      	ldr	r0, [sp, #0]
   1d924:	9901      	ldr	r1, [sp, #4]
   1d926:	1900      	adds	r0, r0, r4
   1d928:	4169      	adcs	r1, r5
   1d92a:	2b00      	cmp	r3, #0
   1d92c:	db22      	blt.n	1d974 <__udivmoddi4+0x13c>
   1d92e:	002b      	movs	r3, r5
   1d930:	465a      	mov	r2, fp
   1d932:	40d3      	lsrs	r3, r2
   1d934:	002a      	movs	r2, r5
   1d936:	4644      	mov	r4, r8
   1d938:	40e2      	lsrs	r2, r4
   1d93a:	001c      	movs	r4, r3
   1d93c:	465b      	mov	r3, fp
   1d93e:	0015      	movs	r5, r2
   1d940:	2b00      	cmp	r3, #0
   1d942:	db2c      	blt.n	1d99e <__udivmoddi4+0x166>
   1d944:	0026      	movs	r6, r4
   1d946:	409e      	lsls	r6, r3
   1d948:	0033      	movs	r3, r6
   1d94a:	0026      	movs	r6, r4
   1d94c:	4647      	mov	r7, r8
   1d94e:	40be      	lsls	r6, r7
   1d950:	0032      	movs	r2, r6
   1d952:	1a80      	subs	r0, r0, r2
   1d954:	4199      	sbcs	r1, r3
   1d956:	9000      	str	r0, [sp, #0]
   1d958:	9101      	str	r1, [sp, #4]
   1d95a:	e7ae      	b.n	1d8ba <__udivmoddi4+0x82>
   1d95c:	4642      	mov	r2, r8
   1d95e:	2320      	movs	r3, #32
   1d960:	1a9b      	subs	r3, r3, r2
   1d962:	4652      	mov	r2, sl
   1d964:	40da      	lsrs	r2, r3
   1d966:	4641      	mov	r1, r8
   1d968:	0013      	movs	r3, r2
   1d96a:	464a      	mov	r2, r9
   1d96c:	408a      	lsls	r2, r1
   1d96e:	0017      	movs	r7, r2
   1d970:	431f      	orrs	r7, r3
   1d972:	e782      	b.n	1d87a <__udivmoddi4+0x42>
   1d974:	4642      	mov	r2, r8
   1d976:	2320      	movs	r3, #32
   1d978:	1a9b      	subs	r3, r3, r2
   1d97a:	002a      	movs	r2, r5
   1d97c:	4646      	mov	r6, r8
   1d97e:	409a      	lsls	r2, r3
   1d980:	0023      	movs	r3, r4
   1d982:	40f3      	lsrs	r3, r6
   1d984:	4313      	orrs	r3, r2
   1d986:	e7d5      	b.n	1d934 <__udivmoddi4+0xfc>
   1d988:	4642      	mov	r2, r8
   1d98a:	2320      	movs	r3, #32
   1d98c:	2100      	movs	r1, #0
   1d98e:	1a9b      	subs	r3, r3, r2
   1d990:	2200      	movs	r2, #0
   1d992:	9100      	str	r1, [sp, #0]
   1d994:	9201      	str	r2, [sp, #4]
   1d996:	2201      	movs	r2, #1
   1d998:	40da      	lsrs	r2, r3
   1d99a:	9201      	str	r2, [sp, #4]
   1d99c:	e782      	b.n	1d8a4 <__udivmoddi4+0x6c>
   1d99e:	4642      	mov	r2, r8
   1d9a0:	2320      	movs	r3, #32
   1d9a2:	0026      	movs	r6, r4
   1d9a4:	1a9b      	subs	r3, r3, r2
   1d9a6:	40de      	lsrs	r6, r3
   1d9a8:	002f      	movs	r7, r5
   1d9aa:	46b4      	mov	ip, r6
   1d9ac:	4097      	lsls	r7, r2
   1d9ae:	4666      	mov	r6, ip
   1d9b0:	003b      	movs	r3, r7
   1d9b2:	4333      	orrs	r3, r6
   1d9b4:	e7c9      	b.n	1d94a <__udivmoddi4+0x112>
   1d9b6:	46c0      	nop			; (mov r8, r8)

0001d9b8 <__aeabi_fadd>:
   1d9b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d9ba:	024a      	lsls	r2, r1, #9
   1d9bc:	0243      	lsls	r3, r0, #9
   1d9be:	0044      	lsls	r4, r0, #1
   1d9c0:	004e      	lsls	r6, r1, #1
   1d9c2:	0fc5      	lsrs	r5, r0, #31
   1d9c4:	0e24      	lsrs	r4, r4, #24
   1d9c6:	0028      	movs	r0, r5
   1d9c8:	099b      	lsrs	r3, r3, #6
   1d9ca:	0e36      	lsrs	r6, r6, #24
   1d9cc:	0fc9      	lsrs	r1, r1, #31
   1d9ce:	0992      	lsrs	r2, r2, #6
   1d9d0:	428d      	cmp	r5, r1
   1d9d2:	d059      	beq.n	1da88 <__aeabi_fadd+0xd0>
   1d9d4:	1ba0      	subs	r0, r4, r6
   1d9d6:	2800      	cmp	r0, #0
   1d9d8:	dc00      	bgt.n	1d9dc <__aeabi_fadd+0x24>
   1d9da:	e08d      	b.n	1daf8 <__aeabi_fadd+0x140>
   1d9dc:	2e00      	cmp	r6, #0
   1d9de:	d11a      	bne.n	1da16 <__aeabi_fadd+0x5e>
   1d9e0:	2a00      	cmp	r2, #0
   1d9e2:	d000      	beq.n	1d9e6 <__aeabi_fadd+0x2e>
   1d9e4:	e079      	b.n	1dada <__aeabi_fadd+0x122>
   1d9e6:	075a      	lsls	r2, r3, #29
   1d9e8:	d004      	beq.n	1d9f4 <__aeabi_fadd+0x3c>
   1d9ea:	220f      	movs	r2, #15
   1d9ec:	401a      	ands	r2, r3
   1d9ee:	2a04      	cmp	r2, #4
   1d9f0:	d000      	beq.n	1d9f4 <__aeabi_fadd+0x3c>
   1d9f2:	3304      	adds	r3, #4
   1d9f4:	015a      	lsls	r2, r3, #5
   1d9f6:	d538      	bpl.n	1da6a <__aeabi_fadd+0xb2>
   1d9f8:	3401      	adds	r4, #1
   1d9fa:	2cff      	cmp	r4, #255	; 0xff
   1d9fc:	d100      	bne.n	1da00 <__aeabi_fadd+0x48>
   1d9fe:	e089      	b.n	1db14 <__aeabi_fadd+0x15c>
   1da00:	0028      	movs	r0, r5
   1da02:	019b      	lsls	r3, r3, #6
   1da04:	0a5b      	lsrs	r3, r3, #9
   1da06:	b2e4      	uxtb	r4, r4
   1da08:	025b      	lsls	r3, r3, #9
   1da0a:	05e4      	lsls	r4, r4, #23
   1da0c:	0a5b      	lsrs	r3, r3, #9
   1da0e:	4323      	orrs	r3, r4
   1da10:	07c0      	lsls	r0, r0, #31
   1da12:	4318      	orrs	r0, r3
   1da14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1da16:	2cff      	cmp	r4, #255	; 0xff
   1da18:	d0e5      	beq.n	1d9e6 <__aeabi_fadd+0x2e>
   1da1a:	2180      	movs	r1, #128	; 0x80
   1da1c:	04c9      	lsls	r1, r1, #19
   1da1e:	430a      	orrs	r2, r1
   1da20:	281b      	cmp	r0, #27
   1da22:	dd00      	ble.n	1da26 <__aeabi_fadd+0x6e>
   1da24:	e089      	b.n	1db3a <__aeabi_fadd+0x182>
   1da26:	0016      	movs	r6, r2
   1da28:	2120      	movs	r1, #32
   1da2a:	40c6      	lsrs	r6, r0
   1da2c:	1a08      	subs	r0, r1, r0
   1da2e:	4082      	lsls	r2, r0
   1da30:	1e51      	subs	r1, r2, #1
   1da32:	418a      	sbcs	r2, r1
   1da34:	4332      	orrs	r2, r6
   1da36:	1a9b      	subs	r3, r3, r2
   1da38:	015a      	lsls	r2, r3, #5
   1da3a:	d514      	bpl.n	1da66 <__aeabi_fadd+0xae>
   1da3c:	019b      	lsls	r3, r3, #6
   1da3e:	099e      	lsrs	r6, r3, #6
   1da40:	0030      	movs	r0, r6
   1da42:	f001 f805 	bl	1ea50 <__clzsi2>
   1da46:	3805      	subs	r0, #5
   1da48:	4086      	lsls	r6, r0
   1da4a:	4284      	cmp	r4, r0
   1da4c:	dc65      	bgt.n	1db1a <__aeabi_fadd+0x162>
   1da4e:	1b04      	subs	r4, r0, r4
   1da50:	0033      	movs	r3, r6
   1da52:	2020      	movs	r0, #32
   1da54:	3401      	adds	r4, #1
   1da56:	40e3      	lsrs	r3, r4
   1da58:	1b04      	subs	r4, r0, r4
   1da5a:	40a6      	lsls	r6, r4
   1da5c:	1e72      	subs	r2, r6, #1
   1da5e:	4196      	sbcs	r6, r2
   1da60:	2400      	movs	r4, #0
   1da62:	4333      	orrs	r3, r6
   1da64:	e7bf      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1da66:	075a      	lsls	r2, r3, #29
   1da68:	d1bf      	bne.n	1d9ea <__aeabi_fadd+0x32>
   1da6a:	08df      	lsrs	r7, r3, #3
   1da6c:	0028      	movs	r0, r5
   1da6e:	2cff      	cmp	r4, #255	; 0xff
   1da70:	d12f      	bne.n	1dad2 <__aeabi_fadd+0x11a>
   1da72:	2f00      	cmp	r7, #0
   1da74:	d100      	bne.n	1da78 <__aeabi_fadd+0xc0>
   1da76:	e087      	b.n	1db88 <__aeabi_fadd+0x1d0>
   1da78:	2280      	movs	r2, #128	; 0x80
   1da7a:	03d2      	lsls	r2, r2, #15
   1da7c:	0013      	movs	r3, r2
   1da7e:	433b      	orrs	r3, r7
   1da80:	025b      	lsls	r3, r3, #9
   1da82:	0a5b      	lsrs	r3, r3, #9
   1da84:	24ff      	movs	r4, #255	; 0xff
   1da86:	e7bf      	b.n	1da08 <__aeabi_fadd+0x50>
   1da88:	1ba1      	subs	r1, r4, r6
   1da8a:	2900      	cmp	r1, #0
   1da8c:	dd49      	ble.n	1db22 <__aeabi_fadd+0x16a>
   1da8e:	2e00      	cmp	r6, #0
   1da90:	d029      	beq.n	1dae6 <__aeabi_fadd+0x12e>
   1da92:	2cff      	cmp	r4, #255	; 0xff
   1da94:	d0a7      	beq.n	1d9e6 <__aeabi_fadd+0x2e>
   1da96:	2680      	movs	r6, #128	; 0x80
   1da98:	04f6      	lsls	r6, r6, #19
   1da9a:	4332      	orrs	r2, r6
   1da9c:	291b      	cmp	r1, #27
   1da9e:	dd00      	ble.n	1daa2 <__aeabi_fadd+0xea>
   1daa0:	e08d      	b.n	1dbbe <__aeabi_fadd+0x206>
   1daa2:	0017      	movs	r7, r2
   1daa4:	2620      	movs	r6, #32
   1daa6:	40cf      	lsrs	r7, r1
   1daa8:	1a71      	subs	r1, r6, r1
   1daaa:	408a      	lsls	r2, r1
   1daac:	1e51      	subs	r1, r2, #1
   1daae:	418a      	sbcs	r2, r1
   1dab0:	433a      	orrs	r2, r7
   1dab2:	189b      	adds	r3, r3, r2
   1dab4:	015a      	lsls	r2, r3, #5
   1dab6:	d5d6      	bpl.n	1da66 <__aeabi_fadd+0xae>
   1dab8:	3401      	adds	r4, #1
   1daba:	2cff      	cmp	r4, #255	; 0xff
   1dabc:	d064      	beq.n	1db88 <__aeabi_fadd+0x1d0>
   1dabe:	2201      	movs	r2, #1
   1dac0:	4976      	ldr	r1, [pc, #472]	; (1dc9c <__aeabi_fadd+0x2e4>)
   1dac2:	401a      	ands	r2, r3
   1dac4:	085b      	lsrs	r3, r3, #1
   1dac6:	400b      	ands	r3, r1
   1dac8:	4313      	orrs	r3, r2
   1daca:	e78c      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dacc:	1e03      	subs	r3, r0, #0
   1dace:	d1ca      	bne.n	1da66 <__aeabi_fadd+0xae>
   1dad0:	2000      	movs	r0, #0
   1dad2:	027b      	lsls	r3, r7, #9
   1dad4:	0a5b      	lsrs	r3, r3, #9
   1dad6:	b2e4      	uxtb	r4, r4
   1dad8:	e796      	b.n	1da08 <__aeabi_fadd+0x50>
   1dada:	3801      	subs	r0, #1
   1dadc:	2800      	cmp	r0, #0
   1dade:	d0aa      	beq.n	1da36 <__aeabi_fadd+0x7e>
   1dae0:	2cff      	cmp	r4, #255	; 0xff
   1dae2:	d19d      	bne.n	1da20 <__aeabi_fadd+0x68>
   1dae4:	e77f      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dae6:	2a00      	cmp	r2, #0
   1dae8:	d100      	bne.n	1daec <__aeabi_fadd+0x134>
   1daea:	e77c      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1daec:	3901      	subs	r1, #1
   1daee:	2900      	cmp	r1, #0
   1daf0:	d0df      	beq.n	1dab2 <__aeabi_fadd+0xfa>
   1daf2:	2cff      	cmp	r4, #255	; 0xff
   1daf4:	d1d2      	bne.n	1da9c <__aeabi_fadd+0xe4>
   1daf6:	e776      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1daf8:	2800      	cmp	r0, #0
   1dafa:	d120      	bne.n	1db3e <__aeabi_fadd+0x186>
   1dafc:	1c60      	adds	r0, r4, #1
   1dafe:	b2c0      	uxtb	r0, r0
   1db00:	2801      	cmp	r0, #1
   1db02:	dd53      	ble.n	1dbac <__aeabi_fadd+0x1f4>
   1db04:	2780      	movs	r7, #128	; 0x80
   1db06:	1a9e      	subs	r6, r3, r2
   1db08:	04ff      	lsls	r7, r7, #19
   1db0a:	4037      	ands	r7, r6
   1db0c:	d02f      	beq.n	1db6e <__aeabi_fadd+0x1b6>
   1db0e:	1ad6      	subs	r6, r2, r3
   1db10:	000d      	movs	r5, r1
   1db12:	e795      	b.n	1da40 <__aeabi_fadd+0x88>
   1db14:	0028      	movs	r0, r5
   1db16:	2300      	movs	r3, #0
   1db18:	e776      	b.n	1da08 <__aeabi_fadd+0x50>
   1db1a:	4b61      	ldr	r3, [pc, #388]	; (1dca0 <__aeabi_fadd+0x2e8>)
   1db1c:	1a24      	subs	r4, r4, r0
   1db1e:	4033      	ands	r3, r6
   1db20:	e761      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1db22:	2900      	cmp	r1, #0
   1db24:	d14d      	bne.n	1dbc2 <__aeabi_fadd+0x20a>
   1db26:	1c61      	adds	r1, r4, #1
   1db28:	b2ce      	uxtb	r6, r1
   1db2a:	2e01      	cmp	r6, #1
   1db2c:	dd2f      	ble.n	1db8e <__aeabi_fadd+0x1d6>
   1db2e:	29ff      	cmp	r1, #255	; 0xff
   1db30:	d02a      	beq.n	1db88 <__aeabi_fadd+0x1d0>
   1db32:	189b      	adds	r3, r3, r2
   1db34:	085b      	lsrs	r3, r3, #1
   1db36:	000c      	movs	r4, r1
   1db38:	e755      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1db3a:	2201      	movs	r2, #1
   1db3c:	e77b      	b.n	1da36 <__aeabi_fadd+0x7e>
   1db3e:	2c00      	cmp	r4, #0
   1db40:	d11b      	bne.n	1db7a <__aeabi_fadd+0x1c2>
   1db42:	2b00      	cmp	r3, #0
   1db44:	d05b      	beq.n	1dbfe <__aeabi_fadd+0x246>
   1db46:	43c0      	mvns	r0, r0
   1db48:	2800      	cmp	r0, #0
   1db4a:	d00c      	beq.n	1db66 <__aeabi_fadd+0x1ae>
   1db4c:	2eff      	cmp	r6, #255	; 0xff
   1db4e:	d07e      	beq.n	1dc4e <__aeabi_fadd+0x296>
   1db50:	281b      	cmp	r0, #27
   1db52:	dd00      	ble.n	1db56 <__aeabi_fadd+0x19e>
   1db54:	e092      	b.n	1dc7c <__aeabi_fadd+0x2c4>
   1db56:	001d      	movs	r5, r3
   1db58:	2420      	movs	r4, #32
   1db5a:	40c5      	lsrs	r5, r0
   1db5c:	1a20      	subs	r0, r4, r0
   1db5e:	4083      	lsls	r3, r0
   1db60:	1e58      	subs	r0, r3, #1
   1db62:	4183      	sbcs	r3, r0
   1db64:	432b      	orrs	r3, r5
   1db66:	1ad3      	subs	r3, r2, r3
   1db68:	0034      	movs	r4, r6
   1db6a:	000d      	movs	r5, r1
   1db6c:	e764      	b.n	1da38 <__aeabi_fadd+0x80>
   1db6e:	2e00      	cmp	r6, #0
   1db70:	d000      	beq.n	1db74 <__aeabi_fadd+0x1bc>
   1db72:	e765      	b.n	1da40 <__aeabi_fadd+0x88>
   1db74:	2000      	movs	r0, #0
   1db76:	2400      	movs	r4, #0
   1db78:	e7ab      	b.n	1dad2 <__aeabi_fadd+0x11a>
   1db7a:	2eff      	cmp	r6, #255	; 0xff
   1db7c:	d067      	beq.n	1dc4e <__aeabi_fadd+0x296>
   1db7e:	2480      	movs	r4, #128	; 0x80
   1db80:	04e4      	lsls	r4, r4, #19
   1db82:	4240      	negs	r0, r0
   1db84:	4323      	orrs	r3, r4
   1db86:	e7e3      	b.n	1db50 <__aeabi_fadd+0x198>
   1db88:	24ff      	movs	r4, #255	; 0xff
   1db8a:	2300      	movs	r3, #0
   1db8c:	e73c      	b.n	1da08 <__aeabi_fadd+0x50>
   1db8e:	2c00      	cmp	r4, #0
   1db90:	d161      	bne.n	1dc56 <__aeabi_fadd+0x29e>
   1db92:	2b00      	cmp	r3, #0
   1db94:	d07e      	beq.n	1dc94 <__aeabi_fadd+0x2dc>
   1db96:	2a00      	cmp	r2, #0
   1db98:	d100      	bne.n	1db9c <__aeabi_fadd+0x1e4>
   1db9a:	e724      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1db9c:	189b      	adds	r3, r3, r2
   1db9e:	015a      	lsls	r2, r3, #5
   1dba0:	d400      	bmi.n	1dba4 <__aeabi_fadd+0x1ec>
   1dba2:	e760      	b.n	1da66 <__aeabi_fadd+0xae>
   1dba4:	4a3e      	ldr	r2, [pc, #248]	; (1dca0 <__aeabi_fadd+0x2e8>)
   1dba6:	000c      	movs	r4, r1
   1dba8:	4013      	ands	r3, r2
   1dbaa:	e71c      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dbac:	2c00      	cmp	r4, #0
   1dbae:	d11e      	bne.n	1dbee <__aeabi_fadd+0x236>
   1dbb0:	2b00      	cmp	r3, #0
   1dbb2:	d12f      	bne.n	1dc14 <__aeabi_fadd+0x25c>
   1dbb4:	2a00      	cmp	r2, #0
   1dbb6:	d066      	beq.n	1dc86 <__aeabi_fadd+0x2ce>
   1dbb8:	0013      	movs	r3, r2
   1dbba:	000d      	movs	r5, r1
   1dbbc:	e713      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dbbe:	2201      	movs	r2, #1
   1dbc0:	e777      	b.n	1dab2 <__aeabi_fadd+0xfa>
   1dbc2:	2c00      	cmp	r4, #0
   1dbc4:	d11f      	bne.n	1dc06 <__aeabi_fadd+0x24e>
   1dbc6:	2b00      	cmp	r3, #0
   1dbc8:	d05a      	beq.n	1dc80 <__aeabi_fadd+0x2c8>
   1dbca:	43c9      	mvns	r1, r1
   1dbcc:	2900      	cmp	r1, #0
   1dbce:	d00b      	beq.n	1dbe8 <__aeabi_fadd+0x230>
   1dbd0:	2eff      	cmp	r6, #255	; 0xff
   1dbd2:	d050      	beq.n	1dc76 <__aeabi_fadd+0x2be>
   1dbd4:	291b      	cmp	r1, #27
   1dbd6:	dc5f      	bgt.n	1dc98 <__aeabi_fadd+0x2e0>
   1dbd8:	001f      	movs	r7, r3
   1dbda:	2420      	movs	r4, #32
   1dbdc:	40cf      	lsrs	r7, r1
   1dbde:	1a61      	subs	r1, r4, r1
   1dbe0:	408b      	lsls	r3, r1
   1dbe2:	1e59      	subs	r1, r3, #1
   1dbe4:	418b      	sbcs	r3, r1
   1dbe6:	433b      	orrs	r3, r7
   1dbe8:	189b      	adds	r3, r3, r2
   1dbea:	0034      	movs	r4, r6
   1dbec:	e762      	b.n	1dab4 <__aeabi_fadd+0xfc>
   1dbee:	2b00      	cmp	r3, #0
   1dbf0:	d11c      	bne.n	1dc2c <__aeabi_fadd+0x274>
   1dbf2:	2a00      	cmp	r2, #0
   1dbf4:	d04a      	beq.n	1dc8c <__aeabi_fadd+0x2d4>
   1dbf6:	0013      	movs	r3, r2
   1dbf8:	000d      	movs	r5, r1
   1dbfa:	24ff      	movs	r4, #255	; 0xff
   1dbfc:	e6f3      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dbfe:	0013      	movs	r3, r2
   1dc00:	0034      	movs	r4, r6
   1dc02:	000d      	movs	r5, r1
   1dc04:	e6ef      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc06:	2eff      	cmp	r6, #255	; 0xff
   1dc08:	d035      	beq.n	1dc76 <__aeabi_fadd+0x2be>
   1dc0a:	2480      	movs	r4, #128	; 0x80
   1dc0c:	04e4      	lsls	r4, r4, #19
   1dc0e:	4249      	negs	r1, r1
   1dc10:	4323      	orrs	r3, r4
   1dc12:	e7df      	b.n	1dbd4 <__aeabi_fadd+0x21c>
   1dc14:	2a00      	cmp	r2, #0
   1dc16:	d100      	bne.n	1dc1a <__aeabi_fadd+0x262>
   1dc18:	e6e5      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc1a:	2780      	movs	r7, #128	; 0x80
   1dc1c:	1a98      	subs	r0, r3, r2
   1dc1e:	04ff      	lsls	r7, r7, #19
   1dc20:	4007      	ands	r7, r0
   1dc22:	d100      	bne.n	1dc26 <__aeabi_fadd+0x26e>
   1dc24:	e752      	b.n	1dacc <__aeabi_fadd+0x114>
   1dc26:	1ad3      	subs	r3, r2, r3
   1dc28:	000d      	movs	r5, r1
   1dc2a:	e6dc      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc2c:	24ff      	movs	r4, #255	; 0xff
   1dc2e:	2a00      	cmp	r2, #0
   1dc30:	d100      	bne.n	1dc34 <__aeabi_fadd+0x27c>
   1dc32:	e6d8      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc34:	2080      	movs	r0, #128	; 0x80
   1dc36:	08db      	lsrs	r3, r3, #3
   1dc38:	03c0      	lsls	r0, r0, #15
   1dc3a:	4203      	tst	r3, r0
   1dc3c:	d004      	beq.n	1dc48 <__aeabi_fadd+0x290>
   1dc3e:	08d2      	lsrs	r2, r2, #3
   1dc40:	4202      	tst	r2, r0
   1dc42:	d101      	bne.n	1dc48 <__aeabi_fadd+0x290>
   1dc44:	0013      	movs	r3, r2
   1dc46:	000d      	movs	r5, r1
   1dc48:	00db      	lsls	r3, r3, #3
   1dc4a:	24ff      	movs	r4, #255	; 0xff
   1dc4c:	e6cb      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc4e:	0013      	movs	r3, r2
   1dc50:	24ff      	movs	r4, #255	; 0xff
   1dc52:	000d      	movs	r5, r1
   1dc54:	e6c7      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc56:	2b00      	cmp	r3, #0
   1dc58:	d00d      	beq.n	1dc76 <__aeabi_fadd+0x2be>
   1dc5a:	24ff      	movs	r4, #255	; 0xff
   1dc5c:	2a00      	cmp	r2, #0
   1dc5e:	d100      	bne.n	1dc62 <__aeabi_fadd+0x2aa>
   1dc60:	e6c1      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc62:	2180      	movs	r1, #128	; 0x80
   1dc64:	08db      	lsrs	r3, r3, #3
   1dc66:	03c9      	lsls	r1, r1, #15
   1dc68:	420b      	tst	r3, r1
   1dc6a:	d0ed      	beq.n	1dc48 <__aeabi_fadd+0x290>
   1dc6c:	08d2      	lsrs	r2, r2, #3
   1dc6e:	420a      	tst	r2, r1
   1dc70:	d1ea      	bne.n	1dc48 <__aeabi_fadd+0x290>
   1dc72:	0013      	movs	r3, r2
   1dc74:	e7e8      	b.n	1dc48 <__aeabi_fadd+0x290>
   1dc76:	0013      	movs	r3, r2
   1dc78:	24ff      	movs	r4, #255	; 0xff
   1dc7a:	e6b4      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc7c:	2301      	movs	r3, #1
   1dc7e:	e772      	b.n	1db66 <__aeabi_fadd+0x1ae>
   1dc80:	0013      	movs	r3, r2
   1dc82:	0034      	movs	r4, r6
   1dc84:	e6af      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc86:	2700      	movs	r7, #0
   1dc88:	2000      	movs	r0, #0
   1dc8a:	e722      	b.n	1dad2 <__aeabi_fadd+0x11a>
   1dc8c:	2780      	movs	r7, #128	; 0x80
   1dc8e:	2000      	movs	r0, #0
   1dc90:	03ff      	lsls	r7, r7, #15
   1dc92:	e6f1      	b.n	1da78 <__aeabi_fadd+0xc0>
   1dc94:	0013      	movs	r3, r2
   1dc96:	e6a6      	b.n	1d9e6 <__aeabi_fadd+0x2e>
   1dc98:	2301      	movs	r3, #1
   1dc9a:	e7a5      	b.n	1dbe8 <__aeabi_fadd+0x230>
   1dc9c:	7dffffff 	.word	0x7dffffff
   1dca0:	fbffffff 	.word	0xfbffffff

0001dca4 <__aeabi_fmul>:
   1dca4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1dca6:	4657      	mov	r7, sl
   1dca8:	464e      	mov	r6, r9
   1dcaa:	4645      	mov	r5, r8
   1dcac:	0043      	lsls	r3, r0, #1
   1dcae:	b4e0      	push	{r5, r6, r7}
   1dcb0:	0246      	lsls	r6, r0, #9
   1dcb2:	4688      	mov	r8, r1
   1dcb4:	0a76      	lsrs	r6, r6, #9
   1dcb6:	0e1f      	lsrs	r7, r3, #24
   1dcb8:	0fc4      	lsrs	r4, r0, #31
   1dcba:	2f00      	cmp	r7, #0
   1dcbc:	d047      	beq.n	1dd4e <__aeabi_fmul+0xaa>
   1dcbe:	2fff      	cmp	r7, #255	; 0xff
   1dcc0:	d025      	beq.n	1dd0e <__aeabi_fmul+0x6a>
   1dcc2:	2300      	movs	r3, #0
   1dcc4:	2580      	movs	r5, #128	; 0x80
   1dcc6:	469a      	mov	sl, r3
   1dcc8:	4699      	mov	r9, r3
   1dcca:	00f6      	lsls	r6, r6, #3
   1dccc:	04ed      	lsls	r5, r5, #19
   1dcce:	432e      	orrs	r6, r5
   1dcd0:	3f7f      	subs	r7, #127	; 0x7f
   1dcd2:	4643      	mov	r3, r8
   1dcd4:	4642      	mov	r2, r8
   1dcd6:	025d      	lsls	r5, r3, #9
   1dcd8:	0fd2      	lsrs	r2, r2, #31
   1dcda:	005b      	lsls	r3, r3, #1
   1dcdc:	0a6d      	lsrs	r5, r5, #9
   1dcde:	0e1b      	lsrs	r3, r3, #24
   1dce0:	4690      	mov	r8, r2
   1dce2:	d040      	beq.n	1dd66 <__aeabi_fmul+0xc2>
   1dce4:	2bff      	cmp	r3, #255	; 0xff
   1dce6:	d039      	beq.n	1dd5c <__aeabi_fmul+0xb8>
   1dce8:	2280      	movs	r2, #128	; 0x80
   1dcea:	2000      	movs	r0, #0
   1dcec:	00ed      	lsls	r5, r5, #3
   1dcee:	04d2      	lsls	r2, r2, #19
   1dcf0:	4315      	orrs	r5, r2
   1dcf2:	3b7f      	subs	r3, #127	; 0x7f
   1dcf4:	18fb      	adds	r3, r7, r3
   1dcf6:	4642      	mov	r2, r8
   1dcf8:	4657      	mov	r7, sl
   1dcfa:	1c59      	adds	r1, r3, #1
   1dcfc:	4062      	eors	r2, r4
   1dcfe:	468c      	mov	ip, r1
   1dd00:	4307      	orrs	r7, r0
   1dd02:	2f0f      	cmp	r7, #15
   1dd04:	d85c      	bhi.n	1ddc0 <__aeabi_fmul+0x11c>
   1dd06:	496f      	ldr	r1, [pc, #444]	; (1dec4 <__aeabi_fmul+0x220>)
   1dd08:	00bf      	lsls	r7, r7, #2
   1dd0a:	59c9      	ldr	r1, [r1, r7]
   1dd0c:	468f      	mov	pc, r1
   1dd0e:	2e00      	cmp	r6, #0
   1dd10:	d145      	bne.n	1dd9e <__aeabi_fmul+0xfa>
   1dd12:	2308      	movs	r3, #8
   1dd14:	469a      	mov	sl, r3
   1dd16:	3b06      	subs	r3, #6
   1dd18:	4699      	mov	r9, r3
   1dd1a:	e7da      	b.n	1dcd2 <__aeabi_fmul+0x2e>
   1dd1c:	4642      	mov	r2, r8
   1dd1e:	2802      	cmp	r0, #2
   1dd20:	d02d      	beq.n	1dd7e <__aeabi_fmul+0xda>
   1dd22:	2803      	cmp	r0, #3
   1dd24:	d100      	bne.n	1dd28 <__aeabi_fmul+0x84>
   1dd26:	e0c3      	b.n	1deb0 <__aeabi_fmul+0x20c>
   1dd28:	2801      	cmp	r0, #1
   1dd2a:	d000      	beq.n	1dd2e <__aeabi_fmul+0x8a>
   1dd2c:	e0a2      	b.n	1de74 <__aeabi_fmul+0x1d0>
   1dd2e:	2500      	movs	r5, #0
   1dd30:	2600      	movs	r6, #0
   1dd32:	4002      	ands	r2, r0
   1dd34:	b2d4      	uxtb	r4, r2
   1dd36:	0276      	lsls	r6, r6, #9
   1dd38:	05ed      	lsls	r5, r5, #23
   1dd3a:	0a76      	lsrs	r6, r6, #9
   1dd3c:	432e      	orrs	r6, r5
   1dd3e:	07e4      	lsls	r4, r4, #31
   1dd40:	4326      	orrs	r6, r4
   1dd42:	0030      	movs	r0, r6
   1dd44:	bc1c      	pop	{r2, r3, r4}
   1dd46:	4690      	mov	r8, r2
   1dd48:	4699      	mov	r9, r3
   1dd4a:	46a2      	mov	sl, r4
   1dd4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1dd4e:	2e00      	cmp	r6, #0
   1dd50:	d11a      	bne.n	1dd88 <__aeabi_fmul+0xe4>
   1dd52:	2304      	movs	r3, #4
   1dd54:	469a      	mov	sl, r3
   1dd56:	3b03      	subs	r3, #3
   1dd58:	4699      	mov	r9, r3
   1dd5a:	e7ba      	b.n	1dcd2 <__aeabi_fmul+0x2e>
   1dd5c:	002a      	movs	r2, r5
   1dd5e:	1e51      	subs	r1, r2, #1
   1dd60:	418a      	sbcs	r2, r1
   1dd62:	1c90      	adds	r0, r2, #2
   1dd64:	e7c6      	b.n	1dcf4 <__aeabi_fmul+0x50>
   1dd66:	2001      	movs	r0, #1
   1dd68:	2d00      	cmp	r5, #0
   1dd6a:	d0c3      	beq.n	1dcf4 <__aeabi_fmul+0x50>
   1dd6c:	0028      	movs	r0, r5
   1dd6e:	f000 fe6f 	bl	1ea50 <__clzsi2>
   1dd72:	1f43      	subs	r3, r0, #5
   1dd74:	3076      	adds	r0, #118	; 0x76
   1dd76:	409d      	lsls	r5, r3
   1dd78:	4243      	negs	r3, r0
   1dd7a:	2000      	movs	r0, #0
   1dd7c:	e7ba      	b.n	1dcf4 <__aeabi_fmul+0x50>
   1dd7e:	2401      	movs	r4, #1
   1dd80:	25ff      	movs	r5, #255	; 0xff
   1dd82:	4014      	ands	r4, r2
   1dd84:	2600      	movs	r6, #0
   1dd86:	e7d6      	b.n	1dd36 <__aeabi_fmul+0x92>
   1dd88:	0030      	movs	r0, r6
   1dd8a:	f000 fe61 	bl	1ea50 <__clzsi2>
   1dd8e:	1f43      	subs	r3, r0, #5
   1dd90:	409e      	lsls	r6, r3
   1dd92:	2300      	movs	r3, #0
   1dd94:	3076      	adds	r0, #118	; 0x76
   1dd96:	4247      	negs	r7, r0
   1dd98:	469a      	mov	sl, r3
   1dd9a:	4699      	mov	r9, r3
   1dd9c:	e799      	b.n	1dcd2 <__aeabi_fmul+0x2e>
   1dd9e:	230c      	movs	r3, #12
   1dda0:	469a      	mov	sl, r3
   1dda2:	3b09      	subs	r3, #9
   1dda4:	4699      	mov	r9, r3
   1dda6:	e794      	b.n	1dcd2 <__aeabi_fmul+0x2e>
   1dda8:	2680      	movs	r6, #128	; 0x80
   1ddaa:	2400      	movs	r4, #0
   1ddac:	03f6      	lsls	r6, r6, #15
   1ddae:	25ff      	movs	r5, #255	; 0xff
   1ddb0:	e7c1      	b.n	1dd36 <__aeabi_fmul+0x92>
   1ddb2:	0035      	movs	r5, r6
   1ddb4:	4648      	mov	r0, r9
   1ddb6:	e7b2      	b.n	1dd1e <__aeabi_fmul+0x7a>
   1ddb8:	0035      	movs	r5, r6
   1ddba:	0022      	movs	r2, r4
   1ddbc:	4648      	mov	r0, r9
   1ddbe:	e7ae      	b.n	1dd1e <__aeabi_fmul+0x7a>
   1ddc0:	0429      	lsls	r1, r5, #16
   1ddc2:	0c09      	lsrs	r1, r1, #16
   1ddc4:	0008      	movs	r0, r1
   1ddc6:	0c37      	lsrs	r7, r6, #16
   1ddc8:	0436      	lsls	r6, r6, #16
   1ddca:	0c36      	lsrs	r6, r6, #16
   1ddcc:	0c2c      	lsrs	r4, r5, #16
   1ddce:	4379      	muls	r1, r7
   1ddd0:	4370      	muls	r0, r6
   1ddd2:	4367      	muls	r7, r4
   1ddd4:	4374      	muls	r4, r6
   1ddd6:	0c06      	lsrs	r6, r0, #16
   1ddd8:	1864      	adds	r4, r4, r1
   1ddda:	1936      	adds	r6, r6, r4
   1dddc:	42b1      	cmp	r1, r6
   1ddde:	d903      	bls.n	1dde8 <__aeabi_fmul+0x144>
   1dde0:	2180      	movs	r1, #128	; 0x80
   1dde2:	0249      	lsls	r1, r1, #9
   1dde4:	4688      	mov	r8, r1
   1dde6:	4447      	add	r7, r8
   1dde8:	0400      	lsls	r0, r0, #16
   1ddea:	0c00      	lsrs	r0, r0, #16
   1ddec:	0431      	lsls	r1, r6, #16
   1ddee:	1809      	adds	r1, r1, r0
   1ddf0:	018d      	lsls	r5, r1, #6
   1ddf2:	1e68      	subs	r0, r5, #1
   1ddf4:	4185      	sbcs	r5, r0
   1ddf6:	0e89      	lsrs	r1, r1, #26
   1ddf8:	4329      	orrs	r1, r5
   1ddfa:	0c35      	lsrs	r5, r6, #16
   1ddfc:	19ed      	adds	r5, r5, r7
   1ddfe:	01ad      	lsls	r5, r5, #6
   1de00:	430d      	orrs	r5, r1
   1de02:	0129      	lsls	r1, r5, #4
   1de04:	d504      	bpl.n	1de10 <__aeabi_fmul+0x16c>
   1de06:	2301      	movs	r3, #1
   1de08:	0869      	lsrs	r1, r5, #1
   1de0a:	401d      	ands	r5, r3
   1de0c:	4663      	mov	r3, ip
   1de0e:	430d      	orrs	r5, r1
   1de10:	0019      	movs	r1, r3
   1de12:	317f      	adds	r1, #127	; 0x7f
   1de14:	2900      	cmp	r1, #0
   1de16:	dd25      	ble.n	1de64 <__aeabi_fmul+0x1c0>
   1de18:	0768      	lsls	r0, r5, #29
   1de1a:	d004      	beq.n	1de26 <__aeabi_fmul+0x182>
   1de1c:	200f      	movs	r0, #15
   1de1e:	4028      	ands	r0, r5
   1de20:	2804      	cmp	r0, #4
   1de22:	d000      	beq.n	1de26 <__aeabi_fmul+0x182>
   1de24:	3504      	adds	r5, #4
   1de26:	0128      	lsls	r0, r5, #4
   1de28:	d503      	bpl.n	1de32 <__aeabi_fmul+0x18e>
   1de2a:	4927      	ldr	r1, [pc, #156]	; (1dec8 <__aeabi_fmul+0x224>)
   1de2c:	3380      	adds	r3, #128	; 0x80
   1de2e:	400d      	ands	r5, r1
   1de30:	0019      	movs	r1, r3
   1de32:	29fe      	cmp	r1, #254	; 0xfe
   1de34:	dca3      	bgt.n	1dd7e <__aeabi_fmul+0xda>
   1de36:	2401      	movs	r4, #1
   1de38:	01ad      	lsls	r5, r5, #6
   1de3a:	0a6e      	lsrs	r6, r5, #9
   1de3c:	4014      	ands	r4, r2
   1de3e:	b2cd      	uxtb	r5, r1
   1de40:	e779      	b.n	1dd36 <__aeabi_fmul+0x92>
   1de42:	2080      	movs	r0, #128	; 0x80
   1de44:	03c0      	lsls	r0, r0, #15
   1de46:	4206      	tst	r6, r0
   1de48:	d007      	beq.n	1de5a <__aeabi_fmul+0x1b6>
   1de4a:	4205      	tst	r5, r0
   1de4c:	d105      	bne.n	1de5a <__aeabi_fmul+0x1b6>
   1de4e:	4328      	orrs	r0, r5
   1de50:	0246      	lsls	r6, r0, #9
   1de52:	0a76      	lsrs	r6, r6, #9
   1de54:	4644      	mov	r4, r8
   1de56:	25ff      	movs	r5, #255	; 0xff
   1de58:	e76d      	b.n	1dd36 <__aeabi_fmul+0x92>
   1de5a:	4306      	orrs	r6, r0
   1de5c:	0276      	lsls	r6, r6, #9
   1de5e:	0a76      	lsrs	r6, r6, #9
   1de60:	25ff      	movs	r5, #255	; 0xff
   1de62:	e768      	b.n	1dd36 <__aeabi_fmul+0x92>
   1de64:	2401      	movs	r4, #1
   1de66:	1a61      	subs	r1, r4, r1
   1de68:	291b      	cmp	r1, #27
   1de6a:	dd05      	ble.n	1de78 <__aeabi_fmul+0x1d4>
   1de6c:	4014      	ands	r4, r2
   1de6e:	2500      	movs	r5, #0
   1de70:	2600      	movs	r6, #0
   1de72:	e760      	b.n	1dd36 <__aeabi_fmul+0x92>
   1de74:	4663      	mov	r3, ip
   1de76:	e7cb      	b.n	1de10 <__aeabi_fmul+0x16c>
   1de78:	002e      	movs	r6, r5
   1de7a:	2320      	movs	r3, #32
   1de7c:	40ce      	lsrs	r6, r1
   1de7e:	1a59      	subs	r1, r3, r1
   1de80:	408d      	lsls	r5, r1
   1de82:	1e6b      	subs	r3, r5, #1
   1de84:	419d      	sbcs	r5, r3
   1de86:	432e      	orrs	r6, r5
   1de88:	0773      	lsls	r3, r6, #29
   1de8a:	d004      	beq.n	1de96 <__aeabi_fmul+0x1f2>
   1de8c:	230f      	movs	r3, #15
   1de8e:	4033      	ands	r3, r6
   1de90:	2b04      	cmp	r3, #4
   1de92:	d000      	beq.n	1de96 <__aeabi_fmul+0x1f2>
   1de94:	3604      	adds	r6, #4
   1de96:	0173      	lsls	r3, r6, #5
   1de98:	d504      	bpl.n	1dea4 <__aeabi_fmul+0x200>
   1de9a:	2401      	movs	r4, #1
   1de9c:	2501      	movs	r5, #1
   1de9e:	4014      	ands	r4, r2
   1dea0:	2600      	movs	r6, #0
   1dea2:	e748      	b.n	1dd36 <__aeabi_fmul+0x92>
   1dea4:	2401      	movs	r4, #1
   1dea6:	01b6      	lsls	r6, r6, #6
   1dea8:	0a76      	lsrs	r6, r6, #9
   1deaa:	4014      	ands	r4, r2
   1deac:	2500      	movs	r5, #0
   1deae:	e742      	b.n	1dd36 <__aeabi_fmul+0x92>
   1deb0:	2680      	movs	r6, #128	; 0x80
   1deb2:	2401      	movs	r4, #1
   1deb4:	03f6      	lsls	r6, r6, #15
   1deb6:	432e      	orrs	r6, r5
   1deb8:	0276      	lsls	r6, r6, #9
   1deba:	0a76      	lsrs	r6, r6, #9
   1debc:	4014      	ands	r4, r2
   1debe:	25ff      	movs	r5, #255	; 0xff
   1dec0:	e739      	b.n	1dd36 <__aeabi_fmul+0x92>
   1dec2:	46c0      	nop			; (mov r8, r8)
   1dec4:	00021dfc 	.word	0x00021dfc
   1dec8:	f7ffffff 	.word	0xf7ffffff

0001decc <__aeabi_fsub>:
   1decc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1dece:	024a      	lsls	r2, r1, #9
   1ded0:	004e      	lsls	r6, r1, #1
   1ded2:	0243      	lsls	r3, r0, #9
   1ded4:	0044      	lsls	r4, r0, #1
   1ded6:	0e24      	lsrs	r4, r4, #24
   1ded8:	0fc5      	lsrs	r5, r0, #31
   1deda:	099b      	lsrs	r3, r3, #6
   1dedc:	0e36      	lsrs	r6, r6, #24
   1dede:	0fc9      	lsrs	r1, r1, #31
   1dee0:	0992      	lsrs	r2, r2, #6
   1dee2:	2eff      	cmp	r6, #255	; 0xff
   1dee4:	d100      	bne.n	1dee8 <__aeabi_fsub+0x1c>
   1dee6:	e083      	b.n	1dff0 <__aeabi_fsub+0x124>
   1dee8:	2001      	movs	r0, #1
   1deea:	4041      	eors	r1, r0
   1deec:	1ba0      	subs	r0, r4, r6
   1deee:	42a9      	cmp	r1, r5
   1def0:	d05c      	beq.n	1dfac <__aeabi_fsub+0xe0>
   1def2:	2800      	cmp	r0, #0
   1def4:	dc00      	bgt.n	1def8 <__aeabi_fsub+0x2c>
   1def6:	e095      	b.n	1e024 <__aeabi_fsub+0x158>
   1def8:	2e00      	cmp	r6, #0
   1defa:	d11c      	bne.n	1df36 <__aeabi_fsub+0x6a>
   1defc:	2a00      	cmp	r2, #0
   1defe:	d000      	beq.n	1df02 <__aeabi_fsub+0x36>
   1df00:	e081      	b.n	1e006 <__aeabi_fsub+0x13a>
   1df02:	075a      	lsls	r2, r3, #29
   1df04:	d004      	beq.n	1df10 <__aeabi_fsub+0x44>
   1df06:	220f      	movs	r2, #15
   1df08:	401a      	ands	r2, r3
   1df0a:	2a04      	cmp	r2, #4
   1df0c:	d000      	beq.n	1df10 <__aeabi_fsub+0x44>
   1df0e:	3304      	adds	r3, #4
   1df10:	015a      	lsls	r2, r3, #5
   1df12:	d53b      	bpl.n	1df8c <__aeabi_fsub+0xc0>
   1df14:	3401      	adds	r4, #1
   1df16:	2cff      	cmp	r4, #255	; 0xff
   1df18:	d100      	bne.n	1df1c <__aeabi_fsub+0x50>
   1df1a:	e091      	b.n	1e040 <__aeabi_fsub+0x174>
   1df1c:	2001      	movs	r0, #1
   1df1e:	019b      	lsls	r3, r3, #6
   1df20:	0a5b      	lsrs	r3, r3, #9
   1df22:	b2e4      	uxtb	r4, r4
   1df24:	4005      	ands	r5, r0
   1df26:	025b      	lsls	r3, r3, #9
   1df28:	05e4      	lsls	r4, r4, #23
   1df2a:	0a5b      	lsrs	r3, r3, #9
   1df2c:	07ed      	lsls	r5, r5, #31
   1df2e:	4323      	orrs	r3, r4
   1df30:	432b      	orrs	r3, r5
   1df32:	0018      	movs	r0, r3
   1df34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1df36:	2cff      	cmp	r4, #255	; 0xff
   1df38:	d0e3      	beq.n	1df02 <__aeabi_fsub+0x36>
   1df3a:	2180      	movs	r1, #128	; 0x80
   1df3c:	04c9      	lsls	r1, r1, #19
   1df3e:	430a      	orrs	r2, r1
   1df40:	281b      	cmp	r0, #27
   1df42:	dd00      	ble.n	1df46 <__aeabi_fsub+0x7a>
   1df44:	e090      	b.n	1e068 <__aeabi_fsub+0x19c>
   1df46:	0016      	movs	r6, r2
   1df48:	2120      	movs	r1, #32
   1df4a:	40c6      	lsrs	r6, r0
   1df4c:	1a08      	subs	r0, r1, r0
   1df4e:	4082      	lsls	r2, r0
   1df50:	1e51      	subs	r1, r2, #1
   1df52:	418a      	sbcs	r2, r1
   1df54:	4332      	orrs	r2, r6
   1df56:	1a9b      	subs	r3, r3, r2
   1df58:	015a      	lsls	r2, r3, #5
   1df5a:	d515      	bpl.n	1df88 <__aeabi_fsub+0xbc>
   1df5c:	019b      	lsls	r3, r3, #6
   1df5e:	099e      	lsrs	r6, r3, #6
   1df60:	0030      	movs	r0, r6
   1df62:	f000 fd75 	bl	1ea50 <__clzsi2>
   1df66:	3805      	subs	r0, #5
   1df68:	4086      	lsls	r6, r0
   1df6a:	4284      	cmp	r4, r0
   1df6c:	dc6c      	bgt.n	1e048 <__aeabi_fsub+0x17c>
   1df6e:	1b04      	subs	r4, r0, r4
   1df70:	0033      	movs	r3, r6
   1df72:	2020      	movs	r0, #32
   1df74:	3401      	adds	r4, #1
   1df76:	40e3      	lsrs	r3, r4
   1df78:	1b04      	subs	r4, r0, r4
   1df7a:	40a6      	lsls	r6, r4
   1df7c:	1e72      	subs	r2, r6, #1
   1df7e:	4196      	sbcs	r6, r2
   1df80:	2400      	movs	r4, #0
   1df82:	4333      	orrs	r3, r6
   1df84:	e7bd      	b.n	1df02 <__aeabi_fsub+0x36>
   1df86:	000d      	movs	r5, r1
   1df88:	075a      	lsls	r2, r3, #29
   1df8a:	d1bc      	bne.n	1df06 <__aeabi_fsub+0x3a>
   1df8c:	08df      	lsrs	r7, r3, #3
   1df8e:	2301      	movs	r3, #1
   1df90:	401d      	ands	r5, r3
   1df92:	2cff      	cmp	r4, #255	; 0xff
   1df94:	d133      	bne.n	1dffe <__aeabi_fsub+0x132>
   1df96:	2f00      	cmp	r7, #0
   1df98:	d100      	bne.n	1df9c <__aeabi_fsub+0xd0>
   1df9a:	e090      	b.n	1e0be <__aeabi_fsub+0x1f2>
   1df9c:	2280      	movs	r2, #128	; 0x80
   1df9e:	03d2      	lsls	r2, r2, #15
   1dfa0:	0013      	movs	r3, r2
   1dfa2:	433b      	orrs	r3, r7
   1dfa4:	025b      	lsls	r3, r3, #9
   1dfa6:	0a5b      	lsrs	r3, r3, #9
   1dfa8:	24ff      	movs	r4, #255	; 0xff
   1dfaa:	e7bc      	b.n	1df26 <__aeabi_fsub+0x5a>
   1dfac:	2800      	cmp	r0, #0
   1dfae:	dd4f      	ble.n	1e050 <__aeabi_fsub+0x184>
   1dfb0:	2e00      	cmp	r6, #0
   1dfb2:	d02e      	beq.n	1e012 <__aeabi_fsub+0x146>
   1dfb4:	2cff      	cmp	r4, #255	; 0xff
   1dfb6:	d0a4      	beq.n	1df02 <__aeabi_fsub+0x36>
   1dfb8:	2580      	movs	r5, #128	; 0x80
   1dfba:	04ed      	lsls	r5, r5, #19
   1dfbc:	432a      	orrs	r2, r5
   1dfbe:	281b      	cmp	r0, #27
   1dfc0:	dd00      	ble.n	1dfc4 <__aeabi_fsub+0xf8>
   1dfc2:	e097      	b.n	1e0f4 <__aeabi_fsub+0x228>
   1dfc4:	0016      	movs	r6, r2
   1dfc6:	2520      	movs	r5, #32
   1dfc8:	40c6      	lsrs	r6, r0
   1dfca:	1a28      	subs	r0, r5, r0
   1dfcc:	4082      	lsls	r2, r0
   1dfce:	1e50      	subs	r0, r2, #1
   1dfd0:	4182      	sbcs	r2, r0
   1dfd2:	4332      	orrs	r2, r6
   1dfd4:	189b      	adds	r3, r3, r2
   1dfd6:	015a      	lsls	r2, r3, #5
   1dfd8:	d5d5      	bpl.n	1df86 <__aeabi_fsub+0xba>
   1dfda:	3401      	adds	r4, #1
   1dfdc:	2cff      	cmp	r4, #255	; 0xff
   1dfde:	d06d      	beq.n	1e0bc <__aeabi_fsub+0x1f0>
   1dfe0:	2201      	movs	r2, #1
   1dfe2:	487b      	ldr	r0, [pc, #492]	; (1e1d0 <__aeabi_fsub+0x304>)
   1dfe4:	401a      	ands	r2, r3
   1dfe6:	085b      	lsrs	r3, r3, #1
   1dfe8:	4003      	ands	r3, r0
   1dfea:	4313      	orrs	r3, r2
   1dfec:	000d      	movs	r5, r1
   1dfee:	e788      	b.n	1df02 <__aeabi_fsub+0x36>
   1dff0:	2a00      	cmp	r2, #0
   1dff2:	d000      	beq.n	1dff6 <__aeabi_fsub+0x12a>
   1dff4:	e77a      	b.n	1deec <__aeabi_fsub+0x20>
   1dff6:	e777      	b.n	1dee8 <__aeabi_fsub+0x1c>
   1dff8:	1e03      	subs	r3, r0, #0
   1dffa:	d1c5      	bne.n	1df88 <__aeabi_fsub+0xbc>
   1dffc:	2500      	movs	r5, #0
   1dffe:	027b      	lsls	r3, r7, #9
   1e000:	0a5b      	lsrs	r3, r3, #9
   1e002:	b2e4      	uxtb	r4, r4
   1e004:	e78f      	b.n	1df26 <__aeabi_fsub+0x5a>
   1e006:	3801      	subs	r0, #1
   1e008:	2800      	cmp	r0, #0
   1e00a:	d0a4      	beq.n	1df56 <__aeabi_fsub+0x8a>
   1e00c:	2cff      	cmp	r4, #255	; 0xff
   1e00e:	d197      	bne.n	1df40 <__aeabi_fsub+0x74>
   1e010:	e777      	b.n	1df02 <__aeabi_fsub+0x36>
   1e012:	2a00      	cmp	r2, #0
   1e014:	d100      	bne.n	1e018 <__aeabi_fsub+0x14c>
   1e016:	e774      	b.n	1df02 <__aeabi_fsub+0x36>
   1e018:	3801      	subs	r0, #1
   1e01a:	2800      	cmp	r0, #0
   1e01c:	d0da      	beq.n	1dfd4 <__aeabi_fsub+0x108>
   1e01e:	2cff      	cmp	r4, #255	; 0xff
   1e020:	d1cd      	bne.n	1dfbe <__aeabi_fsub+0xf2>
   1e022:	e76e      	b.n	1df02 <__aeabi_fsub+0x36>
   1e024:	2800      	cmp	r0, #0
   1e026:	d121      	bne.n	1e06c <__aeabi_fsub+0x1a0>
   1e028:	1c60      	adds	r0, r4, #1
   1e02a:	b2c0      	uxtb	r0, r0
   1e02c:	2801      	cmp	r0, #1
   1e02e:	dd58      	ble.n	1e0e2 <__aeabi_fsub+0x216>
   1e030:	2780      	movs	r7, #128	; 0x80
   1e032:	1a9e      	subs	r6, r3, r2
   1e034:	04ff      	lsls	r7, r7, #19
   1e036:	4037      	ands	r7, r6
   1e038:	d02f      	beq.n	1e09a <__aeabi_fsub+0x1ce>
   1e03a:	1ad6      	subs	r6, r2, r3
   1e03c:	000d      	movs	r5, r1
   1e03e:	e78f      	b.n	1df60 <__aeabi_fsub+0x94>
   1e040:	2301      	movs	r3, #1
   1e042:	401d      	ands	r5, r3
   1e044:	2300      	movs	r3, #0
   1e046:	e76e      	b.n	1df26 <__aeabi_fsub+0x5a>
   1e048:	4b62      	ldr	r3, [pc, #392]	; (1e1d4 <__aeabi_fsub+0x308>)
   1e04a:	1a24      	subs	r4, r4, r0
   1e04c:	4033      	ands	r3, r6
   1e04e:	e758      	b.n	1df02 <__aeabi_fsub+0x36>
   1e050:	2800      	cmp	r0, #0
   1e052:	d151      	bne.n	1e0f8 <__aeabi_fsub+0x22c>
   1e054:	1c60      	adds	r0, r4, #1
   1e056:	b2c6      	uxtb	r6, r0
   1e058:	2e01      	cmp	r6, #1
   1e05a:	dd33      	ble.n	1e0c4 <__aeabi_fsub+0x1f8>
   1e05c:	28ff      	cmp	r0, #255	; 0xff
   1e05e:	d02d      	beq.n	1e0bc <__aeabi_fsub+0x1f0>
   1e060:	189b      	adds	r3, r3, r2
   1e062:	085b      	lsrs	r3, r3, #1
   1e064:	0004      	movs	r4, r0
   1e066:	e74c      	b.n	1df02 <__aeabi_fsub+0x36>
   1e068:	2201      	movs	r2, #1
   1e06a:	e774      	b.n	1df56 <__aeabi_fsub+0x8a>
   1e06c:	2c00      	cmp	r4, #0
   1e06e:	d01a      	beq.n	1e0a6 <__aeabi_fsub+0x1da>
   1e070:	2eff      	cmp	r6, #255	; 0xff
   1e072:	d01f      	beq.n	1e0b4 <__aeabi_fsub+0x1e8>
   1e074:	2480      	movs	r4, #128	; 0x80
   1e076:	04e4      	lsls	r4, r4, #19
   1e078:	4240      	negs	r0, r0
   1e07a:	4323      	orrs	r3, r4
   1e07c:	281b      	cmp	r0, #27
   1e07e:	dd00      	ble.n	1e082 <__aeabi_fsub+0x1b6>
   1e080:	e096      	b.n	1e1b0 <__aeabi_fsub+0x2e4>
   1e082:	001d      	movs	r5, r3
   1e084:	2420      	movs	r4, #32
   1e086:	40c5      	lsrs	r5, r0
   1e088:	1a20      	subs	r0, r4, r0
   1e08a:	4083      	lsls	r3, r0
   1e08c:	1e58      	subs	r0, r3, #1
   1e08e:	4183      	sbcs	r3, r0
   1e090:	432b      	orrs	r3, r5
   1e092:	1ad3      	subs	r3, r2, r3
   1e094:	0034      	movs	r4, r6
   1e096:	000d      	movs	r5, r1
   1e098:	e75e      	b.n	1df58 <__aeabi_fsub+0x8c>
   1e09a:	2e00      	cmp	r6, #0
   1e09c:	d000      	beq.n	1e0a0 <__aeabi_fsub+0x1d4>
   1e09e:	e75f      	b.n	1df60 <__aeabi_fsub+0x94>
   1e0a0:	2500      	movs	r5, #0
   1e0a2:	2400      	movs	r4, #0
   1e0a4:	e7ab      	b.n	1dffe <__aeabi_fsub+0x132>
   1e0a6:	2b00      	cmp	r3, #0
   1e0a8:	d044      	beq.n	1e134 <__aeabi_fsub+0x268>
   1e0aa:	43c0      	mvns	r0, r0
   1e0ac:	2800      	cmp	r0, #0
   1e0ae:	d0f0      	beq.n	1e092 <__aeabi_fsub+0x1c6>
   1e0b0:	2eff      	cmp	r6, #255	; 0xff
   1e0b2:	d1e3      	bne.n	1e07c <__aeabi_fsub+0x1b0>
   1e0b4:	0013      	movs	r3, r2
   1e0b6:	24ff      	movs	r4, #255	; 0xff
   1e0b8:	000d      	movs	r5, r1
   1e0ba:	e722      	b.n	1df02 <__aeabi_fsub+0x36>
   1e0bc:	000d      	movs	r5, r1
   1e0be:	24ff      	movs	r4, #255	; 0xff
   1e0c0:	2300      	movs	r3, #0
   1e0c2:	e730      	b.n	1df26 <__aeabi_fsub+0x5a>
   1e0c4:	2c00      	cmp	r4, #0
   1e0c6:	d15d      	bne.n	1e184 <__aeabi_fsub+0x2b8>
   1e0c8:	2b00      	cmp	r3, #0
   1e0ca:	d07d      	beq.n	1e1c8 <__aeabi_fsub+0x2fc>
   1e0cc:	2a00      	cmp	r2, #0
   1e0ce:	d100      	bne.n	1e0d2 <__aeabi_fsub+0x206>
   1e0d0:	e717      	b.n	1df02 <__aeabi_fsub+0x36>
   1e0d2:	189b      	adds	r3, r3, r2
   1e0d4:	015a      	lsls	r2, r3, #5
   1e0d6:	d400      	bmi.n	1e0da <__aeabi_fsub+0x20e>
   1e0d8:	e756      	b.n	1df88 <__aeabi_fsub+0xbc>
   1e0da:	4a3e      	ldr	r2, [pc, #248]	; (1e1d4 <__aeabi_fsub+0x308>)
   1e0dc:	0004      	movs	r4, r0
   1e0de:	4013      	ands	r3, r2
   1e0e0:	e70f      	b.n	1df02 <__aeabi_fsub+0x36>
   1e0e2:	2c00      	cmp	r4, #0
   1e0e4:	d11e      	bne.n	1e124 <__aeabi_fsub+0x258>
   1e0e6:	2b00      	cmp	r3, #0
   1e0e8:	d12f      	bne.n	1e14a <__aeabi_fsub+0x27e>
   1e0ea:	2a00      	cmp	r2, #0
   1e0ec:	d065      	beq.n	1e1ba <__aeabi_fsub+0x2ee>
   1e0ee:	0013      	movs	r3, r2
   1e0f0:	000d      	movs	r5, r1
   1e0f2:	e706      	b.n	1df02 <__aeabi_fsub+0x36>
   1e0f4:	2201      	movs	r2, #1
   1e0f6:	e76d      	b.n	1dfd4 <__aeabi_fsub+0x108>
   1e0f8:	2c00      	cmp	r4, #0
   1e0fa:	d11f      	bne.n	1e13c <__aeabi_fsub+0x270>
   1e0fc:	2b00      	cmp	r3, #0
   1e0fe:	d059      	beq.n	1e1b4 <__aeabi_fsub+0x2e8>
   1e100:	43c0      	mvns	r0, r0
   1e102:	2800      	cmp	r0, #0
   1e104:	d00b      	beq.n	1e11e <__aeabi_fsub+0x252>
   1e106:	2eff      	cmp	r6, #255	; 0xff
   1e108:	d04f      	beq.n	1e1aa <__aeabi_fsub+0x2de>
   1e10a:	281b      	cmp	r0, #27
   1e10c:	dc5e      	bgt.n	1e1cc <__aeabi_fsub+0x300>
   1e10e:	001d      	movs	r5, r3
   1e110:	2420      	movs	r4, #32
   1e112:	40c5      	lsrs	r5, r0
   1e114:	1a20      	subs	r0, r4, r0
   1e116:	4083      	lsls	r3, r0
   1e118:	1e58      	subs	r0, r3, #1
   1e11a:	4183      	sbcs	r3, r0
   1e11c:	432b      	orrs	r3, r5
   1e11e:	189b      	adds	r3, r3, r2
   1e120:	0034      	movs	r4, r6
   1e122:	e758      	b.n	1dfd6 <__aeabi_fsub+0x10a>
   1e124:	2b00      	cmp	r3, #0
   1e126:	d11c      	bne.n	1e162 <__aeabi_fsub+0x296>
   1e128:	2a00      	cmp	r2, #0
   1e12a:	d049      	beq.n	1e1c0 <__aeabi_fsub+0x2f4>
   1e12c:	0013      	movs	r3, r2
   1e12e:	000d      	movs	r5, r1
   1e130:	24ff      	movs	r4, #255	; 0xff
   1e132:	e6e6      	b.n	1df02 <__aeabi_fsub+0x36>
   1e134:	0013      	movs	r3, r2
   1e136:	0034      	movs	r4, r6
   1e138:	000d      	movs	r5, r1
   1e13a:	e6e2      	b.n	1df02 <__aeabi_fsub+0x36>
   1e13c:	2eff      	cmp	r6, #255	; 0xff
   1e13e:	d034      	beq.n	1e1aa <__aeabi_fsub+0x2de>
   1e140:	2480      	movs	r4, #128	; 0x80
   1e142:	04e4      	lsls	r4, r4, #19
   1e144:	4240      	negs	r0, r0
   1e146:	4323      	orrs	r3, r4
   1e148:	e7df      	b.n	1e10a <__aeabi_fsub+0x23e>
   1e14a:	2a00      	cmp	r2, #0
   1e14c:	d100      	bne.n	1e150 <__aeabi_fsub+0x284>
   1e14e:	e6d8      	b.n	1df02 <__aeabi_fsub+0x36>
   1e150:	2780      	movs	r7, #128	; 0x80
   1e152:	1a98      	subs	r0, r3, r2
   1e154:	04ff      	lsls	r7, r7, #19
   1e156:	4007      	ands	r7, r0
   1e158:	d100      	bne.n	1e15c <__aeabi_fsub+0x290>
   1e15a:	e74d      	b.n	1dff8 <__aeabi_fsub+0x12c>
   1e15c:	1ad3      	subs	r3, r2, r3
   1e15e:	000d      	movs	r5, r1
   1e160:	e6cf      	b.n	1df02 <__aeabi_fsub+0x36>
   1e162:	24ff      	movs	r4, #255	; 0xff
   1e164:	2a00      	cmp	r2, #0
   1e166:	d100      	bne.n	1e16a <__aeabi_fsub+0x29e>
   1e168:	e6cb      	b.n	1df02 <__aeabi_fsub+0x36>
   1e16a:	2080      	movs	r0, #128	; 0x80
   1e16c:	08db      	lsrs	r3, r3, #3
   1e16e:	03c0      	lsls	r0, r0, #15
   1e170:	4203      	tst	r3, r0
   1e172:	d004      	beq.n	1e17e <__aeabi_fsub+0x2b2>
   1e174:	08d2      	lsrs	r2, r2, #3
   1e176:	4202      	tst	r2, r0
   1e178:	d101      	bne.n	1e17e <__aeabi_fsub+0x2b2>
   1e17a:	0013      	movs	r3, r2
   1e17c:	000d      	movs	r5, r1
   1e17e:	00db      	lsls	r3, r3, #3
   1e180:	24ff      	movs	r4, #255	; 0xff
   1e182:	e6be      	b.n	1df02 <__aeabi_fsub+0x36>
   1e184:	2b00      	cmp	r3, #0
   1e186:	d010      	beq.n	1e1aa <__aeabi_fsub+0x2de>
   1e188:	24ff      	movs	r4, #255	; 0xff
   1e18a:	2a00      	cmp	r2, #0
   1e18c:	d100      	bne.n	1e190 <__aeabi_fsub+0x2c4>
   1e18e:	e6b8      	b.n	1df02 <__aeabi_fsub+0x36>
   1e190:	2080      	movs	r0, #128	; 0x80
   1e192:	08db      	lsrs	r3, r3, #3
   1e194:	03c0      	lsls	r0, r0, #15
   1e196:	4203      	tst	r3, r0
   1e198:	d003      	beq.n	1e1a2 <__aeabi_fsub+0x2d6>
   1e19a:	08d2      	lsrs	r2, r2, #3
   1e19c:	4202      	tst	r2, r0
   1e19e:	d100      	bne.n	1e1a2 <__aeabi_fsub+0x2d6>
   1e1a0:	0013      	movs	r3, r2
   1e1a2:	00db      	lsls	r3, r3, #3
   1e1a4:	000d      	movs	r5, r1
   1e1a6:	24ff      	movs	r4, #255	; 0xff
   1e1a8:	e6ab      	b.n	1df02 <__aeabi_fsub+0x36>
   1e1aa:	0013      	movs	r3, r2
   1e1ac:	24ff      	movs	r4, #255	; 0xff
   1e1ae:	e6a8      	b.n	1df02 <__aeabi_fsub+0x36>
   1e1b0:	2301      	movs	r3, #1
   1e1b2:	e76e      	b.n	1e092 <__aeabi_fsub+0x1c6>
   1e1b4:	0013      	movs	r3, r2
   1e1b6:	0034      	movs	r4, r6
   1e1b8:	e6a3      	b.n	1df02 <__aeabi_fsub+0x36>
   1e1ba:	2700      	movs	r7, #0
   1e1bc:	2500      	movs	r5, #0
   1e1be:	e71e      	b.n	1dffe <__aeabi_fsub+0x132>
   1e1c0:	2780      	movs	r7, #128	; 0x80
   1e1c2:	2500      	movs	r5, #0
   1e1c4:	03ff      	lsls	r7, r7, #15
   1e1c6:	e6e9      	b.n	1df9c <__aeabi_fsub+0xd0>
   1e1c8:	0013      	movs	r3, r2
   1e1ca:	e69a      	b.n	1df02 <__aeabi_fsub+0x36>
   1e1cc:	2301      	movs	r3, #1
   1e1ce:	e7a6      	b.n	1e11e <__aeabi_fsub+0x252>
   1e1d0:	7dffffff 	.word	0x7dffffff
   1e1d4:	fbffffff 	.word	0xfbffffff

0001e1d8 <__aeabi_f2iz>:
   1e1d8:	0243      	lsls	r3, r0, #9
   1e1da:	0a59      	lsrs	r1, r3, #9
   1e1dc:	0043      	lsls	r3, r0, #1
   1e1de:	0fc2      	lsrs	r2, r0, #31
   1e1e0:	0e1b      	lsrs	r3, r3, #24
   1e1e2:	2000      	movs	r0, #0
   1e1e4:	2b7e      	cmp	r3, #126	; 0x7e
   1e1e6:	dd0e      	ble.n	1e206 <__aeabi_f2iz+0x2e>
   1e1e8:	2b9d      	cmp	r3, #157	; 0x9d
   1e1ea:	dc0d      	bgt.n	1e208 <__aeabi_f2iz+0x30>
   1e1ec:	2080      	movs	r0, #128	; 0x80
   1e1ee:	0400      	lsls	r0, r0, #16
   1e1f0:	4301      	orrs	r1, r0
   1e1f2:	2b95      	cmp	r3, #149	; 0x95
   1e1f4:	dc0b      	bgt.n	1e20e <__aeabi_f2iz+0x36>
   1e1f6:	2096      	movs	r0, #150	; 0x96
   1e1f8:	1ac3      	subs	r3, r0, r3
   1e1fa:	40d9      	lsrs	r1, r3
   1e1fc:	000b      	movs	r3, r1
   1e1fe:	4258      	negs	r0, r3
   1e200:	2a00      	cmp	r2, #0
   1e202:	d100      	bne.n	1e206 <__aeabi_f2iz+0x2e>
   1e204:	0018      	movs	r0, r3
   1e206:	4770      	bx	lr
   1e208:	4b03      	ldr	r3, [pc, #12]	; (1e218 <__aeabi_f2iz+0x40>)
   1e20a:	18d0      	adds	r0, r2, r3
   1e20c:	e7fb      	b.n	1e206 <__aeabi_f2iz+0x2e>
   1e20e:	3b96      	subs	r3, #150	; 0x96
   1e210:	4099      	lsls	r1, r3
   1e212:	000b      	movs	r3, r1
   1e214:	e7f3      	b.n	1e1fe <__aeabi_f2iz+0x26>
   1e216:	46c0      	nop			; (mov r8, r8)
   1e218:	7fffffff 	.word	0x7fffffff

0001e21c <__aeabi_i2f>:
   1e21c:	b570      	push	{r4, r5, r6, lr}
   1e21e:	2800      	cmp	r0, #0
   1e220:	d030      	beq.n	1e284 <__aeabi_i2f+0x68>
   1e222:	17c3      	asrs	r3, r0, #31
   1e224:	18c5      	adds	r5, r0, r3
   1e226:	405d      	eors	r5, r3
   1e228:	0fc4      	lsrs	r4, r0, #31
   1e22a:	0028      	movs	r0, r5
   1e22c:	f000 fc10 	bl	1ea50 <__clzsi2>
   1e230:	239e      	movs	r3, #158	; 0x9e
   1e232:	1a1b      	subs	r3, r3, r0
   1e234:	2b96      	cmp	r3, #150	; 0x96
   1e236:	dc0d      	bgt.n	1e254 <__aeabi_i2f+0x38>
   1e238:	2296      	movs	r2, #150	; 0x96
   1e23a:	1ad2      	subs	r2, r2, r3
   1e23c:	4095      	lsls	r5, r2
   1e23e:	026a      	lsls	r2, r5, #9
   1e240:	0a52      	lsrs	r2, r2, #9
   1e242:	b2d8      	uxtb	r0, r3
   1e244:	0252      	lsls	r2, r2, #9
   1e246:	05c0      	lsls	r0, r0, #23
   1e248:	0a52      	lsrs	r2, r2, #9
   1e24a:	07e4      	lsls	r4, r4, #31
   1e24c:	4302      	orrs	r2, r0
   1e24e:	4322      	orrs	r2, r4
   1e250:	0010      	movs	r0, r2
   1e252:	bd70      	pop	{r4, r5, r6, pc}
   1e254:	2b99      	cmp	r3, #153	; 0x99
   1e256:	dc19      	bgt.n	1e28c <__aeabi_i2f+0x70>
   1e258:	2299      	movs	r2, #153	; 0x99
   1e25a:	1ad2      	subs	r2, r2, r3
   1e25c:	4095      	lsls	r5, r2
   1e25e:	4a12      	ldr	r2, [pc, #72]	; (1e2a8 <__aeabi_i2f+0x8c>)
   1e260:	402a      	ands	r2, r5
   1e262:	0769      	lsls	r1, r5, #29
   1e264:	d004      	beq.n	1e270 <__aeabi_i2f+0x54>
   1e266:	210f      	movs	r1, #15
   1e268:	400d      	ands	r5, r1
   1e26a:	2d04      	cmp	r5, #4
   1e26c:	d000      	beq.n	1e270 <__aeabi_i2f+0x54>
   1e26e:	3204      	adds	r2, #4
   1e270:	0151      	lsls	r1, r2, #5
   1e272:	d503      	bpl.n	1e27c <__aeabi_i2f+0x60>
   1e274:	4b0c      	ldr	r3, [pc, #48]	; (1e2a8 <__aeabi_i2f+0x8c>)
   1e276:	401a      	ands	r2, r3
   1e278:	239f      	movs	r3, #159	; 0x9f
   1e27a:	1a1b      	subs	r3, r3, r0
   1e27c:	0192      	lsls	r2, r2, #6
   1e27e:	0a52      	lsrs	r2, r2, #9
   1e280:	b2d8      	uxtb	r0, r3
   1e282:	e7df      	b.n	1e244 <__aeabi_i2f+0x28>
   1e284:	2400      	movs	r4, #0
   1e286:	2000      	movs	r0, #0
   1e288:	2200      	movs	r2, #0
   1e28a:	e7db      	b.n	1e244 <__aeabi_i2f+0x28>
   1e28c:	2205      	movs	r2, #5
   1e28e:	002e      	movs	r6, r5
   1e290:	1a12      	subs	r2, r2, r0
   1e292:	21b9      	movs	r1, #185	; 0xb9
   1e294:	40d6      	lsrs	r6, r2
   1e296:	002a      	movs	r2, r5
   1e298:	1ac9      	subs	r1, r1, r3
   1e29a:	408a      	lsls	r2, r1
   1e29c:	1e55      	subs	r5, r2, #1
   1e29e:	41aa      	sbcs	r2, r5
   1e2a0:	0035      	movs	r5, r6
   1e2a2:	4315      	orrs	r5, r2
   1e2a4:	e7db      	b.n	1e25e <__aeabi_i2f+0x42>
   1e2a6:	46c0      	nop			; (mov r8, r8)
   1e2a8:	fbffffff 	.word	0xfbffffff

0001e2ac <__aeabi_ui2f>:
   1e2ac:	b570      	push	{r4, r5, r6, lr}
   1e2ae:	1e04      	subs	r4, r0, #0
   1e2b0:	d028      	beq.n	1e304 <__aeabi_ui2f+0x58>
   1e2b2:	f000 fbcd 	bl	1ea50 <__clzsi2>
   1e2b6:	239e      	movs	r3, #158	; 0x9e
   1e2b8:	1a1b      	subs	r3, r3, r0
   1e2ba:	2b96      	cmp	r3, #150	; 0x96
   1e2bc:	dc0a      	bgt.n	1e2d4 <__aeabi_ui2f+0x28>
   1e2be:	2296      	movs	r2, #150	; 0x96
   1e2c0:	1ad2      	subs	r2, r2, r3
   1e2c2:	4094      	lsls	r4, r2
   1e2c4:	0262      	lsls	r2, r4, #9
   1e2c6:	0a52      	lsrs	r2, r2, #9
   1e2c8:	b2d8      	uxtb	r0, r3
   1e2ca:	0252      	lsls	r2, r2, #9
   1e2cc:	0a52      	lsrs	r2, r2, #9
   1e2ce:	05c0      	lsls	r0, r0, #23
   1e2d0:	4310      	orrs	r0, r2
   1e2d2:	bd70      	pop	{r4, r5, r6, pc}
   1e2d4:	2b99      	cmp	r3, #153	; 0x99
   1e2d6:	dc18      	bgt.n	1e30a <__aeabi_ui2f+0x5e>
   1e2d8:	2299      	movs	r2, #153	; 0x99
   1e2da:	1ad2      	subs	r2, r2, r3
   1e2dc:	4094      	lsls	r4, r2
   1e2de:	4a11      	ldr	r2, [pc, #68]	; (1e324 <__aeabi_ui2f+0x78>)
   1e2e0:	4022      	ands	r2, r4
   1e2e2:	0761      	lsls	r1, r4, #29
   1e2e4:	d004      	beq.n	1e2f0 <__aeabi_ui2f+0x44>
   1e2e6:	210f      	movs	r1, #15
   1e2e8:	400c      	ands	r4, r1
   1e2ea:	2c04      	cmp	r4, #4
   1e2ec:	d000      	beq.n	1e2f0 <__aeabi_ui2f+0x44>
   1e2ee:	3204      	adds	r2, #4
   1e2f0:	0151      	lsls	r1, r2, #5
   1e2f2:	d503      	bpl.n	1e2fc <__aeabi_ui2f+0x50>
   1e2f4:	4b0b      	ldr	r3, [pc, #44]	; (1e324 <__aeabi_ui2f+0x78>)
   1e2f6:	401a      	ands	r2, r3
   1e2f8:	239f      	movs	r3, #159	; 0x9f
   1e2fa:	1a1b      	subs	r3, r3, r0
   1e2fc:	0192      	lsls	r2, r2, #6
   1e2fe:	0a52      	lsrs	r2, r2, #9
   1e300:	b2d8      	uxtb	r0, r3
   1e302:	e7e2      	b.n	1e2ca <__aeabi_ui2f+0x1e>
   1e304:	2000      	movs	r0, #0
   1e306:	2200      	movs	r2, #0
   1e308:	e7df      	b.n	1e2ca <__aeabi_ui2f+0x1e>
   1e30a:	2205      	movs	r2, #5
   1e30c:	0025      	movs	r5, r4
   1e30e:	1a12      	subs	r2, r2, r0
   1e310:	21b9      	movs	r1, #185	; 0xb9
   1e312:	40d5      	lsrs	r5, r2
   1e314:	0022      	movs	r2, r4
   1e316:	1ac9      	subs	r1, r1, r3
   1e318:	408a      	lsls	r2, r1
   1e31a:	1e54      	subs	r4, r2, #1
   1e31c:	41a2      	sbcs	r2, r4
   1e31e:	002c      	movs	r4, r5
   1e320:	4314      	orrs	r4, r2
   1e322:	e7dc      	b.n	1e2de <__aeabi_ui2f+0x32>
   1e324:	fbffffff 	.word	0xfbffffff

0001e328 <__aeabi_dmul>:
   1e328:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e32a:	465f      	mov	r7, fp
   1e32c:	4656      	mov	r6, sl
   1e32e:	464d      	mov	r5, r9
   1e330:	4644      	mov	r4, r8
   1e332:	b4f0      	push	{r4, r5, r6, r7}
   1e334:	030d      	lsls	r5, r1, #12
   1e336:	4699      	mov	r9, r3
   1e338:	004e      	lsls	r6, r1, #1
   1e33a:	0b2b      	lsrs	r3, r5, #12
   1e33c:	b087      	sub	sp, #28
   1e33e:	0007      	movs	r7, r0
   1e340:	4692      	mov	sl, r2
   1e342:	4680      	mov	r8, r0
   1e344:	469b      	mov	fp, r3
   1e346:	0d76      	lsrs	r6, r6, #21
   1e348:	0fcc      	lsrs	r4, r1, #31
   1e34a:	2e00      	cmp	r6, #0
   1e34c:	d069      	beq.n	1e422 <__aeabi_dmul+0xfa>
   1e34e:	4b6d      	ldr	r3, [pc, #436]	; (1e504 <__aeabi_dmul+0x1dc>)
   1e350:	429e      	cmp	r6, r3
   1e352:	d035      	beq.n	1e3c0 <__aeabi_dmul+0x98>
   1e354:	465b      	mov	r3, fp
   1e356:	2280      	movs	r2, #128	; 0x80
   1e358:	00dd      	lsls	r5, r3, #3
   1e35a:	0412      	lsls	r2, r2, #16
   1e35c:	0f43      	lsrs	r3, r0, #29
   1e35e:	4313      	orrs	r3, r2
   1e360:	432b      	orrs	r3, r5
   1e362:	469b      	mov	fp, r3
   1e364:	00c3      	lsls	r3, r0, #3
   1e366:	4698      	mov	r8, r3
   1e368:	4b67      	ldr	r3, [pc, #412]	; (1e508 <__aeabi_dmul+0x1e0>)
   1e36a:	2700      	movs	r7, #0
   1e36c:	469c      	mov	ip, r3
   1e36e:	2300      	movs	r3, #0
   1e370:	4466      	add	r6, ip
   1e372:	9301      	str	r3, [sp, #4]
   1e374:	464a      	mov	r2, r9
   1e376:	0315      	lsls	r5, r2, #12
   1e378:	0050      	lsls	r0, r2, #1
   1e37a:	0fd2      	lsrs	r2, r2, #31
   1e37c:	4653      	mov	r3, sl
   1e37e:	0b2d      	lsrs	r5, r5, #12
   1e380:	0d40      	lsrs	r0, r0, #21
   1e382:	4691      	mov	r9, r2
   1e384:	d100      	bne.n	1e388 <__aeabi_dmul+0x60>
   1e386:	e076      	b.n	1e476 <__aeabi_dmul+0x14e>
   1e388:	4a5e      	ldr	r2, [pc, #376]	; (1e504 <__aeabi_dmul+0x1dc>)
   1e38a:	4290      	cmp	r0, r2
   1e38c:	d06c      	beq.n	1e468 <__aeabi_dmul+0x140>
   1e38e:	2280      	movs	r2, #128	; 0x80
   1e390:	0f5b      	lsrs	r3, r3, #29
   1e392:	0412      	lsls	r2, r2, #16
   1e394:	4313      	orrs	r3, r2
   1e396:	4a5c      	ldr	r2, [pc, #368]	; (1e508 <__aeabi_dmul+0x1e0>)
   1e398:	00ed      	lsls	r5, r5, #3
   1e39a:	4694      	mov	ip, r2
   1e39c:	431d      	orrs	r5, r3
   1e39e:	4653      	mov	r3, sl
   1e3a0:	2200      	movs	r2, #0
   1e3a2:	00db      	lsls	r3, r3, #3
   1e3a4:	4460      	add	r0, ip
   1e3a6:	4649      	mov	r1, r9
   1e3a8:	1836      	adds	r6, r6, r0
   1e3aa:	1c70      	adds	r0, r6, #1
   1e3ac:	4061      	eors	r1, r4
   1e3ae:	9002      	str	r0, [sp, #8]
   1e3b0:	4317      	orrs	r7, r2
   1e3b2:	2f0f      	cmp	r7, #15
   1e3b4:	d900      	bls.n	1e3b8 <__aeabi_dmul+0x90>
   1e3b6:	e0af      	b.n	1e518 <__aeabi_dmul+0x1f0>
   1e3b8:	4854      	ldr	r0, [pc, #336]	; (1e50c <__aeabi_dmul+0x1e4>)
   1e3ba:	00bf      	lsls	r7, r7, #2
   1e3bc:	59c7      	ldr	r7, [r0, r7]
   1e3be:	46bf      	mov	pc, r7
   1e3c0:	465b      	mov	r3, fp
   1e3c2:	431f      	orrs	r7, r3
   1e3c4:	d000      	beq.n	1e3c8 <__aeabi_dmul+0xa0>
   1e3c6:	e088      	b.n	1e4da <__aeabi_dmul+0x1b2>
   1e3c8:	2300      	movs	r3, #0
   1e3ca:	469b      	mov	fp, r3
   1e3cc:	4698      	mov	r8, r3
   1e3ce:	3302      	adds	r3, #2
   1e3d0:	2708      	movs	r7, #8
   1e3d2:	9301      	str	r3, [sp, #4]
   1e3d4:	e7ce      	b.n	1e374 <__aeabi_dmul+0x4c>
   1e3d6:	4649      	mov	r1, r9
   1e3d8:	2a02      	cmp	r2, #2
   1e3da:	d06a      	beq.n	1e4b2 <__aeabi_dmul+0x18a>
   1e3dc:	2a03      	cmp	r2, #3
   1e3de:	d100      	bne.n	1e3e2 <__aeabi_dmul+0xba>
   1e3e0:	e209      	b.n	1e7f6 <__aeabi_dmul+0x4ce>
   1e3e2:	2a01      	cmp	r2, #1
   1e3e4:	d000      	beq.n	1e3e8 <__aeabi_dmul+0xc0>
   1e3e6:	e1bb      	b.n	1e760 <__aeabi_dmul+0x438>
   1e3e8:	4011      	ands	r1, r2
   1e3ea:	2200      	movs	r2, #0
   1e3ec:	2300      	movs	r3, #0
   1e3ee:	2500      	movs	r5, #0
   1e3f0:	4690      	mov	r8, r2
   1e3f2:	b2cc      	uxtb	r4, r1
   1e3f4:	2100      	movs	r1, #0
   1e3f6:	032d      	lsls	r5, r5, #12
   1e3f8:	0d0a      	lsrs	r2, r1, #20
   1e3fa:	0512      	lsls	r2, r2, #20
   1e3fc:	0b2d      	lsrs	r5, r5, #12
   1e3fe:	4315      	orrs	r5, r2
   1e400:	4a43      	ldr	r2, [pc, #268]	; (1e510 <__aeabi_dmul+0x1e8>)
   1e402:	051b      	lsls	r3, r3, #20
   1e404:	4015      	ands	r5, r2
   1e406:	431d      	orrs	r5, r3
   1e408:	006d      	lsls	r5, r5, #1
   1e40a:	07e4      	lsls	r4, r4, #31
   1e40c:	086d      	lsrs	r5, r5, #1
   1e40e:	4325      	orrs	r5, r4
   1e410:	4640      	mov	r0, r8
   1e412:	0029      	movs	r1, r5
   1e414:	b007      	add	sp, #28
   1e416:	bc3c      	pop	{r2, r3, r4, r5}
   1e418:	4690      	mov	r8, r2
   1e41a:	4699      	mov	r9, r3
   1e41c:	46a2      	mov	sl, r4
   1e41e:	46ab      	mov	fp, r5
   1e420:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e422:	4303      	orrs	r3, r0
   1e424:	d052      	beq.n	1e4cc <__aeabi_dmul+0x1a4>
   1e426:	465b      	mov	r3, fp
   1e428:	2b00      	cmp	r3, #0
   1e42a:	d100      	bne.n	1e42e <__aeabi_dmul+0x106>
   1e42c:	e18a      	b.n	1e744 <__aeabi_dmul+0x41c>
   1e42e:	4658      	mov	r0, fp
   1e430:	f000 fb0e 	bl	1ea50 <__clzsi2>
   1e434:	0003      	movs	r3, r0
   1e436:	3b0b      	subs	r3, #11
   1e438:	2b1c      	cmp	r3, #28
   1e43a:	dd00      	ble.n	1e43e <__aeabi_dmul+0x116>
   1e43c:	e17b      	b.n	1e736 <__aeabi_dmul+0x40e>
   1e43e:	221d      	movs	r2, #29
   1e440:	1ad3      	subs	r3, r2, r3
   1e442:	003a      	movs	r2, r7
   1e444:	0001      	movs	r1, r0
   1e446:	465d      	mov	r5, fp
   1e448:	40da      	lsrs	r2, r3
   1e44a:	3908      	subs	r1, #8
   1e44c:	408d      	lsls	r5, r1
   1e44e:	0013      	movs	r3, r2
   1e450:	408f      	lsls	r7, r1
   1e452:	432b      	orrs	r3, r5
   1e454:	469b      	mov	fp, r3
   1e456:	46b8      	mov	r8, r7
   1e458:	4b2e      	ldr	r3, [pc, #184]	; (1e514 <__aeabi_dmul+0x1ec>)
   1e45a:	2700      	movs	r7, #0
   1e45c:	469c      	mov	ip, r3
   1e45e:	2300      	movs	r3, #0
   1e460:	4460      	add	r0, ip
   1e462:	4246      	negs	r6, r0
   1e464:	9301      	str	r3, [sp, #4]
   1e466:	e785      	b.n	1e374 <__aeabi_dmul+0x4c>
   1e468:	4652      	mov	r2, sl
   1e46a:	432a      	orrs	r2, r5
   1e46c:	d12c      	bne.n	1e4c8 <__aeabi_dmul+0x1a0>
   1e46e:	2500      	movs	r5, #0
   1e470:	2300      	movs	r3, #0
   1e472:	2202      	movs	r2, #2
   1e474:	e797      	b.n	1e3a6 <__aeabi_dmul+0x7e>
   1e476:	4652      	mov	r2, sl
   1e478:	432a      	orrs	r2, r5
   1e47a:	d021      	beq.n	1e4c0 <__aeabi_dmul+0x198>
   1e47c:	2d00      	cmp	r5, #0
   1e47e:	d100      	bne.n	1e482 <__aeabi_dmul+0x15a>
   1e480:	e154      	b.n	1e72c <__aeabi_dmul+0x404>
   1e482:	0028      	movs	r0, r5
   1e484:	f000 fae4 	bl	1ea50 <__clzsi2>
   1e488:	0003      	movs	r3, r0
   1e48a:	3b0b      	subs	r3, #11
   1e48c:	2b1c      	cmp	r3, #28
   1e48e:	dd00      	ble.n	1e492 <__aeabi_dmul+0x16a>
   1e490:	e146      	b.n	1e720 <__aeabi_dmul+0x3f8>
   1e492:	211d      	movs	r1, #29
   1e494:	1acb      	subs	r3, r1, r3
   1e496:	4651      	mov	r1, sl
   1e498:	0002      	movs	r2, r0
   1e49a:	40d9      	lsrs	r1, r3
   1e49c:	4653      	mov	r3, sl
   1e49e:	3a08      	subs	r2, #8
   1e4a0:	4095      	lsls	r5, r2
   1e4a2:	4093      	lsls	r3, r2
   1e4a4:	430d      	orrs	r5, r1
   1e4a6:	4a1b      	ldr	r2, [pc, #108]	; (1e514 <__aeabi_dmul+0x1ec>)
   1e4a8:	4694      	mov	ip, r2
   1e4aa:	4460      	add	r0, ip
   1e4ac:	4240      	negs	r0, r0
   1e4ae:	2200      	movs	r2, #0
   1e4b0:	e779      	b.n	1e3a6 <__aeabi_dmul+0x7e>
   1e4b2:	2401      	movs	r4, #1
   1e4b4:	2200      	movs	r2, #0
   1e4b6:	400c      	ands	r4, r1
   1e4b8:	4b12      	ldr	r3, [pc, #72]	; (1e504 <__aeabi_dmul+0x1dc>)
   1e4ba:	2500      	movs	r5, #0
   1e4bc:	4690      	mov	r8, r2
   1e4be:	e799      	b.n	1e3f4 <__aeabi_dmul+0xcc>
   1e4c0:	2500      	movs	r5, #0
   1e4c2:	2300      	movs	r3, #0
   1e4c4:	2201      	movs	r2, #1
   1e4c6:	e76e      	b.n	1e3a6 <__aeabi_dmul+0x7e>
   1e4c8:	2203      	movs	r2, #3
   1e4ca:	e76c      	b.n	1e3a6 <__aeabi_dmul+0x7e>
   1e4cc:	2300      	movs	r3, #0
   1e4ce:	469b      	mov	fp, r3
   1e4d0:	4698      	mov	r8, r3
   1e4d2:	3301      	adds	r3, #1
   1e4d4:	2704      	movs	r7, #4
   1e4d6:	9301      	str	r3, [sp, #4]
   1e4d8:	e74c      	b.n	1e374 <__aeabi_dmul+0x4c>
   1e4da:	2303      	movs	r3, #3
   1e4dc:	270c      	movs	r7, #12
   1e4de:	9301      	str	r3, [sp, #4]
   1e4e0:	e748      	b.n	1e374 <__aeabi_dmul+0x4c>
   1e4e2:	2300      	movs	r3, #0
   1e4e4:	2580      	movs	r5, #128	; 0x80
   1e4e6:	4698      	mov	r8, r3
   1e4e8:	2400      	movs	r4, #0
   1e4ea:	032d      	lsls	r5, r5, #12
   1e4ec:	4b05      	ldr	r3, [pc, #20]	; (1e504 <__aeabi_dmul+0x1dc>)
   1e4ee:	e781      	b.n	1e3f4 <__aeabi_dmul+0xcc>
   1e4f0:	465d      	mov	r5, fp
   1e4f2:	4643      	mov	r3, r8
   1e4f4:	9a01      	ldr	r2, [sp, #4]
   1e4f6:	e76f      	b.n	1e3d8 <__aeabi_dmul+0xb0>
   1e4f8:	465d      	mov	r5, fp
   1e4fa:	4643      	mov	r3, r8
   1e4fc:	0021      	movs	r1, r4
   1e4fe:	9a01      	ldr	r2, [sp, #4]
   1e500:	e76a      	b.n	1e3d8 <__aeabi_dmul+0xb0>
   1e502:	46c0      	nop			; (mov r8, r8)
   1e504:	000007ff 	.word	0x000007ff
   1e508:	fffffc01 	.word	0xfffffc01
   1e50c:	00021e3c 	.word	0x00021e3c
   1e510:	800fffff 	.word	0x800fffff
   1e514:	000003f3 	.word	0x000003f3
   1e518:	4642      	mov	r2, r8
   1e51a:	0c12      	lsrs	r2, r2, #16
   1e51c:	4691      	mov	r9, r2
   1e51e:	0c1a      	lsrs	r2, r3, #16
   1e520:	4694      	mov	ip, r2
   1e522:	4642      	mov	r2, r8
   1e524:	0417      	lsls	r7, r2, #16
   1e526:	464a      	mov	r2, r9
   1e528:	041b      	lsls	r3, r3, #16
   1e52a:	0c1b      	lsrs	r3, r3, #16
   1e52c:	435a      	muls	r2, r3
   1e52e:	4660      	mov	r0, ip
   1e530:	4690      	mov	r8, r2
   1e532:	464a      	mov	r2, r9
   1e534:	4342      	muls	r2, r0
   1e536:	0010      	movs	r0, r2
   1e538:	9203      	str	r2, [sp, #12]
   1e53a:	4662      	mov	r2, ip
   1e53c:	001c      	movs	r4, r3
   1e53e:	0c3f      	lsrs	r7, r7, #16
   1e540:	437a      	muls	r2, r7
   1e542:	437c      	muls	r4, r7
   1e544:	4442      	add	r2, r8
   1e546:	9201      	str	r2, [sp, #4]
   1e548:	0c22      	lsrs	r2, r4, #16
   1e54a:	4692      	mov	sl, r2
   1e54c:	9a01      	ldr	r2, [sp, #4]
   1e54e:	4452      	add	r2, sl
   1e550:	4590      	cmp	r8, r2
   1e552:	d906      	bls.n	1e562 <__aeabi_dmul+0x23a>
   1e554:	4682      	mov	sl, r0
   1e556:	2080      	movs	r0, #128	; 0x80
   1e558:	0240      	lsls	r0, r0, #9
   1e55a:	4680      	mov	r8, r0
   1e55c:	44c2      	add	sl, r8
   1e55e:	4650      	mov	r0, sl
   1e560:	9003      	str	r0, [sp, #12]
   1e562:	0c10      	lsrs	r0, r2, #16
   1e564:	9004      	str	r0, [sp, #16]
   1e566:	4648      	mov	r0, r9
   1e568:	0424      	lsls	r4, r4, #16
   1e56a:	0c24      	lsrs	r4, r4, #16
   1e56c:	0412      	lsls	r2, r2, #16
   1e56e:	1912      	adds	r2, r2, r4
   1e570:	9205      	str	r2, [sp, #20]
   1e572:	0c2a      	lsrs	r2, r5, #16
   1e574:	042d      	lsls	r5, r5, #16
   1e576:	0c2d      	lsrs	r5, r5, #16
   1e578:	4368      	muls	r0, r5
   1e57a:	002c      	movs	r4, r5
   1e57c:	4682      	mov	sl, r0
   1e57e:	4648      	mov	r0, r9
   1e580:	437c      	muls	r4, r7
   1e582:	4350      	muls	r0, r2
   1e584:	4681      	mov	r9, r0
   1e586:	0c20      	lsrs	r0, r4, #16
   1e588:	4680      	mov	r8, r0
   1e58a:	4357      	muls	r7, r2
   1e58c:	4457      	add	r7, sl
   1e58e:	4447      	add	r7, r8
   1e590:	45ba      	cmp	sl, r7
   1e592:	d903      	bls.n	1e59c <__aeabi_dmul+0x274>
   1e594:	2080      	movs	r0, #128	; 0x80
   1e596:	0240      	lsls	r0, r0, #9
   1e598:	4680      	mov	r8, r0
   1e59a:	44c1      	add	r9, r8
   1e59c:	0c38      	lsrs	r0, r7, #16
   1e59e:	043f      	lsls	r7, r7, #16
   1e5a0:	46b8      	mov	r8, r7
   1e5a2:	4448      	add	r0, r9
   1e5a4:	0424      	lsls	r4, r4, #16
   1e5a6:	0c24      	lsrs	r4, r4, #16
   1e5a8:	9001      	str	r0, [sp, #4]
   1e5aa:	9804      	ldr	r0, [sp, #16]
   1e5ac:	44a0      	add	r8, r4
   1e5ae:	4440      	add	r0, r8
   1e5b0:	9004      	str	r0, [sp, #16]
   1e5b2:	4658      	mov	r0, fp
   1e5b4:	0c00      	lsrs	r0, r0, #16
   1e5b6:	4681      	mov	r9, r0
   1e5b8:	4658      	mov	r0, fp
   1e5ba:	0404      	lsls	r4, r0, #16
   1e5bc:	0c20      	lsrs	r0, r4, #16
   1e5be:	4682      	mov	sl, r0
   1e5c0:	0007      	movs	r7, r0
   1e5c2:	4648      	mov	r0, r9
   1e5c4:	435f      	muls	r7, r3
   1e5c6:	464c      	mov	r4, r9
   1e5c8:	4343      	muls	r3, r0
   1e5ca:	4660      	mov	r0, ip
   1e5cc:	4360      	muls	r0, r4
   1e5ce:	4664      	mov	r4, ip
   1e5d0:	4683      	mov	fp, r0
   1e5d2:	4650      	mov	r0, sl
   1e5d4:	4344      	muls	r4, r0
   1e5d6:	0c38      	lsrs	r0, r7, #16
   1e5d8:	4684      	mov	ip, r0
   1e5da:	18e4      	adds	r4, r4, r3
   1e5dc:	4464      	add	r4, ip
   1e5de:	42a3      	cmp	r3, r4
   1e5e0:	d903      	bls.n	1e5ea <__aeabi_dmul+0x2c2>
   1e5e2:	2380      	movs	r3, #128	; 0x80
   1e5e4:	025b      	lsls	r3, r3, #9
   1e5e6:	469c      	mov	ip, r3
   1e5e8:	44e3      	add	fp, ip
   1e5ea:	4648      	mov	r0, r9
   1e5ec:	043f      	lsls	r7, r7, #16
   1e5ee:	0c23      	lsrs	r3, r4, #16
   1e5f0:	0c3f      	lsrs	r7, r7, #16
   1e5f2:	0424      	lsls	r4, r4, #16
   1e5f4:	19e4      	adds	r4, r4, r7
   1e5f6:	4657      	mov	r7, sl
   1e5f8:	4368      	muls	r0, r5
   1e5fa:	436f      	muls	r7, r5
   1e5fc:	4684      	mov	ip, r0
   1e5fe:	464d      	mov	r5, r9
   1e600:	4650      	mov	r0, sl
   1e602:	4355      	muls	r5, r2
   1e604:	4342      	muls	r2, r0
   1e606:	0c38      	lsrs	r0, r7, #16
   1e608:	4681      	mov	r9, r0
   1e60a:	4462      	add	r2, ip
   1e60c:	444a      	add	r2, r9
   1e60e:	445b      	add	r3, fp
   1e610:	4594      	cmp	ip, r2
   1e612:	d903      	bls.n	1e61c <__aeabi_dmul+0x2f4>
   1e614:	2080      	movs	r0, #128	; 0x80
   1e616:	0240      	lsls	r0, r0, #9
   1e618:	4684      	mov	ip, r0
   1e61a:	4465      	add	r5, ip
   1e61c:	9803      	ldr	r0, [sp, #12]
   1e61e:	043f      	lsls	r7, r7, #16
   1e620:	4683      	mov	fp, r0
   1e622:	9804      	ldr	r0, [sp, #16]
   1e624:	0c3f      	lsrs	r7, r7, #16
   1e626:	4684      	mov	ip, r0
   1e628:	44e3      	add	fp, ip
   1e62a:	45c3      	cmp	fp, r8
   1e62c:	4180      	sbcs	r0, r0
   1e62e:	4240      	negs	r0, r0
   1e630:	4682      	mov	sl, r0
   1e632:	0410      	lsls	r0, r2, #16
   1e634:	4684      	mov	ip, r0
   1e636:	9801      	ldr	r0, [sp, #4]
   1e638:	4467      	add	r7, ip
   1e63a:	4684      	mov	ip, r0
   1e63c:	4467      	add	r7, ip
   1e63e:	44a3      	add	fp, r4
   1e640:	46bc      	mov	ip, r7
   1e642:	45a3      	cmp	fp, r4
   1e644:	41a4      	sbcs	r4, r4
   1e646:	4699      	mov	r9, r3
   1e648:	44d4      	add	ip, sl
   1e64a:	4264      	negs	r4, r4
   1e64c:	4287      	cmp	r7, r0
   1e64e:	41bf      	sbcs	r7, r7
   1e650:	45d4      	cmp	ip, sl
   1e652:	4180      	sbcs	r0, r0
   1e654:	44e1      	add	r9, ip
   1e656:	46a0      	mov	r8, r4
   1e658:	4599      	cmp	r9, r3
   1e65a:	419b      	sbcs	r3, r3
   1e65c:	427f      	negs	r7, r7
   1e65e:	4240      	negs	r0, r0
   1e660:	44c8      	add	r8, r9
   1e662:	4307      	orrs	r7, r0
   1e664:	0c12      	lsrs	r2, r2, #16
   1e666:	18ba      	adds	r2, r7, r2
   1e668:	45a0      	cmp	r8, r4
   1e66a:	41a4      	sbcs	r4, r4
   1e66c:	425f      	negs	r7, r3
   1e66e:	003b      	movs	r3, r7
   1e670:	4264      	negs	r4, r4
   1e672:	4323      	orrs	r3, r4
   1e674:	18d7      	adds	r7, r2, r3
   1e676:	4643      	mov	r3, r8
   1e678:	197d      	adds	r5, r7, r5
   1e67a:	0ddb      	lsrs	r3, r3, #23
   1e67c:	026d      	lsls	r5, r5, #9
   1e67e:	431d      	orrs	r5, r3
   1e680:	465b      	mov	r3, fp
   1e682:	025a      	lsls	r2, r3, #9
   1e684:	9b05      	ldr	r3, [sp, #20]
   1e686:	431a      	orrs	r2, r3
   1e688:	1e53      	subs	r3, r2, #1
   1e68a:	419a      	sbcs	r2, r3
   1e68c:	465b      	mov	r3, fp
   1e68e:	0ddb      	lsrs	r3, r3, #23
   1e690:	431a      	orrs	r2, r3
   1e692:	4643      	mov	r3, r8
   1e694:	025b      	lsls	r3, r3, #9
   1e696:	4313      	orrs	r3, r2
   1e698:	01ea      	lsls	r2, r5, #7
   1e69a:	d507      	bpl.n	1e6ac <__aeabi_dmul+0x384>
   1e69c:	2201      	movs	r2, #1
   1e69e:	085c      	lsrs	r4, r3, #1
   1e6a0:	4013      	ands	r3, r2
   1e6a2:	4323      	orrs	r3, r4
   1e6a4:	07ea      	lsls	r2, r5, #31
   1e6a6:	9e02      	ldr	r6, [sp, #8]
   1e6a8:	4313      	orrs	r3, r2
   1e6aa:	086d      	lsrs	r5, r5, #1
   1e6ac:	4a57      	ldr	r2, [pc, #348]	; (1e80c <__aeabi_dmul+0x4e4>)
   1e6ae:	18b2      	adds	r2, r6, r2
   1e6b0:	2a00      	cmp	r2, #0
   1e6b2:	dd4b      	ble.n	1e74c <__aeabi_dmul+0x424>
   1e6b4:	0758      	lsls	r0, r3, #29
   1e6b6:	d009      	beq.n	1e6cc <__aeabi_dmul+0x3a4>
   1e6b8:	200f      	movs	r0, #15
   1e6ba:	4018      	ands	r0, r3
   1e6bc:	2804      	cmp	r0, #4
   1e6be:	d005      	beq.n	1e6cc <__aeabi_dmul+0x3a4>
   1e6c0:	1d18      	adds	r0, r3, #4
   1e6c2:	4298      	cmp	r0, r3
   1e6c4:	419b      	sbcs	r3, r3
   1e6c6:	425b      	negs	r3, r3
   1e6c8:	18ed      	adds	r5, r5, r3
   1e6ca:	0003      	movs	r3, r0
   1e6cc:	01e8      	lsls	r0, r5, #7
   1e6ce:	d504      	bpl.n	1e6da <__aeabi_dmul+0x3b2>
   1e6d0:	4a4f      	ldr	r2, [pc, #316]	; (1e810 <__aeabi_dmul+0x4e8>)
   1e6d2:	4015      	ands	r5, r2
   1e6d4:	2280      	movs	r2, #128	; 0x80
   1e6d6:	00d2      	lsls	r2, r2, #3
   1e6d8:	18b2      	adds	r2, r6, r2
   1e6da:	484e      	ldr	r0, [pc, #312]	; (1e814 <__aeabi_dmul+0x4ec>)
   1e6dc:	4282      	cmp	r2, r0
   1e6de:	dd00      	ble.n	1e6e2 <__aeabi_dmul+0x3ba>
   1e6e0:	e6e7      	b.n	1e4b2 <__aeabi_dmul+0x18a>
   1e6e2:	2401      	movs	r4, #1
   1e6e4:	08db      	lsrs	r3, r3, #3
   1e6e6:	0768      	lsls	r0, r5, #29
   1e6e8:	4318      	orrs	r0, r3
   1e6ea:	026d      	lsls	r5, r5, #9
   1e6ec:	0553      	lsls	r3, r2, #21
   1e6ee:	4680      	mov	r8, r0
   1e6f0:	0b2d      	lsrs	r5, r5, #12
   1e6f2:	0d5b      	lsrs	r3, r3, #21
   1e6f4:	400c      	ands	r4, r1
   1e6f6:	e67d      	b.n	1e3f4 <__aeabi_dmul+0xcc>
   1e6f8:	2280      	movs	r2, #128	; 0x80
   1e6fa:	4659      	mov	r1, fp
   1e6fc:	0312      	lsls	r2, r2, #12
   1e6fe:	4211      	tst	r1, r2
   1e700:	d008      	beq.n	1e714 <__aeabi_dmul+0x3ec>
   1e702:	4215      	tst	r5, r2
   1e704:	d106      	bne.n	1e714 <__aeabi_dmul+0x3ec>
   1e706:	4315      	orrs	r5, r2
   1e708:	032d      	lsls	r5, r5, #12
   1e70a:	4698      	mov	r8, r3
   1e70c:	0b2d      	lsrs	r5, r5, #12
   1e70e:	464c      	mov	r4, r9
   1e710:	4b41      	ldr	r3, [pc, #260]	; (1e818 <__aeabi_dmul+0x4f0>)
   1e712:	e66f      	b.n	1e3f4 <__aeabi_dmul+0xcc>
   1e714:	465d      	mov	r5, fp
   1e716:	4315      	orrs	r5, r2
   1e718:	032d      	lsls	r5, r5, #12
   1e71a:	0b2d      	lsrs	r5, r5, #12
   1e71c:	4b3e      	ldr	r3, [pc, #248]	; (1e818 <__aeabi_dmul+0x4f0>)
   1e71e:	e669      	b.n	1e3f4 <__aeabi_dmul+0xcc>
   1e720:	0003      	movs	r3, r0
   1e722:	4655      	mov	r5, sl
   1e724:	3b28      	subs	r3, #40	; 0x28
   1e726:	409d      	lsls	r5, r3
   1e728:	2300      	movs	r3, #0
   1e72a:	e6bc      	b.n	1e4a6 <__aeabi_dmul+0x17e>
   1e72c:	4650      	mov	r0, sl
   1e72e:	f000 f98f 	bl	1ea50 <__clzsi2>
   1e732:	3020      	adds	r0, #32
   1e734:	e6a8      	b.n	1e488 <__aeabi_dmul+0x160>
   1e736:	0003      	movs	r3, r0
   1e738:	3b28      	subs	r3, #40	; 0x28
   1e73a:	409f      	lsls	r7, r3
   1e73c:	2300      	movs	r3, #0
   1e73e:	46bb      	mov	fp, r7
   1e740:	4698      	mov	r8, r3
   1e742:	e689      	b.n	1e458 <__aeabi_dmul+0x130>
   1e744:	f000 f984 	bl	1ea50 <__clzsi2>
   1e748:	3020      	adds	r0, #32
   1e74a:	e673      	b.n	1e434 <__aeabi_dmul+0x10c>
   1e74c:	2401      	movs	r4, #1
   1e74e:	1aa6      	subs	r6, r4, r2
   1e750:	2e38      	cmp	r6, #56	; 0x38
   1e752:	dd07      	ble.n	1e764 <__aeabi_dmul+0x43c>
   1e754:	2200      	movs	r2, #0
   1e756:	400c      	ands	r4, r1
   1e758:	2300      	movs	r3, #0
   1e75a:	2500      	movs	r5, #0
   1e75c:	4690      	mov	r8, r2
   1e75e:	e649      	b.n	1e3f4 <__aeabi_dmul+0xcc>
   1e760:	9e02      	ldr	r6, [sp, #8]
   1e762:	e7a3      	b.n	1e6ac <__aeabi_dmul+0x384>
   1e764:	2e1f      	cmp	r6, #31
   1e766:	dc20      	bgt.n	1e7aa <__aeabi_dmul+0x482>
   1e768:	2220      	movs	r2, #32
   1e76a:	002c      	movs	r4, r5
   1e76c:	0018      	movs	r0, r3
   1e76e:	1b92      	subs	r2, r2, r6
   1e770:	40f0      	lsrs	r0, r6
   1e772:	4094      	lsls	r4, r2
   1e774:	4093      	lsls	r3, r2
   1e776:	4304      	orrs	r4, r0
   1e778:	1e58      	subs	r0, r3, #1
   1e77a:	4183      	sbcs	r3, r0
   1e77c:	431c      	orrs	r4, r3
   1e77e:	40f5      	lsrs	r5, r6
   1e780:	0763      	lsls	r3, r4, #29
   1e782:	d009      	beq.n	1e798 <__aeabi_dmul+0x470>
   1e784:	230f      	movs	r3, #15
   1e786:	4023      	ands	r3, r4
   1e788:	2b04      	cmp	r3, #4
   1e78a:	d005      	beq.n	1e798 <__aeabi_dmul+0x470>
   1e78c:	0023      	movs	r3, r4
   1e78e:	1d1c      	adds	r4, r3, #4
   1e790:	429c      	cmp	r4, r3
   1e792:	4192      	sbcs	r2, r2
   1e794:	4252      	negs	r2, r2
   1e796:	18ad      	adds	r5, r5, r2
   1e798:	022b      	lsls	r3, r5, #8
   1e79a:	d51f      	bpl.n	1e7dc <__aeabi_dmul+0x4b4>
   1e79c:	2401      	movs	r4, #1
   1e79e:	2200      	movs	r2, #0
   1e7a0:	400c      	ands	r4, r1
   1e7a2:	2301      	movs	r3, #1
   1e7a4:	2500      	movs	r5, #0
   1e7a6:	4690      	mov	r8, r2
   1e7a8:	e624      	b.n	1e3f4 <__aeabi_dmul+0xcc>
   1e7aa:	201f      	movs	r0, #31
   1e7ac:	002c      	movs	r4, r5
   1e7ae:	4240      	negs	r0, r0
   1e7b0:	1a82      	subs	r2, r0, r2
   1e7b2:	40d4      	lsrs	r4, r2
   1e7b4:	2e20      	cmp	r6, #32
   1e7b6:	d01c      	beq.n	1e7f2 <__aeabi_dmul+0x4ca>
   1e7b8:	2240      	movs	r2, #64	; 0x40
   1e7ba:	1b96      	subs	r6, r2, r6
   1e7bc:	40b5      	lsls	r5, r6
   1e7be:	432b      	orrs	r3, r5
   1e7c0:	1e58      	subs	r0, r3, #1
   1e7c2:	4183      	sbcs	r3, r0
   1e7c4:	2007      	movs	r0, #7
   1e7c6:	4323      	orrs	r3, r4
   1e7c8:	4018      	ands	r0, r3
   1e7ca:	2500      	movs	r5, #0
   1e7cc:	2800      	cmp	r0, #0
   1e7ce:	d009      	beq.n	1e7e4 <__aeabi_dmul+0x4bc>
   1e7d0:	220f      	movs	r2, #15
   1e7d2:	2500      	movs	r5, #0
   1e7d4:	401a      	ands	r2, r3
   1e7d6:	001c      	movs	r4, r3
   1e7d8:	2a04      	cmp	r2, #4
   1e7da:	d1d8      	bne.n	1e78e <__aeabi_dmul+0x466>
   1e7dc:	0023      	movs	r3, r4
   1e7de:	0768      	lsls	r0, r5, #29
   1e7e0:	026d      	lsls	r5, r5, #9
   1e7e2:	0b2d      	lsrs	r5, r5, #12
   1e7e4:	2401      	movs	r4, #1
   1e7e6:	08db      	lsrs	r3, r3, #3
   1e7e8:	4303      	orrs	r3, r0
   1e7ea:	4698      	mov	r8, r3
   1e7ec:	400c      	ands	r4, r1
   1e7ee:	2300      	movs	r3, #0
   1e7f0:	e600      	b.n	1e3f4 <__aeabi_dmul+0xcc>
   1e7f2:	2500      	movs	r5, #0
   1e7f4:	e7e3      	b.n	1e7be <__aeabi_dmul+0x496>
   1e7f6:	2280      	movs	r2, #128	; 0x80
   1e7f8:	2401      	movs	r4, #1
   1e7fa:	0312      	lsls	r2, r2, #12
   1e7fc:	4315      	orrs	r5, r2
   1e7fe:	032d      	lsls	r5, r5, #12
   1e800:	4698      	mov	r8, r3
   1e802:	0b2d      	lsrs	r5, r5, #12
   1e804:	400c      	ands	r4, r1
   1e806:	4b04      	ldr	r3, [pc, #16]	; (1e818 <__aeabi_dmul+0x4f0>)
   1e808:	e5f4      	b.n	1e3f4 <__aeabi_dmul+0xcc>
   1e80a:	46c0      	nop			; (mov r8, r8)
   1e80c:	000003ff 	.word	0x000003ff
   1e810:	feffffff 	.word	0xfeffffff
   1e814:	000007fe 	.word	0x000007fe
   1e818:	000007ff 	.word	0x000007ff

0001e81c <__aeabi_f2d>:
   1e81c:	0042      	lsls	r2, r0, #1
   1e81e:	0e12      	lsrs	r2, r2, #24
   1e820:	1c51      	adds	r1, r2, #1
   1e822:	0243      	lsls	r3, r0, #9
   1e824:	b2c9      	uxtb	r1, r1
   1e826:	b570      	push	{r4, r5, r6, lr}
   1e828:	0a5d      	lsrs	r5, r3, #9
   1e82a:	0fc4      	lsrs	r4, r0, #31
   1e82c:	2901      	cmp	r1, #1
   1e82e:	dd15      	ble.n	1e85c <__aeabi_f2d+0x40>
   1e830:	21e0      	movs	r1, #224	; 0xe0
   1e832:	0089      	lsls	r1, r1, #2
   1e834:	468c      	mov	ip, r1
   1e836:	076d      	lsls	r5, r5, #29
   1e838:	0b1b      	lsrs	r3, r3, #12
   1e83a:	4462      	add	r2, ip
   1e83c:	2100      	movs	r1, #0
   1e83e:	0028      	movs	r0, r5
   1e840:	0d0d      	lsrs	r5, r1, #20
   1e842:	052d      	lsls	r5, r5, #20
   1e844:	432b      	orrs	r3, r5
   1e846:	4d1c      	ldr	r5, [pc, #112]	; (1e8b8 <__aeabi_f2d+0x9c>)
   1e848:	0552      	lsls	r2, r2, #21
   1e84a:	402b      	ands	r3, r5
   1e84c:	0852      	lsrs	r2, r2, #1
   1e84e:	4313      	orrs	r3, r2
   1e850:	005b      	lsls	r3, r3, #1
   1e852:	07e4      	lsls	r4, r4, #31
   1e854:	085b      	lsrs	r3, r3, #1
   1e856:	4323      	orrs	r3, r4
   1e858:	0019      	movs	r1, r3
   1e85a:	bd70      	pop	{r4, r5, r6, pc}
   1e85c:	2a00      	cmp	r2, #0
   1e85e:	d115      	bne.n	1e88c <__aeabi_f2d+0x70>
   1e860:	2d00      	cmp	r5, #0
   1e862:	d01f      	beq.n	1e8a4 <__aeabi_f2d+0x88>
   1e864:	0028      	movs	r0, r5
   1e866:	f000 f8f3 	bl	1ea50 <__clzsi2>
   1e86a:	280a      	cmp	r0, #10
   1e86c:	dc1d      	bgt.n	1e8aa <__aeabi_f2d+0x8e>
   1e86e:	230b      	movs	r3, #11
   1e870:	002a      	movs	r2, r5
   1e872:	1a1b      	subs	r3, r3, r0
   1e874:	40da      	lsrs	r2, r3
   1e876:	0013      	movs	r3, r2
   1e878:	0002      	movs	r2, r0
   1e87a:	3215      	adds	r2, #21
   1e87c:	4095      	lsls	r5, r2
   1e87e:	4a0f      	ldr	r2, [pc, #60]	; (1e8bc <__aeabi_f2d+0xa0>)
   1e880:	031b      	lsls	r3, r3, #12
   1e882:	1a12      	subs	r2, r2, r0
   1e884:	0552      	lsls	r2, r2, #21
   1e886:	0b1b      	lsrs	r3, r3, #12
   1e888:	0d52      	lsrs	r2, r2, #21
   1e88a:	e7d7      	b.n	1e83c <__aeabi_f2d+0x20>
   1e88c:	2d00      	cmp	r5, #0
   1e88e:	d006      	beq.n	1e89e <__aeabi_f2d+0x82>
   1e890:	2280      	movs	r2, #128	; 0x80
   1e892:	0b1b      	lsrs	r3, r3, #12
   1e894:	0312      	lsls	r2, r2, #12
   1e896:	4313      	orrs	r3, r2
   1e898:	076d      	lsls	r5, r5, #29
   1e89a:	4a09      	ldr	r2, [pc, #36]	; (1e8c0 <__aeabi_f2d+0xa4>)
   1e89c:	e7ce      	b.n	1e83c <__aeabi_f2d+0x20>
   1e89e:	4a08      	ldr	r2, [pc, #32]	; (1e8c0 <__aeabi_f2d+0xa4>)
   1e8a0:	2300      	movs	r3, #0
   1e8a2:	e7cb      	b.n	1e83c <__aeabi_f2d+0x20>
   1e8a4:	2200      	movs	r2, #0
   1e8a6:	2300      	movs	r3, #0
   1e8a8:	e7c8      	b.n	1e83c <__aeabi_f2d+0x20>
   1e8aa:	0003      	movs	r3, r0
   1e8ac:	3b0b      	subs	r3, #11
   1e8ae:	409d      	lsls	r5, r3
   1e8b0:	002b      	movs	r3, r5
   1e8b2:	2500      	movs	r5, #0
   1e8b4:	e7e3      	b.n	1e87e <__aeabi_f2d+0x62>
   1e8b6:	46c0      	nop			; (mov r8, r8)
   1e8b8:	800fffff 	.word	0x800fffff
   1e8bc:	00000389 	.word	0x00000389
   1e8c0:	000007ff 	.word	0x000007ff

0001e8c4 <__aeabi_d2f>:
   1e8c4:	004b      	lsls	r3, r1, #1
   1e8c6:	b570      	push	{r4, r5, r6, lr}
   1e8c8:	0d5e      	lsrs	r6, r3, #21
   1e8ca:	030c      	lsls	r4, r1, #12
   1e8cc:	1c75      	adds	r5, r6, #1
   1e8ce:	0a64      	lsrs	r4, r4, #9
   1e8d0:	0f42      	lsrs	r2, r0, #29
   1e8d2:	056d      	lsls	r5, r5, #21
   1e8d4:	4322      	orrs	r2, r4
   1e8d6:	0fc9      	lsrs	r1, r1, #31
   1e8d8:	00c4      	lsls	r4, r0, #3
   1e8da:	0d6d      	lsrs	r5, r5, #21
   1e8dc:	2d01      	cmp	r5, #1
   1e8de:	dd2a      	ble.n	1e936 <__aeabi_d2f+0x72>
   1e8e0:	4b3b      	ldr	r3, [pc, #236]	; (1e9d0 <__aeabi_d2f+0x10c>)
   1e8e2:	18f3      	adds	r3, r6, r3
   1e8e4:	2bfe      	cmp	r3, #254	; 0xfe
   1e8e6:	dc1a      	bgt.n	1e91e <__aeabi_d2f+0x5a>
   1e8e8:	2b00      	cmp	r3, #0
   1e8ea:	dd42      	ble.n	1e972 <__aeabi_d2f+0xae>
   1e8ec:	0180      	lsls	r0, r0, #6
   1e8ee:	1e45      	subs	r5, r0, #1
   1e8f0:	41a8      	sbcs	r0, r5
   1e8f2:	00d2      	lsls	r2, r2, #3
   1e8f4:	4310      	orrs	r0, r2
   1e8f6:	0f62      	lsrs	r2, r4, #29
   1e8f8:	4302      	orrs	r2, r0
   1e8fa:	0750      	lsls	r0, r2, #29
   1e8fc:	d004      	beq.n	1e908 <__aeabi_d2f+0x44>
   1e8fe:	200f      	movs	r0, #15
   1e900:	4010      	ands	r0, r2
   1e902:	2804      	cmp	r0, #4
   1e904:	d000      	beq.n	1e908 <__aeabi_d2f+0x44>
   1e906:	3204      	adds	r2, #4
   1e908:	2080      	movs	r0, #128	; 0x80
   1e90a:	04c0      	lsls	r0, r0, #19
   1e90c:	4010      	ands	r0, r2
   1e90e:	d021      	beq.n	1e954 <__aeabi_d2f+0x90>
   1e910:	3301      	adds	r3, #1
   1e912:	2bff      	cmp	r3, #255	; 0xff
   1e914:	d003      	beq.n	1e91e <__aeabi_d2f+0x5a>
   1e916:	0192      	lsls	r2, r2, #6
   1e918:	0a52      	lsrs	r2, r2, #9
   1e91a:	b2db      	uxtb	r3, r3
   1e91c:	e001      	b.n	1e922 <__aeabi_d2f+0x5e>
   1e91e:	23ff      	movs	r3, #255	; 0xff
   1e920:	2200      	movs	r2, #0
   1e922:	0252      	lsls	r2, r2, #9
   1e924:	0a52      	lsrs	r2, r2, #9
   1e926:	05db      	lsls	r3, r3, #23
   1e928:	4313      	orrs	r3, r2
   1e92a:	005b      	lsls	r3, r3, #1
   1e92c:	07c9      	lsls	r1, r1, #31
   1e92e:	085b      	lsrs	r3, r3, #1
   1e930:	430b      	orrs	r3, r1
   1e932:	0018      	movs	r0, r3
   1e934:	bd70      	pop	{r4, r5, r6, pc}
   1e936:	2e00      	cmp	r6, #0
   1e938:	d007      	beq.n	1e94a <__aeabi_d2f+0x86>
   1e93a:	4314      	orrs	r4, r2
   1e93c:	d0ef      	beq.n	1e91e <__aeabi_d2f+0x5a>
   1e93e:	2080      	movs	r0, #128	; 0x80
   1e940:	00d2      	lsls	r2, r2, #3
   1e942:	0480      	lsls	r0, r0, #18
   1e944:	4302      	orrs	r2, r0
   1e946:	23ff      	movs	r3, #255	; 0xff
   1e948:	e7d7      	b.n	1e8fa <__aeabi_d2f+0x36>
   1e94a:	4322      	orrs	r2, r4
   1e94c:	2300      	movs	r3, #0
   1e94e:	2a00      	cmp	r2, #0
   1e950:	d003      	beq.n	1e95a <__aeabi_d2f+0x96>
   1e952:	2205      	movs	r2, #5
   1e954:	08d2      	lsrs	r2, r2, #3
   1e956:	2bff      	cmp	r3, #255	; 0xff
   1e958:	d003      	beq.n	1e962 <__aeabi_d2f+0x9e>
   1e95a:	0252      	lsls	r2, r2, #9
   1e95c:	0a52      	lsrs	r2, r2, #9
   1e95e:	b2db      	uxtb	r3, r3
   1e960:	e7df      	b.n	1e922 <__aeabi_d2f+0x5e>
   1e962:	2a00      	cmp	r2, #0
   1e964:	d032      	beq.n	1e9cc <__aeabi_d2f+0x108>
   1e966:	2080      	movs	r0, #128	; 0x80
   1e968:	03c0      	lsls	r0, r0, #15
   1e96a:	4302      	orrs	r2, r0
   1e96c:	0252      	lsls	r2, r2, #9
   1e96e:	0a52      	lsrs	r2, r2, #9
   1e970:	e7d7      	b.n	1e922 <__aeabi_d2f+0x5e>
   1e972:	0018      	movs	r0, r3
   1e974:	3017      	adds	r0, #23
   1e976:	db14      	blt.n	1e9a2 <__aeabi_d2f+0xde>
   1e978:	2080      	movs	r0, #128	; 0x80
   1e97a:	0400      	lsls	r0, r0, #16
   1e97c:	4302      	orrs	r2, r0
   1e97e:	201e      	movs	r0, #30
   1e980:	1ac0      	subs	r0, r0, r3
   1e982:	281f      	cmp	r0, #31
   1e984:	dc0f      	bgt.n	1e9a6 <__aeabi_d2f+0xe2>
   1e986:	0025      	movs	r5, r4
   1e988:	4b12      	ldr	r3, [pc, #72]	; (1e9d4 <__aeabi_d2f+0x110>)
   1e98a:	18f3      	adds	r3, r6, r3
   1e98c:	409d      	lsls	r5, r3
   1e98e:	1e6e      	subs	r6, r5, #1
   1e990:	41b5      	sbcs	r5, r6
   1e992:	409a      	lsls	r2, r3
   1e994:	002b      	movs	r3, r5
   1e996:	4313      	orrs	r3, r2
   1e998:	0022      	movs	r2, r4
   1e99a:	40c2      	lsrs	r2, r0
   1e99c:	431a      	orrs	r2, r3
   1e99e:	2300      	movs	r3, #0
   1e9a0:	e7ab      	b.n	1e8fa <__aeabi_d2f+0x36>
   1e9a2:	2300      	movs	r3, #0
   1e9a4:	e7d5      	b.n	1e952 <__aeabi_d2f+0x8e>
   1e9a6:	2502      	movs	r5, #2
   1e9a8:	426d      	negs	r5, r5
   1e9aa:	1aeb      	subs	r3, r5, r3
   1e9ac:	0015      	movs	r5, r2
   1e9ae:	40dd      	lsrs	r5, r3
   1e9b0:	2820      	cmp	r0, #32
   1e9b2:	d009      	beq.n	1e9c8 <__aeabi_d2f+0x104>
   1e9b4:	4b08      	ldr	r3, [pc, #32]	; (1e9d8 <__aeabi_d2f+0x114>)
   1e9b6:	18f3      	adds	r3, r6, r3
   1e9b8:	409a      	lsls	r2, r3
   1e9ba:	4314      	orrs	r4, r2
   1e9bc:	1e62      	subs	r2, r4, #1
   1e9be:	4194      	sbcs	r4, r2
   1e9c0:	0022      	movs	r2, r4
   1e9c2:	2300      	movs	r3, #0
   1e9c4:	432a      	orrs	r2, r5
   1e9c6:	e798      	b.n	1e8fa <__aeabi_d2f+0x36>
   1e9c8:	2200      	movs	r2, #0
   1e9ca:	e7f6      	b.n	1e9ba <__aeabi_d2f+0xf6>
   1e9cc:	2200      	movs	r2, #0
   1e9ce:	e7a8      	b.n	1e922 <__aeabi_d2f+0x5e>
   1e9d0:	fffffc80 	.word	0xfffffc80
   1e9d4:	fffffc82 	.word	0xfffffc82
   1e9d8:	fffffca2 	.word	0xfffffca2

0001e9dc <__aeabi_cfrcmple>:
   1e9dc:	4684      	mov	ip, r0
   1e9de:	1c08      	adds	r0, r1, #0
   1e9e0:	4661      	mov	r1, ip
   1e9e2:	e7ff      	b.n	1e9e4 <__aeabi_cfcmpeq>

0001e9e4 <__aeabi_cfcmpeq>:
   1e9e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   1e9e6:	f000 f8c9 	bl	1eb7c <__lesf2>
   1e9ea:	2800      	cmp	r0, #0
   1e9ec:	d401      	bmi.n	1e9f2 <__aeabi_cfcmpeq+0xe>
   1e9ee:	2100      	movs	r1, #0
   1e9f0:	42c8      	cmn	r0, r1
   1e9f2:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

0001e9f4 <__aeabi_fcmpeq>:
   1e9f4:	b510      	push	{r4, lr}
   1e9f6:	f000 f855 	bl	1eaa4 <__eqsf2>
   1e9fa:	4240      	negs	r0, r0
   1e9fc:	3001      	adds	r0, #1
   1e9fe:	bd10      	pop	{r4, pc}

0001ea00 <__aeabi_fcmplt>:
   1ea00:	b510      	push	{r4, lr}
   1ea02:	f000 f8bb 	bl	1eb7c <__lesf2>
   1ea06:	2800      	cmp	r0, #0
   1ea08:	db01      	blt.n	1ea0e <__aeabi_fcmplt+0xe>
   1ea0a:	2000      	movs	r0, #0
   1ea0c:	bd10      	pop	{r4, pc}
   1ea0e:	2001      	movs	r0, #1
   1ea10:	bd10      	pop	{r4, pc}
   1ea12:	46c0      	nop			; (mov r8, r8)

0001ea14 <__aeabi_fcmple>:
   1ea14:	b510      	push	{r4, lr}
   1ea16:	f000 f8b1 	bl	1eb7c <__lesf2>
   1ea1a:	2800      	cmp	r0, #0
   1ea1c:	dd01      	ble.n	1ea22 <__aeabi_fcmple+0xe>
   1ea1e:	2000      	movs	r0, #0
   1ea20:	bd10      	pop	{r4, pc}
   1ea22:	2001      	movs	r0, #1
   1ea24:	bd10      	pop	{r4, pc}
   1ea26:	46c0      	nop			; (mov r8, r8)

0001ea28 <__aeabi_fcmpgt>:
   1ea28:	b510      	push	{r4, lr}
   1ea2a:	f000 f863 	bl	1eaf4 <__gesf2>
   1ea2e:	2800      	cmp	r0, #0
   1ea30:	dc01      	bgt.n	1ea36 <__aeabi_fcmpgt+0xe>
   1ea32:	2000      	movs	r0, #0
   1ea34:	bd10      	pop	{r4, pc}
   1ea36:	2001      	movs	r0, #1
   1ea38:	bd10      	pop	{r4, pc}
   1ea3a:	46c0      	nop			; (mov r8, r8)

0001ea3c <__aeabi_fcmpge>:
   1ea3c:	b510      	push	{r4, lr}
   1ea3e:	f000 f859 	bl	1eaf4 <__gesf2>
   1ea42:	2800      	cmp	r0, #0
   1ea44:	da01      	bge.n	1ea4a <__aeabi_fcmpge+0xe>
   1ea46:	2000      	movs	r0, #0
   1ea48:	bd10      	pop	{r4, pc}
   1ea4a:	2001      	movs	r0, #1
   1ea4c:	bd10      	pop	{r4, pc}
   1ea4e:	46c0      	nop			; (mov r8, r8)

0001ea50 <__clzsi2>:
   1ea50:	211c      	movs	r1, #28
   1ea52:	2301      	movs	r3, #1
   1ea54:	041b      	lsls	r3, r3, #16
   1ea56:	4298      	cmp	r0, r3
   1ea58:	d301      	bcc.n	1ea5e <__clzsi2+0xe>
   1ea5a:	0c00      	lsrs	r0, r0, #16
   1ea5c:	3910      	subs	r1, #16
   1ea5e:	0a1b      	lsrs	r3, r3, #8
   1ea60:	4298      	cmp	r0, r3
   1ea62:	d301      	bcc.n	1ea68 <__clzsi2+0x18>
   1ea64:	0a00      	lsrs	r0, r0, #8
   1ea66:	3908      	subs	r1, #8
   1ea68:	091b      	lsrs	r3, r3, #4
   1ea6a:	4298      	cmp	r0, r3
   1ea6c:	d301      	bcc.n	1ea72 <__clzsi2+0x22>
   1ea6e:	0900      	lsrs	r0, r0, #4
   1ea70:	3904      	subs	r1, #4
   1ea72:	a202      	add	r2, pc, #8	; (adr r2, 1ea7c <__clzsi2+0x2c>)
   1ea74:	5c10      	ldrb	r0, [r2, r0]
   1ea76:	1840      	adds	r0, r0, r1
   1ea78:	4770      	bx	lr
   1ea7a:	46c0      	nop			; (mov r8, r8)
   1ea7c:	02020304 	.word	0x02020304
   1ea80:	01010101 	.word	0x01010101
	...

0001ea8c <__clzdi2>:
   1ea8c:	b510      	push	{r4, lr}
   1ea8e:	2900      	cmp	r1, #0
   1ea90:	d103      	bne.n	1ea9a <__clzdi2+0xe>
   1ea92:	f7ff ffdd 	bl	1ea50 <__clzsi2>
   1ea96:	3020      	adds	r0, #32
   1ea98:	e002      	b.n	1eaa0 <__clzdi2+0x14>
   1ea9a:	1c08      	adds	r0, r1, #0
   1ea9c:	f7ff ffd8 	bl	1ea50 <__clzsi2>
   1eaa0:	bd10      	pop	{r4, pc}
   1eaa2:	46c0      	nop			; (mov r8, r8)

0001eaa4 <__eqsf2>:
   1eaa4:	0243      	lsls	r3, r0, #9
   1eaa6:	b570      	push	{r4, r5, r6, lr}
   1eaa8:	0042      	lsls	r2, r0, #1
   1eaaa:	004c      	lsls	r4, r1, #1
   1eaac:	0a5d      	lsrs	r5, r3, #9
   1eaae:	0fc3      	lsrs	r3, r0, #31
   1eab0:	0248      	lsls	r0, r1, #9
   1eab2:	0e12      	lsrs	r2, r2, #24
   1eab4:	0a46      	lsrs	r6, r0, #9
   1eab6:	0e24      	lsrs	r4, r4, #24
   1eab8:	0fc9      	lsrs	r1, r1, #31
   1eaba:	2aff      	cmp	r2, #255	; 0xff
   1eabc:	d00f      	beq.n	1eade <__eqsf2+0x3a>
   1eabe:	2cff      	cmp	r4, #255	; 0xff
   1eac0:	d011      	beq.n	1eae6 <__eqsf2+0x42>
   1eac2:	2001      	movs	r0, #1
   1eac4:	42a2      	cmp	r2, r4
   1eac6:	d000      	beq.n	1eaca <__eqsf2+0x26>
   1eac8:	bd70      	pop	{r4, r5, r6, pc}
   1eaca:	42b5      	cmp	r5, r6
   1eacc:	d1fc      	bne.n	1eac8 <__eqsf2+0x24>
   1eace:	428b      	cmp	r3, r1
   1ead0:	d00d      	beq.n	1eaee <__eqsf2+0x4a>
   1ead2:	2a00      	cmp	r2, #0
   1ead4:	d1f8      	bne.n	1eac8 <__eqsf2+0x24>
   1ead6:	0028      	movs	r0, r5
   1ead8:	1e43      	subs	r3, r0, #1
   1eada:	4198      	sbcs	r0, r3
   1eadc:	e7f4      	b.n	1eac8 <__eqsf2+0x24>
   1eade:	2001      	movs	r0, #1
   1eae0:	2d00      	cmp	r5, #0
   1eae2:	d1f1      	bne.n	1eac8 <__eqsf2+0x24>
   1eae4:	e7eb      	b.n	1eabe <__eqsf2+0x1a>
   1eae6:	2001      	movs	r0, #1
   1eae8:	2e00      	cmp	r6, #0
   1eaea:	d1ed      	bne.n	1eac8 <__eqsf2+0x24>
   1eaec:	e7e9      	b.n	1eac2 <__eqsf2+0x1e>
   1eaee:	2000      	movs	r0, #0
   1eaf0:	e7ea      	b.n	1eac8 <__eqsf2+0x24>
   1eaf2:	46c0      	nop			; (mov r8, r8)

0001eaf4 <__gesf2>:
   1eaf4:	0243      	lsls	r3, r0, #9
   1eaf6:	b5f0      	push	{r4, r5, r6, r7, lr}
   1eaf8:	0042      	lsls	r2, r0, #1
   1eafa:	0a5d      	lsrs	r5, r3, #9
   1eafc:	0fc3      	lsrs	r3, r0, #31
   1eafe:	0248      	lsls	r0, r1, #9
   1eb00:	0a44      	lsrs	r4, r0, #9
   1eb02:	0048      	lsls	r0, r1, #1
   1eb04:	0e12      	lsrs	r2, r2, #24
   1eb06:	0e00      	lsrs	r0, r0, #24
   1eb08:	0fc9      	lsrs	r1, r1, #31
   1eb0a:	2aff      	cmp	r2, #255	; 0xff
   1eb0c:	d01f      	beq.n	1eb4e <__gesf2+0x5a>
   1eb0e:	28ff      	cmp	r0, #255	; 0xff
   1eb10:	d022      	beq.n	1eb58 <__gesf2+0x64>
   1eb12:	2a00      	cmp	r2, #0
   1eb14:	d109      	bne.n	1eb2a <__gesf2+0x36>
   1eb16:	426e      	negs	r6, r5
   1eb18:	416e      	adcs	r6, r5
   1eb1a:	2800      	cmp	r0, #0
   1eb1c:	d10f      	bne.n	1eb3e <__gesf2+0x4a>
   1eb1e:	2c00      	cmp	r4, #0
   1eb20:	d10d      	bne.n	1eb3e <__gesf2+0x4a>
   1eb22:	2000      	movs	r0, #0
   1eb24:	2d00      	cmp	r5, #0
   1eb26:	d009      	beq.n	1eb3c <__gesf2+0x48>
   1eb28:	e005      	b.n	1eb36 <__gesf2+0x42>
   1eb2a:	2800      	cmp	r0, #0
   1eb2c:	d101      	bne.n	1eb32 <__gesf2+0x3e>
   1eb2e:	2c00      	cmp	r4, #0
   1eb30:	d001      	beq.n	1eb36 <__gesf2+0x42>
   1eb32:	428b      	cmp	r3, r1
   1eb34:	d013      	beq.n	1eb5e <__gesf2+0x6a>
   1eb36:	4258      	negs	r0, r3
   1eb38:	2301      	movs	r3, #1
   1eb3a:	4318      	orrs	r0, r3
   1eb3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1eb3e:	2e00      	cmp	r6, #0
   1eb40:	d0f7      	beq.n	1eb32 <__gesf2+0x3e>
   1eb42:	4248      	negs	r0, r1
   1eb44:	4141      	adcs	r1, r0
   1eb46:	2001      	movs	r0, #1
   1eb48:	4249      	negs	r1, r1
   1eb4a:	4308      	orrs	r0, r1
   1eb4c:	e7f6      	b.n	1eb3c <__gesf2+0x48>
   1eb4e:	2d00      	cmp	r5, #0
   1eb50:	d0dd      	beq.n	1eb0e <__gesf2+0x1a>
   1eb52:	2002      	movs	r0, #2
   1eb54:	4240      	negs	r0, r0
   1eb56:	e7f1      	b.n	1eb3c <__gesf2+0x48>
   1eb58:	2c00      	cmp	r4, #0
   1eb5a:	d0da      	beq.n	1eb12 <__gesf2+0x1e>
   1eb5c:	e7f9      	b.n	1eb52 <__gesf2+0x5e>
   1eb5e:	4282      	cmp	r2, r0
   1eb60:	dce9      	bgt.n	1eb36 <__gesf2+0x42>
   1eb62:	db04      	blt.n	1eb6e <__gesf2+0x7a>
   1eb64:	42a5      	cmp	r5, r4
   1eb66:	d8e6      	bhi.n	1eb36 <__gesf2+0x42>
   1eb68:	2000      	movs	r0, #0
   1eb6a:	42a5      	cmp	r5, r4
   1eb6c:	d2e6      	bcs.n	1eb3c <__gesf2+0x48>
   1eb6e:	4258      	negs	r0, r3
   1eb70:	4143      	adcs	r3, r0
   1eb72:	2001      	movs	r0, #1
   1eb74:	425b      	negs	r3, r3
   1eb76:	4318      	orrs	r0, r3
   1eb78:	e7e0      	b.n	1eb3c <__gesf2+0x48>
   1eb7a:	46c0      	nop			; (mov r8, r8)

0001eb7c <__lesf2>:
   1eb7c:	0243      	lsls	r3, r0, #9
   1eb7e:	b5f0      	push	{r4, r5, r6, r7, lr}
   1eb80:	0042      	lsls	r2, r0, #1
   1eb82:	004c      	lsls	r4, r1, #1
   1eb84:	0a5e      	lsrs	r6, r3, #9
   1eb86:	0fc3      	lsrs	r3, r0, #31
   1eb88:	0248      	lsls	r0, r1, #9
   1eb8a:	0e12      	lsrs	r2, r2, #24
   1eb8c:	0a45      	lsrs	r5, r0, #9
   1eb8e:	0e24      	lsrs	r4, r4, #24
   1eb90:	0fc9      	lsrs	r1, r1, #31
   1eb92:	2aff      	cmp	r2, #255	; 0xff
   1eb94:	d017      	beq.n	1ebc6 <__lesf2+0x4a>
   1eb96:	2cff      	cmp	r4, #255	; 0xff
   1eb98:	d019      	beq.n	1ebce <__lesf2+0x52>
   1eb9a:	2a00      	cmp	r2, #0
   1eb9c:	d10b      	bne.n	1ebb6 <__lesf2+0x3a>
   1eb9e:	4270      	negs	r0, r6
   1eba0:	4170      	adcs	r0, r6
   1eba2:	2c00      	cmp	r4, #0
   1eba4:	d017      	beq.n	1ebd6 <__lesf2+0x5a>
   1eba6:	2800      	cmp	r0, #0
   1eba8:	d007      	beq.n	1ebba <__lesf2+0x3e>
   1ebaa:	4248      	negs	r0, r1
   1ebac:	4141      	adcs	r1, r0
   1ebae:	2001      	movs	r0, #1
   1ebb0:	4249      	negs	r1, r1
   1ebb2:	4308      	orrs	r0, r1
   1ebb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1ebb6:	2c00      	cmp	r4, #0
   1ebb8:	d013      	beq.n	1ebe2 <__lesf2+0x66>
   1ebba:	428b      	cmp	r3, r1
   1ebbc:	d014      	beq.n	1ebe8 <__lesf2+0x6c>
   1ebbe:	4258      	negs	r0, r3
   1ebc0:	2301      	movs	r3, #1
   1ebc2:	4318      	orrs	r0, r3
   1ebc4:	e7f6      	b.n	1ebb4 <__lesf2+0x38>
   1ebc6:	2002      	movs	r0, #2
   1ebc8:	2e00      	cmp	r6, #0
   1ebca:	d1f3      	bne.n	1ebb4 <__lesf2+0x38>
   1ebcc:	e7e3      	b.n	1eb96 <__lesf2+0x1a>
   1ebce:	2002      	movs	r0, #2
   1ebd0:	2d00      	cmp	r5, #0
   1ebd2:	d1ef      	bne.n	1ebb4 <__lesf2+0x38>
   1ebd4:	e7e1      	b.n	1eb9a <__lesf2+0x1e>
   1ebd6:	2d00      	cmp	r5, #0
   1ebd8:	d1e5      	bne.n	1eba6 <__lesf2+0x2a>
   1ebda:	2000      	movs	r0, #0
   1ebdc:	2e00      	cmp	r6, #0
   1ebde:	d0e9      	beq.n	1ebb4 <__lesf2+0x38>
   1ebe0:	e7ed      	b.n	1ebbe <__lesf2+0x42>
   1ebe2:	2d00      	cmp	r5, #0
   1ebe4:	d1e9      	bne.n	1ebba <__lesf2+0x3e>
   1ebe6:	e7ea      	b.n	1ebbe <__lesf2+0x42>
   1ebe8:	42a2      	cmp	r2, r4
   1ebea:	dce8      	bgt.n	1ebbe <__lesf2+0x42>
   1ebec:	db04      	blt.n	1ebf8 <__lesf2+0x7c>
   1ebee:	42ae      	cmp	r6, r5
   1ebf0:	d8e5      	bhi.n	1ebbe <__lesf2+0x42>
   1ebf2:	2000      	movs	r0, #0
   1ebf4:	42ae      	cmp	r6, r5
   1ebf6:	d2dd      	bcs.n	1ebb4 <__lesf2+0x38>
   1ebf8:	4258      	negs	r0, r3
   1ebfa:	4143      	adcs	r3, r0
   1ebfc:	2001      	movs	r0, #1
   1ebfe:	425b      	negs	r3, r3
   1ec00:	4318      	orrs	r0, r3
   1ec02:	e7d7      	b.n	1ebb4 <__lesf2+0x38>

0001ec04 <__libc_init_array>:
   1ec04:	4b0e      	ldr	r3, [pc, #56]	; (1ec40 <__libc_init_array+0x3c>)
   1ec06:	b570      	push	{r4, r5, r6, lr}
   1ec08:	2500      	movs	r5, #0
   1ec0a:	001e      	movs	r6, r3
   1ec0c:	4c0d      	ldr	r4, [pc, #52]	; (1ec44 <__libc_init_array+0x40>)
   1ec0e:	1ae4      	subs	r4, r4, r3
   1ec10:	10a4      	asrs	r4, r4, #2
   1ec12:	42a5      	cmp	r5, r4
   1ec14:	d004      	beq.n	1ec20 <__libc_init_array+0x1c>
   1ec16:	00ab      	lsls	r3, r5, #2
   1ec18:	58f3      	ldr	r3, [r6, r3]
   1ec1a:	4798      	blx	r3
   1ec1c:	3501      	adds	r5, #1
   1ec1e:	e7f8      	b.n	1ec12 <__libc_init_array+0xe>
   1ec20:	f003 fa8a 	bl	22138 <_init>
   1ec24:	4b08      	ldr	r3, [pc, #32]	; (1ec48 <__libc_init_array+0x44>)
   1ec26:	2500      	movs	r5, #0
   1ec28:	001e      	movs	r6, r3
   1ec2a:	4c08      	ldr	r4, [pc, #32]	; (1ec4c <__libc_init_array+0x48>)
   1ec2c:	1ae4      	subs	r4, r4, r3
   1ec2e:	10a4      	asrs	r4, r4, #2
   1ec30:	42a5      	cmp	r5, r4
   1ec32:	d004      	beq.n	1ec3e <__libc_init_array+0x3a>
   1ec34:	00ab      	lsls	r3, r5, #2
   1ec36:	58f3      	ldr	r3, [r6, r3]
   1ec38:	4798      	blx	r3
   1ec3a:	3501      	adds	r5, #1
   1ec3c:	e7f8      	b.n	1ec30 <__libc_init_array+0x2c>
   1ec3e:	bd70      	pop	{r4, r5, r6, pc}
   1ec40:	00022144 	.word	0x00022144
   1ec44:	00022144 	.word	0x00022144
   1ec48:	00022144 	.word	0x00022144
   1ec4c:	00022148 	.word	0x00022148

0001ec50 <localtime>:
   1ec50:	4b07      	ldr	r3, [pc, #28]	; (1ec70 <localtime+0x20>)
   1ec52:	b570      	push	{r4, r5, r6, lr}
   1ec54:	681c      	ldr	r4, [r3, #0]
   1ec56:	0005      	movs	r5, r0
   1ec58:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1ec5a:	2b00      	cmp	r3, #0
   1ec5c:	d103      	bne.n	1ec66 <localtime+0x16>
   1ec5e:	2024      	movs	r0, #36	; 0x24
   1ec60:	f000 f8f8 	bl	1ee54 <malloc>
   1ec64:	63e0      	str	r0, [r4, #60]	; 0x3c
   1ec66:	0028      	movs	r0, r5
   1ec68:	6be1      	ldr	r1, [r4, #60]	; 0x3c
   1ec6a:	f000 f803 	bl	1ec74 <localtime_r>
   1ec6e:	bd70      	pop	{r4, r5, r6, pc}
   1ec70:	20000474 	.word	0x20000474

0001ec74 <localtime_r>:
   1ec74:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1ec76:	000c      	movs	r4, r1
   1ec78:	0007      	movs	r7, r0
   1ec7a:	f000 fedf 	bl	1fa3c <__gettzinfo>
   1ec7e:	0021      	movs	r1, r4
   1ec80:	0005      	movs	r5, r0
   1ec82:	0038      	movs	r0, r7
   1ec84:	f000 fede 	bl	1fa44 <gmtime_r>
   1ec88:	4a6e      	ldr	r2, [pc, #440]	; (1ee44 <localtime_r+0x1d0>)
   1ec8a:	6943      	ldr	r3, [r0, #20]
   1ec8c:	0004      	movs	r4, r0
   1ec8e:	189e      	adds	r6, r3, r2
   1ec90:	07b3      	lsls	r3, r6, #30
   1ec92:	d106      	bne.n	1eca2 <localtime_r+0x2e>
   1ec94:	2164      	movs	r1, #100	; 0x64
   1ec96:	0030      	movs	r0, r6
   1ec98:	f7fe fd64 	bl	1d764 <__aeabi_idivmod>
   1ec9c:	2301      	movs	r3, #1
   1ec9e:	2900      	cmp	r1, #0
   1eca0:	d106      	bne.n	1ecb0 <localtime_r+0x3c>
   1eca2:	21c8      	movs	r1, #200	; 0xc8
   1eca4:	0030      	movs	r0, r6
   1eca6:	0049      	lsls	r1, r1, #1
   1eca8:	f7fe fd5c 	bl	1d764 <__aeabi_idivmod>
   1ecac:	424b      	negs	r3, r1
   1ecae:	414b      	adcs	r3, r1
   1ecb0:	2130      	movs	r1, #48	; 0x30
   1ecb2:	434b      	muls	r3, r1
   1ecb4:	4964      	ldr	r1, [pc, #400]	; (1ee48 <localtime_r+0x1d4>)
   1ecb6:	185b      	adds	r3, r3, r1
   1ecb8:	9301      	str	r3, [sp, #4]
   1ecba:	f000 fcd5 	bl	1f668 <__tz_lock>
   1ecbe:	f000 fcd5 	bl	1f66c <_tzset_unlocked>
   1ecc2:	4b62      	ldr	r3, [pc, #392]	; (1ee4c <localtime_r+0x1d8>)
   1ecc4:	681b      	ldr	r3, [r3, #0]
   1ecc6:	2b00      	cmp	r3, #0
   1ecc8:	d020      	beq.n	1ed0c <localtime_r+0x98>
   1ecca:	686b      	ldr	r3, [r5, #4]
   1eccc:	429e      	cmp	r6, r3
   1ecce:	d105      	bne.n	1ecdc <localtime_r+0x68>
   1ecd0:	6829      	ldr	r1, [r5, #0]
   1ecd2:	683a      	ldr	r2, [r7, #0]
   1ecd4:	69e8      	ldr	r0, [r5, #28]
   1ecd6:	2900      	cmp	r1, #0
   1ecd8:	d108      	bne.n	1ecec <localtime_r+0x78>
   1ecda:	e010      	b.n	1ecfe <localtime_r+0x8a>
   1ecdc:	0030      	movs	r0, r6
   1ecde:	f000 fc15 	bl	1f50c <__tzcalc_limits>
   1ece2:	2800      	cmp	r0, #0
   1ece4:	d1f4      	bne.n	1ecd0 <localtime_r+0x5c>
   1ece6:	2301      	movs	r3, #1
   1ece8:	425b      	negs	r3, r3
   1ecea:	e00f      	b.n	1ed0c <localtime_r+0x98>
   1ecec:	2300      	movs	r3, #0
   1ecee:	4282      	cmp	r2, r0
   1ecf0:	db0c      	blt.n	1ed0c <localtime_r+0x98>
   1ecf2:	6ba8      	ldr	r0, [r5, #56]	; 0x38
   1ecf4:	2101      	movs	r1, #1
   1ecf6:	4282      	cmp	r2, r0
   1ecf8:	db07      	blt.n	1ed0a <localtime_r+0x96>
   1ecfa:	0019      	movs	r1, r3
   1ecfc:	e005      	b.n	1ed0a <localtime_r+0x96>
   1ecfe:	2301      	movs	r3, #1
   1ed00:	4282      	cmp	r2, r0
   1ed02:	da03      	bge.n	1ed0c <localtime_r+0x98>
   1ed04:	6ba8      	ldr	r0, [r5, #56]	; 0x38
   1ed06:	4282      	cmp	r2, r0
   1ed08:	db00      	blt.n	1ed0c <localtime_r+0x98>
   1ed0a:	000b      	movs	r3, r1
   1ed0c:	6223      	str	r3, [r4, #32]
   1ed0e:	6a23      	ldr	r3, [r4, #32]
   1ed10:	2b01      	cmp	r3, #1
   1ed12:	d101      	bne.n	1ed18 <localtime_r+0xa4>
   1ed14:	6bef      	ldr	r7, [r5, #60]	; 0x3c
   1ed16:	e000      	b.n	1ed1a <localtime_r+0xa6>
   1ed18:	6a2f      	ldr	r7, [r5, #32]
   1ed1a:	21e1      	movs	r1, #225	; 0xe1
   1ed1c:	0038      	movs	r0, r7
   1ed1e:	0109      	lsls	r1, r1, #4
   1ed20:	f7fe fd20 	bl	1d764 <__aeabi_idivmod>
   1ed24:	000e      	movs	r6, r1
   1ed26:	213c      	movs	r1, #60	; 0x3c
   1ed28:	0030      	movs	r0, r6
   1ed2a:	f7fe fd1b 	bl	1d764 <__aeabi_idivmod>
   1ed2e:	6823      	ldr	r3, [r4, #0]
   1ed30:	0030      	movs	r0, r6
   1ed32:	1a5d      	subs	r5, r3, r1
   1ed34:	6025      	str	r5, [r4, #0]
   1ed36:	213c      	movs	r1, #60	; 0x3c
   1ed38:	f7fe fc2e 	bl	1d598 <__aeabi_idiv>
   1ed3c:	21e1      	movs	r1, #225	; 0xe1
   1ed3e:	6863      	ldr	r3, [r4, #4]
   1ed40:	0109      	lsls	r1, r1, #4
   1ed42:	1a1e      	subs	r6, r3, r0
   1ed44:	6066      	str	r6, [r4, #4]
   1ed46:	0038      	movs	r0, r7
   1ed48:	f7fe fc26 	bl	1d598 <__aeabi_idiv>
   1ed4c:	68a3      	ldr	r3, [r4, #8]
   1ed4e:	1a1b      	subs	r3, r3, r0
   1ed50:	60a3      	str	r3, [r4, #8]
   1ed52:	2d3b      	cmp	r5, #59	; 0x3b
   1ed54:	dd03      	ble.n	1ed5e <localtime_r+0xea>
   1ed56:	3601      	adds	r6, #1
   1ed58:	6066      	str	r6, [r4, #4]
   1ed5a:	3d3c      	subs	r5, #60	; 0x3c
   1ed5c:	e004      	b.n	1ed68 <localtime_r+0xf4>
   1ed5e:	2d00      	cmp	r5, #0
   1ed60:	da03      	bge.n	1ed6a <localtime_r+0xf6>
   1ed62:	3e01      	subs	r6, #1
   1ed64:	6066      	str	r6, [r4, #4]
   1ed66:	353c      	adds	r5, #60	; 0x3c
   1ed68:	6025      	str	r5, [r4, #0]
   1ed6a:	6862      	ldr	r2, [r4, #4]
   1ed6c:	2a3b      	cmp	r2, #59	; 0x3b
   1ed6e:	dd03      	ble.n	1ed78 <localtime_r+0x104>
   1ed70:	3301      	adds	r3, #1
   1ed72:	60a3      	str	r3, [r4, #8]
   1ed74:	3a3c      	subs	r2, #60	; 0x3c
   1ed76:	e004      	b.n	1ed82 <localtime_r+0x10e>
   1ed78:	2a00      	cmp	r2, #0
   1ed7a:	da03      	bge.n	1ed84 <localtime_r+0x110>
   1ed7c:	3b01      	subs	r3, #1
   1ed7e:	60a3      	str	r3, [r4, #8]
   1ed80:	323c      	adds	r2, #60	; 0x3c
   1ed82:	6062      	str	r2, [r4, #4]
   1ed84:	68a2      	ldr	r2, [r4, #8]
   1ed86:	2a17      	cmp	r2, #23
   1ed88:	dd21      	ble.n	1edce <localtime_r+0x15a>
   1ed8a:	69e3      	ldr	r3, [r4, #28]
   1ed8c:	3301      	adds	r3, #1
   1ed8e:	61e3      	str	r3, [r4, #28]
   1ed90:	69a3      	ldr	r3, [r4, #24]
   1ed92:	3301      	adds	r3, #1
   1ed94:	2b06      	cmp	r3, #6
   1ed96:	dd00      	ble.n	1ed9a <localtime_r+0x126>
   1ed98:	2300      	movs	r3, #0
   1ed9a:	61a3      	str	r3, [r4, #24]
   1ed9c:	3a18      	subs	r2, #24
   1ed9e:	68e3      	ldr	r3, [r4, #12]
   1eda0:	60a2      	str	r2, [r4, #8]
   1eda2:	6922      	ldr	r2, [r4, #16]
   1eda4:	3301      	adds	r3, #1
   1eda6:	9801      	ldr	r0, [sp, #4]
   1eda8:	60e3      	str	r3, [r4, #12]
   1edaa:	0091      	lsls	r1, r2, #2
   1edac:	5809      	ldr	r1, [r1, r0]
   1edae:	428b      	cmp	r3, r1
   1edb0:	dd43      	ble.n	1ee3a <localtime_r+0x1c6>
   1edb2:	1a5b      	subs	r3, r3, r1
   1edb4:	60e3      	str	r3, [r4, #12]
   1edb6:	1c53      	adds	r3, r2, #1
   1edb8:	2b0c      	cmp	r3, #12
   1edba:	d001      	beq.n	1edc0 <localtime_r+0x14c>
   1edbc:	6123      	str	r3, [r4, #16]
   1edbe:	e03c      	b.n	1ee3a <localtime_r+0x1c6>
   1edc0:	2200      	movs	r2, #0
   1edc2:	6963      	ldr	r3, [r4, #20]
   1edc4:	6122      	str	r2, [r4, #16]
   1edc6:	3301      	adds	r3, #1
   1edc8:	6163      	str	r3, [r4, #20]
   1edca:	61e2      	str	r2, [r4, #28]
   1edcc:	e035      	b.n	1ee3a <localtime_r+0x1c6>
   1edce:	2a00      	cmp	r2, #0
   1edd0:	da33      	bge.n	1ee3a <localtime_r+0x1c6>
   1edd2:	69e3      	ldr	r3, [r4, #28]
   1edd4:	3b01      	subs	r3, #1
   1edd6:	61e3      	str	r3, [r4, #28]
   1edd8:	69a3      	ldr	r3, [r4, #24]
   1edda:	3b01      	subs	r3, #1
   1eddc:	d500      	bpl.n	1ede0 <localtime_r+0x16c>
   1edde:	2306      	movs	r3, #6
   1ede0:	61a3      	str	r3, [r4, #24]
   1ede2:	68e3      	ldr	r3, [r4, #12]
   1ede4:	1e59      	subs	r1, r3, #1
   1ede6:	0013      	movs	r3, r2
   1ede8:	3318      	adds	r3, #24
   1edea:	60e1      	str	r1, [r4, #12]
   1edec:	60a3      	str	r3, [r4, #8]
   1edee:	2900      	cmp	r1, #0
   1edf0:	d123      	bne.n	1ee3a <localtime_r+0x1c6>
   1edf2:	6923      	ldr	r3, [r4, #16]
   1edf4:	3b01      	subs	r3, #1
   1edf6:	d401      	bmi.n	1edfc <localtime_r+0x188>
   1edf8:	6123      	str	r3, [r4, #16]
   1edfa:	e019      	b.n	1ee30 <localtime_r+0x1bc>
   1edfc:	230b      	movs	r3, #11
   1edfe:	6965      	ldr	r5, [r4, #20]
   1ee00:	4a13      	ldr	r2, [pc, #76]	; (1ee50 <localtime_r+0x1dc>)
   1ee02:	6123      	str	r3, [r4, #16]
   1ee04:	1e6b      	subs	r3, r5, #1
   1ee06:	6163      	str	r3, [r4, #20]
   1ee08:	18ad      	adds	r5, r5, r2
   1ee0a:	079b      	lsls	r3, r3, #30
   1ee0c:	d106      	bne.n	1ee1c <localtime_r+0x1a8>
   1ee0e:	2164      	movs	r1, #100	; 0x64
   1ee10:	0028      	movs	r0, r5
   1ee12:	f7fe fca7 	bl	1d764 <__aeabi_idivmod>
   1ee16:	2301      	movs	r3, #1
   1ee18:	2900      	cmp	r1, #0
   1ee1a:	d106      	bne.n	1ee2a <localtime_r+0x1b6>
   1ee1c:	21c8      	movs	r1, #200	; 0xc8
   1ee1e:	0028      	movs	r0, r5
   1ee20:	0049      	lsls	r1, r1, #1
   1ee22:	f7fe fc9f 	bl	1d764 <__aeabi_idivmod>
   1ee26:	424b      	negs	r3, r1
   1ee28:	414b      	adcs	r3, r1
   1ee2a:	336d      	adds	r3, #109	; 0x6d
   1ee2c:	33ff      	adds	r3, #255	; 0xff
   1ee2e:	61e3      	str	r3, [r4, #28]
   1ee30:	6923      	ldr	r3, [r4, #16]
   1ee32:	9a01      	ldr	r2, [sp, #4]
   1ee34:	009b      	lsls	r3, r3, #2
   1ee36:	589b      	ldr	r3, [r3, r2]
   1ee38:	60e3      	str	r3, [r4, #12]
   1ee3a:	f000 fc16 	bl	1f66a <__tz_unlock>
   1ee3e:	0020      	movs	r0, r4
   1ee40:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1ee42:	46c0      	nop			; (mov r8, r8)
   1ee44:	0000076c 	.word	0x0000076c
   1ee48:	00021ee0 	.word	0x00021ee0
   1ee4c:	200030b8 	.word	0x200030b8
   1ee50:	0000076b 	.word	0x0000076b

0001ee54 <malloc>:
   1ee54:	b510      	push	{r4, lr}
   1ee56:	4b03      	ldr	r3, [pc, #12]	; (1ee64 <malloc+0x10>)
   1ee58:	0001      	movs	r1, r0
   1ee5a:	6818      	ldr	r0, [r3, #0]
   1ee5c:	f000 fabc 	bl	1f3d8 <_malloc_r>
   1ee60:	bd10      	pop	{r4, pc}
   1ee62:	46c0      	nop			; (mov r8, r8)
   1ee64:	20000474 	.word	0x20000474

0001ee68 <free>:
   1ee68:	b510      	push	{r4, lr}
   1ee6a:	4b03      	ldr	r3, [pc, #12]	; (1ee78 <free+0x10>)
   1ee6c:	0001      	movs	r1, r0
   1ee6e:	6818      	ldr	r0, [r3, #0]
   1ee70:	f000 fa6c 	bl	1f34c <_free_r>
   1ee74:	bd10      	pop	{r4, pc}
   1ee76:	46c0      	nop			; (mov r8, r8)
   1ee78:	20000474 	.word	0x20000474

0001ee7c <memcmp>:
   1ee7c:	b530      	push	{r4, r5, lr}
   1ee7e:	2400      	movs	r4, #0
   1ee80:	42a2      	cmp	r2, r4
   1ee82:	d008      	beq.n	1ee96 <memcmp+0x1a>
   1ee84:	5d03      	ldrb	r3, [r0, r4]
   1ee86:	1c65      	adds	r5, r4, #1
   1ee88:	5d0c      	ldrb	r4, [r1, r4]
   1ee8a:	42a3      	cmp	r3, r4
   1ee8c:	d001      	beq.n	1ee92 <memcmp+0x16>
   1ee8e:	1b18      	subs	r0, r3, r4
   1ee90:	e002      	b.n	1ee98 <memcmp+0x1c>
   1ee92:	002c      	movs	r4, r5
   1ee94:	e7f4      	b.n	1ee80 <memcmp+0x4>
   1ee96:	2000      	movs	r0, #0
   1ee98:	bd30      	pop	{r4, r5, pc}

0001ee9a <memcpy>:
   1ee9a:	2300      	movs	r3, #0
   1ee9c:	b510      	push	{r4, lr}
   1ee9e:	429a      	cmp	r2, r3
   1eea0:	d003      	beq.n	1eeaa <memcpy+0x10>
   1eea2:	5ccc      	ldrb	r4, [r1, r3]
   1eea4:	54c4      	strb	r4, [r0, r3]
   1eea6:	3301      	adds	r3, #1
   1eea8:	e7f9      	b.n	1ee9e <memcpy+0x4>
   1eeaa:	bd10      	pop	{r4, pc}

0001eeac <memset>:
   1eeac:	0003      	movs	r3, r0
   1eeae:	1882      	adds	r2, r0, r2
   1eeb0:	4293      	cmp	r3, r2
   1eeb2:	d002      	beq.n	1eeba <memset+0xe>
   1eeb4:	7019      	strb	r1, [r3, #0]
   1eeb6:	3301      	adds	r3, #1
   1eeb8:	e7fa      	b.n	1eeb0 <memset+0x4>
   1eeba:	4770      	bx	lr

0001eebc <validate_structure>:
   1eebc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1eebe:	6801      	ldr	r1, [r0, #0]
   1eec0:	0004      	movs	r4, r0
   1eec2:	293b      	cmp	r1, #59	; 0x3b
   1eec4:	d910      	bls.n	1eee8 <validate_structure+0x2c>
   1eec6:	223c      	movs	r2, #60	; 0x3c
   1eec8:	4668      	mov	r0, sp
   1eeca:	f000 fd5b 	bl	1f984 <div>
   1eece:	6861      	ldr	r1, [r4, #4]
   1eed0:	9b00      	ldr	r3, [sp, #0]
   1eed2:	9a01      	ldr	r2, [sp, #4]
   1eed4:	185b      	adds	r3, r3, r1
   1eed6:	6063      	str	r3, [r4, #4]
   1eed8:	2a00      	cmp	r2, #0
   1eeda:	db01      	blt.n	1eee0 <validate_structure+0x24>
   1eedc:	6022      	str	r2, [r4, #0]
   1eede:	e003      	b.n	1eee8 <validate_structure+0x2c>
   1eee0:	323c      	adds	r2, #60	; 0x3c
   1eee2:	3b01      	subs	r3, #1
   1eee4:	6022      	str	r2, [r4, #0]
   1eee6:	6063      	str	r3, [r4, #4]
   1eee8:	6861      	ldr	r1, [r4, #4]
   1eeea:	293b      	cmp	r1, #59	; 0x3b
   1eeec:	d910      	bls.n	1ef10 <validate_structure+0x54>
   1eeee:	223c      	movs	r2, #60	; 0x3c
   1eef0:	4668      	mov	r0, sp
   1eef2:	f000 fd47 	bl	1f984 <div>
   1eef6:	68a3      	ldr	r3, [r4, #8]
   1eef8:	9900      	ldr	r1, [sp, #0]
   1eefa:	9a01      	ldr	r2, [sp, #4]
   1eefc:	185b      	adds	r3, r3, r1
   1eefe:	60a3      	str	r3, [r4, #8]
   1ef00:	2a00      	cmp	r2, #0
   1ef02:	db01      	blt.n	1ef08 <validate_structure+0x4c>
   1ef04:	6062      	str	r2, [r4, #4]
   1ef06:	e003      	b.n	1ef10 <validate_structure+0x54>
   1ef08:	323c      	adds	r2, #60	; 0x3c
   1ef0a:	3b01      	subs	r3, #1
   1ef0c:	6062      	str	r2, [r4, #4]
   1ef0e:	60a3      	str	r3, [r4, #8]
   1ef10:	68a1      	ldr	r1, [r4, #8]
   1ef12:	2917      	cmp	r1, #23
   1ef14:	d910      	bls.n	1ef38 <validate_structure+0x7c>
   1ef16:	2218      	movs	r2, #24
   1ef18:	4668      	mov	r0, sp
   1ef1a:	f000 fd33 	bl	1f984 <div>
   1ef1e:	68e3      	ldr	r3, [r4, #12]
   1ef20:	9900      	ldr	r1, [sp, #0]
   1ef22:	9a01      	ldr	r2, [sp, #4]
   1ef24:	185b      	adds	r3, r3, r1
   1ef26:	60e3      	str	r3, [r4, #12]
   1ef28:	2a00      	cmp	r2, #0
   1ef2a:	db01      	blt.n	1ef30 <validate_structure+0x74>
   1ef2c:	60a2      	str	r2, [r4, #8]
   1ef2e:	e003      	b.n	1ef38 <validate_structure+0x7c>
   1ef30:	3218      	adds	r2, #24
   1ef32:	3b01      	subs	r3, #1
   1ef34:	60a2      	str	r2, [r4, #8]
   1ef36:	60e3      	str	r3, [r4, #12]
   1ef38:	6921      	ldr	r1, [r4, #16]
   1ef3a:	290b      	cmp	r1, #11
   1ef3c:	d910      	bls.n	1ef60 <validate_structure+0xa4>
   1ef3e:	220c      	movs	r2, #12
   1ef40:	4668      	mov	r0, sp
   1ef42:	f000 fd1f 	bl	1f984 <div>
   1ef46:	6963      	ldr	r3, [r4, #20]
   1ef48:	9900      	ldr	r1, [sp, #0]
   1ef4a:	9a01      	ldr	r2, [sp, #4]
   1ef4c:	185b      	adds	r3, r3, r1
   1ef4e:	6163      	str	r3, [r4, #20]
   1ef50:	2a00      	cmp	r2, #0
   1ef52:	db01      	blt.n	1ef58 <validate_structure+0x9c>
   1ef54:	6122      	str	r2, [r4, #16]
   1ef56:	e003      	b.n	1ef60 <validate_structure+0xa4>
   1ef58:	320c      	adds	r2, #12
   1ef5a:	3b01      	subs	r3, #1
   1ef5c:	6122      	str	r2, [r4, #16]
   1ef5e:	6163      	str	r3, [r4, #20]
   1ef60:	6966      	ldr	r6, [r4, #20]
   1ef62:	251c      	movs	r5, #28
   1ef64:	07b3      	lsls	r3, r6, #30
   1ef66:	d10f      	bne.n	1ef88 <validate_structure+0xcc>
   1ef68:	2164      	movs	r1, #100	; 0x64
   1ef6a:	0030      	movs	r0, r6
   1ef6c:	f7fe fbfa 	bl	1d764 <__aeabi_idivmod>
   1ef70:	3501      	adds	r5, #1
   1ef72:	2900      	cmp	r1, #0
   1ef74:	d108      	bne.n	1ef88 <validate_structure+0xcc>
   1ef76:	4b33      	ldr	r3, [pc, #204]	; (1f044 <validate_structure+0x188>)
   1ef78:	3191      	adds	r1, #145	; 0x91
   1ef7a:	18f0      	adds	r0, r6, r3
   1ef7c:	31ff      	adds	r1, #255	; 0xff
   1ef7e:	f7fe fbf1 	bl	1d764 <__aeabi_idivmod>
   1ef82:	1e4b      	subs	r3, r1, #1
   1ef84:	4199      	sbcs	r1, r3
   1ef86:	1a6d      	subs	r5, r5, r1
   1ef88:	68e3      	ldr	r3, [r4, #12]
   1ef8a:	271d      	movs	r7, #29
   1ef8c:	2b00      	cmp	r3, #0
   1ef8e:	dc40      	bgt.n	1f012 <validate_structure+0x156>
   1ef90:	68e7      	ldr	r7, [r4, #12]
   1ef92:	2f00      	cmp	r7, #0
   1ef94:	dc54      	bgt.n	1f040 <validate_structure+0x184>
   1ef96:	6923      	ldr	r3, [r4, #16]
   1ef98:	3b01      	subs	r3, #1
   1ef9a:	6123      	str	r3, [r4, #16]
   1ef9c:	3301      	adds	r3, #1
   1ef9e:	d118      	bne.n	1efd2 <validate_structure+0x116>
   1efa0:	230b      	movs	r3, #11
   1efa2:	6966      	ldr	r6, [r4, #20]
   1efa4:	6123      	str	r3, [r4, #16]
   1efa6:	1e70      	subs	r0, r6, #1
   1efa8:	3b08      	subs	r3, #8
   1efaa:	6160      	str	r0, [r4, #20]
   1efac:	251c      	movs	r5, #28
   1efae:	4218      	tst	r0, r3
   1efb0:	d10f      	bne.n	1efd2 <validate_structure+0x116>
   1efb2:	2164      	movs	r1, #100	; 0x64
   1efb4:	f7fe fbd6 	bl	1d764 <__aeabi_idivmod>
   1efb8:	3501      	adds	r5, #1
   1efba:	2900      	cmp	r1, #0
   1efbc:	d109      	bne.n	1efd2 <validate_structure+0x116>
   1efbe:	4b22      	ldr	r3, [pc, #136]	; (1f048 <validate_structure+0x18c>)
   1efc0:	3191      	adds	r1, #145	; 0x91
   1efc2:	18f0      	adds	r0, r6, r3
   1efc4:	31ff      	adds	r1, #255	; 0xff
   1efc6:	f7fe fbcd 	bl	1d764 <__aeabi_idivmod>
   1efca:	231d      	movs	r3, #29
   1efcc:	1e4d      	subs	r5, r1, #1
   1efce:	41a9      	sbcs	r1, r5
   1efd0:	1a5d      	subs	r5, r3, r1
   1efd2:	6922      	ldr	r2, [r4, #16]
   1efd4:	002b      	movs	r3, r5
   1efd6:	2a01      	cmp	r2, #1
   1efd8:	d002      	beq.n	1efe0 <validate_structure+0x124>
   1efda:	4b1c      	ldr	r3, [pc, #112]	; (1f04c <validate_structure+0x190>)
   1efdc:	0092      	lsls	r2, r2, #2
   1efde:	58d3      	ldr	r3, [r2, r3]
   1efe0:	19df      	adds	r7, r3, r7
   1efe2:	60e7      	str	r7, [r4, #12]
   1efe4:	e7d4      	b.n	1ef90 <validate_structure+0xd4>
   1efe6:	6922      	ldr	r2, [r4, #16]
   1efe8:	68e0      	ldr	r0, [r4, #12]
   1efea:	2a01      	cmp	r2, #1
   1efec:	d113      	bne.n	1f016 <validate_structure+0x15a>
   1efee:	4285      	cmp	r5, r0
   1eff0:	da26      	bge.n	1f040 <validate_structure+0x184>
   1eff2:	002b      	movs	r3, r5
   1eff4:	1ac3      	subs	r3, r0, r3
   1eff6:	3201      	adds	r2, #1
   1eff8:	60e3      	str	r3, [r4, #12]
   1effa:	6122      	str	r2, [r4, #16]
   1effc:	2a0c      	cmp	r2, #12
   1effe:	d1f2      	bne.n	1efe6 <validate_structure+0x12a>
   1f000:	2300      	movs	r3, #0
   1f002:	6966      	ldr	r6, [r4, #20]
   1f004:	6123      	str	r3, [r4, #16]
   1f006:	1c70      	adds	r0, r6, #1
   1f008:	3303      	adds	r3, #3
   1f00a:	6160      	str	r0, [r4, #20]
   1f00c:	251c      	movs	r5, #28
   1f00e:	4218      	tst	r0, r3
   1f010:	d006      	beq.n	1f020 <validate_structure+0x164>
   1f012:	490e      	ldr	r1, [pc, #56]	; (1f04c <validate_structure+0x190>)
   1f014:	e7e7      	b.n	1efe6 <validate_structure+0x12a>
   1f016:	0093      	lsls	r3, r2, #2
   1f018:	585b      	ldr	r3, [r3, r1]
   1f01a:	4298      	cmp	r0, r3
   1f01c:	dcea      	bgt.n	1eff4 <validate_structure+0x138>
   1f01e:	e00f      	b.n	1f040 <validate_structure+0x184>
   1f020:	2164      	movs	r1, #100	; 0x64
   1f022:	f7fe fb9f 	bl	1d764 <__aeabi_idivmod>
   1f026:	3501      	adds	r5, #1
   1f028:	2900      	cmp	r1, #0
   1f02a:	d1f2      	bne.n	1f012 <validate_structure+0x156>
   1f02c:	4b08      	ldr	r3, [pc, #32]	; (1f050 <validate_structure+0x194>)
   1f02e:	3191      	adds	r1, #145	; 0x91
   1f030:	18f0      	adds	r0, r6, r3
   1f032:	31ff      	adds	r1, #255	; 0xff
   1f034:	f7fe fb96 	bl	1d764 <__aeabi_idivmod>
   1f038:	1e4d      	subs	r5, r1, #1
   1f03a:	41a9      	sbcs	r1, r5
   1f03c:	1a7d      	subs	r5, r7, r1
   1f03e:	e7e8      	b.n	1f012 <validate_structure+0x156>
   1f040:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1f042:	46c0      	nop			; (mov r8, r8)
   1f044:	0000076c 	.word	0x0000076c
   1f048:	0000076b 	.word	0x0000076b
   1f04c:	00021eb0 	.word	0x00021eb0
   1f050:	0000076d 	.word	0x0000076d

0001f054 <mktime>:
   1f054:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f056:	b085      	sub	sp, #20
   1f058:	0004      	movs	r4, r0
   1f05a:	f000 fcef 	bl	1fa3c <__gettzinfo>
   1f05e:	263c      	movs	r6, #60	; 0x3c
   1f060:	9002      	str	r0, [sp, #8]
   1f062:	0020      	movs	r0, r4
   1f064:	f7ff ff2a 	bl	1eebc <validate_structure>
   1f068:	6863      	ldr	r3, [r4, #4]
   1f06a:	68a2      	ldr	r2, [r4, #8]
   1f06c:	435e      	muls	r6, r3
   1f06e:	6823      	ldr	r3, [r4, #0]
   1f070:	49af      	ldr	r1, [pc, #700]	; (1f330 <mktime+0x2dc>)
   1f072:	18f6      	adds	r6, r6, r3
   1f074:	23e1      	movs	r3, #225	; 0xe1
   1f076:	011b      	lsls	r3, r3, #4
   1f078:	4353      	muls	r3, r2
   1f07a:	6922      	ldr	r2, [r4, #16]
   1f07c:	18f3      	adds	r3, r6, r3
   1f07e:	9303      	str	r3, [sp, #12]
   1f080:	0090      	lsls	r0, r2, #2
   1f082:	68e3      	ldr	r3, [r4, #12]
   1f084:	5840      	ldr	r0, [r0, r1]
   1f086:	3b01      	subs	r3, #1
   1f088:	181b      	adds	r3, r3, r0
   1f08a:	9300      	str	r3, [sp, #0]
   1f08c:	6965      	ldr	r5, [r4, #20]
   1f08e:	2a01      	cmp	r2, #1
   1f090:	dd12      	ble.n	1f0b8 <mktime+0x64>
   1f092:	07ab      	lsls	r3, r5, #30
   1f094:	d110      	bne.n	1f0b8 <mktime+0x64>
   1f096:	2164      	movs	r1, #100	; 0x64
   1f098:	0028      	movs	r0, r5
   1f09a:	f7fe fb63 	bl	1d764 <__aeabi_idivmod>
   1f09e:	2900      	cmp	r1, #0
   1f0a0:	d107      	bne.n	1f0b2 <mktime+0x5e>
   1f0a2:	4ba4      	ldr	r3, [pc, #656]	; (1f334 <mktime+0x2e0>)
   1f0a4:	3191      	adds	r1, #145	; 0x91
   1f0a6:	31ff      	adds	r1, #255	; 0xff
   1f0a8:	18e8      	adds	r0, r5, r3
   1f0aa:	f7fe fb5b 	bl	1d764 <__aeabi_idivmod>
   1f0ae:	2900      	cmp	r1, #0
   1f0b0:	d102      	bne.n	1f0b8 <mktime+0x64>
   1f0b2:	9b00      	ldr	r3, [sp, #0]
   1f0b4:	3301      	adds	r3, #1
   1f0b6:	9300      	str	r3, [sp, #0]
   1f0b8:	9b00      	ldr	r3, [sp, #0]
   1f0ba:	4a9f      	ldr	r2, [pc, #636]	; (1f338 <mktime+0x2e4>)
   1f0bc:	61e3      	str	r3, [r4, #28]
   1f0be:	4b9f      	ldr	r3, [pc, #636]	; (1f33c <mktime+0x2e8>)
   1f0c0:	9501      	str	r5, [sp, #4]
   1f0c2:	18eb      	adds	r3, r5, r3
   1f0c4:	4293      	cmp	r3, r2
   1f0c6:	d900      	bls.n	1f0ca <mktime+0x76>
   1f0c8:	e12e      	b.n	1f328 <mktime+0x2d4>
   1f0ca:	2d46      	cmp	r5, #70	; 0x46
   1f0cc:	dd21      	ble.n	1f112 <mktime+0xbe>
   1f0ce:	27b7      	movs	r7, #183	; 0xb7
   1f0d0:	2646      	movs	r6, #70	; 0x46
   1f0d2:	007f      	lsls	r7, r7, #1
   1f0d4:	2303      	movs	r3, #3
   1f0d6:	421e      	tst	r6, r3
   1f0d8:	d10f      	bne.n	1f0fa <mktime+0xa6>
   1f0da:	2164      	movs	r1, #100	; 0x64
   1f0dc:	0030      	movs	r0, r6
   1f0de:	f7fe fb41 	bl	1d764 <__aeabi_idivmod>
   1f0e2:	2900      	cmp	r1, #0
   1f0e4:	d10c      	bne.n	1f100 <mktime+0xac>
   1f0e6:	4b93      	ldr	r3, [pc, #588]	; (1f334 <mktime+0x2e0>)
   1f0e8:	3191      	adds	r1, #145	; 0x91
   1f0ea:	18f0      	adds	r0, r6, r3
   1f0ec:	31ff      	adds	r1, #255	; 0xff
   1f0ee:	f7fe fb39 	bl	1d764 <__aeabi_idivmod>
   1f0f2:	1e4b      	subs	r3, r1, #1
   1f0f4:	4199      	sbcs	r1, r3
   1f0f6:	1a79      	subs	r1, r7, r1
   1f0f8:	e004      	b.n	1f104 <mktime+0xb0>
   1f0fa:	216e      	movs	r1, #110	; 0x6e
   1f0fc:	31ff      	adds	r1, #255	; 0xff
   1f0fe:	e001      	b.n	1f104 <mktime+0xb0>
   1f100:	21b7      	movs	r1, #183	; 0xb7
   1f102:	0049      	lsls	r1, r1, #1
   1f104:	9b00      	ldr	r3, [sp, #0]
   1f106:	3601      	adds	r6, #1
   1f108:	185b      	adds	r3, r3, r1
   1f10a:	9300      	str	r3, [sp, #0]
   1f10c:	42b5      	cmp	r5, r6
   1f10e:	d1e1      	bne.n	1f0d4 <mktime+0x80>
   1f110:	e046      	b.n	1f1a0 <mktime+0x14c>
   1f112:	2d46      	cmp	r5, #70	; 0x46
   1f114:	d044      	beq.n	1f1a0 <mktime+0x14c>
   1f116:	27b7      	movs	r7, #183	; 0xb7
   1f118:	2645      	movs	r6, #69	; 0x45
   1f11a:	007f      	lsls	r7, r7, #1
   1f11c:	42ae      	cmp	r6, r5
   1f11e:	dd1c      	ble.n	1f15a <mktime+0x106>
   1f120:	2303      	movs	r3, #3
   1f122:	421e      	tst	r6, r3
   1f124:	d10f      	bne.n	1f146 <mktime+0xf2>
   1f126:	2164      	movs	r1, #100	; 0x64
   1f128:	0030      	movs	r0, r6
   1f12a:	f7fe fb1b 	bl	1d764 <__aeabi_idivmod>
   1f12e:	2900      	cmp	r1, #0
   1f130:	d10c      	bne.n	1f14c <mktime+0xf8>
   1f132:	4b80      	ldr	r3, [pc, #512]	; (1f334 <mktime+0x2e0>)
   1f134:	3191      	adds	r1, #145	; 0x91
   1f136:	18f0      	adds	r0, r6, r3
   1f138:	31ff      	adds	r1, #255	; 0xff
   1f13a:	f7fe fb13 	bl	1d764 <__aeabi_idivmod>
   1f13e:	1e4b      	subs	r3, r1, #1
   1f140:	4199      	sbcs	r1, r3
   1f142:	1a79      	subs	r1, r7, r1
   1f144:	e004      	b.n	1f150 <mktime+0xfc>
   1f146:	216e      	movs	r1, #110	; 0x6e
   1f148:	31ff      	adds	r1, #255	; 0xff
   1f14a:	e001      	b.n	1f150 <mktime+0xfc>
   1f14c:	21b7      	movs	r1, #183	; 0xb7
   1f14e:	0049      	lsls	r1, r1, #1
   1f150:	9b00      	ldr	r3, [sp, #0]
   1f152:	3e01      	subs	r6, #1
   1f154:	1a5b      	subs	r3, r3, r1
   1f156:	9300      	str	r3, [sp, #0]
   1f158:	e7e0      	b.n	1f11c <mktime+0xc8>
   1f15a:	2d45      	cmp	r5, #69	; 0x45
   1f15c:	dd01      	ble.n	1f162 <mktime+0x10e>
   1f15e:	2345      	movs	r3, #69	; 0x45
   1f160:	9301      	str	r3, [sp, #4]
   1f162:	2303      	movs	r3, #3
   1f164:	9a01      	ldr	r2, [sp, #4]
   1f166:	421a      	tst	r2, r3
   1f168:	d112      	bne.n	1f190 <mktime+0x13c>
   1f16a:	2164      	movs	r1, #100	; 0x64
   1f16c:	0010      	movs	r0, r2
   1f16e:	f7fe faf9 	bl	1d764 <__aeabi_idivmod>
   1f172:	2900      	cmp	r1, #0
   1f174:	d10f      	bne.n	1f196 <mktime+0x142>
   1f176:	9b01      	ldr	r3, [sp, #4]
   1f178:	4a6e      	ldr	r2, [pc, #440]	; (1f334 <mktime+0x2e0>)
   1f17a:	3191      	adds	r1, #145	; 0x91
   1f17c:	1898      	adds	r0, r3, r2
   1f17e:	31ff      	adds	r1, #255	; 0xff
   1f180:	f7fe faf0 	bl	1d764 <__aeabi_idivmod>
   1f184:	1e4b      	subs	r3, r1, #1
   1f186:	4199      	sbcs	r1, r3
   1f188:	23b7      	movs	r3, #183	; 0xb7
   1f18a:	005b      	lsls	r3, r3, #1
   1f18c:	1a59      	subs	r1, r3, r1
   1f18e:	e004      	b.n	1f19a <mktime+0x146>
   1f190:	216e      	movs	r1, #110	; 0x6e
   1f192:	31ff      	adds	r1, #255	; 0xff
   1f194:	e001      	b.n	1f19a <mktime+0x146>
   1f196:	21b7      	movs	r1, #183	; 0xb7
   1f198:	0049      	lsls	r1, r1, #1
   1f19a:	9b00      	ldr	r3, [sp, #0]
   1f19c:	1a5b      	subs	r3, r3, r1
   1f19e:	9300      	str	r3, [sp, #0]
   1f1a0:	9b00      	ldr	r3, [sp, #0]
   1f1a2:	4e67      	ldr	r6, [pc, #412]	; (1f340 <mktime+0x2ec>)
   1f1a4:	435e      	muls	r6, r3
   1f1a6:	9b03      	ldr	r3, [sp, #12]
   1f1a8:	18f6      	adds	r6, r6, r3
   1f1aa:	f000 fa5d 	bl	1f668 <__tz_lock>
   1f1ae:	f000 fa5d 	bl	1f66c <_tzset_unlocked>
   1f1b2:	4b64      	ldr	r3, [pc, #400]	; (1f344 <mktime+0x2f0>)
   1f1b4:	681d      	ldr	r5, [r3, #0]
   1f1b6:	2d00      	cmp	r5, #0
   1f1b8:	d100      	bne.n	1f1bc <mktime+0x168>
   1f1ba:	e0a4      	b.n	1f306 <mktime+0x2b2>
   1f1bc:	6963      	ldr	r3, [r4, #20]
   1f1be:	4a5d      	ldr	r2, [pc, #372]	; (1f334 <mktime+0x2e0>)
   1f1c0:	6a27      	ldr	r7, [r4, #32]
   1f1c2:	1898      	adds	r0, r3, r2
   1f1c4:	2f00      	cmp	r7, #0
   1f1c6:	dd00      	ble.n	1f1ca <mktime+0x176>
   1f1c8:	2701      	movs	r7, #1
   1f1ca:	9b02      	ldr	r3, [sp, #8]
   1f1cc:	685b      	ldr	r3, [r3, #4]
   1f1ce:	9303      	str	r3, [sp, #12]
   1f1d0:	4298      	cmp	r0, r3
   1f1d2:	d10b      	bne.n	1f1ec <mktime+0x198>
   1f1d4:	9b02      	ldr	r3, [sp, #8]
   1f1d6:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
   1f1d8:	69db      	ldr	r3, [r3, #28]
   1f1da:	9303      	str	r3, [sp, #12]
   1f1dc:	1a1a      	subs	r2, r3, r0
   1f1de:	9b02      	ldr	r3, [sp, #8]
   1f1e0:	6b99      	ldr	r1, [r3, #56]	; 0x38
   1f1e2:	6a1b      	ldr	r3, [r3, #32]
   1f1e4:	1acd      	subs	r5, r1, r3
   1f1e6:	42ae      	cmp	r6, r5
   1f1e8:	da05      	bge.n	1f1f6 <mktime+0x1a2>
   1f1ea:	e007      	b.n	1f1fc <mktime+0x1a8>
   1f1ec:	f000 f98e 	bl	1f50c <__tzcalc_limits>
   1f1f0:	2800      	cmp	r0, #0
   1f1f2:	d1ef      	bne.n	1f1d4 <mktime+0x180>
   1f1f4:	e07c      	b.n	1f2f0 <mktime+0x29c>
   1f1f6:	1a09      	subs	r1, r1, r0
   1f1f8:	428e      	cmp	r6, r1
   1f1fa:	db79      	blt.n	1f2f0 <mktime+0x29c>
   1f1fc:	9902      	ldr	r1, [sp, #8]
   1f1fe:	6809      	ldr	r1, [r1, #0]
   1f200:	2900      	cmp	r1, #0
   1f202:	d006      	beq.n	1f212 <mktime+0x1be>
   1f204:	4296      	cmp	r6, r2
   1f206:	db7b      	blt.n	1f300 <mktime+0x2ac>
   1f208:	2201      	movs	r2, #1
   1f20a:	42ae      	cmp	r6, r5
   1f20c:	db07      	blt.n	1f21e <mktime+0x1ca>
   1f20e:	2200      	movs	r2, #0
   1f210:	e005      	b.n	1f21e <mktime+0x1ca>
   1f212:	4296      	cmp	r6, r2
   1f214:	da07      	bge.n	1f226 <mktime+0x1d2>
   1f216:	2201      	movs	r2, #1
   1f218:	42ae      	cmp	r6, r5
   1f21a:	db00      	blt.n	1f21e <mktime+0x1ca>
   1f21c:	000a      	movs	r2, r1
   1f21e:	0015      	movs	r5, r2
   1f220:	2f00      	cmp	r7, #0
   1f222:	da03      	bge.n	1f22c <mktime+0x1d8>
   1f224:	e065      	b.n	1f2f2 <mktime+0x29e>
   1f226:	2501      	movs	r5, #1
   1f228:	2f00      	cmp	r7, #0
   1f22a:	db64      	blt.n	1f2f6 <mktime+0x2a2>
   1f22c:	406f      	eors	r7, r5
   1f22e:	2f01      	cmp	r7, #1
   1f230:	d15f      	bne.n	1f2f2 <mktime+0x29e>
   1f232:	1a1b      	subs	r3, r3, r0
   1f234:	2d00      	cmp	r5, #0
   1f236:	d100      	bne.n	1f23a <mktime+0x1e6>
   1f238:	425b      	negs	r3, r3
   1f23a:	6822      	ldr	r2, [r4, #0]
   1f23c:	0020      	movs	r0, r4
   1f23e:	18d2      	adds	r2, r2, r3
   1f240:	6022      	str	r2, [r4, #0]
   1f242:	18f6      	adds	r6, r6, r3
   1f244:	68e7      	ldr	r7, [r4, #12]
   1f246:	f7ff fe39 	bl	1eebc <validate_structure>
   1f24a:	68e3      	ldr	r3, [r4, #12]
   1f24c:	1bdf      	subs	r7, r3, r7
   1f24e:	d050      	beq.n	1f2f2 <mktime+0x29e>
   1f250:	2f01      	cmp	r7, #1
   1f252:	dc03      	bgt.n	1f25c <mktime+0x208>
   1f254:	1c7b      	adds	r3, r7, #1
   1f256:	da03      	bge.n	1f260 <mktime+0x20c>
   1f258:	2701      	movs	r7, #1
   1f25a:	e001      	b.n	1f260 <mktime+0x20c>
   1f25c:	2701      	movs	r7, #1
   1f25e:	427f      	negs	r7, r7
   1f260:	9b00      	ldr	r3, [sp, #0]
   1f262:	69e2      	ldr	r2, [r4, #28]
   1f264:	19db      	adds	r3, r3, r7
   1f266:	9300      	str	r3, [sp, #0]
   1f268:	2303      	movs	r3, #3
   1f26a:	18bf      	adds	r7, r7, r2
   1f26c:	d51e      	bpl.n	1f2ac <mktime+0x258>
   1f26e:	9a01      	ldr	r2, [sp, #4]
   1f270:	1e50      	subs	r0, r2, #1
   1f272:	4218      	tst	r0, r3
   1f274:	d113      	bne.n	1f29e <mktime+0x24a>
   1f276:	2164      	movs	r1, #100	; 0x64
   1f278:	f7fe fa74 	bl	1d764 <__aeabi_idivmod>
   1f27c:	2900      	cmp	r1, #0
   1f27e:	d111      	bne.n	1f2a4 <mktime+0x250>
   1f280:	4a31      	ldr	r2, [pc, #196]	; (1f348 <mktime+0x2f4>)
   1f282:	9b01      	ldr	r3, [sp, #4]
   1f284:	4694      	mov	ip, r2
   1f286:	3191      	adds	r1, #145	; 0x91
   1f288:	4463      	add	r3, ip
   1f28a:	0018      	movs	r0, r3
   1f28c:	31ff      	adds	r1, #255	; 0xff
   1f28e:	f7fe fa69 	bl	1d764 <__aeabi_idivmod>
   1f292:	1e4b      	subs	r3, r1, #1
   1f294:	4199      	sbcs	r1, r3
   1f296:	236e      	movs	r3, #110	; 0x6e
   1f298:	33ff      	adds	r3, #255	; 0xff
   1f29a:	1a59      	subs	r1, r3, r1
   1f29c:	e004      	b.n	1f2a8 <mktime+0x254>
   1f29e:	21b6      	movs	r1, #182	; 0xb6
   1f2a0:	0049      	lsls	r1, r1, #1
   1f2a2:	e001      	b.n	1f2a8 <mktime+0x254>
   1f2a4:	216e      	movs	r1, #110	; 0x6e
   1f2a6:	31ff      	adds	r1, #255	; 0xff
   1f2a8:	61e1      	str	r1, [r4, #28]
   1f2aa:	e022      	b.n	1f2f2 <mktime+0x29e>
   1f2ac:	9a01      	ldr	r2, [sp, #4]
   1f2ae:	421a      	tst	r2, r3
   1f2b0:	d114      	bne.n	1f2dc <mktime+0x288>
   1f2b2:	2164      	movs	r1, #100	; 0x64
   1f2b4:	0010      	movs	r0, r2
   1f2b6:	f7fe fa55 	bl	1d764 <__aeabi_idivmod>
   1f2ba:	2900      	cmp	r1, #0
   1f2bc:	d111      	bne.n	1f2e2 <mktime+0x28e>
   1f2be:	4a1d      	ldr	r2, [pc, #116]	; (1f334 <mktime+0x2e0>)
   1f2c0:	9b01      	ldr	r3, [sp, #4]
   1f2c2:	4694      	mov	ip, r2
   1f2c4:	3191      	adds	r1, #145	; 0x91
   1f2c6:	4463      	add	r3, ip
   1f2c8:	0018      	movs	r0, r3
   1f2ca:	31ff      	adds	r1, #255	; 0xff
   1f2cc:	f7fe fa4a 	bl	1d764 <__aeabi_idivmod>
   1f2d0:	1e4b      	subs	r3, r1, #1
   1f2d2:	4199      	sbcs	r1, r3
   1f2d4:	23b7      	movs	r3, #183	; 0xb7
   1f2d6:	005b      	lsls	r3, r3, #1
   1f2d8:	1a59      	subs	r1, r3, r1
   1f2da:	e004      	b.n	1f2e6 <mktime+0x292>
   1f2dc:	216e      	movs	r1, #110	; 0x6e
   1f2de:	31ff      	adds	r1, #255	; 0xff
   1f2e0:	e001      	b.n	1f2e6 <mktime+0x292>
   1f2e2:	21b7      	movs	r1, #183	; 0xb7
   1f2e4:	0049      	lsls	r1, r1, #1
   1f2e6:	42b9      	cmp	r1, r7
   1f2e8:	dc00      	bgt.n	1f2ec <mktime+0x298>
   1f2ea:	1a7f      	subs	r7, r7, r1
   1f2ec:	61e7      	str	r7, [r4, #28]
   1f2ee:	e000      	b.n	1f2f2 <mktime+0x29e>
   1f2f0:	003d      	movs	r5, r7
   1f2f2:	2d01      	cmp	r5, #1
   1f2f4:	d107      	bne.n	1f306 <mktime+0x2b2>
   1f2f6:	9b02      	ldr	r3, [sp, #8]
   1f2f8:	2501      	movs	r5, #1
   1f2fa:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
   1f2fc:	1836      	adds	r6, r6, r0
   1f2fe:	e005      	b.n	1f30c <mktime+0x2b8>
   1f300:	2500      	movs	r5, #0
   1f302:	2f00      	cmp	r7, #0
   1f304:	da92      	bge.n	1f22c <mktime+0x1d8>
   1f306:	9b02      	ldr	r3, [sp, #8]
   1f308:	6a18      	ldr	r0, [r3, #32]
   1f30a:	1836      	adds	r6, r6, r0
   1f30c:	f000 f9ad 	bl	1f66a <__tz_unlock>
   1f310:	9800      	ldr	r0, [sp, #0]
   1f312:	6225      	str	r5, [r4, #32]
   1f314:	3004      	adds	r0, #4
   1f316:	2107      	movs	r1, #7
   1f318:	f7fe fa24 	bl	1d764 <__aeabi_idivmod>
   1f31c:	2900      	cmp	r1, #0
   1f31e:	da00      	bge.n	1f322 <mktime+0x2ce>
   1f320:	3107      	adds	r1, #7
   1f322:	61a1      	str	r1, [r4, #24]
   1f324:	0030      	movs	r0, r6
   1f326:	e001      	b.n	1f32c <mktime+0x2d8>
   1f328:	2001      	movs	r0, #1
   1f32a:	4240      	negs	r0, r0
   1f32c:	b005      	add	sp, #20
   1f32e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f330:	00021e80 	.word	0x00021e80
   1f334:	0000076c 	.word	0x0000076c
   1f338:	00004e20 	.word	0x00004e20
   1f33c:	00002710 	.word	0x00002710
   1f340:	00015180 	.word	0x00015180
   1f344:	200030b8 	.word	0x200030b8
   1f348:	0000076b 	.word	0x0000076b

0001f34c <_free_r>:
   1f34c:	b530      	push	{r4, r5, lr}
   1f34e:	2900      	cmp	r1, #0
   1f350:	d03e      	beq.n	1f3d0 <_free_r+0x84>
   1f352:	3904      	subs	r1, #4
   1f354:	680b      	ldr	r3, [r1, #0]
   1f356:	2b00      	cmp	r3, #0
   1f358:	da00      	bge.n	1f35c <_free_r+0x10>
   1f35a:	18c9      	adds	r1, r1, r3
   1f35c:	4a1d      	ldr	r2, [pc, #116]	; (1f3d4 <_free_r+0x88>)
   1f35e:	6813      	ldr	r3, [r2, #0]
   1f360:	0014      	movs	r4, r2
   1f362:	2b00      	cmp	r3, #0
   1f364:	d102      	bne.n	1f36c <_free_r+0x20>
   1f366:	604b      	str	r3, [r1, #4]
   1f368:	6011      	str	r1, [r2, #0]
   1f36a:	e031      	b.n	1f3d0 <_free_r+0x84>
   1f36c:	428b      	cmp	r3, r1
   1f36e:	d90d      	bls.n	1f38c <_free_r+0x40>
   1f370:	680a      	ldr	r2, [r1, #0]
   1f372:	1888      	adds	r0, r1, r2
   1f374:	4283      	cmp	r3, r0
   1f376:	d103      	bne.n	1f380 <_free_r+0x34>
   1f378:	6818      	ldr	r0, [r3, #0]
   1f37a:	685b      	ldr	r3, [r3, #4]
   1f37c:	1882      	adds	r2, r0, r2
   1f37e:	600a      	str	r2, [r1, #0]
   1f380:	604b      	str	r3, [r1, #4]
   1f382:	6021      	str	r1, [r4, #0]
   1f384:	e024      	b.n	1f3d0 <_free_r+0x84>
   1f386:	428a      	cmp	r2, r1
   1f388:	d803      	bhi.n	1f392 <_free_r+0x46>
   1f38a:	0013      	movs	r3, r2
   1f38c:	685a      	ldr	r2, [r3, #4]
   1f38e:	2a00      	cmp	r2, #0
   1f390:	d1f9      	bne.n	1f386 <_free_r+0x3a>
   1f392:	681d      	ldr	r5, [r3, #0]
   1f394:	195c      	adds	r4, r3, r5
   1f396:	428c      	cmp	r4, r1
   1f398:	d10b      	bne.n	1f3b2 <_free_r+0x66>
   1f39a:	6809      	ldr	r1, [r1, #0]
   1f39c:	1869      	adds	r1, r5, r1
   1f39e:	1858      	adds	r0, r3, r1
   1f3a0:	6019      	str	r1, [r3, #0]
   1f3a2:	4282      	cmp	r2, r0
   1f3a4:	d114      	bne.n	1f3d0 <_free_r+0x84>
   1f3a6:	6810      	ldr	r0, [r2, #0]
   1f3a8:	6852      	ldr	r2, [r2, #4]
   1f3aa:	1841      	adds	r1, r0, r1
   1f3ac:	6019      	str	r1, [r3, #0]
   1f3ae:	605a      	str	r2, [r3, #4]
   1f3b0:	e00e      	b.n	1f3d0 <_free_r+0x84>
   1f3b2:	428c      	cmp	r4, r1
   1f3b4:	d902      	bls.n	1f3bc <_free_r+0x70>
   1f3b6:	230c      	movs	r3, #12
   1f3b8:	6003      	str	r3, [r0, #0]
   1f3ba:	e009      	b.n	1f3d0 <_free_r+0x84>
   1f3bc:	6808      	ldr	r0, [r1, #0]
   1f3be:	180c      	adds	r4, r1, r0
   1f3c0:	42a2      	cmp	r2, r4
   1f3c2:	d103      	bne.n	1f3cc <_free_r+0x80>
   1f3c4:	6814      	ldr	r4, [r2, #0]
   1f3c6:	6852      	ldr	r2, [r2, #4]
   1f3c8:	1820      	adds	r0, r4, r0
   1f3ca:	6008      	str	r0, [r1, #0]
   1f3cc:	604a      	str	r2, [r1, #4]
   1f3ce:	6059      	str	r1, [r3, #4]
   1f3d0:	bd30      	pop	{r4, r5, pc}
   1f3d2:	46c0      	nop			; (mov r8, r8)
   1f3d4:	20003098 	.word	0x20003098

0001f3d8 <_malloc_r>:
   1f3d8:	2303      	movs	r3, #3
   1f3da:	b570      	push	{r4, r5, r6, lr}
   1f3dc:	1ccd      	adds	r5, r1, #3
   1f3de:	439d      	bics	r5, r3
   1f3e0:	3508      	adds	r5, #8
   1f3e2:	0006      	movs	r6, r0
   1f3e4:	2d0c      	cmp	r5, #12
   1f3e6:	d201      	bcs.n	1f3ec <_malloc_r+0x14>
   1f3e8:	250c      	movs	r5, #12
   1f3ea:	e005      	b.n	1f3f8 <_malloc_r+0x20>
   1f3ec:	2d00      	cmp	r5, #0
   1f3ee:	da03      	bge.n	1f3f8 <_malloc_r+0x20>
   1f3f0:	230c      	movs	r3, #12
   1f3f2:	2000      	movs	r0, #0
   1f3f4:	6033      	str	r3, [r6, #0]
   1f3f6:	e040      	b.n	1f47a <_malloc_r+0xa2>
   1f3f8:	42a9      	cmp	r1, r5
   1f3fa:	d8f9      	bhi.n	1f3f0 <_malloc_r+0x18>
   1f3fc:	4b1f      	ldr	r3, [pc, #124]	; (1f47c <_malloc_r+0xa4>)
   1f3fe:	681c      	ldr	r4, [r3, #0]
   1f400:	001a      	movs	r2, r3
   1f402:	0021      	movs	r1, r4
   1f404:	2900      	cmp	r1, #0
   1f406:	d013      	beq.n	1f430 <_malloc_r+0x58>
   1f408:	680b      	ldr	r3, [r1, #0]
   1f40a:	1b5b      	subs	r3, r3, r5
   1f40c:	d40d      	bmi.n	1f42a <_malloc_r+0x52>
   1f40e:	2b0b      	cmp	r3, #11
   1f410:	d902      	bls.n	1f418 <_malloc_r+0x40>
   1f412:	600b      	str	r3, [r1, #0]
   1f414:	18cc      	adds	r4, r1, r3
   1f416:	e01e      	b.n	1f456 <_malloc_r+0x7e>
   1f418:	428c      	cmp	r4, r1
   1f41a:	d102      	bne.n	1f422 <_malloc_r+0x4a>
   1f41c:	6863      	ldr	r3, [r4, #4]
   1f41e:	6013      	str	r3, [r2, #0]
   1f420:	e01a      	b.n	1f458 <_malloc_r+0x80>
   1f422:	684b      	ldr	r3, [r1, #4]
   1f424:	6063      	str	r3, [r4, #4]
   1f426:	000c      	movs	r4, r1
   1f428:	e016      	b.n	1f458 <_malloc_r+0x80>
   1f42a:	000c      	movs	r4, r1
   1f42c:	6849      	ldr	r1, [r1, #4]
   1f42e:	e7e9      	b.n	1f404 <_malloc_r+0x2c>
   1f430:	4c13      	ldr	r4, [pc, #76]	; (1f480 <_malloc_r+0xa8>)
   1f432:	6823      	ldr	r3, [r4, #0]
   1f434:	2b00      	cmp	r3, #0
   1f436:	d103      	bne.n	1f440 <_malloc_r+0x68>
   1f438:	0030      	movs	r0, r6
   1f43a:	f000 f823 	bl	1f484 <_sbrk_r>
   1f43e:	6020      	str	r0, [r4, #0]
   1f440:	0029      	movs	r1, r5
   1f442:	0030      	movs	r0, r6
   1f444:	f000 f81e 	bl	1f484 <_sbrk_r>
   1f448:	1c43      	adds	r3, r0, #1
   1f44a:	d0d1      	beq.n	1f3f0 <_malloc_r+0x18>
   1f44c:	2303      	movs	r3, #3
   1f44e:	1cc4      	adds	r4, r0, #3
   1f450:	439c      	bics	r4, r3
   1f452:	42a0      	cmp	r0, r4
   1f454:	d10a      	bne.n	1f46c <_malloc_r+0x94>
   1f456:	6025      	str	r5, [r4, #0]
   1f458:	0020      	movs	r0, r4
   1f45a:	2207      	movs	r2, #7
   1f45c:	300b      	adds	r0, #11
   1f45e:	1d23      	adds	r3, r4, #4
   1f460:	4390      	bics	r0, r2
   1f462:	1ac3      	subs	r3, r0, r3
   1f464:	d009      	beq.n	1f47a <_malloc_r+0xa2>
   1f466:	425a      	negs	r2, r3
   1f468:	50e2      	str	r2, [r4, r3]
   1f46a:	e006      	b.n	1f47a <_malloc_r+0xa2>
   1f46c:	1a21      	subs	r1, r4, r0
   1f46e:	0030      	movs	r0, r6
   1f470:	f000 f808 	bl	1f484 <_sbrk_r>
   1f474:	1c43      	adds	r3, r0, #1
   1f476:	d1ee      	bne.n	1f456 <_malloc_r+0x7e>
   1f478:	e7ba      	b.n	1f3f0 <_malloc_r+0x18>
   1f47a:	bd70      	pop	{r4, r5, r6, pc}
   1f47c:	20003098 	.word	0x20003098
   1f480:	20003094 	.word	0x20003094

0001f484 <_sbrk_r>:
   1f484:	2300      	movs	r3, #0
   1f486:	b570      	push	{r4, r5, r6, lr}
   1f488:	4c06      	ldr	r4, [pc, #24]	; (1f4a4 <_sbrk_r+0x20>)
   1f48a:	0005      	movs	r5, r0
   1f48c:	0008      	movs	r0, r1
   1f48e:	6023      	str	r3, [r4, #0]
   1f490:	f7f7 fcf6 	bl	16e80 <_sbrk>
   1f494:	1c43      	adds	r3, r0, #1
   1f496:	d103      	bne.n	1f4a0 <_sbrk_r+0x1c>
   1f498:	6823      	ldr	r3, [r4, #0]
   1f49a:	2b00      	cmp	r3, #0
   1f49c:	d000      	beq.n	1f4a0 <_sbrk_r+0x1c>
   1f49e:	602b      	str	r3, [r5, #0]
   1f4a0:	bd70      	pop	{r4, r5, r6, pc}
   1f4a2:	46c0      	nop			; (mov r8, r8)
   1f4a4:	20004dec 	.word	0x20004dec

0001f4a8 <siprintf>:
   1f4a8:	b40e      	push	{r1, r2, r3}
   1f4aa:	b510      	push	{r4, lr}
   1f4ac:	b09d      	sub	sp, #116	; 0x74
   1f4ae:	a902      	add	r1, sp, #8
   1f4b0:	9002      	str	r0, [sp, #8]
   1f4b2:	6108      	str	r0, [r1, #16]
   1f4b4:	480b      	ldr	r0, [pc, #44]	; (1f4e4 <siprintf+0x3c>)
   1f4b6:	2482      	movs	r4, #130	; 0x82
   1f4b8:	6088      	str	r0, [r1, #8]
   1f4ba:	6148      	str	r0, [r1, #20]
   1f4bc:	2001      	movs	r0, #1
   1f4be:	4240      	negs	r0, r0
   1f4c0:	ab1f      	add	r3, sp, #124	; 0x7c
   1f4c2:	81c8      	strh	r0, [r1, #14]
   1f4c4:	4808      	ldr	r0, [pc, #32]	; (1f4e8 <siprintf+0x40>)
   1f4c6:	cb04      	ldmia	r3!, {r2}
   1f4c8:	00a4      	lsls	r4, r4, #2
   1f4ca:	6800      	ldr	r0, [r0, #0]
   1f4cc:	9301      	str	r3, [sp, #4]
   1f4ce:	818c      	strh	r4, [r1, #12]
   1f4d0:	f000 fbd6 	bl	1fc80 <_svfiprintf_r>
   1f4d4:	2300      	movs	r3, #0
   1f4d6:	9a02      	ldr	r2, [sp, #8]
   1f4d8:	7013      	strb	r3, [r2, #0]
   1f4da:	b01d      	add	sp, #116	; 0x74
   1f4dc:	bc10      	pop	{r4}
   1f4de:	bc08      	pop	{r3}
   1f4e0:	b003      	add	sp, #12
   1f4e2:	4718      	bx	r3
   1f4e4:	7fffffff 	.word	0x7fffffff
   1f4e8:	20000474 	.word	0x20000474

0001f4ec <strcpy>:
   1f4ec:	1c03      	adds	r3, r0, #0
   1f4ee:	780a      	ldrb	r2, [r1, #0]
   1f4f0:	3101      	adds	r1, #1
   1f4f2:	701a      	strb	r2, [r3, #0]
   1f4f4:	3301      	adds	r3, #1
   1f4f6:	2a00      	cmp	r2, #0
   1f4f8:	d1f9      	bne.n	1f4ee <strcpy+0x2>
   1f4fa:	4770      	bx	lr

0001f4fc <strlen>:
   1f4fc:	2300      	movs	r3, #0
   1f4fe:	5cc2      	ldrb	r2, [r0, r3]
   1f500:	3301      	adds	r3, #1
   1f502:	2a00      	cmp	r2, #0
   1f504:	d1fb      	bne.n	1f4fe <strlen+0x2>
   1f506:	1e58      	subs	r0, r3, #1
   1f508:	4770      	bx	lr
	...

0001f50c <__tzcalc_limits>:
   1f50c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f50e:	b089      	sub	sp, #36	; 0x24
   1f510:	0005      	movs	r5, r0
   1f512:	f000 fa93 	bl	1fa3c <__gettzinfo>
   1f516:	4b4c      	ldr	r3, [pc, #304]	; (1f648 <__tzcalc_limits+0x13c>)
   1f518:	0006      	movs	r6, r0
   1f51a:	2000      	movs	r0, #0
   1f51c:	429d      	cmp	r5, r3
   1f51e:	dc00      	bgt.n	1f522 <__tzcalc_limits+0x16>
   1f520:	e090      	b.n	1f644 <__tzcalc_limits+0x138>
   1f522:	4b4a      	ldr	r3, [pc, #296]	; (1f64c <__tzcalc_limits+0x140>)
   1f524:	2164      	movs	r1, #100	; 0x64
   1f526:	18ec      	adds	r4, r5, r3
   1f528:	236e      	movs	r3, #110	; 0x6e
   1f52a:	33ff      	adds	r3, #255	; 0xff
   1f52c:	435c      	muls	r4, r3
   1f52e:	4b48      	ldr	r3, [pc, #288]	; (1f650 <__tzcalc_limits+0x144>)
   1f530:	6075      	str	r5, [r6, #4]
   1f532:	18eb      	adds	r3, r5, r3
   1f534:	109b      	asrs	r3, r3, #2
   1f536:	18e4      	adds	r4, r4, r3
   1f538:	4b46      	ldr	r3, [pc, #280]	; (1f654 <__tzcalc_limits+0x148>)
   1f53a:	4249      	negs	r1, r1
   1f53c:	18e8      	adds	r0, r5, r3
   1f53e:	f7fe f82b 	bl	1d598 <__aeabi_idiv>
   1f542:	21c8      	movs	r1, #200	; 0xc8
   1f544:	4b44      	ldr	r3, [pc, #272]	; (1f658 <__tzcalc_limits+0x14c>)
   1f546:	1824      	adds	r4, r4, r0
   1f548:	0049      	lsls	r1, r1, #1
   1f54a:	18e8      	adds	r0, r5, r3
   1f54c:	f7fe f824 	bl	1d598 <__aeabi_idiv>
   1f550:	2164      	movs	r1, #100	; 0x64
   1f552:	1823      	adds	r3, r4, r0
   1f554:	0028      	movs	r0, r5
   1f556:	9301      	str	r3, [sp, #4]
   1f558:	f7fe f904 	bl	1d764 <__aeabi_idivmod>
   1f55c:	9102      	str	r1, [sp, #8]
   1f55e:	21c8      	movs	r1, #200	; 0xc8
   1f560:	0028      	movs	r0, r5
   1f562:	0049      	lsls	r1, r1, #1
   1f564:	f7fe f8fe 	bl	1d764 <__aeabi_idivmod>
   1f568:	000a      	movs	r2, r1
   1f56a:	4253      	negs	r3, r2
   1f56c:	415a      	adcs	r2, r3
   1f56e:	0033      	movs	r3, r6
   1f570:	3340      	adds	r3, #64	; 0x40
   1f572:	9307      	str	r3, [sp, #28]
   1f574:	2303      	movs	r3, #3
   1f576:	0034      	movs	r4, r6
   1f578:	401d      	ands	r5, r3
   1f57a:	9103      	str	r1, [sp, #12]
   1f57c:	9205      	str	r2, [sp, #20]
   1f57e:	3408      	adds	r4, #8
   1f580:	9506      	str	r5, [sp, #24]
   1f582:	7823      	ldrb	r3, [r4, #0]
   1f584:	2b4a      	cmp	r3, #74	; 0x4a
   1f586:	d113      	bne.n	1f5b0 <__tzcalc_limits+0xa4>
   1f588:	68e2      	ldr	r2, [r4, #12]
   1f58a:	9b01      	ldr	r3, [sp, #4]
   1f58c:	9906      	ldr	r1, [sp, #24]
   1f58e:	189b      	adds	r3, r3, r2
   1f590:	2900      	cmp	r1, #0
   1f592:	d102      	bne.n	1f59a <__tzcalc_limits+0x8e>
   1f594:	9902      	ldr	r1, [sp, #8]
   1f596:	2900      	cmp	r1, #0
   1f598:	d103      	bne.n	1f5a2 <__tzcalc_limits+0x96>
   1f59a:	2700      	movs	r7, #0
   1f59c:	9903      	ldr	r1, [sp, #12]
   1f59e:	42b9      	cmp	r1, r7
   1f5a0:	d103      	bne.n	1f5aa <__tzcalc_limits+0x9e>
   1f5a2:	2701      	movs	r7, #1
   1f5a4:	2a3b      	cmp	r2, #59	; 0x3b
   1f5a6:	dc00      	bgt.n	1f5aa <__tzcalc_limits+0x9e>
   1f5a8:	2700      	movs	r7, #0
   1f5aa:	18ff      	adds	r7, r7, r3
   1f5ac:	3f01      	subs	r7, #1
   1f5ae:	e036      	b.n	1f61e <__tzcalc_limits+0x112>
   1f5b0:	2b44      	cmp	r3, #68	; 0x44
   1f5b2:	d103      	bne.n	1f5bc <__tzcalc_limits+0xb0>
   1f5b4:	9b01      	ldr	r3, [sp, #4]
   1f5b6:	68e2      	ldr	r2, [r4, #12]
   1f5b8:	189f      	adds	r7, r3, r2
   1f5ba:	e030      	b.n	1f61e <__tzcalc_limits+0x112>
   1f5bc:	9a06      	ldr	r2, [sp, #24]
   1f5be:	9b05      	ldr	r3, [sp, #20]
   1f5c0:	2a00      	cmp	r2, #0
   1f5c2:	d103      	bne.n	1f5cc <__tzcalc_limits+0xc0>
   1f5c4:	9a02      	ldr	r2, [sp, #8]
   1f5c6:	2a00      	cmp	r2, #0
   1f5c8:	d000      	beq.n	1f5cc <__tzcalc_limits+0xc0>
   1f5ca:	2301      	movs	r3, #1
   1f5cc:	2230      	movs	r2, #48	; 0x30
   1f5ce:	4353      	muls	r3, r2
   1f5d0:	4a22      	ldr	r2, [pc, #136]	; (1f65c <__tzcalc_limits+0x150>)
   1f5d2:	6865      	ldr	r5, [r4, #4]
   1f5d4:	189b      	adds	r3, r3, r2
   1f5d6:	9304      	str	r3, [sp, #16]
   1f5d8:	001a      	movs	r2, r3
   1f5da:	2301      	movs	r3, #1
   1f5dc:	9f01      	ldr	r7, [sp, #4]
   1f5de:	42ab      	cmp	r3, r5
   1f5e0:	da03      	bge.n	1f5ea <__tzcalc_limits+0xde>
   1f5e2:	ca02      	ldmia	r2!, {r1}
   1f5e4:	3301      	adds	r3, #1
   1f5e6:	187f      	adds	r7, r7, r1
   1f5e8:	e7f9      	b.n	1f5de <__tzcalc_limits+0xd2>
   1f5ea:	2d00      	cmp	r5, #0
   1f5ec:	dc00      	bgt.n	1f5f0 <__tzcalc_limits+0xe4>
   1f5ee:	2501      	movs	r5, #1
   1f5f0:	1d38      	adds	r0, r7, #4
   1f5f2:	2107      	movs	r1, #7
   1f5f4:	f7fe f8b6 	bl	1d764 <__aeabi_idivmod>
   1f5f8:	68e3      	ldr	r3, [r4, #12]
   1f5fa:	1a5b      	subs	r3, r3, r1
   1f5fc:	d500      	bpl.n	1f600 <__tzcalc_limits+0xf4>
   1f5fe:	3307      	adds	r3, #7
   1f600:	68a2      	ldr	r2, [r4, #8]
   1f602:	1e51      	subs	r1, r2, #1
   1f604:	2207      	movs	r2, #7
   1f606:	4351      	muls	r1, r2
   1f608:	18c9      	adds	r1, r1, r3
   1f60a:	4b15      	ldr	r3, [pc, #84]	; (1f660 <__tzcalc_limits+0x154>)
   1f60c:	18ed      	adds	r5, r5, r3
   1f60e:	9b04      	ldr	r3, [sp, #16]
   1f610:	00ad      	lsls	r5, r5, #2
   1f612:	58eb      	ldr	r3, [r5, r3]
   1f614:	4299      	cmp	r1, r3
   1f616:	db01      	blt.n	1f61c <__tzcalc_limits+0x110>
   1f618:	3907      	subs	r1, #7
   1f61a:	e7fb      	b.n	1f614 <__tzcalc_limits+0x108>
   1f61c:	187f      	adds	r7, r7, r1
   1f61e:	4911      	ldr	r1, [pc, #68]	; (1f664 <__tzcalc_limits+0x158>)
   1f620:	6923      	ldr	r3, [r4, #16]
   1f622:	434f      	muls	r7, r1
   1f624:	18ff      	adds	r7, r7, r3
   1f626:	69a3      	ldr	r3, [r4, #24]
   1f628:	18ff      	adds	r7, r7, r3
   1f62a:	9b07      	ldr	r3, [sp, #28]
   1f62c:	6167      	str	r7, [r4, #20]
   1f62e:	341c      	adds	r4, #28
   1f630:	429c      	cmp	r4, r3
   1f632:	d1a6      	bne.n	1f582 <__tzcalc_limits+0x76>
   1f634:	69f2      	ldr	r2, [r6, #28]
   1f636:	6bb1      	ldr	r1, [r6, #56]	; 0x38
   1f638:	2301      	movs	r3, #1
   1f63a:	428a      	cmp	r2, r1
   1f63c:	db00      	blt.n	1f640 <__tzcalc_limits+0x134>
   1f63e:	2300      	movs	r3, #0
   1f640:	2001      	movs	r0, #1
   1f642:	6033      	str	r3, [r6, #0]
   1f644:	b009      	add	sp, #36	; 0x24
   1f646:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f648:	000007b1 	.word	0x000007b1
   1f64c:	fffff84e 	.word	0xfffff84e
   1f650:	fffff84f 	.word	0xfffff84f
   1f654:	fffff893 	.word	0xfffff893
   1f658:	fffff9bf 	.word	0xfffff9bf
   1f65c:	00021ee0 	.word	0x00021ee0
   1f660:	3fffffff 	.word	0x3fffffff
   1f664:	00015180 	.word	0x00015180

0001f668 <__tz_lock>:
   1f668:	4770      	bx	lr

0001f66a <__tz_unlock>:
   1f66a:	4770      	bx	lr

0001f66c <_tzset_unlocked>:
   1f66c:	b510      	push	{r4, lr}
   1f66e:	4b02      	ldr	r3, [pc, #8]	; (1f678 <_tzset_unlocked+0xc>)
   1f670:	6818      	ldr	r0, [r3, #0]
   1f672:	f000 f803 	bl	1f67c <_tzset_unlocked_r>
   1f676:	bd10      	pop	{r4, pc}
   1f678:	20000474 	.word	0x20000474

0001f67c <_tzset_unlocked_r>:
   1f67c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f67e:	b08d      	sub	sp, #52	; 0x34
   1f680:	0006      	movs	r6, r0
   1f682:	f000 f9db 	bl	1fa3c <__gettzinfo>
   1f686:	49b2      	ldr	r1, [pc, #712]	; (1f950 <_tzset_unlocked_r+0x2d4>)
   1f688:	0007      	movs	r7, r0
   1f68a:	0030      	movs	r0, r6
   1f68c:	f000 f9d0 	bl	1fa30 <_getenv_r>
   1f690:	4db0      	ldr	r5, [pc, #704]	; (1f954 <_tzset_unlocked_r+0x2d8>)
   1f692:	1e04      	subs	r4, r0, #0
   1f694:	d10c      	bne.n	1f6b0 <_tzset_unlocked_r+0x34>
   1f696:	4bb0      	ldr	r3, [pc, #704]	; (1f958 <_tzset_unlocked_r+0x2dc>)
   1f698:	4ab0      	ldr	r2, [pc, #704]	; (1f95c <_tzset_unlocked_r+0x2e0>)
   1f69a:	6018      	str	r0, [r3, #0]
   1f69c:	4bb0      	ldr	r3, [pc, #704]	; (1f960 <_tzset_unlocked_r+0x2e4>)
   1f69e:	6018      	str	r0, [r3, #0]
   1f6a0:	4bb0      	ldr	r3, [pc, #704]	; (1f964 <_tzset_unlocked_r+0x2e8>)
   1f6a2:	6828      	ldr	r0, [r5, #0]
   1f6a4:	601a      	str	r2, [r3, #0]
   1f6a6:	605a      	str	r2, [r3, #4]
   1f6a8:	f7ff fbde 	bl	1ee68 <free>
   1f6ac:	602c      	str	r4, [r5, #0]
   1f6ae:	e14d      	b.n	1f94c <_tzset_unlocked_r+0x2d0>
   1f6b0:	6829      	ldr	r1, [r5, #0]
   1f6b2:	2900      	cmp	r1, #0
   1f6b4:	d110      	bne.n	1f6d8 <_tzset_unlocked_r+0x5c>
   1f6b6:	6828      	ldr	r0, [r5, #0]
   1f6b8:	f7ff fbd6 	bl	1ee68 <free>
   1f6bc:	0020      	movs	r0, r4
   1f6be:	f7ff ff1d 	bl	1f4fc <strlen>
   1f6c2:	1c41      	adds	r1, r0, #1
   1f6c4:	0030      	movs	r0, r6
   1f6c6:	f7ff fe87 	bl	1f3d8 <_malloc_r>
   1f6ca:	6028      	str	r0, [r5, #0]
   1f6cc:	2800      	cmp	r0, #0
   1f6ce:	d009      	beq.n	1f6e4 <_tzset_unlocked_r+0x68>
   1f6d0:	0021      	movs	r1, r4
   1f6d2:	f7ff ff0b 	bl	1f4ec <strcpy>
   1f6d6:	e005      	b.n	1f6e4 <_tzset_unlocked_r+0x68>
   1f6d8:	f000 fd8a 	bl	201f0 <strcmp>
   1f6dc:	2800      	cmp	r0, #0
   1f6de:	d100      	bne.n	1f6e2 <_tzset_unlocked_r+0x66>
   1f6e0:	e134      	b.n	1f94c <_tzset_unlocked_r+0x2d0>
   1f6e2:	e7e8      	b.n	1f6b6 <_tzset_unlocked_r+0x3a>
   1f6e4:	7823      	ldrb	r3, [r4, #0]
   1f6e6:	3b3a      	subs	r3, #58	; 0x3a
   1f6e8:	4259      	negs	r1, r3
   1f6ea:	4159      	adcs	r1, r3
   1f6ec:	1864      	adds	r4, r4, r1
   1f6ee:	ab0a      	add	r3, sp, #40	; 0x28
   1f6f0:	4a9d      	ldr	r2, [pc, #628]	; (1f968 <_tzset_unlocked_r+0x2ec>)
   1f6f2:	499e      	ldr	r1, [pc, #632]	; (1f96c <_tzset_unlocked_r+0x2f0>)
   1f6f4:	0020      	movs	r0, r4
   1f6f6:	f000 fd51 	bl	2019c <siscanf>
   1f6fa:	2800      	cmp	r0, #0
   1f6fc:	dc00      	bgt.n	1f700 <_tzset_unlocked_r+0x84>
   1f6fe:	e125      	b.n	1f94c <_tzset_unlocked_r+0x2d0>
   1f700:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1f702:	18e4      	adds	r4, r4, r3
   1f704:	7823      	ldrb	r3, [r4, #0]
   1f706:	2b2d      	cmp	r3, #45	; 0x2d
   1f708:	d103      	bne.n	1f712 <_tzset_unlocked_r+0x96>
   1f70a:	3b2e      	subs	r3, #46	; 0x2e
   1f70c:	3401      	adds	r4, #1
   1f70e:	9304      	str	r3, [sp, #16]
   1f710:	e005      	b.n	1f71e <_tzset_unlocked_r+0xa2>
   1f712:	2201      	movs	r2, #1
   1f714:	3b2b      	subs	r3, #43	; 0x2b
   1f716:	9204      	str	r2, [sp, #16]
   1f718:	4259      	negs	r1, r3
   1f71a:	4159      	adcs	r1, r3
   1f71c:	1864      	adds	r4, r4, r1
   1f71e:	2200      	movs	r2, #0
   1f720:	ab02      	add	r3, sp, #8
   1f722:	82da      	strh	r2, [r3, #22]
   1f724:	2300      	movs	r3, #0
   1f726:	ad08      	add	r5, sp, #32
   1f728:	802b      	strh	r3, [r5, #0]
   1f72a:	2316      	movs	r3, #22
   1f72c:	aa02      	add	r2, sp, #8
   1f72e:	ae0a      	add	r6, sp, #40	; 0x28
   1f730:	189b      	adds	r3, r3, r2
   1f732:	9300      	str	r3, [sp, #0]
   1f734:	9603      	str	r6, [sp, #12]
   1f736:	9502      	str	r5, [sp, #8]
   1f738:	9601      	str	r6, [sp, #4]
   1f73a:	0033      	movs	r3, r6
   1f73c:	aa07      	add	r2, sp, #28
   1f73e:	498c      	ldr	r1, [pc, #560]	; (1f970 <_tzset_unlocked_r+0x2f4>)
   1f740:	0020      	movs	r0, r4
   1f742:	f000 fd2b 	bl	2019c <siscanf>
   1f746:	2800      	cmp	r0, #0
   1f748:	dc00      	bgt.n	1f74c <_tzset_unlocked_r+0xd0>
   1f74a:	e0ff      	b.n	1f94c <_tzset_unlocked_r+0x2d0>
   1f74c:	ab02      	add	r3, sp, #8
   1f74e:	8ad9      	ldrh	r1, [r3, #22]
   1f750:	233c      	movs	r3, #60	; 0x3c
   1f752:	434b      	muls	r3, r1
   1f754:	882a      	ldrh	r2, [r5, #0]
   1f756:	4d83      	ldr	r5, [pc, #524]	; (1f964 <_tzset_unlocked_r+0x2e8>)
   1f758:	1899      	adds	r1, r3, r2
   1f75a:	22e1      	movs	r2, #225	; 0xe1
   1f75c:	ab02      	add	r3, sp, #8
   1f75e:	8a9b      	ldrh	r3, [r3, #20]
   1f760:	0112      	lsls	r2, r2, #4
   1f762:	435a      	muls	r2, r3
   1f764:	188b      	adds	r3, r1, r2
   1f766:	9a04      	ldr	r2, [sp, #16]
   1f768:	4980      	ldr	r1, [pc, #512]	; (1f96c <_tzset_unlocked_r+0x2f0>)
   1f76a:	435a      	muls	r2, r3
   1f76c:	4b7e      	ldr	r3, [pc, #504]	; (1f968 <_tzset_unlocked_r+0x2ec>)
   1f76e:	623a      	str	r2, [r7, #32]
   1f770:	602b      	str	r3, [r5, #0]
   1f772:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1f774:	4a7f      	ldr	r2, [pc, #508]	; (1f974 <_tzset_unlocked_r+0x2f8>)
   1f776:	18e4      	adds	r4, r4, r3
   1f778:	0020      	movs	r0, r4
   1f77a:	0033      	movs	r3, r6
   1f77c:	f000 fd0e 	bl	2019c <siscanf>
   1f780:	2800      	cmp	r0, #0
   1f782:	dc08      	bgt.n	1f796 <_tzset_unlocked_r+0x11a>
   1f784:	682b      	ldr	r3, [r5, #0]
   1f786:	6a3a      	ldr	r2, [r7, #32]
   1f788:	606b      	str	r3, [r5, #4]
   1f78a:	4b73      	ldr	r3, [pc, #460]	; (1f958 <_tzset_unlocked_r+0x2dc>)
   1f78c:	601a      	str	r2, [r3, #0]
   1f78e:	2200      	movs	r2, #0
   1f790:	4b73      	ldr	r3, [pc, #460]	; (1f960 <_tzset_unlocked_r+0x2e4>)
   1f792:	601a      	str	r2, [r3, #0]
   1f794:	e0da      	b.n	1f94c <_tzset_unlocked_r+0x2d0>
   1f796:	4b77      	ldr	r3, [pc, #476]	; (1f974 <_tzset_unlocked_r+0x2f8>)
   1f798:	606b      	str	r3, [r5, #4]
   1f79a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1f79c:	18e4      	adds	r4, r4, r3
   1f79e:	7823      	ldrb	r3, [r4, #0]
   1f7a0:	2b2d      	cmp	r3, #45	; 0x2d
   1f7a2:	d103      	bne.n	1f7ac <_tzset_unlocked_r+0x130>
   1f7a4:	3b2e      	subs	r3, #46	; 0x2e
   1f7a6:	3401      	adds	r4, #1
   1f7a8:	9304      	str	r3, [sp, #16]
   1f7aa:	e005      	b.n	1f7b8 <_tzset_unlocked_r+0x13c>
   1f7ac:	2201      	movs	r2, #1
   1f7ae:	3b2b      	subs	r3, #43	; 0x2b
   1f7b0:	9204      	str	r2, [sp, #16]
   1f7b2:	4259      	negs	r1, r3
   1f7b4:	4159      	adcs	r1, r3
   1f7b6:	1864      	adds	r4, r4, r1
   1f7b8:	2300      	movs	r3, #0
   1f7ba:	aa02      	add	r2, sp, #8
   1f7bc:	82d3      	strh	r3, [r2, #22]
   1f7be:	2216      	movs	r2, #22
   1f7c0:	ad07      	add	r5, sp, #28
   1f7c2:	ae08      	add	r6, sp, #32
   1f7c4:	a902      	add	r1, sp, #8
   1f7c6:	802b      	strh	r3, [r5, #0]
   1f7c8:	8033      	strh	r3, [r6, #0]
   1f7ca:	1852      	adds	r2, r2, r1
   1f7cc:	930a      	str	r3, [sp, #40]	; 0x28
   1f7ce:	ab0a      	add	r3, sp, #40	; 0x28
   1f7d0:	9200      	str	r2, [sp, #0]
   1f7d2:	9303      	str	r3, [sp, #12]
   1f7d4:	9602      	str	r6, [sp, #8]
   1f7d6:	9301      	str	r3, [sp, #4]
   1f7d8:	002a      	movs	r2, r5
   1f7da:	4965      	ldr	r1, [pc, #404]	; (1f970 <_tzset_unlocked_r+0x2f4>)
   1f7dc:	0020      	movs	r0, r4
   1f7de:	f000 fcdd 	bl	2019c <siscanf>
   1f7e2:	2800      	cmp	r0, #0
   1f7e4:	dc03      	bgt.n	1f7ee <_tzset_unlocked_r+0x172>
   1f7e6:	6a3b      	ldr	r3, [r7, #32]
   1f7e8:	4a63      	ldr	r2, [pc, #396]	; (1f978 <_tzset_unlocked_r+0x2fc>)
   1f7ea:	189b      	adds	r3, r3, r2
   1f7ec:	e00d      	b.n	1f80a <_tzset_unlocked_r+0x18e>
   1f7ee:	ab02      	add	r3, sp, #8
   1f7f0:	8ad9      	ldrh	r1, [r3, #22]
   1f7f2:	233c      	movs	r3, #60	; 0x3c
   1f7f4:	434b      	muls	r3, r1
   1f7f6:	8832      	ldrh	r2, [r6, #0]
   1f7f8:	1899      	adds	r1, r3, r2
   1f7fa:	22e1      	movs	r2, #225	; 0xe1
   1f7fc:	882b      	ldrh	r3, [r5, #0]
   1f7fe:	0112      	lsls	r2, r2, #4
   1f800:	435a      	muls	r2, r3
   1f802:	188b      	adds	r3, r1, r2
   1f804:	9a04      	ldr	r2, [sp, #16]
   1f806:	435a      	muls	r2, r3
   1f808:	0013      	movs	r3, r2
   1f80a:	63fb      	str	r3, [r7, #60]	; 0x3c
   1f80c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1f80e:	18e6      	adds	r6, r4, r3
   1f810:	003c      	movs	r4, r7
   1f812:	2300      	movs	r3, #0
   1f814:	3408      	adds	r4, #8
   1f816:	9305      	str	r3, [sp, #20]
   1f818:	7833      	ldrb	r3, [r6, #0]
   1f81a:	3b2c      	subs	r3, #44	; 0x2c
   1f81c:	4259      	negs	r1, r3
   1f81e:	4159      	adcs	r1, r3
   1f820:	1876      	adds	r6, r6, r1
   1f822:	7833      	ldrb	r3, [r6, #0]
   1f824:	9304      	str	r3, [sp, #16]
   1f826:	2b4d      	cmp	r3, #77	; 0x4d
   1f828:	d128      	bne.n	1f87c <_tzset_unlocked_r+0x200>
   1f82a:	221e      	movs	r2, #30
   1f82c:	a902      	add	r1, sp, #8
   1f82e:	1852      	adds	r2, r2, r1
   1f830:	9202      	str	r2, [sp, #8]
   1f832:	221a      	movs	r2, #26
   1f834:	ab0a      	add	r3, sp, #40	; 0x28
   1f836:	ad09      	add	r5, sp, #36	; 0x24
   1f838:	1852      	adds	r2, r2, r1
   1f83a:	9303      	str	r3, [sp, #12]
   1f83c:	9301      	str	r3, [sp, #4]
   1f83e:	9500      	str	r5, [sp, #0]
   1f840:	494e      	ldr	r1, [pc, #312]	; (1f97c <_tzset_unlocked_r+0x300>)
   1f842:	0030      	movs	r0, r6
   1f844:	f000 fcaa 	bl	2019c <siscanf>
   1f848:	2803      	cmp	r0, #3
   1f84a:	d000      	beq.n	1f84e <_tzset_unlocked_r+0x1d2>
   1f84c:	e07e      	b.n	1f94c <_tzset_unlocked_r+0x2d0>
   1f84e:	ab02      	add	r3, sp, #8
   1f850:	8b59      	ldrh	r1, [r3, #26]
   1f852:	1e4b      	subs	r3, r1, #1
   1f854:	2b0b      	cmp	r3, #11
   1f856:	d879      	bhi.n	1f94c <_tzset_unlocked_r+0x2d0>
   1f858:	882a      	ldrh	r2, [r5, #0]
   1f85a:	1e53      	subs	r3, r2, #1
   1f85c:	2b04      	cmp	r3, #4
   1f85e:	d875      	bhi.n	1f94c <_tzset_unlocked_r+0x2d0>
   1f860:	ab02      	add	r3, sp, #8
   1f862:	8bdb      	ldrh	r3, [r3, #30]
   1f864:	2b06      	cmp	r3, #6
   1f866:	d871      	bhi.n	1f94c <_tzset_unlocked_r+0x2d0>
   1f868:	4668      	mov	r0, sp
   1f86a:	7c00      	ldrb	r0, [r0, #16]
   1f86c:	6061      	str	r1, [r4, #4]
   1f86e:	7020      	strb	r0, [r4, #0]
   1f870:	60a2      	str	r2, [r4, #8]
   1f872:	60e3      	str	r3, [r4, #12]
   1f874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1f876:	18f3      	adds	r3, r6, r3
   1f878:	9304      	str	r3, [sp, #16]
   1f87a:	e02b      	b.n	1f8d4 <_tzset_unlocked_r+0x258>
   1f87c:	9b04      	ldr	r3, [sp, #16]
   1f87e:	2544      	movs	r5, #68	; 0x44
   1f880:	2b4a      	cmp	r3, #74	; 0x4a
   1f882:	d101      	bne.n	1f888 <_tzset_unlocked_r+0x20c>
   1f884:	001d      	movs	r5, r3
   1f886:	3601      	adds	r6, #1
   1f888:	220a      	movs	r2, #10
   1f88a:	a90b      	add	r1, sp, #44	; 0x2c
   1f88c:	0030      	movs	r0, r6
   1f88e:	f000 fd4f 	bl	20330 <strtoul>
   1f892:	231e      	movs	r3, #30
   1f894:	aa02      	add	r2, sp, #8
   1f896:	189b      	adds	r3, r3, r2
   1f898:	8018      	strh	r0, [r3, #0]
   1f89a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1f89c:	9304      	str	r3, [sp, #16]
   1f89e:	429e      	cmp	r6, r3
   1f8a0:	d115      	bne.n	1f8ce <_tzset_unlocked_r+0x252>
   1f8a2:	9b05      	ldr	r3, [sp, #20]
   1f8a4:	2b00      	cmp	r3, #0
   1f8a6:	d108      	bne.n	1f8ba <_tzset_unlocked_r+0x23e>
   1f8a8:	334d      	adds	r3, #77	; 0x4d
   1f8aa:	723b      	strb	r3, [r7, #8]
   1f8ac:	2303      	movs	r3, #3
   1f8ae:	60fb      	str	r3, [r7, #12]
   1f8b0:	3b01      	subs	r3, #1
   1f8b2:	613b      	str	r3, [r7, #16]
   1f8b4:	9b05      	ldr	r3, [sp, #20]
   1f8b6:	617b      	str	r3, [r7, #20]
   1f8b8:	e00c      	b.n	1f8d4 <_tzset_unlocked_r+0x258>
   1f8ba:	224d      	movs	r2, #77	; 0x4d
   1f8bc:	1d7b      	adds	r3, r7, #5
   1f8be:	77da      	strb	r2, [r3, #31]
   1f8c0:	230b      	movs	r3, #11
   1f8c2:	62bb      	str	r3, [r7, #40]	; 0x28
   1f8c4:	3b0a      	subs	r3, #10
   1f8c6:	62fb      	str	r3, [r7, #44]	; 0x2c
   1f8c8:	2300      	movs	r3, #0
   1f8ca:	633b      	str	r3, [r7, #48]	; 0x30
   1f8cc:	e002      	b.n	1f8d4 <_tzset_unlocked_r+0x258>
   1f8ce:	b280      	uxth	r0, r0
   1f8d0:	7025      	strb	r5, [r4, #0]
   1f8d2:	60e0      	str	r0, [r4, #12]
   1f8d4:	2302      	movs	r3, #2
   1f8d6:	2616      	movs	r6, #22
   1f8d8:	aa07      	add	r2, sp, #28
   1f8da:	8013      	strh	r3, [r2, #0]
   1f8dc:	ab02      	add	r3, sp, #8
   1f8de:	18f6      	adds	r6, r6, r3
   1f8e0:	2300      	movs	r3, #0
   1f8e2:	ad08      	add	r5, sp, #32
   1f8e4:	8033      	strh	r3, [r6, #0]
   1f8e6:	802b      	strh	r3, [r5, #0]
   1f8e8:	930a      	str	r3, [sp, #40]	; 0x28
   1f8ea:	9b04      	ldr	r3, [sp, #16]
   1f8ec:	781b      	ldrb	r3, [r3, #0]
   1f8ee:	2b2f      	cmp	r3, #47	; 0x2f
   1f8f0:	d108      	bne.n	1f904 <_tzset_unlocked_r+0x288>
   1f8f2:	ab0a      	add	r3, sp, #40	; 0x28
   1f8f4:	9303      	str	r3, [sp, #12]
   1f8f6:	9502      	str	r5, [sp, #8]
   1f8f8:	9301      	str	r3, [sp, #4]
   1f8fa:	9600      	str	r6, [sp, #0]
   1f8fc:	4920      	ldr	r1, [pc, #128]	; (1f980 <_tzset_unlocked_r+0x304>)
   1f8fe:	9804      	ldr	r0, [sp, #16]
   1f900:	f000 fc4c 	bl	2019c <siscanf>
   1f904:	233c      	movs	r3, #60	; 0x3c
   1f906:	8831      	ldrh	r1, [r6, #0]
   1f908:	882a      	ldrh	r2, [r5, #0]
   1f90a:	434b      	muls	r3, r1
   1f90c:	1899      	adds	r1, r3, r2
   1f90e:	22e1      	movs	r2, #225	; 0xe1
   1f910:	ab07      	add	r3, sp, #28
   1f912:	881b      	ldrh	r3, [r3, #0]
   1f914:	0112      	lsls	r2, r2, #4
   1f916:	435a      	muls	r2, r3
   1f918:	188b      	adds	r3, r1, r2
   1f91a:	6123      	str	r3, [r4, #16]
   1f91c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1f91e:	9b04      	ldr	r3, [sp, #16]
   1f920:	4694      	mov	ip, r2
   1f922:	4463      	add	r3, ip
   1f924:	001e      	movs	r6, r3
   1f926:	9b05      	ldr	r3, [sp, #20]
   1f928:	341c      	adds	r4, #28
   1f92a:	3301      	adds	r3, #1
   1f92c:	9305      	str	r3, [sp, #20]
   1f92e:	2b02      	cmp	r3, #2
   1f930:	d000      	beq.n	1f934 <_tzset_unlocked_r+0x2b8>
   1f932:	e771      	b.n	1f818 <_tzset_unlocked_r+0x19c>
   1f934:	6878      	ldr	r0, [r7, #4]
   1f936:	f7ff fde9 	bl	1f50c <__tzcalc_limits>
   1f93a:	6a3a      	ldr	r2, [r7, #32]
   1f93c:	4b06      	ldr	r3, [pc, #24]	; (1f958 <_tzset_unlocked_r+0x2dc>)
   1f93e:	601a      	str	r2, [r3, #0]
   1f940:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1f942:	1a9b      	subs	r3, r3, r2
   1f944:	1e5a      	subs	r2, r3, #1
   1f946:	4193      	sbcs	r3, r2
   1f948:	4a05      	ldr	r2, [pc, #20]	; (1f960 <_tzset_unlocked_r+0x2e4>)
   1f94a:	6013      	str	r3, [r2, #0]
   1f94c:	b00d      	add	sp, #52	; 0x34
   1f94e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f950:	00021f40 	.word	0x00021f40
   1f954:	200030b4 	.word	0x200030b4
   1f958:	200030bc 	.word	0x200030bc
   1f95c:	00021f43 	.word	0x00021f43
   1f960:	200030b8 	.word	0x200030b8
   1f964:	20000478 	.word	0x20000478
   1f968:	200030a7 	.word	0x200030a7
   1f96c:	00021f47 	.word	0x00021f47
   1f970:	00021f6a 	.word	0x00021f6a
   1f974:	2000309c 	.word	0x2000309c
   1f978:	fffff1f0 	.word	0xfffff1f0
   1f97c:	00021f56 	.word	0x00021f56
   1f980:	00021f69 	.word	0x00021f69

0001f984 <div>:
   1f984:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1f986:	000f      	movs	r7, r1
   1f988:	0006      	movs	r6, r0
   1f98a:	0011      	movs	r1, r2
   1f98c:	0038      	movs	r0, r7
   1f98e:	0015      	movs	r5, r2
   1f990:	f7fd fe02 	bl	1d598 <__aeabi_idiv>
   1f994:	0029      	movs	r1, r5
   1f996:	0004      	movs	r4, r0
   1f998:	0038      	movs	r0, r7
   1f99a:	f7fd fee3 	bl	1d764 <__aeabi_idivmod>
   1f99e:	2f00      	cmp	r7, #0
   1f9a0:	db04      	blt.n	1f9ac <div+0x28>
   1f9a2:	2900      	cmp	r1, #0
   1f9a4:	da06      	bge.n	1f9b4 <div+0x30>
   1f9a6:	3401      	adds	r4, #1
   1f9a8:	1b49      	subs	r1, r1, r5
   1f9aa:	e003      	b.n	1f9b4 <div+0x30>
   1f9ac:	2900      	cmp	r1, #0
   1f9ae:	dd01      	ble.n	1f9b4 <div+0x30>
   1f9b0:	3c01      	subs	r4, #1
   1f9b2:	1949      	adds	r1, r1, r5
   1f9b4:	0030      	movs	r0, r6
   1f9b6:	6034      	str	r4, [r6, #0]
   1f9b8:	6071      	str	r1, [r6, #4]
   1f9ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001f9bc <_findenv_r>:
   1f9bc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f9be:	000e      	movs	r6, r1
   1f9c0:	b085      	sub	sp, #20
   1f9c2:	0007      	movs	r7, r0
   1f9c4:	9202      	str	r2, [sp, #8]
   1f9c6:	f000 fcbf 	bl	20348 <__env_lock>
   1f9ca:	4b18      	ldr	r3, [pc, #96]	; (1fa2c <_findenv_r+0x70>)
   1f9cc:	681d      	ldr	r5, [r3, #0]
   1f9ce:	9303      	str	r3, [sp, #12]
   1f9d0:	0033      	movs	r3, r6
   1f9d2:	2d00      	cmp	r5, #0
   1f9d4:	d107      	bne.n	1f9e6 <_findenv_r+0x2a>
   1f9d6:	0038      	movs	r0, r7
   1f9d8:	f000 fcb7 	bl	2034a <__env_unlock>
   1f9dc:	2000      	movs	r0, #0
   1f9de:	e023      	b.n	1fa28 <_findenv_r+0x6c>
   1f9e0:	2a3d      	cmp	r2, #61	; 0x3d
   1f9e2:	d0f8      	beq.n	1f9d6 <_findenv_r+0x1a>
   1f9e4:	3301      	adds	r3, #1
   1f9e6:	781a      	ldrb	r2, [r3, #0]
   1f9e8:	2a00      	cmp	r2, #0
   1f9ea:	d1f9      	bne.n	1f9e0 <_findenv_r+0x24>
   1f9ec:	1b9b      	subs	r3, r3, r6
   1f9ee:	9301      	str	r3, [sp, #4]
   1f9f0:	6828      	ldr	r0, [r5, #0]
   1f9f2:	2800      	cmp	r0, #0
   1f9f4:	d0ef      	beq.n	1f9d6 <_findenv_r+0x1a>
   1f9f6:	9a01      	ldr	r2, [sp, #4]
   1f9f8:	0031      	movs	r1, r6
   1f9fa:	f000 fc03 	bl	20204 <strncmp>
   1f9fe:	2800      	cmp	r0, #0
   1fa00:	d110      	bne.n	1fa24 <_findenv_r+0x68>
   1fa02:	682b      	ldr	r3, [r5, #0]
   1fa04:	9a01      	ldr	r2, [sp, #4]
   1fa06:	189c      	adds	r4, r3, r2
   1fa08:	7823      	ldrb	r3, [r4, #0]
   1fa0a:	2b3d      	cmp	r3, #61	; 0x3d
   1fa0c:	d10a      	bne.n	1fa24 <_findenv_r+0x68>
   1fa0e:	9b03      	ldr	r3, [sp, #12]
   1fa10:	0038      	movs	r0, r7
   1fa12:	681b      	ldr	r3, [r3, #0]
   1fa14:	1aed      	subs	r5, r5, r3
   1fa16:	9b02      	ldr	r3, [sp, #8]
   1fa18:	10ad      	asrs	r5, r5, #2
   1fa1a:	601d      	str	r5, [r3, #0]
   1fa1c:	f000 fc95 	bl	2034a <__env_unlock>
   1fa20:	1c60      	adds	r0, r4, #1
   1fa22:	e001      	b.n	1fa28 <_findenv_r+0x6c>
   1fa24:	3504      	adds	r5, #4
   1fa26:	e7e3      	b.n	1f9f0 <_findenv_r+0x34>
   1fa28:	b005      	add	sp, #20
   1fa2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1fa2c:	200004c4 	.word	0x200004c4

0001fa30 <_getenv_r>:
   1fa30:	b507      	push	{r0, r1, r2, lr}
   1fa32:	aa01      	add	r2, sp, #4
   1fa34:	f7ff ffc2 	bl	1f9bc <_findenv_r>
   1fa38:	bd0e      	pop	{r1, r2, r3, pc}
	...

0001fa3c <__gettzinfo>:
   1fa3c:	4800      	ldr	r0, [pc, #0]	; (1fa40 <__gettzinfo+0x4>)
   1fa3e:	4770      	bx	lr
   1fa40:	20000480 	.word	0x20000480

0001fa44 <gmtime_r>:
   1fa44:	b5f0      	push	{r4, r5, r6, r7, lr}
   1fa46:	6806      	ldr	r6, [r0, #0]
   1fa48:	b085      	sub	sp, #20
   1fa4a:	000d      	movs	r5, r1
   1fa4c:	0030      	movs	r0, r6
   1fa4e:	4951      	ldr	r1, [pc, #324]	; (1fb94 <gmtime_r+0x150>)
   1fa50:	f7fd fda2 	bl	1d598 <__aeabi_idiv>
   1fa54:	494f      	ldr	r1, [pc, #316]	; (1fb94 <gmtime_r+0x150>)
   1fa56:	0004      	movs	r4, r0
   1fa58:	0030      	movs	r0, r6
   1fa5a:	f7fd fe83 	bl	1d764 <__aeabi_idivmod>
   1fa5e:	1e0f      	subs	r7, r1, #0
   1fa60:	db01      	blt.n	1fa66 <gmtime_r+0x22>
   1fa62:	4b4d      	ldr	r3, [pc, #308]	; (1fb98 <gmtime_r+0x154>)
   1fa64:	e002      	b.n	1fa6c <gmtime_r+0x28>
   1fa66:	4b4b      	ldr	r3, [pc, #300]	; (1fb94 <gmtime_r+0x150>)
   1fa68:	18cf      	adds	r7, r1, r3
   1fa6a:	4b4c      	ldr	r3, [pc, #304]	; (1fb9c <gmtime_r+0x158>)
   1fa6c:	21e1      	movs	r1, #225	; 0xe1
   1fa6e:	0038      	movs	r0, r7
   1fa70:	0109      	lsls	r1, r1, #4
   1fa72:	18e6      	adds	r6, r4, r3
   1fa74:	f7fd fd90 	bl	1d598 <__aeabi_idiv>
   1fa78:	21e1      	movs	r1, #225	; 0xe1
   1fa7a:	60a8      	str	r0, [r5, #8]
   1fa7c:	0109      	lsls	r1, r1, #4
   1fa7e:	0038      	movs	r0, r7
   1fa80:	f7fd fe70 	bl	1d764 <__aeabi_idivmod>
   1fa84:	000c      	movs	r4, r1
   1fa86:	213c      	movs	r1, #60	; 0x3c
   1fa88:	0020      	movs	r0, r4
   1fa8a:	f7fd fd85 	bl	1d598 <__aeabi_idiv>
   1fa8e:	213c      	movs	r1, #60	; 0x3c
   1fa90:	6068      	str	r0, [r5, #4]
   1fa92:	0020      	movs	r0, r4
   1fa94:	f7fd fe66 	bl	1d764 <__aeabi_idivmod>
   1fa98:	1cf0      	adds	r0, r6, #3
   1fa9a:	6029      	str	r1, [r5, #0]
   1fa9c:	2107      	movs	r1, #7
   1fa9e:	f7fd fe61 	bl	1d764 <__aeabi_idivmod>
   1faa2:	0030      	movs	r0, r6
   1faa4:	61a9      	str	r1, [r5, #24]
   1faa6:	493e      	ldr	r1, [pc, #248]	; (1fba0 <gmtime_r+0x15c>)
   1faa8:	f7fd fd76 	bl	1d598 <__aeabi_idiv>
   1faac:	4c3d      	ldr	r4, [pc, #244]	; (1fba4 <gmtime_r+0x160>)
   1faae:	493e      	ldr	r1, [pc, #248]	; (1fba8 <gmtime_r+0x164>)
   1fab0:	4344      	muls	r4, r0
   1fab2:	19a4      	adds	r4, r4, r6
   1fab4:	0007      	movs	r7, r0
   1fab6:	0020      	movs	r0, r4
   1fab8:	f7fd fce4 	bl	1d484 <__aeabi_uidiv>
   1fabc:	493b      	ldr	r1, [pc, #236]	; (1fbac <gmtime_r+0x168>)
   1fabe:	1906      	adds	r6, r0, r4
   1fac0:	0020      	movs	r0, r4
   1fac2:	f7fd fcdf 	bl	1d484 <__aeabi_uidiv>
   1fac6:	493a      	ldr	r1, [pc, #232]	; (1fbb0 <gmtime_r+0x16c>)
   1fac8:	1a36      	subs	r6, r6, r0
   1faca:	0020      	movs	r0, r4
   1facc:	f7fd fcda 	bl	1d484 <__aeabi_uidiv>
   1fad0:	216e      	movs	r1, #110	; 0x6e
   1fad2:	1a36      	subs	r6, r6, r0
   1fad4:	31ff      	adds	r1, #255	; 0xff
   1fad6:	0030      	movs	r0, r6
   1fad8:	f7fd fcd4 	bl	1d484 <__aeabi_uidiv>
   1fadc:	4935      	ldr	r1, [pc, #212]	; (1fbb4 <gmtime_r+0x170>)
   1fade:	9001      	str	r0, [sp, #4]
   1fae0:	0030      	movs	r0, r6
   1fae2:	f7fd fccf 	bl	1d484 <__aeabi_uidiv>
   1fae6:	4931      	ldr	r1, [pc, #196]	; (1fbac <gmtime_r+0x168>)
   1fae8:	1904      	adds	r4, r0, r4
   1faea:	0030      	movs	r0, r6
   1faec:	f7fd fcca 	bl	1d484 <__aeabi_uidiv>
   1faf0:	236e      	movs	r3, #110	; 0x6e
   1faf2:	9a01      	ldr	r2, [sp, #4]
   1faf4:	33ff      	adds	r3, #255	; 0xff
   1faf6:	4353      	muls	r3, r2
   1faf8:	1a24      	subs	r4, r4, r0
   1fafa:	1ae3      	subs	r3, r4, r3
   1fafc:	2605      	movs	r6, #5
   1fafe:	0018      	movs	r0, r3
   1fb00:	4370      	muls	r0, r6
   1fb02:	2199      	movs	r1, #153	; 0x99
   1fb04:	3002      	adds	r0, #2
   1fb06:	9302      	str	r3, [sp, #8]
   1fb08:	f7fd fcbc 	bl	1d484 <__aeabi_uidiv>
   1fb0c:	0004      	movs	r4, r0
   1fb0e:	2099      	movs	r0, #153	; 0x99
   1fb10:	4360      	muls	r0, r4
   1fb12:	9b02      	ldr	r3, [sp, #8]
   1fb14:	0031      	movs	r1, r6
   1fb16:	3301      	adds	r3, #1
   1fb18:	3002      	adds	r0, #2
   1fb1a:	9303      	str	r3, [sp, #12]
   1fb1c:	f7fd fcb2 	bl	1d484 <__aeabi_uidiv>
   1fb20:	9b03      	ldr	r3, [sp, #12]
   1fb22:	3e03      	subs	r6, #3
   1fb24:	1a1b      	subs	r3, r3, r0
   1fb26:	9303      	str	r3, [sp, #12]
   1fb28:	2c09      	cmp	r4, #9
   1fb2a:	d900      	bls.n	1fb2e <gmtime_r+0xea>
   1fb2c:	3e0c      	subs	r6, #12
   1fb2e:	23c8      	movs	r3, #200	; 0xc8
   1fb30:	005b      	lsls	r3, r3, #1
   1fb32:	435f      	muls	r7, r3
   1fb34:	9b01      	ldr	r3, [sp, #4]
   1fb36:	1936      	adds	r6, r6, r4
   1fb38:	18fb      	adds	r3, r7, r3
   1fb3a:	2401      	movs	r4, #1
   1fb3c:	2700      	movs	r7, #0
   1fb3e:	42b4      	cmp	r4, r6
   1fb40:	417f      	adcs	r7, r7
   1fb42:	19df      	adds	r7, r3, r7
   1fb44:	2332      	movs	r3, #50	; 0x32
   1fb46:	9a02      	ldr	r2, [sp, #8]
   1fb48:	33ff      	adds	r3, #255	; 0xff
   1fb4a:	429a      	cmp	r2, r3
   1fb4c:	d903      	bls.n	1fb56 <gmtime_r+0x112>
   1fb4e:	0014      	movs	r4, r2
   1fb50:	3c33      	subs	r4, #51	; 0x33
   1fb52:	3cff      	subs	r4, #255	; 0xff
   1fb54:	e012      	b.n	1fb7c <gmtime_r+0x138>
   1fb56:	9b01      	ldr	r3, [sp, #4]
   1fb58:	079b      	lsls	r3, r3, #30
   1fb5a:	d105      	bne.n	1fb68 <gmtime_r+0x124>
   1fb5c:	2164      	movs	r1, #100	; 0x64
   1fb5e:	9801      	ldr	r0, [sp, #4]
   1fb60:	f7fd fd16 	bl	1d590 <__aeabi_uidivmod>
   1fb64:	2900      	cmp	r1, #0
   1fb66:	d106      	bne.n	1fb76 <gmtime_r+0x132>
   1fb68:	21c8      	movs	r1, #200	; 0xc8
   1fb6a:	9801      	ldr	r0, [sp, #4]
   1fb6c:	0049      	lsls	r1, r1, #1
   1fb6e:	f7fd fd0f 	bl	1d590 <__aeabi_uidivmod>
   1fb72:	424c      	negs	r4, r1
   1fb74:	414c      	adcs	r4, r1
   1fb76:	9802      	ldr	r0, [sp, #8]
   1fb78:	303b      	adds	r0, #59	; 0x3b
   1fb7a:	1904      	adds	r4, r0, r4
   1fb7c:	4b0e      	ldr	r3, [pc, #56]	; (1fbb8 <gmtime_r+0x174>)
   1fb7e:	0028      	movs	r0, r5
   1fb80:	18ff      	adds	r7, r7, r3
   1fb82:	9b03      	ldr	r3, [sp, #12]
   1fb84:	61ec      	str	r4, [r5, #28]
   1fb86:	60eb      	str	r3, [r5, #12]
   1fb88:	2300      	movs	r3, #0
   1fb8a:	616f      	str	r7, [r5, #20]
   1fb8c:	612e      	str	r6, [r5, #16]
   1fb8e:	622b      	str	r3, [r5, #32]
   1fb90:	b005      	add	sp, #20
   1fb92:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1fb94:	00015180 	.word	0x00015180
   1fb98:	000afa6c 	.word	0x000afa6c
   1fb9c:	000afa6b 	.word	0x000afa6b
   1fba0:	00023ab1 	.word	0x00023ab1
   1fba4:	fffdc54f 	.word	0xfffdc54f
   1fba8:	00008eac 	.word	0x00008eac
   1fbac:	000005b4 	.word	0x000005b4
   1fbb0:	00023ab0 	.word	0x00023ab0
   1fbb4:	00008e94 	.word	0x00008e94
   1fbb8:	fffff894 	.word	0xfffff894

0001fbbc <__ssputs_r>:
   1fbbc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1fbbe:	688e      	ldr	r6, [r1, #8]
   1fbc0:	b085      	sub	sp, #20
   1fbc2:	0007      	movs	r7, r0
   1fbc4:	000c      	movs	r4, r1
   1fbc6:	9203      	str	r2, [sp, #12]
   1fbc8:	9301      	str	r3, [sp, #4]
   1fbca:	429e      	cmp	r6, r3
   1fbcc:	d843      	bhi.n	1fc56 <__ssputs_r+0x9a>
   1fbce:	2390      	movs	r3, #144	; 0x90
   1fbd0:	898a      	ldrh	r2, [r1, #12]
   1fbd2:	00db      	lsls	r3, r3, #3
   1fbd4:	421a      	tst	r2, r3
   1fbd6:	d03e      	beq.n	1fc56 <__ssputs_r+0x9a>
   1fbd8:	2503      	movs	r5, #3
   1fbda:	6909      	ldr	r1, [r1, #16]
   1fbdc:	6823      	ldr	r3, [r4, #0]
   1fbde:	9801      	ldr	r0, [sp, #4]
   1fbe0:	1a5b      	subs	r3, r3, r1
   1fbe2:	9302      	str	r3, [sp, #8]
   1fbe4:	6963      	ldr	r3, [r4, #20]
   1fbe6:	435d      	muls	r5, r3
   1fbe8:	0feb      	lsrs	r3, r5, #31
   1fbea:	195d      	adds	r5, r3, r5
   1fbec:	9b02      	ldr	r3, [sp, #8]
   1fbee:	106d      	asrs	r5, r5, #1
   1fbf0:	3301      	adds	r3, #1
   1fbf2:	181b      	adds	r3, r3, r0
   1fbf4:	42ab      	cmp	r3, r5
   1fbf6:	d900      	bls.n	1fbfa <__ssputs_r+0x3e>
   1fbf8:	001d      	movs	r5, r3
   1fbfa:	0553      	lsls	r3, r2, #21
   1fbfc:	d510      	bpl.n	1fc20 <__ssputs_r+0x64>
   1fbfe:	0029      	movs	r1, r5
   1fc00:	0038      	movs	r0, r7
   1fc02:	f7ff fbe9 	bl	1f3d8 <_malloc_r>
   1fc06:	1e06      	subs	r6, r0, #0
   1fc08:	d014      	beq.n	1fc34 <__ssputs_r+0x78>
   1fc0a:	9a02      	ldr	r2, [sp, #8]
   1fc0c:	6921      	ldr	r1, [r4, #16]
   1fc0e:	f7ff f944 	bl	1ee9a <memcpy>
   1fc12:	89a2      	ldrh	r2, [r4, #12]
   1fc14:	4b19      	ldr	r3, [pc, #100]	; (1fc7c <__ssputs_r+0xc0>)
   1fc16:	4013      	ands	r3, r2
   1fc18:	2280      	movs	r2, #128	; 0x80
   1fc1a:	4313      	orrs	r3, r2
   1fc1c:	81a3      	strh	r3, [r4, #12]
   1fc1e:	e012      	b.n	1fc46 <__ssputs_r+0x8a>
   1fc20:	002a      	movs	r2, r5
   1fc22:	0038      	movs	r0, r7
   1fc24:	f000 fbb2 	bl	2038c <_realloc_r>
   1fc28:	1e06      	subs	r6, r0, #0
   1fc2a:	d10c      	bne.n	1fc46 <__ssputs_r+0x8a>
   1fc2c:	6921      	ldr	r1, [r4, #16]
   1fc2e:	0038      	movs	r0, r7
   1fc30:	f7ff fb8c 	bl	1f34c <_free_r>
   1fc34:	230c      	movs	r3, #12
   1fc36:	2240      	movs	r2, #64	; 0x40
   1fc38:	2001      	movs	r0, #1
   1fc3a:	603b      	str	r3, [r7, #0]
   1fc3c:	89a3      	ldrh	r3, [r4, #12]
   1fc3e:	4240      	negs	r0, r0
   1fc40:	4313      	orrs	r3, r2
   1fc42:	81a3      	strh	r3, [r4, #12]
   1fc44:	e017      	b.n	1fc76 <__ssputs_r+0xba>
   1fc46:	9b02      	ldr	r3, [sp, #8]
   1fc48:	6126      	str	r6, [r4, #16]
   1fc4a:	18f6      	adds	r6, r6, r3
   1fc4c:	6026      	str	r6, [r4, #0]
   1fc4e:	6165      	str	r5, [r4, #20]
   1fc50:	9e01      	ldr	r6, [sp, #4]
   1fc52:	1aed      	subs	r5, r5, r3
   1fc54:	60a5      	str	r5, [r4, #8]
   1fc56:	9b01      	ldr	r3, [sp, #4]
   1fc58:	42b3      	cmp	r3, r6
   1fc5a:	d200      	bcs.n	1fc5e <__ssputs_r+0xa2>
   1fc5c:	001e      	movs	r6, r3
   1fc5e:	0032      	movs	r2, r6
   1fc60:	9903      	ldr	r1, [sp, #12]
   1fc62:	6820      	ldr	r0, [r4, #0]
   1fc64:	f000 fb7d 	bl	20362 <memmove>
   1fc68:	2000      	movs	r0, #0
   1fc6a:	68a3      	ldr	r3, [r4, #8]
   1fc6c:	1b9b      	subs	r3, r3, r6
   1fc6e:	60a3      	str	r3, [r4, #8]
   1fc70:	6823      	ldr	r3, [r4, #0]
   1fc72:	199e      	adds	r6, r3, r6
   1fc74:	6026      	str	r6, [r4, #0]
   1fc76:	b005      	add	sp, #20
   1fc78:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1fc7a:	46c0      	nop			; (mov r8, r8)
   1fc7c:	fffffb7f 	.word	0xfffffb7f

0001fc80 <_svfiprintf_r>:
   1fc80:	b5f0      	push	{r4, r5, r6, r7, lr}
   1fc82:	b09f      	sub	sp, #124	; 0x7c
   1fc84:	9002      	str	r0, [sp, #8]
   1fc86:	9305      	str	r3, [sp, #20]
   1fc88:	898b      	ldrh	r3, [r1, #12]
   1fc8a:	000f      	movs	r7, r1
   1fc8c:	0016      	movs	r6, r2
   1fc8e:	061b      	lsls	r3, r3, #24
   1fc90:	d510      	bpl.n	1fcb4 <_svfiprintf_r+0x34>
   1fc92:	690b      	ldr	r3, [r1, #16]
   1fc94:	2b00      	cmp	r3, #0
   1fc96:	d10d      	bne.n	1fcb4 <_svfiprintf_r+0x34>
   1fc98:	2140      	movs	r1, #64	; 0x40
   1fc9a:	f7ff fb9d 	bl	1f3d8 <_malloc_r>
   1fc9e:	6038      	str	r0, [r7, #0]
   1fca0:	6138      	str	r0, [r7, #16]
   1fca2:	2800      	cmp	r0, #0
   1fca4:	d104      	bne.n	1fcb0 <_svfiprintf_r+0x30>
   1fca6:	230c      	movs	r3, #12
   1fca8:	9a02      	ldr	r2, [sp, #8]
   1fcaa:	3801      	subs	r0, #1
   1fcac:	6013      	str	r3, [r2, #0]
   1fcae:	e0d8      	b.n	1fe62 <_svfiprintf_r+0x1e2>
   1fcb0:	2340      	movs	r3, #64	; 0x40
   1fcb2:	617b      	str	r3, [r7, #20]
   1fcb4:	2300      	movs	r3, #0
   1fcb6:	ad06      	add	r5, sp, #24
   1fcb8:	616b      	str	r3, [r5, #20]
   1fcba:	3320      	adds	r3, #32
   1fcbc:	766b      	strb	r3, [r5, #25]
   1fcbe:	3310      	adds	r3, #16
   1fcc0:	76ab      	strb	r3, [r5, #26]
   1fcc2:	0034      	movs	r4, r6
   1fcc4:	7823      	ldrb	r3, [r4, #0]
   1fcc6:	2b00      	cmp	r3, #0
   1fcc8:	d103      	bne.n	1fcd2 <_svfiprintf_r+0x52>
   1fcca:	1ba3      	subs	r3, r4, r6
   1fccc:	9304      	str	r3, [sp, #16]
   1fcce:	d012      	beq.n	1fcf6 <_svfiprintf_r+0x76>
   1fcd0:	e003      	b.n	1fcda <_svfiprintf_r+0x5a>
   1fcd2:	2b25      	cmp	r3, #37	; 0x25
   1fcd4:	d0f9      	beq.n	1fcca <_svfiprintf_r+0x4a>
   1fcd6:	3401      	adds	r4, #1
   1fcd8:	e7f4      	b.n	1fcc4 <_svfiprintf_r+0x44>
   1fcda:	1ba3      	subs	r3, r4, r6
   1fcdc:	0032      	movs	r2, r6
   1fcde:	0039      	movs	r1, r7
   1fce0:	9802      	ldr	r0, [sp, #8]
   1fce2:	f7ff ff6b 	bl	1fbbc <__ssputs_r>
   1fce6:	1c43      	adds	r3, r0, #1
   1fce8:	d100      	bne.n	1fcec <_svfiprintf_r+0x6c>
   1fcea:	e0b4      	b.n	1fe56 <_svfiprintf_r+0x1d6>
   1fcec:	696a      	ldr	r2, [r5, #20]
   1fcee:	9b04      	ldr	r3, [sp, #16]
   1fcf0:	4694      	mov	ip, r2
   1fcf2:	4463      	add	r3, ip
   1fcf4:	616b      	str	r3, [r5, #20]
   1fcf6:	7823      	ldrb	r3, [r4, #0]
   1fcf8:	2b00      	cmp	r3, #0
   1fcfa:	d100      	bne.n	1fcfe <_svfiprintf_r+0x7e>
   1fcfc:	e0ab      	b.n	1fe56 <_svfiprintf_r+0x1d6>
   1fcfe:	2201      	movs	r2, #1
   1fd00:	2300      	movs	r3, #0
   1fd02:	4252      	negs	r2, r2
   1fd04:	606a      	str	r2, [r5, #4]
   1fd06:	a902      	add	r1, sp, #8
   1fd08:	3254      	adds	r2, #84	; 0x54
   1fd0a:	1852      	adds	r2, r2, r1
   1fd0c:	3401      	adds	r4, #1
   1fd0e:	602b      	str	r3, [r5, #0]
   1fd10:	60eb      	str	r3, [r5, #12]
   1fd12:	60ab      	str	r3, [r5, #8]
   1fd14:	7013      	strb	r3, [r2, #0]
   1fd16:	65ab      	str	r3, [r5, #88]	; 0x58
   1fd18:	4e53      	ldr	r6, [pc, #332]	; (1fe68 <_svfiprintf_r+0x1e8>)
   1fd1a:	7821      	ldrb	r1, [r4, #0]
   1fd1c:	2205      	movs	r2, #5
   1fd1e:	0030      	movs	r0, r6
   1fd20:	f000 fb14 	bl	2034c <memchr>
   1fd24:	2800      	cmp	r0, #0
   1fd26:	d007      	beq.n	1fd38 <_svfiprintf_r+0xb8>
   1fd28:	2301      	movs	r3, #1
   1fd2a:	1b80      	subs	r0, r0, r6
   1fd2c:	4083      	lsls	r3, r0
   1fd2e:	682a      	ldr	r2, [r5, #0]
   1fd30:	3401      	adds	r4, #1
   1fd32:	4313      	orrs	r3, r2
   1fd34:	602b      	str	r3, [r5, #0]
   1fd36:	e7ef      	b.n	1fd18 <_svfiprintf_r+0x98>
   1fd38:	682b      	ldr	r3, [r5, #0]
   1fd3a:	06da      	lsls	r2, r3, #27
   1fd3c:	d504      	bpl.n	1fd48 <_svfiprintf_r+0xc8>
   1fd3e:	2253      	movs	r2, #83	; 0x53
   1fd40:	2120      	movs	r1, #32
   1fd42:	a802      	add	r0, sp, #8
   1fd44:	1812      	adds	r2, r2, r0
   1fd46:	7011      	strb	r1, [r2, #0]
   1fd48:	071a      	lsls	r2, r3, #28
   1fd4a:	d504      	bpl.n	1fd56 <_svfiprintf_r+0xd6>
   1fd4c:	2253      	movs	r2, #83	; 0x53
   1fd4e:	212b      	movs	r1, #43	; 0x2b
   1fd50:	a802      	add	r0, sp, #8
   1fd52:	1812      	adds	r2, r2, r0
   1fd54:	7011      	strb	r1, [r2, #0]
   1fd56:	7822      	ldrb	r2, [r4, #0]
   1fd58:	2a2a      	cmp	r2, #42	; 0x2a
   1fd5a:	d003      	beq.n	1fd64 <_svfiprintf_r+0xe4>
   1fd5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1fd5e:	2000      	movs	r0, #0
   1fd60:	210a      	movs	r1, #10
   1fd62:	e00e      	b.n	1fd82 <_svfiprintf_r+0x102>
   1fd64:	9a05      	ldr	r2, [sp, #20]
   1fd66:	1d11      	adds	r1, r2, #4
   1fd68:	6812      	ldr	r2, [r2, #0]
   1fd6a:	9105      	str	r1, [sp, #20]
   1fd6c:	2a00      	cmp	r2, #0
   1fd6e:	db01      	blt.n	1fd74 <_svfiprintf_r+0xf4>
   1fd70:	9209      	str	r2, [sp, #36]	; 0x24
   1fd72:	e004      	b.n	1fd7e <_svfiprintf_r+0xfe>
   1fd74:	4252      	negs	r2, r2
   1fd76:	60ea      	str	r2, [r5, #12]
   1fd78:	2202      	movs	r2, #2
   1fd7a:	4313      	orrs	r3, r2
   1fd7c:	602b      	str	r3, [r5, #0]
   1fd7e:	3401      	adds	r4, #1
   1fd80:	e00b      	b.n	1fd9a <_svfiprintf_r+0x11a>
   1fd82:	7822      	ldrb	r2, [r4, #0]
   1fd84:	3a30      	subs	r2, #48	; 0x30
   1fd86:	2a09      	cmp	r2, #9
   1fd88:	d804      	bhi.n	1fd94 <_svfiprintf_r+0x114>
   1fd8a:	434b      	muls	r3, r1
   1fd8c:	3401      	adds	r4, #1
   1fd8e:	189b      	adds	r3, r3, r2
   1fd90:	2001      	movs	r0, #1
   1fd92:	e7f6      	b.n	1fd82 <_svfiprintf_r+0x102>
   1fd94:	2800      	cmp	r0, #0
   1fd96:	d000      	beq.n	1fd9a <_svfiprintf_r+0x11a>
   1fd98:	9309      	str	r3, [sp, #36]	; 0x24
   1fd9a:	7823      	ldrb	r3, [r4, #0]
   1fd9c:	2b2e      	cmp	r3, #46	; 0x2e
   1fd9e:	d11e      	bne.n	1fdde <_svfiprintf_r+0x15e>
   1fda0:	7863      	ldrb	r3, [r4, #1]
   1fda2:	2b2a      	cmp	r3, #42	; 0x2a
   1fda4:	d10a      	bne.n	1fdbc <_svfiprintf_r+0x13c>
   1fda6:	9b05      	ldr	r3, [sp, #20]
   1fda8:	3402      	adds	r4, #2
   1fdaa:	1d1a      	adds	r2, r3, #4
   1fdac:	681b      	ldr	r3, [r3, #0]
   1fdae:	9205      	str	r2, [sp, #20]
   1fdb0:	2b00      	cmp	r3, #0
   1fdb2:	da01      	bge.n	1fdb8 <_svfiprintf_r+0x138>
   1fdb4:	2301      	movs	r3, #1
   1fdb6:	425b      	negs	r3, r3
   1fdb8:	9307      	str	r3, [sp, #28]
   1fdba:	e010      	b.n	1fdde <_svfiprintf_r+0x15e>
   1fdbc:	2300      	movs	r3, #0
   1fdbe:	200a      	movs	r0, #10
   1fdc0:	001a      	movs	r2, r3
   1fdc2:	3401      	adds	r4, #1
   1fdc4:	606b      	str	r3, [r5, #4]
   1fdc6:	7821      	ldrb	r1, [r4, #0]
   1fdc8:	3930      	subs	r1, #48	; 0x30
   1fdca:	2909      	cmp	r1, #9
   1fdcc:	d804      	bhi.n	1fdd8 <_svfiprintf_r+0x158>
   1fdce:	4342      	muls	r2, r0
   1fdd0:	3401      	adds	r4, #1
   1fdd2:	1852      	adds	r2, r2, r1
   1fdd4:	2301      	movs	r3, #1
   1fdd6:	e7f6      	b.n	1fdc6 <_svfiprintf_r+0x146>
   1fdd8:	2b00      	cmp	r3, #0
   1fdda:	d000      	beq.n	1fdde <_svfiprintf_r+0x15e>
   1fddc:	9207      	str	r2, [sp, #28]
   1fdde:	4e23      	ldr	r6, [pc, #140]	; (1fe6c <_svfiprintf_r+0x1ec>)
   1fde0:	7821      	ldrb	r1, [r4, #0]
   1fde2:	2203      	movs	r2, #3
   1fde4:	0030      	movs	r0, r6
   1fde6:	f000 fab1 	bl	2034c <memchr>
   1fdea:	2800      	cmp	r0, #0
   1fdec:	d006      	beq.n	1fdfc <_svfiprintf_r+0x17c>
   1fdee:	2340      	movs	r3, #64	; 0x40
   1fdf0:	1b80      	subs	r0, r0, r6
   1fdf2:	4083      	lsls	r3, r0
   1fdf4:	682a      	ldr	r2, [r5, #0]
   1fdf6:	3401      	adds	r4, #1
   1fdf8:	4313      	orrs	r3, r2
   1fdfa:	602b      	str	r3, [r5, #0]
   1fdfc:	7821      	ldrb	r1, [r4, #0]
   1fdfe:	2206      	movs	r2, #6
   1fe00:	481b      	ldr	r0, [pc, #108]	; (1fe70 <_svfiprintf_r+0x1f0>)
   1fe02:	1c66      	adds	r6, r4, #1
   1fe04:	7629      	strb	r1, [r5, #24]
   1fe06:	f000 faa1 	bl	2034c <memchr>
   1fe0a:	2800      	cmp	r0, #0
   1fe0c:	d012      	beq.n	1fe34 <_svfiprintf_r+0x1b4>
   1fe0e:	4b19      	ldr	r3, [pc, #100]	; (1fe74 <_svfiprintf_r+0x1f4>)
   1fe10:	2b00      	cmp	r3, #0
   1fe12:	d106      	bne.n	1fe22 <_svfiprintf_r+0x1a2>
   1fe14:	2207      	movs	r2, #7
   1fe16:	9b05      	ldr	r3, [sp, #20]
   1fe18:	3307      	adds	r3, #7
   1fe1a:	4393      	bics	r3, r2
   1fe1c:	3308      	adds	r3, #8
   1fe1e:	9305      	str	r3, [sp, #20]
   1fe20:	e014      	b.n	1fe4c <_svfiprintf_r+0x1cc>
   1fe22:	ab05      	add	r3, sp, #20
   1fe24:	9300      	str	r3, [sp, #0]
   1fe26:	003a      	movs	r2, r7
   1fe28:	4b13      	ldr	r3, [pc, #76]	; (1fe78 <_svfiprintf_r+0x1f8>)
   1fe2a:	0029      	movs	r1, r5
   1fe2c:	9802      	ldr	r0, [sp, #8]
   1fe2e:	e000      	b.n	1fe32 <_svfiprintf_r+0x1b2>
   1fe30:	bf00      	nop
   1fe32:	e007      	b.n	1fe44 <_svfiprintf_r+0x1c4>
   1fe34:	ab05      	add	r3, sp, #20
   1fe36:	9300      	str	r3, [sp, #0]
   1fe38:	003a      	movs	r2, r7
   1fe3a:	4b0f      	ldr	r3, [pc, #60]	; (1fe78 <_svfiprintf_r+0x1f8>)
   1fe3c:	0029      	movs	r1, r5
   1fe3e:	9802      	ldr	r0, [sp, #8]
   1fe40:	f000 f88a 	bl	1ff58 <_printf_i>
   1fe44:	9003      	str	r0, [sp, #12]
   1fe46:	9b03      	ldr	r3, [sp, #12]
   1fe48:	3301      	adds	r3, #1
   1fe4a:	d004      	beq.n	1fe56 <_svfiprintf_r+0x1d6>
   1fe4c:	696b      	ldr	r3, [r5, #20]
   1fe4e:	9a03      	ldr	r2, [sp, #12]
   1fe50:	189b      	adds	r3, r3, r2
   1fe52:	616b      	str	r3, [r5, #20]
   1fe54:	e735      	b.n	1fcc2 <_svfiprintf_r+0x42>
   1fe56:	89bb      	ldrh	r3, [r7, #12]
   1fe58:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1fe5a:	065b      	lsls	r3, r3, #25
   1fe5c:	d501      	bpl.n	1fe62 <_svfiprintf_r+0x1e2>
   1fe5e:	2001      	movs	r0, #1
   1fe60:	4240      	negs	r0, r0
   1fe62:	b01f      	add	sp, #124	; 0x7c
   1fe64:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1fe66:	46c0      	nop			; (mov r8, r8)
   1fe68:	00021fdc 	.word	0x00021fdc
   1fe6c:	00021fe2 	.word	0x00021fe2
   1fe70:	00021fe6 	.word	0x00021fe6
   1fe74:	00000000 	.word	0x00000000
   1fe78:	0001fbbd 	.word	0x0001fbbd

0001fe7c <_printf_common>:
   1fe7c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1fe7e:	0017      	movs	r7, r2
   1fe80:	9301      	str	r3, [sp, #4]
   1fe82:	688a      	ldr	r2, [r1, #8]
   1fe84:	690b      	ldr	r3, [r1, #16]
   1fe86:	9000      	str	r0, [sp, #0]
   1fe88:	000c      	movs	r4, r1
   1fe8a:	4293      	cmp	r3, r2
   1fe8c:	da00      	bge.n	1fe90 <_printf_common+0x14>
   1fe8e:	0013      	movs	r3, r2
   1fe90:	0022      	movs	r2, r4
   1fe92:	603b      	str	r3, [r7, #0]
   1fe94:	3243      	adds	r2, #67	; 0x43
   1fe96:	7812      	ldrb	r2, [r2, #0]
   1fe98:	2a00      	cmp	r2, #0
   1fe9a:	d001      	beq.n	1fea0 <_printf_common+0x24>
   1fe9c:	3301      	adds	r3, #1
   1fe9e:	603b      	str	r3, [r7, #0]
   1fea0:	6823      	ldr	r3, [r4, #0]
   1fea2:	069b      	lsls	r3, r3, #26
   1fea4:	d502      	bpl.n	1feac <_printf_common+0x30>
   1fea6:	683b      	ldr	r3, [r7, #0]
   1fea8:	3302      	adds	r3, #2
   1feaa:	603b      	str	r3, [r7, #0]
   1feac:	2506      	movs	r5, #6
   1feae:	6823      	ldr	r3, [r4, #0]
   1feb0:	401d      	ands	r5, r3
   1feb2:	d01e      	beq.n	1fef2 <_printf_common+0x76>
   1feb4:	0023      	movs	r3, r4
   1feb6:	3343      	adds	r3, #67	; 0x43
   1feb8:	781b      	ldrb	r3, [r3, #0]
   1feba:	1e5a      	subs	r2, r3, #1
   1febc:	4193      	sbcs	r3, r2
   1febe:	6822      	ldr	r2, [r4, #0]
   1fec0:	0692      	lsls	r2, r2, #26
   1fec2:	d51c      	bpl.n	1fefe <_printf_common+0x82>
   1fec4:	2030      	movs	r0, #48	; 0x30
   1fec6:	18e1      	adds	r1, r4, r3
   1fec8:	3143      	adds	r1, #67	; 0x43
   1feca:	7008      	strb	r0, [r1, #0]
   1fecc:	0021      	movs	r1, r4
   1fece:	1c5a      	adds	r2, r3, #1
   1fed0:	3145      	adds	r1, #69	; 0x45
   1fed2:	7809      	ldrb	r1, [r1, #0]
   1fed4:	18a2      	adds	r2, r4, r2
   1fed6:	3243      	adds	r2, #67	; 0x43
   1fed8:	3302      	adds	r3, #2
   1feda:	7011      	strb	r1, [r2, #0]
   1fedc:	e00f      	b.n	1fefe <_printf_common+0x82>
   1fede:	0022      	movs	r2, r4
   1fee0:	2301      	movs	r3, #1
   1fee2:	3219      	adds	r2, #25
   1fee4:	9901      	ldr	r1, [sp, #4]
   1fee6:	9800      	ldr	r0, [sp, #0]
   1fee8:	9e08      	ldr	r6, [sp, #32]
   1feea:	47b0      	blx	r6
   1feec:	1c43      	adds	r3, r0, #1
   1feee:	d00e      	beq.n	1ff0e <_printf_common+0x92>
   1fef0:	3501      	adds	r5, #1
   1fef2:	68e3      	ldr	r3, [r4, #12]
   1fef4:	683a      	ldr	r2, [r7, #0]
   1fef6:	1a9b      	subs	r3, r3, r2
   1fef8:	429d      	cmp	r5, r3
   1fefa:	dbf0      	blt.n	1fede <_printf_common+0x62>
   1fefc:	e7da      	b.n	1feb4 <_printf_common+0x38>
   1fefe:	0022      	movs	r2, r4
   1ff00:	9901      	ldr	r1, [sp, #4]
   1ff02:	3243      	adds	r2, #67	; 0x43
   1ff04:	9800      	ldr	r0, [sp, #0]
   1ff06:	9d08      	ldr	r5, [sp, #32]
   1ff08:	47a8      	blx	r5
   1ff0a:	1c43      	adds	r3, r0, #1
   1ff0c:	d102      	bne.n	1ff14 <_printf_common+0x98>
   1ff0e:	2001      	movs	r0, #1
   1ff10:	4240      	negs	r0, r0
   1ff12:	e020      	b.n	1ff56 <_printf_common+0xda>
   1ff14:	2306      	movs	r3, #6
   1ff16:	6820      	ldr	r0, [r4, #0]
   1ff18:	68e1      	ldr	r1, [r4, #12]
   1ff1a:	683a      	ldr	r2, [r7, #0]
   1ff1c:	4003      	ands	r3, r0
   1ff1e:	2500      	movs	r5, #0
   1ff20:	2b04      	cmp	r3, #4
   1ff22:	d103      	bne.n	1ff2c <_printf_common+0xb0>
   1ff24:	1a8d      	subs	r5, r1, r2
   1ff26:	43eb      	mvns	r3, r5
   1ff28:	17db      	asrs	r3, r3, #31
   1ff2a:	401d      	ands	r5, r3
   1ff2c:	68a3      	ldr	r3, [r4, #8]
   1ff2e:	6922      	ldr	r2, [r4, #16]
   1ff30:	4293      	cmp	r3, r2
   1ff32:	dd01      	ble.n	1ff38 <_printf_common+0xbc>
   1ff34:	1a9b      	subs	r3, r3, r2
   1ff36:	18ed      	adds	r5, r5, r3
   1ff38:	2700      	movs	r7, #0
   1ff3a:	42bd      	cmp	r5, r7
   1ff3c:	d00a      	beq.n	1ff54 <_printf_common+0xd8>
   1ff3e:	0022      	movs	r2, r4
   1ff40:	2301      	movs	r3, #1
   1ff42:	321a      	adds	r2, #26
   1ff44:	9901      	ldr	r1, [sp, #4]
   1ff46:	9800      	ldr	r0, [sp, #0]
   1ff48:	9e08      	ldr	r6, [sp, #32]
   1ff4a:	47b0      	blx	r6
   1ff4c:	1c43      	adds	r3, r0, #1
   1ff4e:	d0de      	beq.n	1ff0e <_printf_common+0x92>
   1ff50:	3701      	adds	r7, #1
   1ff52:	e7f2      	b.n	1ff3a <_printf_common+0xbe>
   1ff54:	2000      	movs	r0, #0
   1ff56:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001ff58 <_printf_i>:
   1ff58:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ff5a:	b08b      	sub	sp, #44	; 0x2c
   1ff5c:	9206      	str	r2, [sp, #24]
   1ff5e:	000a      	movs	r2, r1
   1ff60:	3243      	adds	r2, #67	; 0x43
   1ff62:	9307      	str	r3, [sp, #28]
   1ff64:	9005      	str	r0, [sp, #20]
   1ff66:	9204      	str	r2, [sp, #16]
   1ff68:	7e0a      	ldrb	r2, [r1, #24]
   1ff6a:	000c      	movs	r4, r1
   1ff6c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1ff6e:	2a6e      	cmp	r2, #110	; 0x6e
   1ff70:	d100      	bne.n	1ff74 <_printf_i+0x1c>
   1ff72:	e0ab      	b.n	200cc <_printf_i+0x174>
   1ff74:	d811      	bhi.n	1ff9a <_printf_i+0x42>
   1ff76:	2a63      	cmp	r2, #99	; 0x63
   1ff78:	d022      	beq.n	1ffc0 <_printf_i+0x68>
   1ff7a:	d809      	bhi.n	1ff90 <_printf_i+0x38>
   1ff7c:	2a00      	cmp	r2, #0
   1ff7e:	d100      	bne.n	1ff82 <_printf_i+0x2a>
   1ff80:	e0b5      	b.n	200ee <_printf_i+0x196>
   1ff82:	2a58      	cmp	r2, #88	; 0x58
   1ff84:	d000      	beq.n	1ff88 <_printf_i+0x30>
   1ff86:	e0c5      	b.n	20114 <_printf_i+0x1bc>
   1ff88:	3145      	adds	r1, #69	; 0x45
   1ff8a:	700a      	strb	r2, [r1, #0]
   1ff8c:	4a81      	ldr	r2, [pc, #516]	; (20194 <_printf_i+0x23c>)
   1ff8e:	e04f      	b.n	20030 <_printf_i+0xd8>
   1ff90:	2a64      	cmp	r2, #100	; 0x64
   1ff92:	d01d      	beq.n	1ffd0 <_printf_i+0x78>
   1ff94:	2a69      	cmp	r2, #105	; 0x69
   1ff96:	d01b      	beq.n	1ffd0 <_printf_i+0x78>
   1ff98:	e0bc      	b.n	20114 <_printf_i+0x1bc>
   1ff9a:	2a73      	cmp	r2, #115	; 0x73
   1ff9c:	d100      	bne.n	1ffa0 <_printf_i+0x48>
   1ff9e:	e0aa      	b.n	200f6 <_printf_i+0x19e>
   1ffa0:	d809      	bhi.n	1ffb6 <_printf_i+0x5e>
   1ffa2:	2a6f      	cmp	r2, #111	; 0x6f
   1ffa4:	d029      	beq.n	1fffa <_printf_i+0xa2>
   1ffa6:	2a70      	cmp	r2, #112	; 0x70
   1ffa8:	d000      	beq.n	1ffac <_printf_i+0x54>
   1ffaa:	e0b3      	b.n	20114 <_printf_i+0x1bc>
   1ffac:	2220      	movs	r2, #32
   1ffae:	6809      	ldr	r1, [r1, #0]
   1ffb0:	430a      	orrs	r2, r1
   1ffb2:	6022      	str	r2, [r4, #0]
   1ffb4:	e037      	b.n	20026 <_printf_i+0xce>
   1ffb6:	2a75      	cmp	r2, #117	; 0x75
   1ffb8:	d01f      	beq.n	1fffa <_printf_i+0xa2>
   1ffba:	2a78      	cmp	r2, #120	; 0x78
   1ffbc:	d033      	beq.n	20026 <_printf_i+0xce>
   1ffbe:	e0a9      	b.n	20114 <_printf_i+0x1bc>
   1ffc0:	000e      	movs	r6, r1
   1ffc2:	681a      	ldr	r2, [r3, #0]
   1ffc4:	3642      	adds	r6, #66	; 0x42
   1ffc6:	1d11      	adds	r1, r2, #4
   1ffc8:	6019      	str	r1, [r3, #0]
   1ffca:	6813      	ldr	r3, [r2, #0]
   1ffcc:	7033      	strb	r3, [r6, #0]
   1ffce:	e0a4      	b.n	2011a <_printf_i+0x1c2>
   1ffd0:	6821      	ldr	r1, [r4, #0]
   1ffd2:	681a      	ldr	r2, [r3, #0]
   1ffd4:	0608      	lsls	r0, r1, #24
   1ffd6:	d406      	bmi.n	1ffe6 <_printf_i+0x8e>
   1ffd8:	0649      	lsls	r1, r1, #25
   1ffda:	d504      	bpl.n	1ffe6 <_printf_i+0x8e>
   1ffdc:	1d11      	adds	r1, r2, #4
   1ffde:	6019      	str	r1, [r3, #0]
   1ffe0:	2300      	movs	r3, #0
   1ffe2:	5ed5      	ldrsh	r5, [r2, r3]
   1ffe4:	e002      	b.n	1ffec <_printf_i+0x94>
   1ffe6:	1d11      	adds	r1, r2, #4
   1ffe8:	6019      	str	r1, [r3, #0]
   1ffea:	6815      	ldr	r5, [r2, #0]
   1ffec:	2d00      	cmp	r5, #0
   1ffee:	da3b      	bge.n	20068 <_printf_i+0x110>
   1fff0:	232d      	movs	r3, #45	; 0x2d
   1fff2:	9a04      	ldr	r2, [sp, #16]
   1fff4:	426d      	negs	r5, r5
   1fff6:	7013      	strb	r3, [r2, #0]
   1fff8:	e036      	b.n	20068 <_printf_i+0x110>
   1fffa:	6821      	ldr	r1, [r4, #0]
   1fffc:	681a      	ldr	r2, [r3, #0]
   1fffe:	0608      	lsls	r0, r1, #24
   20000:	d406      	bmi.n	20010 <_printf_i+0xb8>
   20002:	0649      	lsls	r1, r1, #25
   20004:	d504      	bpl.n	20010 <_printf_i+0xb8>
   20006:	6815      	ldr	r5, [r2, #0]
   20008:	1d11      	adds	r1, r2, #4
   2000a:	6019      	str	r1, [r3, #0]
   2000c:	b2ad      	uxth	r5, r5
   2000e:	e002      	b.n	20016 <_printf_i+0xbe>
   20010:	1d11      	adds	r1, r2, #4
   20012:	6019      	str	r1, [r3, #0]
   20014:	6815      	ldr	r5, [r2, #0]
   20016:	4b5f      	ldr	r3, [pc, #380]	; (20194 <_printf_i+0x23c>)
   20018:	7e22      	ldrb	r2, [r4, #24]
   2001a:	9303      	str	r3, [sp, #12]
   2001c:	2708      	movs	r7, #8
   2001e:	2a6f      	cmp	r2, #111	; 0x6f
   20020:	d01d      	beq.n	2005e <_printf_i+0x106>
   20022:	270a      	movs	r7, #10
   20024:	e01b      	b.n	2005e <_printf_i+0x106>
   20026:	0022      	movs	r2, r4
   20028:	2178      	movs	r1, #120	; 0x78
   2002a:	3245      	adds	r2, #69	; 0x45
   2002c:	7011      	strb	r1, [r2, #0]
   2002e:	4a5a      	ldr	r2, [pc, #360]	; (20198 <_printf_i+0x240>)
   20030:	6819      	ldr	r1, [r3, #0]
   20032:	9203      	str	r2, [sp, #12]
   20034:	1d08      	adds	r0, r1, #4
   20036:	6822      	ldr	r2, [r4, #0]
   20038:	6018      	str	r0, [r3, #0]
   2003a:	680d      	ldr	r5, [r1, #0]
   2003c:	0610      	lsls	r0, r2, #24
   2003e:	d402      	bmi.n	20046 <_printf_i+0xee>
   20040:	0650      	lsls	r0, r2, #25
   20042:	d500      	bpl.n	20046 <_printf_i+0xee>
   20044:	b2ad      	uxth	r5, r5
   20046:	07d3      	lsls	r3, r2, #31
   20048:	d502      	bpl.n	20050 <_printf_i+0xf8>
   2004a:	2320      	movs	r3, #32
   2004c:	431a      	orrs	r2, r3
   2004e:	6022      	str	r2, [r4, #0]
   20050:	2710      	movs	r7, #16
   20052:	2d00      	cmp	r5, #0
   20054:	d103      	bne.n	2005e <_printf_i+0x106>
   20056:	2320      	movs	r3, #32
   20058:	6822      	ldr	r2, [r4, #0]
   2005a:	439a      	bics	r2, r3
   2005c:	6022      	str	r2, [r4, #0]
   2005e:	0023      	movs	r3, r4
   20060:	2200      	movs	r2, #0
   20062:	3343      	adds	r3, #67	; 0x43
   20064:	701a      	strb	r2, [r3, #0]
   20066:	e002      	b.n	2006e <_printf_i+0x116>
   20068:	270a      	movs	r7, #10
   2006a:	4b4a      	ldr	r3, [pc, #296]	; (20194 <_printf_i+0x23c>)
   2006c:	9303      	str	r3, [sp, #12]
   2006e:	6863      	ldr	r3, [r4, #4]
   20070:	60a3      	str	r3, [r4, #8]
   20072:	2b00      	cmp	r3, #0
   20074:	db09      	blt.n	2008a <_printf_i+0x132>
   20076:	2204      	movs	r2, #4
   20078:	6821      	ldr	r1, [r4, #0]
   2007a:	4391      	bics	r1, r2
   2007c:	6021      	str	r1, [r4, #0]
   2007e:	2d00      	cmp	r5, #0
   20080:	d105      	bne.n	2008e <_printf_i+0x136>
   20082:	9e04      	ldr	r6, [sp, #16]
   20084:	2b00      	cmp	r3, #0
   20086:	d011      	beq.n	200ac <_printf_i+0x154>
   20088:	e07b      	b.n	20182 <_printf_i+0x22a>
   2008a:	2d00      	cmp	r5, #0
   2008c:	d079      	beq.n	20182 <_printf_i+0x22a>
   2008e:	9e04      	ldr	r6, [sp, #16]
   20090:	0028      	movs	r0, r5
   20092:	0039      	movs	r1, r7
   20094:	f7fd fa7c 	bl	1d590 <__aeabi_uidivmod>
   20098:	9b03      	ldr	r3, [sp, #12]
   2009a:	3e01      	subs	r6, #1
   2009c:	5c5b      	ldrb	r3, [r3, r1]
   2009e:	0028      	movs	r0, r5
   200a0:	7033      	strb	r3, [r6, #0]
   200a2:	0039      	movs	r1, r7
   200a4:	f7fd f9ee 	bl	1d484 <__aeabi_uidiv>
   200a8:	1e05      	subs	r5, r0, #0
   200aa:	d1f1      	bne.n	20090 <_printf_i+0x138>
   200ac:	2f08      	cmp	r7, #8
   200ae:	d109      	bne.n	200c4 <_printf_i+0x16c>
   200b0:	6823      	ldr	r3, [r4, #0]
   200b2:	07db      	lsls	r3, r3, #31
   200b4:	d506      	bpl.n	200c4 <_printf_i+0x16c>
   200b6:	6863      	ldr	r3, [r4, #4]
   200b8:	6922      	ldr	r2, [r4, #16]
   200ba:	4293      	cmp	r3, r2
   200bc:	dc02      	bgt.n	200c4 <_printf_i+0x16c>
   200be:	2330      	movs	r3, #48	; 0x30
   200c0:	3e01      	subs	r6, #1
   200c2:	7033      	strb	r3, [r6, #0]
   200c4:	9b04      	ldr	r3, [sp, #16]
   200c6:	1b9b      	subs	r3, r3, r6
   200c8:	6123      	str	r3, [r4, #16]
   200ca:	e02b      	b.n	20124 <_printf_i+0x1cc>
   200cc:	6809      	ldr	r1, [r1, #0]
   200ce:	681a      	ldr	r2, [r3, #0]
   200d0:	0608      	lsls	r0, r1, #24
   200d2:	d407      	bmi.n	200e4 <_printf_i+0x18c>
   200d4:	0649      	lsls	r1, r1, #25
   200d6:	d505      	bpl.n	200e4 <_printf_i+0x18c>
   200d8:	1d11      	adds	r1, r2, #4
   200da:	6019      	str	r1, [r3, #0]
   200dc:	6813      	ldr	r3, [r2, #0]
   200de:	8aa2      	ldrh	r2, [r4, #20]
   200e0:	801a      	strh	r2, [r3, #0]
   200e2:	e004      	b.n	200ee <_printf_i+0x196>
   200e4:	1d11      	adds	r1, r2, #4
   200e6:	6019      	str	r1, [r3, #0]
   200e8:	6813      	ldr	r3, [r2, #0]
   200ea:	6962      	ldr	r2, [r4, #20]
   200ec:	601a      	str	r2, [r3, #0]
   200ee:	2300      	movs	r3, #0
   200f0:	9e04      	ldr	r6, [sp, #16]
   200f2:	6123      	str	r3, [r4, #16]
   200f4:	e016      	b.n	20124 <_printf_i+0x1cc>
   200f6:	681a      	ldr	r2, [r3, #0]
   200f8:	1d11      	adds	r1, r2, #4
   200fa:	6019      	str	r1, [r3, #0]
   200fc:	6816      	ldr	r6, [r2, #0]
   200fe:	2100      	movs	r1, #0
   20100:	6862      	ldr	r2, [r4, #4]
   20102:	0030      	movs	r0, r6
   20104:	f000 f922 	bl	2034c <memchr>
   20108:	2800      	cmp	r0, #0
   2010a:	d001      	beq.n	20110 <_printf_i+0x1b8>
   2010c:	1b80      	subs	r0, r0, r6
   2010e:	6060      	str	r0, [r4, #4]
   20110:	6863      	ldr	r3, [r4, #4]
   20112:	e003      	b.n	2011c <_printf_i+0x1c4>
   20114:	0026      	movs	r6, r4
   20116:	3642      	adds	r6, #66	; 0x42
   20118:	7032      	strb	r2, [r6, #0]
   2011a:	2301      	movs	r3, #1
   2011c:	6123      	str	r3, [r4, #16]
   2011e:	2300      	movs	r3, #0
   20120:	9a04      	ldr	r2, [sp, #16]
   20122:	7013      	strb	r3, [r2, #0]
   20124:	9b07      	ldr	r3, [sp, #28]
   20126:	aa09      	add	r2, sp, #36	; 0x24
   20128:	9300      	str	r3, [sp, #0]
   2012a:	0021      	movs	r1, r4
   2012c:	9b06      	ldr	r3, [sp, #24]
   2012e:	9805      	ldr	r0, [sp, #20]
   20130:	f7ff fea4 	bl	1fe7c <_printf_common>
   20134:	1c43      	adds	r3, r0, #1
   20136:	d102      	bne.n	2013e <_printf_i+0x1e6>
   20138:	2001      	movs	r0, #1
   2013a:	4240      	negs	r0, r0
   2013c:	e027      	b.n	2018e <_printf_i+0x236>
   2013e:	6923      	ldr	r3, [r4, #16]
   20140:	0032      	movs	r2, r6
   20142:	9906      	ldr	r1, [sp, #24]
   20144:	9805      	ldr	r0, [sp, #20]
   20146:	9d07      	ldr	r5, [sp, #28]
   20148:	47a8      	blx	r5
   2014a:	1c43      	adds	r3, r0, #1
   2014c:	d0f4      	beq.n	20138 <_printf_i+0x1e0>
   2014e:	6823      	ldr	r3, [r4, #0]
   20150:	2500      	movs	r5, #0
   20152:	079b      	lsls	r3, r3, #30
   20154:	d40f      	bmi.n	20176 <_printf_i+0x21e>
   20156:	9b09      	ldr	r3, [sp, #36]	; 0x24
   20158:	68e0      	ldr	r0, [r4, #12]
   2015a:	4298      	cmp	r0, r3
   2015c:	da17      	bge.n	2018e <_printf_i+0x236>
   2015e:	0018      	movs	r0, r3
   20160:	e015      	b.n	2018e <_printf_i+0x236>
   20162:	0022      	movs	r2, r4
   20164:	2301      	movs	r3, #1
   20166:	3219      	adds	r2, #25
   20168:	9906      	ldr	r1, [sp, #24]
   2016a:	9805      	ldr	r0, [sp, #20]
   2016c:	9e07      	ldr	r6, [sp, #28]
   2016e:	47b0      	blx	r6
   20170:	1c43      	adds	r3, r0, #1
   20172:	d0e1      	beq.n	20138 <_printf_i+0x1e0>
   20174:	3501      	adds	r5, #1
   20176:	68e3      	ldr	r3, [r4, #12]
   20178:	9a09      	ldr	r2, [sp, #36]	; 0x24
   2017a:	1a9b      	subs	r3, r3, r2
   2017c:	429d      	cmp	r5, r3
   2017e:	dbf0      	blt.n	20162 <_printf_i+0x20a>
   20180:	e7e9      	b.n	20156 <_printf_i+0x1fe>
   20182:	0026      	movs	r6, r4
   20184:	9b03      	ldr	r3, [sp, #12]
   20186:	3642      	adds	r6, #66	; 0x42
   20188:	781b      	ldrb	r3, [r3, #0]
   2018a:	7033      	strb	r3, [r6, #0]
   2018c:	e78e      	b.n	200ac <_printf_i+0x154>
   2018e:	b00b      	add	sp, #44	; 0x2c
   20190:	bdf0      	pop	{r4, r5, r6, r7, pc}
   20192:	46c0      	nop			; (mov r8, r8)
   20194:	00021fed 	.word	0x00021fed
   20198:	00021ffe 	.word	0x00021ffe

0002019c <siscanf>:
   2019c:	b40e      	push	{r1, r2, r3}
   2019e:	2381      	movs	r3, #129	; 0x81
   201a0:	b570      	push	{r4, r5, r6, lr}
   201a2:	b09d      	sub	sp, #116	; 0x74
   201a4:	ac02      	add	r4, sp, #8
   201a6:	ad21      	add	r5, sp, #132	; 0x84
   201a8:	009b      	lsls	r3, r3, #2
   201aa:	cd40      	ldmia	r5!, {r6}
   201ac:	81a3      	strh	r3, [r4, #12]
   201ae:	9002      	str	r0, [sp, #8]
   201b0:	9006      	str	r0, [sp, #24]
   201b2:	f7ff f9a3 	bl	1f4fc <strlen>
   201b6:	4b0b      	ldr	r3, [pc, #44]	; (201e4 <siscanf+0x48>)
   201b8:	6060      	str	r0, [r4, #4]
   201ba:	6263      	str	r3, [r4, #36]	; 0x24
   201bc:	2300      	movs	r3, #0
   201be:	6160      	str	r0, [r4, #20]
   201c0:	4809      	ldr	r0, [pc, #36]	; (201e8 <siscanf+0x4c>)
   201c2:	6363      	str	r3, [r4, #52]	; 0x34
   201c4:	64a3      	str	r3, [r4, #72]	; 0x48
   201c6:	3b01      	subs	r3, #1
   201c8:	81e3      	strh	r3, [r4, #14]
   201ca:	0032      	movs	r2, r6
   201cc:	002b      	movs	r3, r5
   201ce:	0021      	movs	r1, r4
   201d0:	6800      	ldr	r0, [r0, #0]
   201d2:	9501      	str	r5, [sp, #4]
   201d4:	f000 f95c 	bl	20490 <__ssvfiscanf_r>
   201d8:	b01d      	add	sp, #116	; 0x74
   201da:	bc70      	pop	{r4, r5, r6}
   201dc:	bc08      	pop	{r3}
   201de:	b003      	add	sp, #12
   201e0:	4718      	bx	r3
   201e2:	46c0      	nop			; (mov r8, r8)
   201e4:	000201ed 	.word	0x000201ed
   201e8:	20000474 	.word	0x20000474

000201ec <__seofread>:
   201ec:	2000      	movs	r0, #0
   201ee:	4770      	bx	lr

000201f0 <strcmp>:
   201f0:	7802      	ldrb	r2, [r0, #0]
   201f2:	780b      	ldrb	r3, [r1, #0]
   201f4:	2a00      	cmp	r2, #0
   201f6:	d003      	beq.n	20200 <strcmp+0x10>
   201f8:	3001      	adds	r0, #1
   201fa:	3101      	adds	r1, #1
   201fc:	429a      	cmp	r2, r3
   201fe:	d0f7      	beq.n	201f0 <strcmp>
   20200:	1ad0      	subs	r0, r2, r3
   20202:	4770      	bx	lr

00020204 <strncmp>:
   20204:	2300      	movs	r3, #0
   20206:	b530      	push	{r4, r5, lr}
   20208:	429a      	cmp	r2, r3
   2020a:	d00b      	beq.n	20224 <strncmp+0x20>
   2020c:	3a01      	subs	r2, #1
   2020e:	5cc4      	ldrb	r4, [r0, r3]
   20210:	5ccd      	ldrb	r5, [r1, r3]
   20212:	42ac      	cmp	r4, r5
   20214:	d105      	bne.n	20222 <strncmp+0x1e>
   20216:	429a      	cmp	r2, r3
   20218:	d002      	beq.n	20220 <strncmp+0x1c>
   2021a:	3301      	adds	r3, #1
   2021c:	2c00      	cmp	r4, #0
   2021e:	d1f6      	bne.n	2020e <strncmp+0xa>
   20220:	0025      	movs	r5, r4
   20222:	1b63      	subs	r3, r4, r5
   20224:	0018      	movs	r0, r3
   20226:	bd30      	pop	{r4, r5, pc}

00020228 <_strtoul_r>:
   20228:	b5f0      	push	{r4, r5, r6, r7, lr}
   2022a:	001e      	movs	r6, r3
   2022c:	4b3f      	ldr	r3, [pc, #252]	; (2032c <_strtoul_r+0x104>)
   2022e:	b087      	sub	sp, #28
   20230:	681b      	ldr	r3, [r3, #0]
   20232:	9104      	str	r1, [sp, #16]
   20234:	9302      	str	r3, [sp, #8]
   20236:	0017      	movs	r7, r2
   20238:	000b      	movs	r3, r1
   2023a:	2108      	movs	r1, #8
   2023c:	9005      	str	r0, [sp, #20]
   2023e:	781c      	ldrb	r4, [r3, #0]
   20240:	9a02      	ldr	r2, [sp, #8]
   20242:	1c5d      	adds	r5, r3, #1
   20244:	1912      	adds	r2, r2, r4
   20246:	7852      	ldrb	r2, [r2, #1]
   20248:	400a      	ands	r2, r1
   2024a:	d001      	beq.n	20250 <_strtoul_r+0x28>
   2024c:	002b      	movs	r3, r5
   2024e:	e7f6      	b.n	2023e <_strtoul_r+0x16>
   20250:	2c2d      	cmp	r4, #45	; 0x2d
   20252:	d104      	bne.n	2025e <_strtoul_r+0x36>
   20254:	1c9d      	adds	r5, r3, #2
   20256:	785c      	ldrb	r4, [r3, #1]
   20258:	2301      	movs	r3, #1
   2025a:	9301      	str	r3, [sp, #4]
   2025c:	e004      	b.n	20268 <_strtoul_r+0x40>
   2025e:	9201      	str	r2, [sp, #4]
   20260:	2c2b      	cmp	r4, #43	; 0x2b
   20262:	d101      	bne.n	20268 <_strtoul_r+0x40>
   20264:	785c      	ldrb	r4, [r3, #1]
   20266:	1c9d      	adds	r5, r3, #2
   20268:	2e00      	cmp	r6, #0
   2026a:	d002      	beq.n	20272 <_strtoul_r+0x4a>
   2026c:	2e10      	cmp	r6, #16
   2026e:	d10a      	bne.n	20286 <_strtoul_r+0x5e>
   20270:	e057      	b.n	20322 <_strtoul_r+0xfa>
   20272:	2c30      	cmp	r4, #48	; 0x30
   20274:	d153      	bne.n	2031e <_strtoul_r+0xf6>
   20276:	2220      	movs	r2, #32
   20278:	782b      	ldrb	r3, [r5, #0]
   2027a:	4393      	bics	r3, r2
   2027c:	2b58      	cmp	r3, #88	; 0x58
   2027e:	d149      	bne.n	20314 <_strtoul_r+0xec>
   20280:	2610      	movs	r6, #16
   20282:	786c      	ldrb	r4, [r5, #1]
   20284:	3502      	adds	r5, #2
   20286:	2001      	movs	r0, #1
   20288:	0031      	movs	r1, r6
   2028a:	4240      	negs	r0, r0
   2028c:	f7fd f8fa 	bl	1d484 <__aeabi_uidiv>
   20290:	9003      	str	r0, [sp, #12]
   20292:	2001      	movs	r0, #1
   20294:	0031      	movs	r1, r6
   20296:	4240      	negs	r0, r0
   20298:	f7fd f97a 	bl	1d590 <__aeabi_uidivmod>
   2029c:	2300      	movs	r3, #0
   2029e:	468c      	mov	ip, r1
   202a0:	0018      	movs	r0, r3
   202a2:	9a02      	ldr	r2, [sp, #8]
   202a4:	1912      	adds	r2, r2, r4
   202a6:	7851      	ldrb	r1, [r2, #1]
   202a8:	2204      	movs	r2, #4
   202aa:	4211      	tst	r1, r2
   202ac:	d001      	beq.n	202b2 <_strtoul_r+0x8a>
   202ae:	3c30      	subs	r4, #48	; 0x30
   202b0:	e007      	b.n	202c2 <_strtoul_r+0x9a>
   202b2:	2203      	movs	r2, #3
   202b4:	4011      	ands	r1, r2
   202b6:	d017      	beq.n	202e8 <_strtoul_r+0xc0>
   202b8:	3234      	adds	r2, #52	; 0x34
   202ba:	2901      	cmp	r1, #1
   202bc:	d000      	beq.n	202c0 <_strtoul_r+0x98>
   202be:	3220      	adds	r2, #32
   202c0:	1aa4      	subs	r4, r4, r2
   202c2:	42a6      	cmp	r6, r4
   202c4:	dd10      	ble.n	202e8 <_strtoul_r+0xc0>
   202c6:	2b00      	cmp	r3, #0
   202c8:	db09      	blt.n	202de <_strtoul_r+0xb6>
   202ca:	9b03      	ldr	r3, [sp, #12]
   202cc:	4298      	cmp	r0, r3
   202ce:	d806      	bhi.n	202de <_strtoul_r+0xb6>
   202d0:	d101      	bne.n	202d6 <_strtoul_r+0xae>
   202d2:	4564      	cmp	r4, ip
   202d4:	dc03      	bgt.n	202de <_strtoul_r+0xb6>
   202d6:	4370      	muls	r0, r6
   202d8:	2301      	movs	r3, #1
   202da:	1820      	adds	r0, r4, r0
   202dc:	e001      	b.n	202e2 <_strtoul_r+0xba>
   202de:	2301      	movs	r3, #1
   202e0:	425b      	negs	r3, r3
   202e2:	782c      	ldrb	r4, [r5, #0]
   202e4:	3501      	adds	r5, #1
   202e6:	e7dc      	b.n	202a2 <_strtoul_r+0x7a>
   202e8:	2b00      	cmp	r3, #0
   202ea:	da07      	bge.n	202fc <_strtoul_r+0xd4>
   202ec:	2322      	movs	r3, #34	; 0x22
   202ee:	2001      	movs	r0, #1
   202f0:	9a05      	ldr	r2, [sp, #20]
   202f2:	4240      	negs	r0, r0
   202f4:	6013      	str	r3, [r2, #0]
   202f6:	2f00      	cmp	r7, #0
   202f8:	d109      	bne.n	2030e <_strtoul_r+0xe6>
   202fa:	e015      	b.n	20328 <_strtoul_r+0x100>
   202fc:	9a01      	ldr	r2, [sp, #4]
   202fe:	2a00      	cmp	r2, #0
   20300:	d000      	beq.n	20304 <_strtoul_r+0xdc>
   20302:	4240      	negs	r0, r0
   20304:	2f00      	cmp	r7, #0
   20306:	d00f      	beq.n	20328 <_strtoul_r+0x100>
   20308:	9a04      	ldr	r2, [sp, #16]
   2030a:	2b00      	cmp	r3, #0
   2030c:	d000      	beq.n	20310 <_strtoul_r+0xe8>
   2030e:	1e6a      	subs	r2, r5, #1
   20310:	603a      	str	r2, [r7, #0]
   20312:	e009      	b.n	20328 <_strtoul_r+0x100>
   20314:	2430      	movs	r4, #48	; 0x30
   20316:	2e00      	cmp	r6, #0
   20318:	d1b5      	bne.n	20286 <_strtoul_r+0x5e>
   2031a:	2608      	movs	r6, #8
   2031c:	e7b3      	b.n	20286 <_strtoul_r+0x5e>
   2031e:	260a      	movs	r6, #10
   20320:	e7b1      	b.n	20286 <_strtoul_r+0x5e>
   20322:	2c30      	cmp	r4, #48	; 0x30
   20324:	d0a7      	beq.n	20276 <_strtoul_r+0x4e>
   20326:	e7ae      	b.n	20286 <_strtoul_r+0x5e>
   20328:	b007      	add	sp, #28
   2032a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2032c:	200004c0 	.word	0x200004c0

00020330 <strtoul>:
   20330:	b510      	push	{r4, lr}
   20332:	0013      	movs	r3, r2
   20334:	000a      	movs	r2, r1
   20336:	0001      	movs	r1, r0
   20338:	4802      	ldr	r0, [pc, #8]	; (20344 <strtoul+0x14>)
   2033a:	6800      	ldr	r0, [r0, #0]
   2033c:	f7ff ff74 	bl	20228 <_strtoul_r>
   20340:	bd10      	pop	{r4, pc}
   20342:	46c0      	nop			; (mov r8, r8)
   20344:	20000474 	.word	0x20000474

00020348 <__env_lock>:
   20348:	4770      	bx	lr

0002034a <__env_unlock>:
   2034a:	4770      	bx	lr

0002034c <memchr>:
   2034c:	b2c9      	uxtb	r1, r1
   2034e:	1882      	adds	r2, r0, r2
   20350:	4290      	cmp	r0, r2
   20352:	d004      	beq.n	2035e <memchr+0x12>
   20354:	7803      	ldrb	r3, [r0, #0]
   20356:	428b      	cmp	r3, r1
   20358:	d002      	beq.n	20360 <memchr+0x14>
   2035a:	3001      	adds	r0, #1
   2035c:	e7f8      	b.n	20350 <memchr+0x4>
   2035e:	2000      	movs	r0, #0
   20360:	4770      	bx	lr

00020362 <memmove>:
   20362:	b510      	push	{r4, lr}
   20364:	4288      	cmp	r0, r1
   20366:	d902      	bls.n	2036e <memmove+0xc>
   20368:	188b      	adds	r3, r1, r2
   2036a:	4298      	cmp	r0, r3
   2036c:	d301      	bcc.n	20372 <memmove+0x10>
   2036e:	2300      	movs	r3, #0
   20370:	e005      	b.n	2037e <memmove+0x1c>
   20372:	1a9b      	subs	r3, r3, r2
   20374:	3a01      	subs	r2, #1
   20376:	d308      	bcc.n	2038a <memmove+0x28>
   20378:	5c99      	ldrb	r1, [r3, r2]
   2037a:	5481      	strb	r1, [r0, r2]
   2037c:	e7fa      	b.n	20374 <memmove+0x12>
   2037e:	4293      	cmp	r3, r2
   20380:	d003      	beq.n	2038a <memmove+0x28>
   20382:	5ccc      	ldrb	r4, [r1, r3]
   20384:	54c4      	strb	r4, [r0, r3]
   20386:	3301      	adds	r3, #1
   20388:	e7f9      	b.n	2037e <memmove+0x1c>
   2038a:	bd10      	pop	{r4, pc}

0002038c <_realloc_r>:
   2038c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2038e:	0006      	movs	r6, r0
   20390:	000c      	movs	r4, r1
   20392:	0015      	movs	r5, r2
   20394:	2900      	cmp	r1, #0
   20396:	d104      	bne.n	203a2 <_realloc_r+0x16>
   20398:	0011      	movs	r1, r2
   2039a:	f7ff f81d 	bl	1f3d8 <_malloc_r>
   2039e:	0004      	movs	r4, r0
   203a0:	e018      	b.n	203d4 <_realloc_r+0x48>
   203a2:	2a00      	cmp	r2, #0
   203a4:	d103      	bne.n	203ae <_realloc_r+0x22>
   203a6:	f7fe ffd1 	bl	1f34c <_free_r>
   203aa:	002c      	movs	r4, r5
   203ac:	e012      	b.n	203d4 <_realloc_r+0x48>
   203ae:	f000 fc51 	bl	20c54 <_malloc_usable_size_r>
   203b2:	4285      	cmp	r5, r0
   203b4:	d90e      	bls.n	203d4 <_realloc_r+0x48>
   203b6:	0029      	movs	r1, r5
   203b8:	0030      	movs	r0, r6
   203ba:	f7ff f80d 	bl	1f3d8 <_malloc_r>
   203be:	1e07      	subs	r7, r0, #0
   203c0:	d007      	beq.n	203d2 <_realloc_r+0x46>
   203c2:	0021      	movs	r1, r4
   203c4:	002a      	movs	r2, r5
   203c6:	f7fe fd68 	bl	1ee9a <memcpy>
   203ca:	0021      	movs	r1, r4
   203cc:	0030      	movs	r0, r6
   203ce:	f7fe ffbd 	bl	1f34c <_free_r>
   203d2:	003c      	movs	r4, r7
   203d4:	0020      	movs	r0, r4
   203d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000203d8 <_sungetc_r>:
   203d8:	b570      	push	{r4, r5, r6, lr}
   203da:	000e      	movs	r6, r1
   203dc:	0014      	movs	r4, r2
   203de:	1c4b      	adds	r3, r1, #1
   203e0:	d102      	bne.n	203e8 <_sungetc_r+0x10>
   203e2:	2001      	movs	r0, #1
   203e4:	4240      	negs	r0, r0
   203e6:	e032      	b.n	2044e <_sungetc_r+0x76>
   203e8:	8993      	ldrh	r3, [r2, #12]
   203ea:	2220      	movs	r2, #32
   203ec:	4393      	bics	r3, r2
   203ee:	6b62      	ldr	r2, [r4, #52]	; 0x34
   203f0:	81a3      	strh	r3, [r4, #12]
   203f2:	b2cd      	uxtb	r5, r1
   203f4:	6863      	ldr	r3, [r4, #4]
   203f6:	2a00      	cmp	r2, #0
   203f8:	d00e      	beq.n	20418 <_sungetc_r+0x40>
   203fa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   203fc:	4293      	cmp	r3, r2
   203fe:	da05      	bge.n	2040c <_sungetc_r+0x34>
   20400:	6823      	ldr	r3, [r4, #0]
   20402:	3b01      	subs	r3, #1
   20404:	6023      	str	r3, [r4, #0]
   20406:	701e      	strb	r6, [r3, #0]
   20408:	6863      	ldr	r3, [r4, #4]
   2040a:	e010      	b.n	2042e <_sungetc_r+0x56>
   2040c:	0021      	movs	r1, r4
   2040e:	f000 fbe3 	bl	20bd8 <__submore>
   20412:	2800      	cmp	r0, #0
   20414:	d0f4      	beq.n	20400 <_sungetc_r+0x28>
   20416:	e7e4      	b.n	203e2 <_sungetc_r+0xa>
   20418:	6921      	ldr	r1, [r4, #16]
   2041a:	6822      	ldr	r2, [r4, #0]
   2041c:	2900      	cmp	r1, #0
   2041e:	d008      	beq.n	20432 <_sungetc_r+0x5a>
   20420:	4291      	cmp	r1, r2
   20422:	d206      	bcs.n	20432 <_sungetc_r+0x5a>
   20424:	1e51      	subs	r1, r2, #1
   20426:	7808      	ldrb	r0, [r1, #0]
   20428:	4285      	cmp	r5, r0
   2042a:	d102      	bne.n	20432 <_sungetc_r+0x5a>
   2042c:	6021      	str	r1, [r4, #0]
   2042e:	3301      	adds	r3, #1
   20430:	e00b      	b.n	2044a <_sungetc_r+0x72>
   20432:	6423      	str	r3, [r4, #64]	; 0x40
   20434:	0023      	movs	r3, r4
   20436:	3344      	adds	r3, #68	; 0x44
   20438:	6363      	str	r3, [r4, #52]	; 0x34
   2043a:	2303      	movs	r3, #3
   2043c:	63a3      	str	r3, [r4, #56]	; 0x38
   2043e:	0023      	movs	r3, r4
   20440:	3346      	adds	r3, #70	; 0x46
   20442:	63e2      	str	r2, [r4, #60]	; 0x3c
   20444:	701e      	strb	r6, [r3, #0]
   20446:	6023      	str	r3, [r4, #0]
   20448:	2301      	movs	r3, #1
   2044a:	0028      	movs	r0, r5
   2044c:	6063      	str	r3, [r4, #4]
   2044e:	bd70      	pop	{r4, r5, r6, pc}

00020450 <__ssrefill_r>:
   20450:	b510      	push	{r4, lr}
   20452:	000c      	movs	r4, r1
   20454:	6b49      	ldr	r1, [r1, #52]	; 0x34
   20456:	2900      	cmp	r1, #0
   20458:	d00e      	beq.n	20478 <__ssrefill_r+0x28>
   2045a:	0023      	movs	r3, r4
   2045c:	3344      	adds	r3, #68	; 0x44
   2045e:	4299      	cmp	r1, r3
   20460:	d001      	beq.n	20466 <__ssrefill_r+0x16>
   20462:	f7fe ff73 	bl	1f34c <_free_r>
   20466:	2000      	movs	r0, #0
   20468:	6c23      	ldr	r3, [r4, #64]	; 0x40
   2046a:	6360      	str	r0, [r4, #52]	; 0x34
   2046c:	6063      	str	r3, [r4, #4]
   2046e:	4283      	cmp	r3, r0
   20470:	d002      	beq.n	20478 <__ssrefill_r+0x28>
   20472:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   20474:	6023      	str	r3, [r4, #0]
   20476:	e009      	b.n	2048c <__ssrefill_r+0x3c>
   20478:	6923      	ldr	r3, [r4, #16]
   2047a:	2220      	movs	r2, #32
   2047c:	6023      	str	r3, [r4, #0]
   2047e:	2300      	movs	r3, #0
   20480:	2001      	movs	r0, #1
   20482:	6063      	str	r3, [r4, #4]
   20484:	89a3      	ldrh	r3, [r4, #12]
   20486:	4240      	negs	r0, r0
   20488:	4313      	orrs	r3, r2
   2048a:	81a3      	strh	r3, [r4, #12]
   2048c:	bd10      	pop	{r4, pc}
	...

00020490 <__ssvfiscanf_r>:
   20490:	b5f0      	push	{r4, r5, r6, r7, lr}
   20492:	4cb8      	ldr	r4, [pc, #736]	; (20774 <__ssvfiscanf_r+0x2e4>)
   20494:	000d      	movs	r5, r1
   20496:	44a5      	add	sp, r4
   20498:	9303      	str	r3, [sp, #12]
   2049a:	2300      	movs	r3, #0
   2049c:	9000      	str	r0, [sp, #0]
   2049e:	9348      	str	r3, [sp, #288]	; 0x120
   204a0:	9349      	str	r3, [sp, #292]	; 0x124
   204a2:	2086      	movs	r0, #134	; 0x86
   204a4:	ab05      	add	r3, sp, #20
   204a6:	934a      	str	r3, [sp, #296]	; 0x128
   204a8:	23be      	movs	r3, #190	; 0xbe
   204aa:	0040      	lsls	r0, r0, #1
   204ac:	9201      	str	r2, [sp, #4]
   204ae:	a902      	add	r1, sp, #8
   204b0:	4ab1      	ldr	r2, [pc, #708]	; (20778 <__ssvfiscanf_r+0x2e8>)
   204b2:	005b      	lsls	r3, r3, #1
   204b4:	1809      	adds	r1, r1, r0
   204b6:	50ca      	str	r2, [r1, r3]
   204b8:	3304      	adds	r3, #4
   204ba:	001e      	movs	r6, r3
   204bc:	4aaf      	ldr	r2, [pc, #700]	; (2077c <__ssvfiscanf_r+0x2ec>)
   204be:	a902      	add	r1, sp, #8
   204c0:	1809      	adds	r1, r1, r0
   204c2:	50ca      	str	r2, [r1, r3]
   204c4:	9b01      	ldr	r3, [sp, #4]
   204c6:	781a      	ldrb	r2, [r3, #0]
   204c8:	2a00      	cmp	r2, #0
   204ca:	d100      	bne.n	204ce <__ssvfiscanf_r+0x3e>
   204cc:	e149      	b.n	20762 <__ssvfiscanf_r+0x2d2>
   204ce:	2108      	movs	r1, #8
   204d0:	4cab      	ldr	r4, [pc, #684]	; (20780 <__ssvfiscanf_r+0x2f0>)
   204d2:	6823      	ldr	r3, [r4, #0]
   204d4:	189b      	adds	r3, r3, r2
   204d6:	785b      	ldrb	r3, [r3, #1]
   204d8:	400b      	ands	r3, r1
   204da:	d023      	beq.n	20524 <__ssvfiscanf_r+0x94>
   204dc:	686b      	ldr	r3, [r5, #4]
   204de:	2b00      	cmp	r3, #0
   204e0:	dd11      	ble.n	20506 <__ssvfiscanf_r+0x76>
   204e2:	682b      	ldr	r3, [r5, #0]
   204e4:	6821      	ldr	r1, [r4, #0]
   204e6:	781a      	ldrb	r2, [r3, #0]
   204e8:	188a      	adds	r2, r1, r2
   204ea:	2108      	movs	r1, #8
   204ec:	7852      	ldrb	r2, [r2, #1]
   204ee:	420a      	tst	r2, r1
   204f0:	d014      	beq.n	2051c <__ssvfiscanf_r+0x8c>
   204f2:	9a49      	ldr	r2, [sp, #292]	; 0x124
   204f4:	3301      	adds	r3, #1
   204f6:	9202      	str	r2, [sp, #8]
   204f8:	3201      	adds	r2, #1
   204fa:	9249      	str	r2, [sp, #292]	; 0x124
   204fc:	686a      	ldr	r2, [r5, #4]
   204fe:	602b      	str	r3, [r5, #0]
   20500:	3a01      	subs	r2, #1
   20502:	606a      	str	r2, [r5, #4]
   20504:	e7ea      	b.n	204dc <__ssvfiscanf_r+0x4c>
   20506:	2286      	movs	r2, #134	; 0x86
   20508:	ab02      	add	r3, sp, #8
   2050a:	0052      	lsls	r2, r2, #1
   2050c:	189b      	adds	r3, r3, r2
   2050e:	599b      	ldr	r3, [r3, r6]
   20510:	0029      	movs	r1, r5
   20512:	9800      	ldr	r0, [sp, #0]
   20514:	9302      	str	r3, [sp, #8]
   20516:	4798      	blx	r3
   20518:	2800      	cmp	r0, #0
   2051a:	d0e2      	beq.n	204e2 <__ssvfiscanf_r+0x52>
   2051c:	9f01      	ldr	r7, [sp, #4]
   2051e:	3701      	adds	r7, #1
   20520:	9701      	str	r7, [sp, #4]
   20522:	e7cf      	b.n	204c4 <__ssvfiscanf_r+0x34>
   20524:	9901      	ldr	r1, [sp, #4]
   20526:	0014      	movs	r4, r2
   20528:	1c4f      	adds	r7, r1, #1
   2052a:	2a25      	cmp	r2, #37	; 0x25
   2052c:	d155      	bne.n	205da <__ssvfiscanf_r+0x14a>
   2052e:	9347      	str	r3, [sp, #284]	; 0x11c
   20530:	9345      	str	r3, [sp, #276]	; 0x114
   20532:	784b      	ldrb	r3, [r1, #1]
   20534:	2b2a      	cmp	r3, #42	; 0x2a
   20536:	d102      	bne.n	2053e <__ssvfiscanf_r+0xae>
   20538:	3b1a      	subs	r3, #26
   2053a:	9345      	str	r3, [sp, #276]	; 0x114
   2053c:	3701      	adds	r7, #1
   2053e:	003c      	movs	r4, r7
   20540:	220a      	movs	r2, #10
   20542:	7821      	ldrb	r1, [r4, #0]
   20544:	000b      	movs	r3, r1
   20546:	3b30      	subs	r3, #48	; 0x30
   20548:	2b09      	cmp	r3, #9
   2054a:	d807      	bhi.n	2055c <__ssvfiscanf_r+0xcc>
   2054c:	9b47      	ldr	r3, [sp, #284]	; 0x11c
   2054e:	3401      	adds	r4, #1
   20550:	9301      	str	r3, [sp, #4]
   20552:	4353      	muls	r3, r2
   20554:	3b30      	subs	r3, #48	; 0x30
   20556:	1859      	adds	r1, r3, r1
   20558:	9147      	str	r1, [sp, #284]	; 0x11c
   2055a:	e7f2      	b.n	20542 <__ssvfiscanf_r+0xb2>
   2055c:	4f89      	ldr	r7, [pc, #548]	; (20784 <__ssvfiscanf_r+0x2f4>)
   2055e:	2203      	movs	r2, #3
   20560:	0038      	movs	r0, r7
   20562:	f7ff fef3 	bl	2034c <memchr>
   20566:	2800      	cmp	r0, #0
   20568:	d007      	beq.n	2057a <__ssvfiscanf_r+0xea>
   2056a:	2301      	movs	r3, #1
   2056c:	1bc0      	subs	r0, r0, r7
   2056e:	4083      	lsls	r3, r0
   20570:	9a45      	ldr	r2, [sp, #276]	; 0x114
   20572:	3401      	adds	r4, #1
   20574:	4313      	orrs	r3, r2
   20576:	9201      	str	r2, [sp, #4]
   20578:	9345      	str	r3, [sp, #276]	; 0x114
   2057a:	1c67      	adds	r7, r4, #1
   2057c:	7824      	ldrb	r4, [r4, #0]
   2057e:	2c67      	cmp	r4, #103	; 0x67
   20580:	d818      	bhi.n	205b4 <__ssvfiscanf_r+0x124>
   20582:	2c65      	cmp	r4, #101	; 0x65
   20584:	d300      	bcc.n	20588 <__ssvfiscanf_r+0xf8>
   20586:	e08b      	b.n	206a0 <__ssvfiscanf_r+0x210>
   20588:	2c47      	cmp	r4, #71	; 0x47
   2058a:	d808      	bhi.n	2059e <__ssvfiscanf_r+0x10e>
   2058c:	2c45      	cmp	r4, #69	; 0x45
   2058e:	d300      	bcc.n	20592 <__ssvfiscanf_r+0x102>
   20590:	e086      	b.n	206a0 <__ssvfiscanf_r+0x210>
   20592:	2c00      	cmp	r4, #0
   20594:	d100      	bne.n	20598 <__ssvfiscanf_r+0x108>
   20596:	e0e6      	b.n	20766 <__ssvfiscanf_r+0x2d6>
   20598:	2c25      	cmp	r4, #37	; 0x25
   2059a:	d01e      	beq.n	205da <__ssvfiscanf_r+0x14a>
   2059c:	e082      	b.n	206a4 <__ssvfiscanf_r+0x214>
   2059e:	2c5b      	cmp	r4, #91	; 0x5b
   205a0:	d056      	beq.n	20650 <__ssvfiscanf_r+0x1c0>
   205a2:	d802      	bhi.n	205aa <__ssvfiscanf_r+0x11a>
   205a4:	2c58      	cmp	r4, #88	; 0x58
   205a6:	d041      	beq.n	2062c <__ssvfiscanf_r+0x19c>
   205a8:	e07c      	b.n	206a4 <__ssvfiscanf_r+0x214>
   205aa:	2c63      	cmp	r4, #99	; 0x63
   205ac:	d05e      	beq.n	2066c <__ssvfiscanf_r+0x1dc>
   205ae:	2c64      	cmp	r4, #100	; 0x64
   205b0:	d045      	beq.n	2063e <__ssvfiscanf_r+0x1ae>
   205b2:	e077      	b.n	206a4 <__ssvfiscanf_r+0x214>
   205b4:	2c70      	cmp	r4, #112	; 0x70
   205b6:	d033      	beq.n	20620 <__ssvfiscanf_r+0x190>
   205b8:	d807      	bhi.n	205ca <__ssvfiscanf_r+0x13a>
   205ba:	2c6e      	cmp	r4, #110	; 0x6e
   205bc:	d05e      	beq.n	2067c <__ssvfiscanf_r+0x1ec>
   205be:	d840      	bhi.n	20642 <__ssvfiscanf_r+0x1b2>
   205c0:	2c69      	cmp	r4, #105	; 0x69
   205c2:	d16f      	bne.n	206a4 <__ssvfiscanf_r+0x214>
   205c4:	2300      	movs	r3, #0
   205c6:	9346      	str	r3, [sp, #280]	; 0x118
   205c8:	e040      	b.n	2064c <__ssvfiscanf_r+0x1bc>
   205ca:	2c75      	cmp	r4, #117	; 0x75
   205cc:	d037      	beq.n	2063e <__ssvfiscanf_r+0x1ae>
   205ce:	2c78      	cmp	r4, #120	; 0x78
   205d0:	d02c      	beq.n	2062c <__ssvfiscanf_r+0x19c>
   205d2:	2302      	movs	r3, #2
   205d4:	2c73      	cmp	r4, #115	; 0x73
   205d6:	d047      	beq.n	20668 <__ssvfiscanf_r+0x1d8>
   205d8:	e064      	b.n	206a4 <__ssvfiscanf_r+0x214>
   205da:	686b      	ldr	r3, [r5, #4]
   205dc:	2b00      	cmp	r3, #0
   205de:	dd0e      	ble.n	205fe <__ssvfiscanf_r+0x16e>
   205e0:	682b      	ldr	r3, [r5, #0]
   205e2:	781a      	ldrb	r2, [r3, #0]
   205e4:	4294      	cmp	r4, r2
   205e6:	d000      	beq.n	205ea <__ssvfiscanf_r+0x15a>
   205e8:	e0bb      	b.n	20762 <__ssvfiscanf_r+0x2d2>
   205ea:	3301      	adds	r3, #1
   205ec:	686a      	ldr	r2, [r5, #4]
   205ee:	602b      	str	r3, [r5, #0]
   205f0:	9b49      	ldr	r3, [sp, #292]	; 0x124
   205f2:	3a01      	subs	r2, #1
   205f4:	9301      	str	r3, [sp, #4]
   205f6:	3301      	adds	r3, #1
   205f8:	606a      	str	r2, [r5, #4]
   205fa:	9349      	str	r3, [sp, #292]	; 0x124
   205fc:	e790      	b.n	20520 <__ssvfiscanf_r+0x90>
   205fe:	2286      	movs	r2, #134	; 0x86
   20600:	ab02      	add	r3, sp, #8
   20602:	0052      	lsls	r2, r2, #1
   20604:	189b      	adds	r3, r3, r2
   20606:	599b      	ldr	r3, [r3, r6]
   20608:	0029      	movs	r1, r5
   2060a:	9800      	ldr	r0, [sp, #0]
   2060c:	9301      	str	r3, [sp, #4]
   2060e:	4798      	blx	r3
   20610:	2800      	cmp	r0, #0
   20612:	d0e5      	beq.n	205e0 <__ssvfiscanf_r+0x150>
   20614:	9848      	ldr	r0, [sp, #288]	; 0x120
   20616:	2800      	cmp	r0, #0
   20618:	d000      	beq.n	2061c <__ssvfiscanf_r+0x18c>
   2061a:	e09e      	b.n	2075a <__ssvfiscanf_r+0x2ca>
   2061c:	3801      	subs	r0, #1
   2061e:	e0a4      	b.n	2076a <__ssvfiscanf_r+0x2da>
   20620:	9b45      	ldr	r3, [sp, #276]	; 0x114
   20622:	9301      	str	r3, [sp, #4]
   20624:	2320      	movs	r3, #32
   20626:	9a01      	ldr	r2, [sp, #4]
   20628:	4313      	orrs	r3, r2
   2062a:	9345      	str	r3, [sp, #276]	; 0x114
   2062c:	9b45      	ldr	r3, [sp, #276]	; 0x114
   2062e:	9301      	str	r3, [sp, #4]
   20630:	2380      	movs	r3, #128	; 0x80
   20632:	9a01      	ldr	r2, [sp, #4]
   20634:	009b      	lsls	r3, r3, #2
   20636:	4313      	orrs	r3, r2
   20638:	9345      	str	r3, [sp, #276]	; 0x114
   2063a:	2310      	movs	r3, #16
   2063c:	e002      	b.n	20644 <__ssvfiscanf_r+0x1b4>
   2063e:	230a      	movs	r3, #10
   20640:	e000      	b.n	20644 <__ssvfiscanf_r+0x1b4>
   20642:	2308      	movs	r3, #8
   20644:	9346      	str	r3, [sp, #280]	; 0x118
   20646:	2304      	movs	r3, #4
   20648:	2c6e      	cmp	r4, #110	; 0x6e
   2064a:	dc0d      	bgt.n	20668 <__ssvfiscanf_r+0x1d8>
   2064c:	2303      	movs	r3, #3
   2064e:	e00b      	b.n	20668 <__ssvfiscanf_r+0x1d8>
   20650:	0039      	movs	r1, r7
   20652:	a805      	add	r0, sp, #20
   20654:	f000 f9fc 	bl	20a50 <__sccl>
   20658:	9b45      	ldr	r3, [sp, #276]	; 0x114
   2065a:	0007      	movs	r7, r0
   2065c:	9301      	str	r3, [sp, #4]
   2065e:	2340      	movs	r3, #64	; 0x40
   20660:	9a01      	ldr	r2, [sp, #4]
   20662:	4313      	orrs	r3, r2
   20664:	9345      	str	r3, [sp, #276]	; 0x114
   20666:	2301      	movs	r3, #1
   20668:	934b      	str	r3, [sp, #300]	; 0x12c
   2066a:	e01f      	b.n	206ac <__ssvfiscanf_r+0x21c>
   2066c:	9b45      	ldr	r3, [sp, #276]	; 0x114
   2066e:	9301      	str	r3, [sp, #4]
   20670:	2340      	movs	r3, #64	; 0x40
   20672:	9a01      	ldr	r2, [sp, #4]
   20674:	4313      	orrs	r3, r2
   20676:	9345      	str	r3, [sp, #276]	; 0x114
   20678:	2300      	movs	r3, #0
   2067a:	e7f5      	b.n	20668 <__ssvfiscanf_r+0x1d8>
   2067c:	9945      	ldr	r1, [sp, #276]	; 0x114
   2067e:	06cb      	lsls	r3, r1, #27
   20680:	d500      	bpl.n	20684 <__ssvfiscanf_r+0x1f4>
   20682:	e74d      	b.n	20520 <__ssvfiscanf_r+0x90>
   20684:	9b03      	ldr	r3, [sp, #12]
   20686:	9a49      	ldr	r2, [sp, #292]	; 0x124
   20688:	07c8      	lsls	r0, r1, #31
   2068a:	d504      	bpl.n	20696 <__ssvfiscanf_r+0x206>
   2068c:	1d19      	adds	r1, r3, #4
   2068e:	9103      	str	r1, [sp, #12]
   20690:	681b      	ldr	r3, [r3, #0]
   20692:	801a      	strh	r2, [r3, #0]
   20694:	e744      	b.n	20520 <__ssvfiscanf_r+0x90>
   20696:	1d19      	adds	r1, r3, #4
   20698:	9103      	str	r1, [sp, #12]
   2069a:	681b      	ldr	r3, [r3, #0]
   2069c:	601a      	str	r2, [r3, #0]
   2069e:	e73f      	b.n	20520 <__ssvfiscanf_r+0x90>
   206a0:	2305      	movs	r3, #5
   206a2:	e7e1      	b.n	20668 <__ssvfiscanf_r+0x1d8>
   206a4:	2303      	movs	r3, #3
   206a6:	934b      	str	r3, [sp, #300]	; 0x12c
   206a8:	3307      	adds	r3, #7
   206aa:	9346      	str	r3, [sp, #280]	; 0x118
   206ac:	686b      	ldr	r3, [r5, #4]
   206ae:	2b00      	cmp	r3, #0
   206b0:	dd04      	ble.n	206bc <__ssvfiscanf_r+0x22c>
   206b2:	9b45      	ldr	r3, [sp, #276]	; 0x114
   206b4:	9301      	str	r3, [sp, #4]
   206b6:	065b      	lsls	r3, r3, #25
   206b8:	d517      	bpl.n	206ea <__ssvfiscanf_r+0x25a>
   206ba:	e01f      	b.n	206fc <__ssvfiscanf_r+0x26c>
   206bc:	2286      	movs	r2, #134	; 0x86
   206be:	ab02      	add	r3, sp, #8
   206c0:	0052      	lsls	r2, r2, #1
   206c2:	189b      	adds	r3, r3, r2
   206c4:	599b      	ldr	r3, [r3, r6]
   206c6:	0029      	movs	r1, r5
   206c8:	9800      	ldr	r0, [sp, #0]
   206ca:	9301      	str	r3, [sp, #4]
   206cc:	4798      	blx	r3
   206ce:	2800      	cmp	r0, #0
   206d0:	d0ef      	beq.n	206b2 <__ssvfiscanf_r+0x222>
   206d2:	e79f      	b.n	20614 <__ssvfiscanf_r+0x184>
   206d4:	9a49      	ldr	r2, [sp, #292]	; 0x124
   206d6:	9201      	str	r2, [sp, #4]
   206d8:	3201      	adds	r2, #1
   206da:	9249      	str	r2, [sp, #292]	; 0x124
   206dc:	686a      	ldr	r2, [r5, #4]
   206de:	3a01      	subs	r2, #1
   206e0:	606a      	str	r2, [r5, #4]
   206e2:	2a00      	cmp	r2, #0
   206e4:	dd14      	ble.n	20710 <__ssvfiscanf_r+0x280>
   206e6:	3301      	adds	r3, #1
   206e8:	602b      	str	r3, [r5, #0]
   206ea:	682b      	ldr	r3, [r5, #0]
   206ec:	4924      	ldr	r1, [pc, #144]	; (20780 <__ssvfiscanf_r+0x2f0>)
   206ee:	781a      	ldrb	r2, [r3, #0]
   206f0:	6809      	ldr	r1, [r1, #0]
   206f2:	188a      	adds	r2, r1, r2
   206f4:	2108      	movs	r1, #8
   206f6:	7852      	ldrb	r2, [r2, #1]
   206f8:	420a      	tst	r2, r1
   206fa:	d1eb      	bne.n	206d4 <__ssvfiscanf_r+0x244>
   206fc:	9b4b      	ldr	r3, [sp, #300]	; 0x12c
   206fe:	2b02      	cmp	r3, #2
   20700:	dc12      	bgt.n	20728 <__ssvfiscanf_r+0x298>
   20702:	ab03      	add	r3, sp, #12
   20704:	002a      	movs	r2, r5
   20706:	a945      	add	r1, sp, #276	; 0x114
   20708:	9800      	ldr	r0, [sp, #0]
   2070a:	f000 f83f 	bl	2078c <_scanf_chars>
   2070e:	e01e      	b.n	2074e <__ssvfiscanf_r+0x2be>
   20710:	2286      	movs	r2, #134	; 0x86
   20712:	ab02      	add	r3, sp, #8
   20714:	0052      	lsls	r2, r2, #1
   20716:	189b      	adds	r3, r3, r2
   20718:	599b      	ldr	r3, [r3, r6]
   2071a:	0029      	movs	r1, r5
   2071c:	9800      	ldr	r0, [sp, #0]
   2071e:	9301      	str	r3, [sp, #4]
   20720:	4798      	blx	r3
   20722:	2800      	cmp	r0, #0
   20724:	d0e1      	beq.n	206ea <__ssvfiscanf_r+0x25a>
   20726:	e775      	b.n	20614 <__ssvfiscanf_r+0x184>
   20728:	2b04      	cmp	r3, #4
   2072a:	dc06      	bgt.n	2073a <__ssvfiscanf_r+0x2aa>
   2072c:	ab03      	add	r3, sp, #12
   2072e:	002a      	movs	r2, r5
   20730:	a945      	add	r1, sp, #276	; 0x114
   20732:	9800      	ldr	r0, [sp, #0]
   20734:	f000 f88c 	bl	20850 <_scanf_i>
   20738:	e009      	b.n	2074e <__ssvfiscanf_r+0x2be>
   2073a:	4b13      	ldr	r3, [pc, #76]	; (20788 <__ssvfiscanf_r+0x2f8>)
   2073c:	2b00      	cmp	r3, #0
   2073e:	d100      	bne.n	20742 <__ssvfiscanf_r+0x2b2>
   20740:	e6ee      	b.n	20520 <__ssvfiscanf_r+0x90>
   20742:	ab03      	add	r3, sp, #12
   20744:	002a      	movs	r2, r5
   20746:	a945      	add	r1, sp, #276	; 0x114
   20748:	9800      	ldr	r0, [sp, #0]
   2074a:	e000      	b.n	2074e <__ssvfiscanf_r+0x2be>
   2074c:	bf00      	nop
   2074e:	2801      	cmp	r0, #1
   20750:	d007      	beq.n	20762 <__ssvfiscanf_r+0x2d2>
   20752:	2802      	cmp	r0, #2
   20754:	d000      	beq.n	20758 <__ssvfiscanf_r+0x2c8>
   20756:	e6e3      	b.n	20520 <__ssvfiscanf_r+0x90>
   20758:	e75c      	b.n	20614 <__ssvfiscanf_r+0x184>
   2075a:	89ab      	ldrh	r3, [r5, #12]
   2075c:	065b      	lsls	r3, r3, #25
   2075e:	d504      	bpl.n	2076a <__ssvfiscanf_r+0x2da>
   20760:	e001      	b.n	20766 <__ssvfiscanf_r+0x2d6>
   20762:	9848      	ldr	r0, [sp, #288]	; 0x120
   20764:	e001      	b.n	2076a <__ssvfiscanf_r+0x2da>
   20766:	2001      	movs	r0, #1
   20768:	4240      	negs	r0, r0
   2076a:	23a7      	movs	r3, #167	; 0xa7
   2076c:	009b      	lsls	r3, r3, #2
   2076e:	449d      	add	sp, r3
   20770:	bdf0      	pop	{r4, r5, r6, r7, pc}
   20772:	46c0      	nop			; (mov r8, r8)
   20774:	fffffd64 	.word	0xfffffd64
   20778:	000203d9 	.word	0x000203d9
   2077c:	00020451 	.word	0x00020451
   20780:	200004c0 	.word	0x200004c0
   20784:	00021fe2 	.word	0x00021fe2
   20788:	00000000 	.word	0x00000000

0002078c <_scanf_chars>:
   2078c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2078e:	0015      	movs	r5, r2
   20790:	688a      	ldr	r2, [r1, #8]
   20792:	9001      	str	r0, [sp, #4]
   20794:	000c      	movs	r4, r1
   20796:	2a00      	cmp	r2, #0
   20798:	d106      	bne.n	207a8 <_scanf_chars+0x1c>
   2079a:	698a      	ldr	r2, [r1, #24]
   2079c:	1e51      	subs	r1, r2, #1
   2079e:	418a      	sbcs	r2, r1
   207a0:	2101      	movs	r1, #1
   207a2:	4252      	negs	r2, r2
   207a4:	430a      	orrs	r2, r1
   207a6:	60a2      	str	r2, [r4, #8]
   207a8:	6822      	ldr	r2, [r4, #0]
   207aa:	06d2      	lsls	r2, r2, #27
   207ac:	d403      	bmi.n	207b6 <_scanf_chars+0x2a>
   207ae:	681a      	ldr	r2, [r3, #0]
   207b0:	1d11      	adds	r1, r2, #4
   207b2:	6019      	str	r1, [r3, #0]
   207b4:	6817      	ldr	r7, [r2, #0]
   207b6:	2600      	movs	r6, #0
   207b8:	69a0      	ldr	r0, [r4, #24]
   207ba:	2800      	cmp	r0, #0
   207bc:	d11e      	bne.n	207fc <_scanf_chars+0x70>
   207be:	2210      	movs	r2, #16
   207c0:	6823      	ldr	r3, [r4, #0]
   207c2:	3601      	adds	r6, #1
   207c4:	4213      	tst	r3, r2
   207c6:	d103      	bne.n	207d0 <_scanf_chars+0x44>
   207c8:	682b      	ldr	r3, [r5, #0]
   207ca:	781b      	ldrb	r3, [r3, #0]
   207cc:	703b      	strb	r3, [r7, #0]
   207ce:	3701      	adds	r7, #1
   207d0:	682a      	ldr	r2, [r5, #0]
   207d2:	686b      	ldr	r3, [r5, #4]
   207d4:	3201      	adds	r2, #1
   207d6:	602a      	str	r2, [r5, #0]
   207d8:	68a2      	ldr	r2, [r4, #8]
   207da:	3b01      	subs	r3, #1
   207dc:	3a01      	subs	r2, #1
   207de:	606b      	str	r3, [r5, #4]
   207e0:	60a2      	str	r2, [r4, #8]
   207e2:	2a00      	cmp	r2, #0
   207e4:	d01e      	beq.n	20824 <_scanf_chars+0x98>
   207e6:	2b00      	cmp	r3, #0
   207e8:	dce6      	bgt.n	207b8 <_scanf_chars+0x2c>
   207ea:	23c0      	movs	r3, #192	; 0xc0
   207ec:	005b      	lsls	r3, r3, #1
   207ee:	58e3      	ldr	r3, [r4, r3]
   207f0:	0029      	movs	r1, r5
   207f2:	9801      	ldr	r0, [sp, #4]
   207f4:	4798      	blx	r3
   207f6:	2800      	cmp	r0, #0
   207f8:	d0de      	beq.n	207b8 <_scanf_chars+0x2c>
   207fa:	e013      	b.n	20824 <_scanf_chars+0x98>
   207fc:	2801      	cmp	r0, #1
   207fe:	d106      	bne.n	2080e <_scanf_chars+0x82>
   20800:	682b      	ldr	r3, [r5, #0]
   20802:	6962      	ldr	r2, [r4, #20]
   20804:	781b      	ldrb	r3, [r3, #0]
   20806:	5cd3      	ldrb	r3, [r2, r3]
   20808:	2b00      	cmp	r3, #0
   2080a:	d1d8      	bne.n	207be <_scanf_chars+0x32>
   2080c:	e01a      	b.n	20844 <_scanf_chars+0xb8>
   2080e:	2802      	cmp	r0, #2
   20810:	d108      	bne.n	20824 <_scanf_chars+0x98>
   20812:	682b      	ldr	r3, [r5, #0]
   20814:	4a0d      	ldr	r2, [pc, #52]	; (2084c <_scanf_chars+0xc0>)
   20816:	781b      	ldrb	r3, [r3, #0]
   20818:	6812      	ldr	r2, [r2, #0]
   2081a:	18d3      	adds	r3, r2, r3
   2081c:	2208      	movs	r2, #8
   2081e:	785b      	ldrb	r3, [r3, #1]
   20820:	4213      	tst	r3, r2
   20822:	d0cc      	beq.n	207be <_scanf_chars+0x32>
   20824:	2310      	movs	r3, #16
   20826:	6822      	ldr	r2, [r4, #0]
   20828:	4013      	ands	r3, r2
   2082a:	d106      	bne.n	2083a <_scanf_chars+0xae>
   2082c:	68e2      	ldr	r2, [r4, #12]
   2082e:	3201      	adds	r2, #1
   20830:	60e2      	str	r2, [r4, #12]
   20832:	69a2      	ldr	r2, [r4, #24]
   20834:	2a00      	cmp	r2, #0
   20836:	d000      	beq.n	2083a <_scanf_chars+0xae>
   20838:	703b      	strb	r3, [r7, #0]
   2083a:	6923      	ldr	r3, [r4, #16]
   2083c:	2000      	movs	r0, #0
   2083e:	199e      	adds	r6, r3, r6
   20840:	6126      	str	r6, [r4, #16]
   20842:	e001      	b.n	20848 <_scanf_chars+0xbc>
   20844:	2e00      	cmp	r6, #0
   20846:	d1ed      	bne.n	20824 <_scanf_chars+0x98>
   20848:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   2084a:	46c0      	nop			; (mov r8, r8)
   2084c:	200004c0 	.word	0x200004c0

00020850 <_scanf_i>:
   20850:	b5f0      	push	{r4, r5, r6, r7, lr}
   20852:	000c      	movs	r4, r1
   20854:	b08d      	sub	sp, #52	; 0x34
   20856:	9302      	str	r3, [sp, #8]
   20858:	4b77      	ldr	r3, [pc, #476]	; (20a38 <_scanf_i+0x1e8>)
   2085a:	9005      	str	r0, [sp, #20]
   2085c:	0016      	movs	r6, r2
   2085e:	aa09      	add	r2, sp, #36	; 0x24
   20860:	cb23      	ldmia	r3!, {r0, r1, r5}
   20862:	c223      	stmia	r2!, {r0, r1, r5}
   20864:	4b75      	ldr	r3, [pc, #468]	; (20a3c <_scanf_i+0x1ec>)
   20866:	9306      	str	r3, [sp, #24]
   20868:	69a3      	ldr	r3, [r4, #24]
   2086a:	2b03      	cmp	r3, #3
   2086c:	d001      	beq.n	20872 <_scanf_i+0x22>
   2086e:	4b74      	ldr	r3, [pc, #464]	; (20a40 <_scanf_i+0x1f0>)
   20870:	9306      	str	r3, [sp, #24]
   20872:	2200      	movs	r2, #0
   20874:	68a3      	ldr	r3, [r4, #8]
   20876:	9204      	str	r2, [sp, #16]
   20878:	325d      	adds	r2, #93	; 0x5d
   2087a:	1e59      	subs	r1, r3, #1
   2087c:	32ff      	adds	r2, #255	; 0xff
   2087e:	4291      	cmp	r1, r2
   20880:	d905      	bls.n	2088e <_scanf_i+0x3e>
   20882:	3b5e      	subs	r3, #94	; 0x5e
   20884:	3bff      	subs	r3, #255	; 0xff
   20886:	9304      	str	r3, [sp, #16]
   20888:	235e      	movs	r3, #94	; 0x5e
   2088a:	33ff      	adds	r3, #255	; 0xff
   2088c:	60a3      	str	r3, [r4, #8]
   2088e:	0023      	movs	r3, r4
   20890:	331c      	adds	r3, #28
   20892:	9301      	str	r3, [sp, #4]
   20894:	23d0      	movs	r3, #208	; 0xd0
   20896:	2700      	movs	r7, #0
   20898:	6822      	ldr	r2, [r4, #0]
   2089a:	011b      	lsls	r3, r3, #4
   2089c:	4313      	orrs	r3, r2
   2089e:	6023      	str	r3, [r4, #0]
   208a0:	9b01      	ldr	r3, [sp, #4]
   208a2:	9303      	str	r3, [sp, #12]
   208a4:	6833      	ldr	r3, [r6, #0]
   208a6:	a809      	add	r0, sp, #36	; 0x24
   208a8:	7819      	ldrb	r1, [r3, #0]
   208aa:	00bb      	lsls	r3, r7, #2
   208ac:	2202      	movs	r2, #2
   208ae:	5818      	ldr	r0, [r3, r0]
   208b0:	f7ff fd4c 	bl	2034c <memchr>
   208b4:	2800      	cmp	r0, #0
   208b6:	d03b      	beq.n	20930 <_scanf_i+0xe0>
   208b8:	2f01      	cmp	r7, #1
   208ba:	d10d      	bne.n	208d8 <_scanf_i+0x88>
   208bc:	6863      	ldr	r3, [r4, #4]
   208be:	2b00      	cmp	r3, #0
   208c0:	d106      	bne.n	208d0 <_scanf_i+0x80>
   208c2:	3308      	adds	r3, #8
   208c4:	6822      	ldr	r2, [r4, #0]
   208c6:	6063      	str	r3, [r4, #4]
   208c8:	33f9      	adds	r3, #249	; 0xf9
   208ca:	33ff      	adds	r3, #255	; 0xff
   208cc:	4313      	orrs	r3, r2
   208ce:	6023      	str	r3, [r4, #0]
   208d0:	4b5c      	ldr	r3, [pc, #368]	; (20a44 <_scanf_i+0x1f4>)
   208d2:	6822      	ldr	r2, [r4, #0]
   208d4:	4013      	ands	r3, r2
   208d6:	e00e      	b.n	208f6 <_scanf_i+0xa6>
   208d8:	2f02      	cmp	r7, #2
   208da:	d10d      	bne.n	208f8 <_scanf_i+0xa8>
   208dc:	21c0      	movs	r1, #192	; 0xc0
   208de:	2280      	movs	r2, #128	; 0x80
   208e0:	6823      	ldr	r3, [r4, #0]
   208e2:	00c9      	lsls	r1, r1, #3
   208e4:	4019      	ands	r1, r3
   208e6:	0092      	lsls	r2, r2, #2
   208e8:	4291      	cmp	r1, r2
   208ea:	d124      	bne.n	20936 <_scanf_i+0xe6>
   208ec:	3af1      	subs	r2, #241	; 0xf1
   208ee:	3aff      	subs	r2, #255	; 0xff
   208f0:	6062      	str	r2, [r4, #4]
   208f2:	32f0      	adds	r2, #240	; 0xf0
   208f4:	4313      	orrs	r3, r2
   208f6:	6023      	str	r3, [r4, #0]
   208f8:	68a3      	ldr	r3, [r4, #8]
   208fa:	1e5a      	subs	r2, r3, #1
   208fc:	60a2      	str	r2, [r4, #8]
   208fe:	2b00      	cmp	r3, #0
   20900:	d016      	beq.n	20930 <_scanf_i+0xe0>
   20902:	9b03      	ldr	r3, [sp, #12]
   20904:	1c5d      	adds	r5, r3, #1
   20906:	6833      	ldr	r3, [r6, #0]
   20908:	1c5a      	adds	r2, r3, #1
   2090a:	6032      	str	r2, [r6, #0]
   2090c:	781b      	ldrb	r3, [r3, #0]
   2090e:	9a03      	ldr	r2, [sp, #12]
   20910:	9503      	str	r5, [sp, #12]
   20912:	7013      	strb	r3, [r2, #0]
   20914:	6873      	ldr	r3, [r6, #4]
   20916:	3b01      	subs	r3, #1
   20918:	6073      	str	r3, [r6, #4]
   2091a:	2b00      	cmp	r3, #0
   2091c:	dc08      	bgt.n	20930 <_scanf_i+0xe0>
   2091e:	23c0      	movs	r3, #192	; 0xc0
   20920:	005b      	lsls	r3, r3, #1
   20922:	58e3      	ldr	r3, [r4, r3]
   20924:	0031      	movs	r1, r6
   20926:	9805      	ldr	r0, [sp, #20]
   20928:	9307      	str	r3, [sp, #28]
   2092a:	4798      	blx	r3
   2092c:	2800      	cmp	r0, #0
   2092e:	d147      	bne.n	209c0 <_scanf_i+0x170>
   20930:	3701      	adds	r7, #1
   20932:	2f03      	cmp	r7, #3
   20934:	d1b6      	bne.n	208a4 <_scanf_i+0x54>
   20936:	6863      	ldr	r3, [r4, #4]
   20938:	2b00      	cmp	r3, #0
   2093a:	d101      	bne.n	20940 <_scanf_i+0xf0>
   2093c:	330a      	adds	r3, #10
   2093e:	6063      	str	r3, [r4, #4]
   20940:	2110      	movs	r1, #16
   20942:	2700      	movs	r7, #0
   20944:	6863      	ldr	r3, [r4, #4]
   20946:	6960      	ldr	r0, [r4, #20]
   20948:	1ac9      	subs	r1, r1, r3
   2094a:	4b3f      	ldr	r3, [pc, #252]	; (20a48 <_scanf_i+0x1f8>)
   2094c:	18c9      	adds	r1, r1, r3
   2094e:	f000 f87f 	bl	20a50 <__sccl>
   20952:	9d03      	ldr	r5, [sp, #12]
   20954:	68a3      	ldr	r3, [r4, #8]
   20956:	2b00      	cmp	r3, #0
   20958:	d033      	beq.n	209c2 <_scanf_i+0x172>
   2095a:	6832      	ldr	r2, [r6, #0]
   2095c:	6960      	ldr	r0, [r4, #20]
   2095e:	7811      	ldrb	r1, [r2, #0]
   20960:	5c40      	ldrb	r0, [r0, r1]
   20962:	2800      	cmp	r0, #0
   20964:	d02d      	beq.n	209c2 <_scanf_i+0x172>
   20966:	2930      	cmp	r1, #48	; 0x30
   20968:	d10d      	bne.n	20986 <_scanf_i+0x136>
   2096a:	2080      	movs	r0, #128	; 0x80
   2096c:	6821      	ldr	r1, [r4, #0]
   2096e:	0100      	lsls	r0, r0, #4
   20970:	4201      	tst	r1, r0
   20972:	d008      	beq.n	20986 <_scanf_i+0x136>
   20974:	9a04      	ldr	r2, [sp, #16]
   20976:	3701      	adds	r7, #1
   20978:	2a00      	cmp	r2, #0
   2097a:	d00b      	beq.n	20994 <_scanf_i+0x144>
   2097c:	3a01      	subs	r2, #1
   2097e:	3301      	adds	r3, #1
   20980:	9204      	str	r2, [sp, #16]
   20982:	60a3      	str	r3, [r4, #8]
   20984:	e006      	b.n	20994 <_scanf_i+0x144>
   20986:	6821      	ldr	r1, [r4, #0]
   20988:	4b30      	ldr	r3, [pc, #192]	; (20a4c <_scanf_i+0x1fc>)
   2098a:	400b      	ands	r3, r1
   2098c:	6023      	str	r3, [r4, #0]
   2098e:	7813      	ldrb	r3, [r2, #0]
   20990:	702b      	strb	r3, [r5, #0]
   20992:	3501      	adds	r5, #1
   20994:	6873      	ldr	r3, [r6, #4]
   20996:	3b01      	subs	r3, #1
   20998:	6073      	str	r3, [r6, #4]
   2099a:	2b00      	cmp	r3, #0
   2099c:	dd03      	ble.n	209a6 <_scanf_i+0x156>
   2099e:	6833      	ldr	r3, [r6, #0]
   209a0:	3301      	adds	r3, #1
   209a2:	6033      	str	r3, [r6, #0]
   209a4:	e008      	b.n	209b8 <_scanf_i+0x168>
   209a6:	23c0      	movs	r3, #192	; 0xc0
   209a8:	005b      	lsls	r3, r3, #1
   209aa:	58e3      	ldr	r3, [r4, r3]
   209ac:	0031      	movs	r1, r6
   209ae:	9805      	ldr	r0, [sp, #20]
   209b0:	9303      	str	r3, [sp, #12]
   209b2:	4798      	blx	r3
   209b4:	2800      	cmp	r0, #0
   209b6:	d104      	bne.n	209c2 <_scanf_i+0x172>
   209b8:	68a3      	ldr	r3, [r4, #8]
   209ba:	3b01      	subs	r3, #1
   209bc:	60a3      	str	r3, [r4, #8]
   209be:	e7c9      	b.n	20954 <_scanf_i+0x104>
   209c0:	2700      	movs	r7, #0
   209c2:	6823      	ldr	r3, [r4, #0]
   209c4:	05db      	lsls	r3, r3, #23
   209c6:	d50e      	bpl.n	209e6 <_scanf_i+0x196>
   209c8:	9b01      	ldr	r3, [sp, #4]
   209ca:	429d      	cmp	r5, r3
   209cc:	d907      	bls.n	209de <_scanf_i+0x18e>
   209ce:	23be      	movs	r3, #190	; 0xbe
   209d0:	3d01      	subs	r5, #1
   209d2:	005b      	lsls	r3, r3, #1
   209d4:	7829      	ldrb	r1, [r5, #0]
   209d6:	58e3      	ldr	r3, [r4, r3]
   209d8:	0032      	movs	r2, r6
   209da:	9805      	ldr	r0, [sp, #20]
   209dc:	4798      	blx	r3
   209de:	9b01      	ldr	r3, [sp, #4]
   209e0:	2001      	movs	r0, #1
   209e2:	429d      	cmp	r5, r3
   209e4:	d025      	beq.n	20a32 <_scanf_i+0x1e2>
   209e6:	2210      	movs	r2, #16
   209e8:	6823      	ldr	r3, [r4, #0]
   209ea:	401a      	ands	r2, r3
   209ec:	d11a      	bne.n	20a24 <_scanf_i+0x1d4>
   209ee:	702a      	strb	r2, [r5, #0]
   209f0:	6863      	ldr	r3, [r4, #4]
   209f2:	9901      	ldr	r1, [sp, #4]
   209f4:	9805      	ldr	r0, [sp, #20]
   209f6:	9e06      	ldr	r6, [sp, #24]
   209f8:	47b0      	blx	r6
   209fa:	9b02      	ldr	r3, [sp, #8]
   209fc:	6822      	ldr	r2, [r4, #0]
   209fe:	681b      	ldr	r3, [r3, #0]
   20a00:	0691      	lsls	r1, r2, #26
   20a02:	d407      	bmi.n	20a14 <_scanf_i+0x1c4>
   20a04:	07d1      	lsls	r1, r2, #31
   20a06:	d505      	bpl.n	20a14 <_scanf_i+0x1c4>
   20a08:	9902      	ldr	r1, [sp, #8]
   20a0a:	1d1a      	adds	r2, r3, #4
   20a0c:	600a      	str	r2, [r1, #0]
   20a0e:	681b      	ldr	r3, [r3, #0]
   20a10:	8018      	strh	r0, [r3, #0]
   20a12:	e004      	b.n	20a1e <_scanf_i+0x1ce>
   20a14:	9902      	ldr	r1, [sp, #8]
   20a16:	1d1a      	adds	r2, r3, #4
   20a18:	600a      	str	r2, [r1, #0]
   20a1a:	681b      	ldr	r3, [r3, #0]
   20a1c:	6018      	str	r0, [r3, #0]
   20a1e:	68e3      	ldr	r3, [r4, #12]
   20a20:	3301      	adds	r3, #1
   20a22:	60e3      	str	r3, [r4, #12]
   20a24:	2000      	movs	r0, #0
   20a26:	9b01      	ldr	r3, [sp, #4]
   20a28:	1aed      	subs	r5, r5, r3
   20a2a:	6923      	ldr	r3, [r4, #16]
   20a2c:	19ed      	adds	r5, r5, r7
   20a2e:	195d      	adds	r5, r3, r5
   20a30:	6125      	str	r5, [r4, #16]
   20a32:	b00d      	add	sp, #52	; 0x34
   20a34:	bdf0      	pop	{r4, r5, r6, r7, pc}
   20a36:	46c0      	nop			; (mov r8, r8)
   20a38:	00022110 	.word	0x00022110
   20a3c:	00020ab5 	.word	0x00020ab5
   20a40:	00020229 	.word	0x00020229
   20a44:	fffffaff 	.word	0xfffffaff
   20a48:	0002211c 	.word	0x0002211c
   20a4c:	fffff6ff 	.word	0xfffff6ff

00020a50 <__sccl>:
   20a50:	b570      	push	{r4, r5, r6, lr}
   20a52:	780b      	ldrb	r3, [r1, #0]
   20a54:	2b5e      	cmp	r3, #94	; 0x5e
   20a56:	d002      	beq.n	20a5e <__sccl+0xe>
   20a58:	1c4a      	adds	r2, r1, #1
   20a5a:	2500      	movs	r5, #0
   20a5c:	e002      	b.n	20a64 <__sccl+0x14>
   20a5e:	2501      	movs	r5, #1
   20a60:	784b      	ldrb	r3, [r1, #1]
   20a62:	1c8a      	adds	r2, r1, #2
   20a64:	0001      	movs	r1, r0
   20a66:	1c44      	adds	r4, r0, #1
   20a68:	34ff      	adds	r4, #255	; 0xff
   20a6a:	700d      	strb	r5, [r1, #0]
   20a6c:	3101      	adds	r1, #1
   20a6e:	42a1      	cmp	r1, r4
   20a70:	d1fb      	bne.n	20a6a <__sccl+0x1a>
   20a72:	2b00      	cmp	r3, #0
   20a74:	d101      	bne.n	20a7a <__sccl+0x2a>
   20a76:	1e50      	subs	r0, r2, #1
   20a78:	e01b      	b.n	20ab2 <__sccl+0x62>
   20a7a:	2101      	movs	r1, #1
   20a7c:	404d      	eors	r5, r1
   20a7e:	0011      	movs	r1, r2
   20a80:	54c5      	strb	r5, [r0, r3]
   20a82:	780c      	ldrb	r4, [r1, #0]
   20a84:	1c4a      	adds	r2, r1, #1
   20a86:	2c2d      	cmp	r4, #45	; 0x2d
   20a88:	d007      	beq.n	20a9a <__sccl+0x4a>
   20a8a:	2c5d      	cmp	r4, #93	; 0x5d
   20a8c:	d010      	beq.n	20ab0 <__sccl+0x60>
   20a8e:	2c00      	cmp	r4, #0
   20a90:	d001      	beq.n	20a96 <__sccl+0x46>
   20a92:	0023      	movs	r3, r4
   20a94:	e7f3      	b.n	20a7e <__sccl+0x2e>
   20a96:	0008      	movs	r0, r1
   20a98:	e00b      	b.n	20ab2 <__sccl+0x62>
   20a9a:	784e      	ldrb	r6, [r1, #1]
   20a9c:	2e5d      	cmp	r6, #93	; 0x5d
   20a9e:	d0f8      	beq.n	20a92 <__sccl+0x42>
   20aa0:	42b3      	cmp	r3, r6
   20aa2:	dcf6      	bgt.n	20a92 <__sccl+0x42>
   20aa4:	3102      	adds	r1, #2
   20aa6:	3301      	adds	r3, #1
   20aa8:	54c5      	strb	r5, [r0, r3]
   20aaa:	429e      	cmp	r6, r3
   20aac:	dcfb      	bgt.n	20aa6 <__sccl+0x56>
   20aae:	e7e8      	b.n	20a82 <__sccl+0x32>
   20ab0:	0010      	movs	r0, r2
   20ab2:	bd70      	pop	{r4, r5, r6, pc}

00020ab4 <_strtol_r>:
   20ab4:	b5f0      	push	{r4, r5, r6, r7, lr}
   20ab6:	001e      	movs	r6, r3
   20ab8:	4b45      	ldr	r3, [pc, #276]	; (20bd0 <_strtol_r+0x11c>)
   20aba:	b087      	sub	sp, #28
   20abc:	681b      	ldr	r3, [r3, #0]
   20abe:	9201      	str	r2, [sp, #4]
   20ac0:	9302      	str	r3, [sp, #8]
   20ac2:	2208      	movs	r2, #8
   20ac4:	000b      	movs	r3, r1
   20ac6:	9005      	str	r0, [sp, #20]
   20ac8:	9103      	str	r1, [sp, #12]
   20aca:	781c      	ldrb	r4, [r3, #0]
   20acc:	9902      	ldr	r1, [sp, #8]
   20ace:	1c5d      	adds	r5, r3, #1
   20ad0:	1909      	adds	r1, r1, r4
   20ad2:	7848      	ldrb	r0, [r1, #1]
   20ad4:	4010      	ands	r0, r2
   20ad6:	d001      	beq.n	20adc <_strtol_r+0x28>
   20ad8:	002b      	movs	r3, r5
   20ada:	e7f6      	b.n	20aca <_strtol_r+0x16>
   20adc:	2c2d      	cmp	r4, #45	; 0x2d
   20ade:	d104      	bne.n	20aea <_strtol_r+0x36>
   20ae0:	1c9d      	adds	r5, r3, #2
   20ae2:	785c      	ldrb	r4, [r3, #1]
   20ae4:	2301      	movs	r3, #1
   20ae6:	9300      	str	r3, [sp, #0]
   20ae8:	e004      	b.n	20af4 <_strtol_r+0x40>
   20aea:	9000      	str	r0, [sp, #0]
   20aec:	2c2b      	cmp	r4, #43	; 0x2b
   20aee:	d101      	bne.n	20af4 <_strtol_r+0x40>
   20af0:	785c      	ldrb	r4, [r3, #1]
   20af2:	1c9d      	adds	r5, r3, #2
   20af4:	2e00      	cmp	r6, #0
   20af6:	d002      	beq.n	20afe <_strtol_r+0x4a>
   20af8:	2e10      	cmp	r6, #16
   20afa:	d10a      	bne.n	20b12 <_strtol_r+0x5e>
   20afc:	e062      	b.n	20bc4 <_strtol_r+0x110>
   20afe:	2c30      	cmp	r4, #48	; 0x30
   20b00:	d15e      	bne.n	20bc0 <_strtol_r+0x10c>
   20b02:	2220      	movs	r2, #32
   20b04:	782b      	ldrb	r3, [r5, #0]
   20b06:	4393      	bics	r3, r2
   20b08:	2b58      	cmp	r3, #88	; 0x58
   20b0a:	d154      	bne.n	20bb6 <_strtol_r+0x102>
   20b0c:	2610      	movs	r6, #16
   20b0e:	786c      	ldrb	r4, [r5, #1]
   20b10:	3502      	adds	r5, #2
   20b12:	9f00      	ldr	r7, [sp, #0]
   20b14:	0031      	movs	r1, r6
   20b16:	1e7b      	subs	r3, r7, #1
   20b18:	419f      	sbcs	r7, r3
   20b1a:	4b2e      	ldr	r3, [pc, #184]	; (20bd4 <_strtol_r+0x120>)
   20b1c:	18ff      	adds	r7, r7, r3
   20b1e:	0038      	movs	r0, r7
   20b20:	f7fc fd36 	bl	1d590 <__aeabi_uidivmod>
   20b24:	0038      	movs	r0, r7
   20b26:	9104      	str	r1, [sp, #16]
   20b28:	0031      	movs	r1, r6
   20b2a:	f7fc fcab 	bl	1d484 <__aeabi_uidiv>
   20b2e:	2300      	movs	r3, #0
   20b30:	2203      	movs	r2, #3
   20b32:	0007      	movs	r7, r0
   20b34:	4694      	mov	ip, r2
   20b36:	0018      	movs	r0, r3
   20b38:	9a02      	ldr	r2, [sp, #8]
   20b3a:	1912      	adds	r2, r2, r4
   20b3c:	7851      	ldrb	r1, [r2, #1]
   20b3e:	2204      	movs	r2, #4
   20b40:	4211      	tst	r1, r2
   20b42:	d001      	beq.n	20b48 <_strtol_r+0x94>
   20b44:	3c30      	subs	r4, #48	; 0x30
   20b46:	e007      	b.n	20b58 <_strtol_r+0xa4>
   20b48:	4662      	mov	r2, ip
   20b4a:	4011      	ands	r1, r2
   20b4c:	d017      	beq.n	20b7e <_strtol_r+0xca>
   20b4e:	2237      	movs	r2, #55	; 0x37
   20b50:	2901      	cmp	r1, #1
   20b52:	d000      	beq.n	20b56 <_strtol_r+0xa2>
   20b54:	3220      	adds	r2, #32
   20b56:	1aa4      	subs	r4, r4, r2
   20b58:	42a6      	cmp	r6, r4
   20b5a:	dd10      	ble.n	20b7e <_strtol_r+0xca>
   20b5c:	1c5a      	adds	r2, r3, #1
   20b5e:	d00b      	beq.n	20b78 <_strtol_r+0xc4>
   20b60:	42b8      	cmp	r0, r7
   20b62:	d807      	bhi.n	20b74 <_strtol_r+0xc0>
   20b64:	d102      	bne.n	20b6c <_strtol_r+0xb8>
   20b66:	9b04      	ldr	r3, [sp, #16]
   20b68:	429c      	cmp	r4, r3
   20b6a:	dc03      	bgt.n	20b74 <_strtol_r+0xc0>
   20b6c:	4370      	muls	r0, r6
   20b6e:	2301      	movs	r3, #1
   20b70:	1820      	adds	r0, r4, r0
   20b72:	e001      	b.n	20b78 <_strtol_r+0xc4>
   20b74:	2301      	movs	r3, #1
   20b76:	425b      	negs	r3, r3
   20b78:	782c      	ldrb	r4, [r5, #0]
   20b7a:	3501      	adds	r5, #1
   20b7c:	e7dc      	b.n	20b38 <_strtol_r+0x84>
   20b7e:	1c5a      	adds	r2, r3, #1
   20b80:	d10b      	bne.n	20b9a <_strtol_r+0xe6>
   20b82:	9800      	ldr	r0, [sp, #0]
   20b84:	9a05      	ldr	r2, [sp, #20]
   20b86:	1e43      	subs	r3, r0, #1
   20b88:	4198      	sbcs	r0, r3
   20b8a:	4b12      	ldr	r3, [pc, #72]	; (20bd4 <_strtol_r+0x120>)
   20b8c:	18c0      	adds	r0, r0, r3
   20b8e:	2322      	movs	r3, #34	; 0x22
   20b90:	6013      	str	r3, [r2, #0]
   20b92:	9b01      	ldr	r3, [sp, #4]
   20b94:	2b00      	cmp	r3, #0
   20b96:	d10a      	bne.n	20bae <_strtol_r+0xfa>
   20b98:	e017      	b.n	20bca <_strtol_r+0x116>
   20b9a:	9a00      	ldr	r2, [sp, #0]
   20b9c:	2a00      	cmp	r2, #0
   20b9e:	d000      	beq.n	20ba2 <_strtol_r+0xee>
   20ba0:	4240      	negs	r0, r0
   20ba2:	9a01      	ldr	r2, [sp, #4]
   20ba4:	2a00      	cmp	r2, #0
   20ba6:	d010      	beq.n	20bca <_strtol_r+0x116>
   20ba8:	9a03      	ldr	r2, [sp, #12]
   20baa:	2b00      	cmp	r3, #0
   20bac:	d000      	beq.n	20bb0 <_strtol_r+0xfc>
   20bae:	1e6a      	subs	r2, r5, #1
   20bb0:	9b01      	ldr	r3, [sp, #4]
   20bb2:	601a      	str	r2, [r3, #0]
   20bb4:	e009      	b.n	20bca <_strtol_r+0x116>
   20bb6:	2430      	movs	r4, #48	; 0x30
   20bb8:	2e00      	cmp	r6, #0
   20bba:	d1aa      	bne.n	20b12 <_strtol_r+0x5e>
   20bbc:	2608      	movs	r6, #8
   20bbe:	e7a8      	b.n	20b12 <_strtol_r+0x5e>
   20bc0:	260a      	movs	r6, #10
   20bc2:	e7a6      	b.n	20b12 <_strtol_r+0x5e>
   20bc4:	2c30      	cmp	r4, #48	; 0x30
   20bc6:	d09c      	beq.n	20b02 <_strtol_r+0x4e>
   20bc8:	e7a3      	b.n	20b12 <_strtol_r+0x5e>
   20bca:	b007      	add	sp, #28
   20bcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   20bce:	46c0      	nop			; (mov r8, r8)
   20bd0:	200004c0 	.word	0x200004c0
   20bd4:	7fffffff 	.word	0x7fffffff

00020bd8 <__submore>:
   20bd8:	000b      	movs	r3, r1
   20bda:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   20bdc:	6b4d      	ldr	r5, [r1, #52]	; 0x34
   20bde:	3344      	adds	r3, #68	; 0x44
   20be0:	000c      	movs	r4, r1
   20be2:	429d      	cmp	r5, r3
   20be4:	d11b      	bne.n	20c1e <__submore+0x46>
   20be6:	2680      	movs	r6, #128	; 0x80
   20be8:	00f6      	lsls	r6, r6, #3
   20bea:	0031      	movs	r1, r6
   20bec:	f7fe fbf4 	bl	1f3d8 <_malloc_r>
   20bf0:	2800      	cmp	r0, #0
   20bf2:	d102      	bne.n	20bfa <__submore+0x22>
   20bf4:	2001      	movs	r0, #1
   20bf6:	4240      	negs	r0, r0
   20bf8:	e025      	b.n	20c46 <__submore+0x6e>
   20bfa:	0023      	movs	r3, r4
   20bfc:	6360      	str	r0, [r4, #52]	; 0x34
   20bfe:	63a6      	str	r6, [r4, #56]	; 0x38
   20c00:	3346      	adds	r3, #70	; 0x46
   20c02:	781a      	ldrb	r2, [r3, #0]
   20c04:	4b10      	ldr	r3, [pc, #64]	; (20c48 <__submore+0x70>)
   20c06:	54c2      	strb	r2, [r0, r3]
   20c08:	0023      	movs	r3, r4
   20c0a:	3345      	adds	r3, #69	; 0x45
   20c0c:	781a      	ldrb	r2, [r3, #0]
   20c0e:	4b0f      	ldr	r3, [pc, #60]	; (20c4c <__submore+0x74>)
   20c10:	54c2      	strb	r2, [r0, r3]
   20c12:	782a      	ldrb	r2, [r5, #0]
   20c14:	4b0e      	ldr	r3, [pc, #56]	; (20c50 <__submore+0x78>)
   20c16:	54c2      	strb	r2, [r0, r3]
   20c18:	18c0      	adds	r0, r0, r3
   20c1a:	6020      	str	r0, [r4, #0]
   20c1c:	e012      	b.n	20c44 <__submore+0x6c>
   20c1e:	6b8e      	ldr	r6, [r1, #56]	; 0x38
   20c20:	0029      	movs	r1, r5
   20c22:	0073      	lsls	r3, r6, #1
   20c24:	001a      	movs	r2, r3
   20c26:	9301      	str	r3, [sp, #4]
   20c28:	f7ff fbb0 	bl	2038c <_realloc_r>
   20c2c:	1e05      	subs	r5, r0, #0
   20c2e:	d0e1      	beq.n	20bf4 <__submore+0x1c>
   20c30:	1987      	adds	r7, r0, r6
   20c32:	0001      	movs	r1, r0
   20c34:	0032      	movs	r2, r6
   20c36:	0038      	movs	r0, r7
   20c38:	f7fe f92f 	bl	1ee9a <memcpy>
   20c3c:	9b01      	ldr	r3, [sp, #4]
   20c3e:	6027      	str	r7, [r4, #0]
   20c40:	6365      	str	r5, [r4, #52]	; 0x34
   20c42:	63a3      	str	r3, [r4, #56]	; 0x38
   20c44:	2000      	movs	r0, #0
   20c46:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   20c48:	000003ff 	.word	0x000003ff
   20c4c:	000003fe 	.word	0x000003fe
   20c50:	000003fd 	.word	0x000003fd

00020c54 <_malloc_usable_size_r>:
   20c54:	1f0b      	subs	r3, r1, #4
   20c56:	681a      	ldr	r2, [r3, #0]
   20c58:	1f10      	subs	r0, r2, #4
   20c5a:	2a00      	cmp	r2, #0
   20c5c:	da04      	bge.n	20c68 <_malloc_usable_size_r+0x14>
   20c5e:	1889      	adds	r1, r1, r2
   20c60:	3904      	subs	r1, #4
   20c62:	680b      	ldr	r3, [r1, #0]
   20c64:	18d0      	adds	r0, r2, r3
   20c66:	3804      	subs	r0, #4
   20c68:	4770      	bx	lr
   20c6a:	0000      	movs	r0, r0
   20c6c:	00009650 	.word	0x00009650
   20c70:	00009628 	.word	0x00009628
   20c74:	00009620 	.word	0x00009620
   20c78:	00009638 	.word	0x00009638
   20c7c:	00009630 	.word	0x00009630
   20c80:	00009650 	.word	0x00009650
   20c84:	00009640 	.word	0x00009640
   20c88:	00009648 	.word	0x00009648

00020c8c <crc7_syndrome_table>:
   20c8c:	1b120900 3f362d24 535a4148 777e656c     ....$-6?HAZSle~w
   20c9c:	020b1019 262f343d 4a435851 6e677c75     ....=4/&QXCJu|gn
   20cac:	29203b32 0d041f16 6168737a 454c575e     2; )....zsha^WLE
   20cbc:	3039222b 141d060f 78716a63 5c554e47     +"90....cjqxGNU\
   20ccc:	7f766d64 5b524940 373e252c 131a0108     dmv.@IR[,%>7....
   20cdc:	666f747d 424b5059 2e273c35 0a031811     }tofYPKB5<'.....
   20cec:	4d445f56 69607b72 050c171e 2128333a     V_DMr{`i....:3(!
   20cfc:	545d464f 7079626b 1c150e07 38312a23     OF]Tkbyp....#*18
   20d0c:	5a534841 7e776c65 121b0009 363f242d     AHSZelw~....-$?6
   20d1c:	434a5158 676e757c 0b021910 2f263d34     XQJC|ung....4=&/
   20d2c:	68617a73 4c455e57 2029323b 040d161f     szahW^EL;2) ....
   20d3c:	7178636a 555c474e 39302b22 1d140f06     jcxqNG\U"+09....
   20d4c:	3e372c25 1a130801 767f646d 525b4049     %,7>....md.vI@[R
   20d5c:	272e353c 030a1118 6f667d74 4b425950     <5.'....t}foPYBK
   20d6c:	0c051e17 28213a33 444d565f 6069727b     ....3:!(_VMD{ri`
   20d7c:	151c070e 3138232a 5d544f46 79706b62     ....*#81FOT]bkpy
   20d8c:	0000a9b0 0000a9b0 0000aa40 0000a904     ........@.......
   20d9c:	0000a94a 0000a96c 0000a9f2 0000a9f2     J...l...........
   20dac:	0000aaac 0000a8d8 0000ab06 0000ab06     ................
   20dbc:	0000ab06 0000ab06 0000a98e 44494652     ............RFID
   20dcc:	00000000                                ....

00020dd0 <pt>:
	...
   20dd8:	10101010 00101010 18181818 00181818     ................
   20de8:	1c1c1c1c 001c1c1c 1e1e1e1e 001e1e1e     ................
   20df8:	1f1f1f1f 001f1f1f                       ........

00020e00 <LCD_INIT_STRING>:
   20e00:	06010c28 6f636f4e 74737953 00006d65     (...NocoSystem..
   20e10:	636e6957 00000000 6d6d6f43 00000000     Winc....Comm....
   20e20:	6e65704f 63617053 00000065 6e65704f     OpenSpace...Open
   20e30:	63617053 73744265 00242472 72737442     SpaceBtsr$$.Btsr
   20e40:	69466957 00000000 49464957 45524944     WiFi....WIFIDIRE
   20e50:	545f5443 00545345 502f3a30 694c6772     CT_TEST.0:/PrgLi
   20e60:	622e7473 00006e69 532f3a30 70757465     st.bin..0:/Setup
   20e70:	6e69622e 00000000 4c2f3a30 6c656261     .bin....0:/Label
   20e80:	69622e73 0000006e 4c2f3a30 2f73676f     s.bin...0:/Logs/
   20e90:	25676f4c 2e643330 006e6962 542f3a30     Log%03d.bin.0:/T
   20ea0:	694c6761 622e7473 00006e69 522f3a30     agList.bin..0:/R
   20eb0:	69546e75 622e656d 00006e69 0000e436     unTime.bin..6...
   20ec0:	0000dc90 0000dd24 0000e1d6 0000e24e     ....$.......N...
   20ed0:	0000e274 0000e2f4 0000e436 0000e35e     t.......6...^...
   20ee0:	0000e3e0 0000ee72 0000ee72 0000ee66     ....r...r...f...
   20ef0:	0000ee72 0000ee66 0000ee40 0000ee40     r...f...@...@...
   20f00:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20f10:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20f20:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20f30:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20f40:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20f50:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20f60:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20f70:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20f80:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20f90:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20fa0:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20fb0:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20fc0:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20fd0:	0000ee72 0000ee72 0000ee72 0000ee72     r...r...r...r...
   20fe0:	0000ee72 0000ee66 0000ee66 0000ee7c     r...f...f...|...
   20ff0:	0000ee7c 0000ee7c 0000ee7c 454c4449     |...|...|...IDLE
   21000:	00000000                                ....

00021004 <sd_mmc_trans_units>:
   21004:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

00021020 <sd_trans_multipliers>:
   21020:	00000000 0000000a 0000000c 0000000d     ................
   21030:	0000000f 00000014 00000019 0000001e     ................
   21040:	00000023 00000028 0000002d 00000032     #...(...-...2...
   21050:	00000037 0000003c 00000046 00000050     7...<...F...P...

00021060 <mmc_trans_multipliers>:
   21060:	00000000 0000000a 0000000c 0000000d     ................
   21070:	0000000f 00000014 0000001a 0000001e     ................
   21080:	00000023 00000028 0000002d 00000034     #...(...-...4...
   21090:	00000037 0000003c 00000046 00000050     7...<...F...P...
   210a0:	2f445322 20434d4d 64726143 6f6c5320     "SD/MMC Card Slo
   210b0:	22302074 00000000                       t 0"....

000210b8 <lun_desc>:
   210b8:	0001221d 00012275 000122c1 0001230d     ."..u"..."...#..
   210c8:	0001233d 000123c1 00012451 000210a0     =#...#..Q$......
   210d8:	42000800 42000c00 42001000 42001400     ...B...B...B...B
   210e8:	42001800 42001c00 0c0b0a09 00000e0d     ...B...B........
   210f8:	00015f8e 00016006 00016006 00015fac     ._...`...`..._..
   21108:	00015fa6 00015fb2 00015f94 00015fb8     ._..._..._..._..
   21118:	00015fec 000162d0 00016320 00016320     ._...b.. c.. c..
   21128:	0001631c 000162c2 000162e2 000162b2     .c...b...b...b..
   21138:	000162f4 00016306 0001636e 0001639c     .b...c..nc...c..
   21148:	0001639c 00016398 00016368 00016374     .c...c..hc..tc..
   21158:	00016362 0001637a 00016380              bc..zc...c..

00021164 <ExCvt>:
   21164:	41455543 43414141 49454545 41414949     CUEAAAACEEEIIIAA
   21174:	4f929245 55554f4f 4f554f59 9f9e4f9c     E..OOOUUYOUO.O..
   21184:	554f4941 a7a6a5a5 abaaa9a8 afaeadac     AIOU............
   21194:	b3b2b1b0 414141b4 bbbab9b8 bfbebdbc     .....AAA........
   211a4:	c3c2c1c0 4141c5c4 cbcac9c8 cfcecdcc     ......AA........
   211b4:	4545d1d1 49494945 dbdad949 df49dddc     ..EEEIIII.....I.
   211c4:	4f4fe14f e8e64f4f 555555e8 efee5959     O.OOOO...UUUYY..
   211d4:	f3f2f1f0 f7f6f5f4 fbfaf9f8 fffefdfc     ................

000211e4 <LfnOfs>:
   211e4:	07050301 12100e09 1c181614 0000001e     ................
   211f4:	3c3a2a22 7f7c3f3e 00000000 3d3b2c2b     "*:<>?|.....+,;=
   21204:	00005d5b                                []..

00021208 <Tbl>:
   21208:	00fc00c7 00e200e9 00e000e4 00e700e5     ................
   21218:	00eb00ea 00ef00e8 00ec00ee 00c500c4     ................
   21228:	00e600c9 00f400c6 00f200f6 00f900fb     ................
   21238:	00d600ff 00f800dc 00d800a3 019200d7     ................
   21248:	00ed00e1 00fa00f3 00d100f1 00ba00aa     ................
   21258:	00ae00bf 00bd00ac 00a100bc 00bb00ab     ................
   21268:	25922591 25022593 00c12524 00c000c2     .%.%.%.%$%......
   21278:	256300a9 25572551 00a2255d 251000a5     ..c%Q%W%]%.....%
   21288:	25342514 251c252c 253c2500 00c300e3     .%4%,%.%.%<%....
   21298:	2554255a 25662569 25502560 00a4256c     Z%T%i%f%`%P%l%..
   212a8:	00d000f0 00cb00ca 013100c8 00ce00cd     ..........1.....
   212b8:	251800cf 2588250c 00a62584 258000cc     ...%.%.%.%.....%
   212c8:	00df00d3 00d200d4 00d500f5 00fe00b5     ................
   212d8:	00da00de 00d900db 00dd00fd 00b400af     ................
   212e8:	00b100ad 00be2017 00a700b6 00b800f7     ..... ..........
   212f8:	00a800b0 00b900b7 00b200b3 00a025a0     .............%..

00021308 <lower.4383>:
   21308:	00e100e0 00e300e2 00e500e4 00e700e6     ................
   21318:	00e900e8 00eb00ea 00ed00ec 00ef00ee     ................
   21328:	00f100f0 00f300f2 00f500f4 00f800f6     ................
   21338:	00fa00f9 00fc00fb 00fe00fd 010100ff     ................
   21348:	01050103 01090107 010d010b 0111010f     ................
   21358:	01150113 01190117 011d011b 0121011f     ..............!.
   21368:	01250123 01290127 012d012b 0131012f     #.%.'.).+.-./.1.
   21378:	01350133 013a0137 013e013c 01420140     3.5.7.:.<.>.@.B.
   21388:	01460144 014b0148 014f014d 01530151     D.F.H.K.M.O.Q.S.
   21398:	01570155 015b0159 015f015d 01630161     U.W.Y.[.]._.a.c.
   213a8:	01670165 016b0169 016f016d 01730171     e.g.i.k.m.o.q.s.
   213b8:	01770175 017c017a 0183017e 01880185     u.w.z.|.~.......
   213c8:	0192018c 01a10199 01a801a3 01b001ad     ................
   213d8:	01b601b4 01bd01b9 01c901c6 01ce01cc     ................
   213e8:	01d201d0 01d601d4 01da01d8 01dd01dc     ................
   213f8:	01e101df 01e501e3 01e901e7 01ed01eb     ................
   21408:	01f301ef 01fb01f5 01ff01fd 02030201     ................
   21418:	02070205 020b0209 020f020d 02130211     ................
   21428:	02170215 03b203b1 03b403b3 03b603b5     ................
   21438:	03b803b7 03ba03b9 03bc03bb 03be03bd     ................
   21448:	03c003bf 03c303c1 03c503c4 03c703c6     ................
   21458:	03c903c8 03cb03ca 03cd03cc 03e303ce     ................
   21468:	03e703e5 03eb03e9 04310430 04330432     ........0.1.2.3.
   21478:	04350434 04370436 04390438 043b043a     4.5.6.7.8.9.:.;.
   21488:	043d043c 043f043e 04410440 04430442     <.=.>.?.@.A.B.C.
   21498:	04450444 04470446 04490448 044b044a     D.E.F.G.H.I.J.K.
   214a8:	044d044c 044f044e 04530452 04550454     L.M.N.O.R.S.T.U.
   214b8:	04570456 04590458 045b045a 045e045c     V.W.X.Y.Z.[.\.^.
   214c8:	0461045f 04650463 04690467 046d046b     _.a.c.e.g.i.k.m.
   214d8:	0471046f 04750473 04790477 047d047b     o.q.s.u.w.y.{.}.
   214e8:	0481047f 04930491 04970495 049b0499     ................
   214f8:	049f049d 04a304a1 04a704a5 04ab04a9     ................
   21508:	04af04ad 04b304b1 04b704b5 04bb04b9     ................
   21518:	04bf04bd 04c404c2 04d104c8 04d504d3     ................
   21528:	04d904d7 04dd04db 04e104df 04e504e3     ................
   21538:	04e904e7 04ed04eb 04f104ef 04f504f3     ................
   21548:	056104f9 05630562 05650564 05670566     ..a.b.c.d.e.f.g.
   21558:	05690568 056b056a 056d056c 056f056e     h.i.j.k.l.m.n.o.
   21568:	05710570 05730572 05750574 05770576     p.q.r.s.t.u.v.w.
   21578:	05790578 057b057a 057d057c 057f057e     x.y.z.{.|.}.~...
   21588:	05810580 05830582 05850584 1e010586     ................
   21598:	1e051e03 1e091e07 1e0d1e0b 1e111e0f     ................
   215a8:	1e151e13 1e191e17 1e1d1e1b 1e211e1f     ..............!.
   215b8:	1e251e23 1e291e27 1e2d1e2b 1e311e2f     #.%.'.).+.-./.1.
   215c8:	1e351e33 1e391e37 1e3d1e3b 1e411e3f     3.5.7.9.;.=.?.A.
   215d8:	1e451e43 1e491e47 1e4d1e4b 1e511e4f     C.E.G.I.K.M.O.Q.
   215e8:	1e551e53 1e591e57 1e5d1e5b 1e611e5f     S.U.W.Y.[.]._.a.
   215f8:	1e651e63 1e691e67 1e6d1e6b 1e711e6f     c.e.g.i.k.m.o.q.
   21608:	1e751e73 1e791e77 1e7d1e7b 1e811e7f     s.u.w.y.{.}.....
   21618:	1e851e83 1e891e87 1e8d1e8b 1e911e8f     ................
   21628:	1e951e93 1e991e97 1e9d1e9b 1ea11e9f     ................
   21638:	1ea51ea3 1ea91ea7 1ead1eab 1eb11eaf     ................
   21648:	1eb51eb3 1eb91eb7 1ebd1ebb 1ec11ebf     ................
   21658:	1ec51ec3 1ec91ec7 1ecd1ecb 1ed11ecf     ................
   21668:	1ed51ed3 1ed91ed7 1edd1edb 1ee11edf     ................
   21678:	1ee51ee3 1ee91ee7 1eed1eeb 1ef11eef     ................
   21688:	1ef51ef3 1ef91ef7 21712170 21732172     ........p!q!r!s!
   21698:	21752174 21772176 21792178 217b217a     t!u!v!w!x!y!z!{!
   216a8:	217d217c 217f217e ff42ff41 ff44ff43     |!}!~!.!A.B.C.D.
   216b8:	ff46ff45 ff48ff47 ff4aff49 ff4cff4b     E.F.G.H.I.J.K.L.
   216c8:	ff4eff4d ff50ff4f ff52ff51 ff54ff53     M.N.O.P.Q.R.S.T.
   216d8:	ff56ff55 ff58ff57 ff5aff59              U.V.W.X.Y.Z.

000216e4 <upper.4384>:
   216e4:	00c100c0 00c300c2 00c500c4 00c700c6     ................
   216f4:	00c900c8 00cb00ca 00cd00cc 00cf00ce     ................
   21704:	00d100d0 00d300d2 00d500d4 00d800d6     ................
   21714:	00da00d9 00dc00db 00de00dd 01000178     ............x...
   21724:	01040102 01080106 010c010a 0110010e     ................
   21734:	01140112 01180116 011c011a 0120011e     .............. .
   21744:	01240122 01280126 012c012a 0130012e     ".$.&.(.*.,...0.
   21754:	01340132 01390136 013d013b 0141013f     2.4.6.9.;.=.?.A.
   21764:	01450143 014a0147 014e014c 01520150     C.E.G.J.L.N.P.R.
   21774:	01560154 015a0158 015e015c 01620160     T.V.X.Z.\.^.`.b.
   21784:	01660164 016a0168 016e016c 01720170     d.f.h.j.l.n.p.r.
   21794:	01760174 017b0179 0182017d 01870184     t.v.y.{.}.......
   217a4:	0191018b 01a00198 01a701a2 01af01ac     ................
   217b4:	01b501b3 01bc01b8 01c701c4 01cd01ca     ................
   217c4:	01d101cf 01d501d3 01d901d7 018e01db     ................
   217d4:	01e001de 01e401e2 01e801e6 01ec01ea     ................
   217e4:	01f101ee 01fa01f4 01fe01fc 02020200     ................
   217f4:	02060204 020a0208 020e020c 02120210     ................
   21804:	02160214 03920391 03940393 03960395     ................
   21814:	03980397 039a0399 039c039b 039e039d     ................
   21824:	03a0039f 03a303a1 03a503a4 03a703a6     ................
   21834:	03a903a8 03ab03aa 038e038c 03e2038f     ................
   21844:	03e603e4 03ea03e8 04110410 04130412     ................
   21854:	04150414 04170416 04190418 041b041a     ................
   21864:	041d041c 041f041e 04210420 04230422     ........ .!.".#.
   21874:	04250424 04270426 04290428 042b042a     $.%.&.'.(.).*.+.
   21884:	042d042c 042f042e 04030402 04050404     ,.-.../.........
   21894:	04070406 04090408 040b040a 040e040c     ................
   218a4:	0460040f 04640462 04680466 046c046a     ..`.b.d.f.h.j.l.
   218b4:	0470046e 04740472 04780476 047c047a     n.p.r.t.v.x.z.|.
   218c4:	0480047e 04920490 04960494 049a0498     ~...............
   218d4:	049e049c 04a204a0 04a604a4 04aa04a8     ................
   218e4:	04ae04ac 04b204b0 04b604b4 04ba04b8     ................
   218f4:	04be04bc 04c304c1 04d005c7 04d404d2     ................
   21904:	04d804d6 04dc04da 04e004de 04e404e2     ................
   21914:	04e804e6 04ec04ea 04f004ee 04f404f2     ................
   21924:	053104f8 05330532 05350534 05370536     ..1.2.3.4.5.6.7.
   21934:	05390538 053b053a 053d053c 053f053e     8.9.:.;.<.=.>.?.
   21944:	05410540 05430542 05450544 05470546     @.A.B.C.D.E.F.G.
   21954:	05490548 054b054a 054d054c 054f054e     H.I.J.K.L.M.N.O.
   21964:	05510550 05530552 05550554 1e000556     P.Q.R.S.T.U.V...
   21974:	1e041e02 1e081e06 1e0c1e0a 1e101e0e     ................
   21984:	1e141e12 1e181e16 1e1c1e1a 1e201e1e     .............. .
   21994:	1e241e22 1e281e26 1e2c1e2a 1e301e2e     ".$.&.(.*.,...0.
   219a4:	1e341e32 1e381e36 1e3c1e3a 1e401e3e     2.4.6.8.:.<.>.@.
   219b4:	1e441e42 1e481e46 1e4c1e4a 1e501e4e     B.D.F.H.J.L.N.P.
   219c4:	1e541e52 1e581e56 1e5c1e5a 1e601e5e     R.T.V.X.Z.\.^.`.
   219d4:	1e641e62 1e681e66 1e6c1e6a 1e701e6e     b.d.f.h.j.l.n.p.
   219e4:	1e741e72 1e781e76 1e7c1e7a 1e801e7e     r.t.v.x.z.|.~...
   219f4:	1e841e82 1e881e86 1e8c1e8a 1e901e8e     ................
   21a04:	1e941e92 1e981e96 1e9c1e9a 1ea01e9e     ................
   21a14:	1ea41ea2 1ea81ea6 1eac1eaa 1eb01eae     ................
   21a24:	1eb41eb2 1eb81eb6 1ebc1eba 1ec01ebe     ................
   21a34:	1ec41ec2 1ec81ec6 1ecc1eca 1ed01ece     ................
   21a44:	1ed41ed2 1ed81ed6 1edc1eda 1ee01ede     ................
   21a54:	1ee41ee2 1ee81ee6 1eec1eea 1ef01eee     ................
   21a64:	1ef41ef2 1ef81ef6 21612160 21632162     ........`!a!b!c!
   21a74:	21652164 21672166 21692168 216b216a     d!e!f!g!h!i!j!k!
   21a84:	216d216c 216f216e ff22ff21 ff24ff23     l!m!n!o!!.".#.$.
   21a94:	ff26ff25 ff28ff27 ff2aff29 ff2cff2b     %.&.'.(.).*.+.,.
   21aa4:	ff2eff2d ff30ff2f ff32ff31 ff34ff33     -.../.0.1.2.3.4.
   21ab4:	ff36ff35 ff38ff37 ff3aff39              5.6.7.8.9.:.

00021ac0 <uscrctab>:
   21ac0:	10210000 30632042 50a54084 70e760c6     ..!.B c0.@.P.`.p
   21ad0:	91298108 b16ba14a d1adc18c f1efe1ce     ..).J.k.........
   21ae0:	02101231 22523273 429452b5 62d672f7     1...s2R".R.B.r.b
   21af0:	83189339 a35ab37b c39cd3bd e3def3ff     9...{.Z.........
   21b00:	34432462 14010420 74c764e6 548544a4     b$C4 ....d.t.D.T
   21b10:	b54ba56a 95098528 f5cfe5ee d58dc5ac     j.K.(...........
   21b20:	26723653 06301611 66f676d7 46b45695     S6r&..0..v.f.V.F
   21b30:	a77ab75b 87389719 e7fef7df c7bcd79d     [.z...8.........
   21b40:	58e548c4 78a76886 18610840 38232802     .H.X.h.x@.a..(#8
   21b50:	d9edc9cc f9afe98e 99698948 b92ba90a     ........H.i...+.
   21b60:	4ad45af5 6a967ab7 0a501a71 2a123a33     .Z.J.z.jq.P.3:.*
   21b70:	cbdcdbfd eb9efbbf 8b589b79 ab1abb3b     ........y.X.;...
   21b80:	7c876ca6 5cc54ce4 3c032c22 1c410c60     .l.|.L.\",.<`.A.
   21b90:	fd8fedae ddcdcdec bd0bad2a 9d498d68     ........*...h.I.
   21ba0:	6eb67e97 4ef45ed5 2e323e13 0e701e51     .~.n.^.N.>2.Q.p.
   21bb0:	efbeff9f cffcdfdd af3abf1b 8f789f59     ..........:.Y.x.
   21bc0:	81a99188 a1ebb1ca c12dd10c e16ff14e     ..........-.N.o.
   21bd0:	00a11080 20e330c2 40255004 60677046     .....0. .P%@Fpg`
   21be0:	939883b9 b3daa3fb d31cc33d f35ee37f     ........=.....^.
   21bf0:	129002b1 32d222f3 52144235 72566277     .....".25B.RwbVr
   21c00:	a5cbb5ea 858995a8 e54ff56e c50dd52c     ........n.O.,...
   21c10:	24c334e2 048114a0 64477466 44055424     .4.$....ftGd$T.D
   21c20:	b7faa7db 97b88799 f77ee75f d73cc71d     ........_.~...<.
   21c30:	36f226d3 16b00691 76766657 56344615     .&.6....Wfvv.F4V
   21c40:	c96dd94c e92ff90e 89e999c8 a9abb98a     L.m.../.........
   21c50:	48655844 68277806 08e118c0 28a33882     DXeH.x'h.....8.(
   21c60:	db5ccb7d fb1eeb3f 9bd88bf9 bb9aabbb     }.\.?...........
   21c70:	5a544a75 7a166a37 1ad00af1 3a922ab3     uJTZ7j.z.....*.:
   21c80:	ed0ffd2e cd4ddd6c ad8bbdaa 8dc99de8     ....l.M.........
   21c90:	6c077c26 4c455c64 2c833ca2 0cc11ce0     &|.ld\EL.<.,....
   21ca0:	ff3eef1f df7ccf5d bfbaaf9b 9ff88fd9     ..>.].|.........
   21cb0:	7e366e17 5e744e55 3eb22e93 1ef00ed1     .n6~UNt^...>....
   21cc0:	6e69614d 00000000 6f2f3a30 75707475     Main....0:/outpu
   21cd0:	69622e74 0000006e 502f3a30 694c6772     t.bin...0:/PrgLi
   21ce0:	622e7473 00006e69 532f3a30 70757465     st.bin..0:/Setup
   21cf0:	6e69622e 00000000 4c2f3a30 6154676f     .bin....0:/LogTa
   21d00:	2e656c62 006e6962 4c2f3a30 6c656261     ble.bin.0:/Label
   21d10:	69622e73 0000006e 522f3a30 69546e75     s.bin...0:/RunTi
   21d20:	622e656d 00006e69 542f3a30 694c6761     me.bin..0:/TagLi
   21d30:	622e7473 00006e69 73676f4c 00000000     st.bin..Logs....
   21d40:	64323025 3230253a 73252064 00000000     %02d:%02d %s....
   21d50:	00007354 00006954 00006654 00007054     Ts..Ti..Tf..Tp..
   21d60:	00006154 00003157 00003257 00006957     Ta..W1..W2..Wi..
   21d70:	4c2f3a30 2f73676f 25676f4c 2e643330     0:/Logs/Log%03d.
   21d80:	006e6962 4e202020 534f434f 45545359     bin.   NOCOSYSTE
   21d90:	0000004d 20202020 4944454d 534f4942     M...    MEDIBIOS
   21da0:	00000000 00003a30 0001bb1a 0001bb7a     ....0:......z...
   21db0:	0001bbda 0001bc52 0001bcb2 0001bd96     ....R...........
   21dc0:	0001bd12 0001bd54 0001cabc 0001cb50     ....T.......P...
   21dd0:	0001cbd0 0001cc50 0001cce2 0001cdcc     ....P...........
   21de0:	0001cfa4 0001cfa4 0001cfa4 0001cf24     ............$...
   21df0:	0001cea0 0001ce60 0001ceda 0001ddc0     ....`...........
   21e00:	0001dd1e 0001dd1e 0001dd1c 0001ddb2     ................
   21e10:	0001ddb2 0001dda8 0001dd1c 0001ddb2     ................
   21e20:	0001dda8 0001ddb2 0001dd1c 0001ddb8     ................
   21e30:	0001ddb8 0001ddb8 0001de42 0001e518     ........B.......
   21e40:	0001e3d8 0001e3d8 0001e3d6 0001e4f0     ................
   21e50:	0001e4f0 0001e4e2 0001e3d6 0001e4f0     ................
   21e60:	0001e4e2 0001e4f0 0001e3d6 0001e4f8     ................
   21e70:	0001e4f8 0001e4f8 0001e6f8 00000043     ............C...

00021e80 <_DAYS_BEFORE_MONTH>:
   21e80:	00000000 0000001f 0000003b 0000005a     ........;...Z...
   21e90:	00000078 00000097 000000b5 000000d4     x...............
   21ea0:	000000f3 00000111 00000130 0000014e     ........0...N...

00021eb0 <DAYS_IN_MONTH>:
   21eb0:	0000001f 0000001c 0000001f 0000001e     ................
   21ec0:	0000001f 0000001e 0000001f 0000001f     ................
   21ed0:	0000001e 0000001f 0000001e 0000001f     ................

00021ee0 <__month_lengths>:
   21ee0:	0000001f 0000001c 0000001f 0000001e     ................
   21ef0:	0000001f 0000001e 0000001f 0000001f     ................
   21f00:	0000001e 0000001f 0000001e 0000001f     ................
   21f10:	0000001f 0000001d 0000001f 0000001e     ................
   21f20:	0000001f 0000001e 0000001f 0000001f     ................
   21f30:	0000001e 0000001f 0000001e 0000001f     ................
   21f40:	47005a54 2500544d 5e5b3031 2c392d30     TZ.GMT.%10[^0-9,
   21f50:	255d2d2b 254d006e 6e257568 7568252e     +-]%n.M%hu%n.%hu
   21f60:	252e6e25 6e257568 68252f00 3a6e2575     %n.%hu%n./%hu%n:
   21f70:	25756825 68253a6e 006e2575              %hu%n:%hu%n.

00021f7c <__sf_fake_stdin>:
	...

00021f9c <__sf_fake_stdout>:
	...

00021fbc <__sf_fake_stderr>:
	...
   21fdc:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
   21fec:	32313000 36353433 41393837 45444342     .0123456789ABCDE
   21ffc:	31300046 35343332 39383736 64636261     F.0123456789abcd
   2200c:	00006665                                         ef.

0002200f <_ctype_>:
   2200f:	20202000 20202020 28282020 20282828     .         ((((( 
   2201f:	20202020 20202020 20202020 20202020                     
   2202f:	10108820 10101010 10101010 10101010      ...............
   2203f:	04040410 04040404 10040404 10101010     ................
   2204f:	41411010 41414141 01010101 01010101     ..AAAAAA........
   2205f:	01010101 01010101 01010101 10101010     ................
   2206f:	42421010 42424242 02020202 02020202     ..BBBBBB........
   2207f:	02020202 02020202 02020202 10101010     ................
   2208f:	00000020 00000000 00000000 00000000      ...............
	...
   2210f:	02212e00 02213100 02213400 462d4100     ..!..1!..4!..A-F
   2211f:	38662d61 32313039 36353433 2b005d37     a-f8901234567].+
   2212f:	3030002d 00587800 c0b5f800                       -.00.xX..

00022138 <_init>:
   22138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2213a:	46c0      	nop			; (mov r8, r8)
   2213c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2213e:	bc08      	pop	{r3}
   22140:	469e      	mov	lr, r3
   22142:	4770      	bx	lr

00022144 <__init_array_start>:
   22144:	000080dd 	.word	0x000080dd

00022148 <_fini>:
   22148:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2214a:	46c0      	nop			; (mov r8, r8)
   2214c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2214e:	bc08      	pop	{r3}
   22150:	469e      	mov	lr, r3
   22152:	4770      	bx	lr

00022154 <__fini_array_start>:
   22154:	000080b5 	.word	0x000080b5

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:

// Delay loop is put to SRAM so that FWS will not affect delay time
//OPTIMIZE_HIGH
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
20000000:	b580      	push	{r7, lr}
20000002:	b082      	sub	sp, #8
20000004:	af00      	add	r7, sp, #0
20000006:	6078      	str	r0, [r7, #4]

20000008 <loop>:
	UNUSED(n);

	__asm (
20000008:	f3bf 8f5f 	dmb	sy
2000000c:	3801      	subs	r0, #1
2000000e:	2800      	cmp	r0, #0
20000010:	d1fa      	bne.n	20000008 <loop>
		"SUB r0, r0, #1 \n"
#endif
		"CMP r0, #0  \n"
		"BNE loop         "
	);
}
20000012:	46c0      	nop			; (mov r8, r8)
20000014:	46bd      	mov	sp, r7
20000016:	b002      	add	sp, #8
20000018:	bd80      	pop	{r7, pc}
2000001a:	46c0      	nop			; (mov r8, r8)

2000001c <egstrNmBusCapabilities>:
2000001c:	0100 0000                                   ....

20000020 <clk_status_reg_adr>:
20000020:	000f 0000                                   ....

20000024 <tcp_server_socket>:
20000024:	ffff                                             .

20000025 <tcp_client_socket>:
20000025:	00ff aa00                                        ...

20000028 <uxCriticalNesting>:
20000028:	aaaa aaaa                                   ....

2000002c <sd_mmc_cards>:
	...
20000034:	002f 0000 0000 0000 0000 0000 0000 0000     /...............
	...

20000050 <ss_pins>:
20000050:	0111                                             .

20000051 <g_interrupt_enabled>:
20000051:	0001 2000                                        ...

20000054 <LCDlabels>:
20000054:	2020 2020 4920 534e 5245 0054 0000 0000          INSERT.....
	...
20000074:	2020 454d 4f4d 5952 4320 5241 0044 0000       MEMORY CARD...
	...
20000094:	3025 6432 6325 3025 6432 2520 3230 2f64     %02d%c%02d %02d/
200000a4:	3025 6432 252f 3230 2064 6325 0000 0000     %02d/%02d %c....
200000b4:	3a48 3225 2e64 6425 2525 2020 3a54 3225     H:%2d.%d%%  T:%2
200000c4:	2e64 6425 0043 0000 0000 0000 0000 0000     d.%dC...........
200000d4:	2020 2020 5220 4645 4c49 004c 0000 0000          REFILL.....
	...

20000414 <impure_data>:
20000414:	0000 0000 1f7c 0002 1f9c 0002 1fbc 0002     ....|...........
	...
20000434:	1e7c 0002 0000 0000 0000 0000 0000 0000     |...............
	...

20000474 <_impure_ptr>:
20000474:	0414 2000                                   ... 

20000478 <_tzname>:
20000478:	1f43 0002 1f43 0002                         C...C...

20000480 <tzinfo>:
20000480:	0001 0000 0000 0000 004a 0000 0000 0000     ........J.......
	...
200004a4:	004a 0000 0000 0000 0000 0000 0000 0000     J...............
	...

200004c0 <__ctype_ptr__>:
200004c0:	200f 0002                                   . ..

200004c4 <environ>:
200004c4:	30c0 2000                                   .0. 
